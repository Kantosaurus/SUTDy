"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ical.js";
exports.ids = ["vendor-chunks/ical.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/ical.js/dist/ical.js":
/*!*******************************************!*\
  !*** ./node_modules/ical.js/dist/ical.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ICALmodule)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Represents the BINARY value type, which contains extra methods for encoding and decoding.\n *\n * @memberof ICAL\n */ class Binary {\n    /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {Binary}               The binary value instance\n   */ static fromString(aString) {\n        return new Binary(aString);\n    }\n    /**\n   * Creates a new ICAL.Binary instance\n   *\n   * @param {String} aValue     The binary data for this value\n   */ constructor(aValue){\n        /**\n   * The type name, to be used in the jCal object.\n   * @default \"binary\"\n   * @constant\n   */ this.icaltype = \"binary\";\n        this.value = aValue;\n    }\n    /**\n   * Base64 decode the current value\n   *\n   * @return {String}         The base64-decoded value\n   */ decodeValue() {\n        return this._b64_decode(this.value);\n    }\n    /**\n   * Encodes the passed parameter with base64 and sets the internal\n   * value to the result.\n   *\n   * @param {String} aValue      The raw binary value to encode\n   */ setEncodedValue(aValue) {\n        this.value = this._b64_encode(aValue);\n    }\n    _b64_encode(data) {\n        // http://kevin.vanzonneveld.net\n        // +   original by: Tyler Akins (http://rumkin.com)\n        // +   improved by: Bayron Guevara\n        // +   improved by: Thunder.m\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +   bugfixed by: Pellentesque Malesuada\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +   improved by: Rafał Kukawski (http://kukawski.pl)\n        // *     example 1: base64_encode('Kevin van Zonneveld');\n        // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n        // mozilla has this native\n        // - but breaks in 2.0.0.12!\n        //if (typeof this.window['atob'] == 'function') {\n        //    return atob(data);\n        //}\n        let b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = \"\", tmp_arr = [];\n        if (!data) {\n            return data;\n        }\n        do {\n            o1 = data.charCodeAt(i++);\n            o2 = data.charCodeAt(i++);\n            o3 = data.charCodeAt(i++);\n            bits = o1 << 16 | o2 << 8 | o3;\n            h1 = bits >> 18 & 0x3f;\n            h2 = bits >> 12 & 0x3f;\n            h3 = bits >> 6 & 0x3f;\n            h4 = bits & 0x3f;\n            // use hexets to index into b64, and append result to encoded string\n            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n        }while (i < data.length);\n        enc = tmp_arr.join(\"\");\n        let r = data.length % 3;\n        return (r ? enc.slice(0, r - 3) : enc) + \"===\".slice(r || 3);\n    }\n    _b64_decode(data) {\n        // http://kevin.vanzonneveld.net\n        // +   original by: Tyler Akins (http://rumkin.com)\n        // +   improved by: Thunder.m\n        // +      input by: Aman Gupta\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +   bugfixed by: Onno Marsman\n        // +   bugfixed by: Pellentesque Malesuada\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +      input by: Brett Zamir (http://brett-zamir.me)\n        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n        // *     returns 1: 'Kevin van Zonneveld'\n        // mozilla has this native\n        // - but breaks in 2.0.0.12!\n        //if (typeof this.window['btoa'] == 'function') {\n        //    return btoa(data);\n        //}\n        let b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = \"\", tmp_arr = [];\n        if (!data) {\n            return data;\n        }\n        data += \"\";\n        do {\n            h1 = b64.indexOf(data.charAt(i++));\n            h2 = b64.indexOf(data.charAt(i++));\n            h3 = b64.indexOf(data.charAt(i++));\n            h4 = b64.indexOf(data.charAt(i++));\n            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n            o1 = bits >> 16 & 0xff;\n            o2 = bits >> 8 & 0xff;\n            o3 = bits & 0xff;\n            if (h3 == 64) {\n                tmp_arr[ac++] = String.fromCharCode(o1);\n            } else if (h4 == 64) {\n                tmp_arr[ac++] = String.fromCharCode(o1, o2);\n            } else {\n                tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n            }\n        }while (i < data.length);\n        dec = tmp_arr.join(\"\");\n        return dec;\n    }\n    /**\n   * The string representation of this value\n   * @return {String}\n   */ toString() {\n        return this.value;\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ const DURATION_LETTERS = /([PDWHMTS]{1,1})/;\nconst DATA_PROPS_TO_COPY = [\n    \"weeks\",\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"isNegative\"\n];\n/**\n * This class represents the \"duration\" value type, with various calculation\n * and manipulation methods.\n *\n * @memberof ICAL\n */ class Duration {\n    /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {Duration}             The newly created duration instance\n   */ static fromSeconds(aSeconds) {\n        return new Duration().fromSeconds(aSeconds);\n    }\n    /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */ static isValueString(string) {\n        return string[0] === \"P\" || string[1] === \"P\";\n    }\n    /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {Duration}         The created duration instance\n   */ static fromString(aStr) {\n        let pos = 0;\n        let dict = Object.create(null);\n        let chunks = 0;\n        while((pos = aStr.search(DURATION_LETTERS)) !== -1){\n            let type = aStr[pos];\n            let numeric = aStr.slice(0, Math.max(0, pos));\n            aStr = aStr.slice(pos + 1);\n            chunks += parseDurationChunk(type, numeric, dict);\n        }\n        if (chunks < 2) {\n            // There must be at least a chunk with \"P\" and some unit chunk\n            throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n        }\n        return new Duration(dict);\n    }\n    /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData                An object with members of the duration\n   * @param {Number=} aData.weeks         Duration in weeks\n   * @param {Number=} aData.days          Duration in days\n   * @param {Number=} aData.hours         Duration in hours\n   * @param {Number=} aData.minutes       Duration in minutes\n   * @param {Number=} aData.seconds       Duration in seconds\n   * @param {Boolean=} aData.isNegative   If true, the duration is negative\n   * @return {Duration}                   The createad duration instance\n   */ static fromData(aData) {\n        return new Duration(aData);\n    }\n    /**\n   * Creates a new ICAL.Duration instance.\n   *\n   * @param {Object} data                 An object with members of the duration\n   * @param {Number=} data.weeks          Duration in weeks\n   * @param {Number=} data.days           Duration in days\n   * @param {Number=} data.hours          Duration in hours\n   * @param {Number=} data.minutes        Duration in minutes\n   * @param {Number=} data.seconds        Duration in seconds\n   * @param {Boolean=} data.isNegative    If true, the duration is negative\n   */ constructor(data){\n        /**\n   * The weeks in this duration\n   * @type {Number}\n   * @default 0\n   */ this.weeks = 0;\n        /**\n   * The days in this duration\n   * @type {Number}\n   * @default 0\n   */ this.days = 0;\n        /**\n   * The days in this duration\n   * @type {Number}\n   * @default 0\n   */ this.hours = 0;\n        /**\n   * The minutes in this duration\n   * @type {Number}\n   * @default 0\n   */ this.minutes = 0;\n        /**\n   * The seconds in this duration\n   * @type {Number}\n   * @default 0\n   */ this.seconds = 0;\n        /**\n   * The seconds in this duration\n   * @type {Boolean}\n   * @default false\n   */ this.isNegative = false;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icalduration\"\n   */ this.icalclass = \"icalduration\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"duration\"\n   */ this.icaltype = \"duration\";\n        this.wrappedJSObject = this;\n        this.fromData(data);\n    }\n    /**\n   * Returns a clone of the duration object.\n   *\n   * @return {Duration}      The cloned object\n   */ clone() {\n        return Duration.fromData(this);\n    }\n    /**\n   * The duration value expressed as a number of seconds.\n   *\n   * @return {Number}             The duration value in seconds\n   */ toSeconds() {\n        let seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n        return this.isNegative ? -seconds : seconds;\n    }\n    /**\n   * Reads the passed seconds value into this duration object. Afterwards,\n   * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n   * accordingly.\n   *\n   * @param {Number} aSeconds     The duration value in seconds\n   * @return {Duration}           Returns this instance\n   */ fromSeconds(aSeconds) {\n        let secs = Math.abs(aSeconds);\n        this.isNegative = aSeconds < 0;\n        this.days = trunc(secs / 86400);\n        // If we have a flat number of weeks, use them.\n        if (this.days % 7 == 0) {\n            this.weeks = this.days / 7;\n            this.days = 0;\n        } else {\n            this.weeks = 0;\n        }\n        secs -= (this.days + 7 * this.weeks) * 86400;\n        this.hours = trunc(secs / 3600);\n        secs -= this.hours * 3600;\n        this.minutes = trunc(secs / 60);\n        secs -= this.minutes * 60;\n        this.seconds = secs;\n        return this;\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} aData                An object with members of the duration\n   * @param {Number=} aData.weeks         Duration in weeks\n   * @param {Number=} aData.days          Duration in days\n   * @param {Number=} aData.hours         Duration in hours\n   * @param {Number=} aData.minutes       Duration in minutes\n   * @param {Number=} aData.seconds       Duration in seconds\n   * @param {Boolean=} aData.isNegative   If true, the duration is negative\n   */ fromData(aData) {\n        for (let prop of DATA_PROPS_TO_COPY){\n            if (aData && prop in aData) {\n                this[prop] = aData[prop];\n            } else {\n                this[prop] = 0;\n            }\n        }\n    }\n    /**\n   * Resets the duration instance to the default values, i.e. PT0S\n   */ reset() {\n        this.isNegative = false;\n        this.weeks = 0;\n        this.days = 0;\n        this.hours = 0;\n        this.minutes = 0;\n        this.seconds = 0;\n    }\n    /**\n   * Compares the duration instance with another one.\n   *\n   * @param {Duration} aOther             The instance to compare with\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compare(aOther) {\n        let thisSeconds = this.toSeconds();\n        let otherSeconds = aOther.toSeconds();\n        return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    }\n    /**\n   * Normalizes the duration instance. For example, a duration with a value\n   * of 61 seconds will be normalized to 1 minute and 1 second.\n   */ normalize() {\n        this.fromSeconds(this.toSeconds());\n    }\n    /**\n   * The string representation of this duration.\n   * @return {String}\n   */ toString() {\n        if (this.toSeconds() == 0) {\n            return \"PT0S\";\n        } else {\n            let str = \"\";\n            if (this.isNegative) str += \"-\";\n            str += \"P\";\n            if (this.weeks) str += this.weeks + \"W\";\n            if (this.days) str += this.days + \"D\";\n            if (this.hours || this.minutes || this.seconds) {\n                str += \"T\";\n                if (this.hours) str += this.hours + \"H\";\n                if (this.minutes) str += this.minutes + \"M\";\n                if (this.seconds) str += this.seconds + \"S\";\n            }\n            return str;\n        }\n    }\n    /**\n   * The iCalendar string representation of this duration.\n   * @return {String}\n   */ toICALString() {\n        return this.toString();\n    }\n}\n/**\n * Internal helper function to handle a chunk of a duration.\n *\n * @private\n * @param {String} letter type of duration chunk\n * @param {String} number numeric value or -/+\n * @param {Object} dict target to assign values to\n */ function parseDurationChunk(letter, number, object) {\n    let type;\n    switch(letter){\n        case \"P\":\n            if (number && number === \"-\") {\n                object.isNegative = true;\n            } else {\n                object.isNegative = false;\n            }\n            break;\n        case \"D\":\n            type = \"days\";\n            break;\n        case \"W\":\n            type = \"weeks\";\n            break;\n        case \"H\":\n            type = \"hours\";\n            break;\n        case \"M\":\n            type = \"minutes\";\n            break;\n        case \"S\":\n            type = \"seconds\";\n            break;\n        default:\n            // Not a valid chunk\n            return 0;\n    }\n    if (type) {\n        if (!number && number !== 0) {\n            throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n        }\n        let num = parseInt(number, 10);\n        if (isStrictlyNaN(num)) {\n            throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n        }\n        object[type] = num;\n    }\n    return 1;\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").weekDay} weekDay\n * Imports the 'weekDay' type from the \"types.js\" module\n */ /**\n * @classdesc\n * iCalendar Time representation (similar to JS Date object).  Fully\n * independent of system (OS) timezone / time.  Unlike JS Date, the month\n * January is 1, not zero.\n *\n * @example\n * var time = new ICAL.Time({\n *   year: 2012,\n *   month: 10,\n *   day: 11\n *   minute: 0,\n *   second: 0,\n *   isDate: false\n * });\n *\n *\n * @memberof ICAL\n*/ class Time {\n    static{\n        this._dowCache = {};\n    }\n    static{\n        this._wnCache = {};\n    }\n    /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */ static daysInMonth(month, year) {\n        let _daysInMonth = [\n            0,\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        let days = 30;\n        if (month < 1 || month > 12) return days;\n        days = _daysInMonth[month];\n        if (month == 2) {\n            days += Time.isLeapYear(year);\n        }\n        return days;\n    }\n    /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */ static isLeapYear(year) {\n        if (year <= 1752) {\n            return year % 4 == 0;\n        } else {\n            return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n        }\n    }\n    /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {Time}                 The created instance with the calculated date\n   */ static fromDayOfYear(aDayOfYear, aYear) {\n        let year = aYear;\n        let doy = aDayOfYear;\n        let tt = new Time();\n        tt.auto_normalize = false;\n        let is_leap = Time.isLeapYear(year) ? 1 : 0;\n        if (doy < 1) {\n            year--;\n            is_leap = Time.isLeapYear(year) ? 1 : 0;\n            doy += Time.daysInYearPassedMonth[is_leap][12];\n            return Time.fromDayOfYear(doy, year);\n        } else if (doy > Time.daysInYearPassedMonth[is_leap][12]) {\n            is_leap = Time.isLeapYear(year) ? 1 : 0;\n            doy -= Time.daysInYearPassedMonth[is_leap][12];\n            year++;\n            return Time.fromDayOfYear(doy, year);\n        }\n        tt.year = year;\n        tt.isDate = true;\n        for(let month = 11; month >= 0; month--){\n            if (doy > Time.daysInYearPassedMonth[is_leap][month]) {\n                tt.month = month + 1;\n                tt.day = doy - Time.daysInYearPassedMonth[is_leap][month];\n                break;\n            }\n        }\n        tt.auto_normalize = true;\n        return tt;\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {Time}             The date/time instance\n   */ static fromStringv2(str) {\n        return new Time({\n            year: parseInt(str.slice(0, 4), 10),\n            month: parseInt(str.slice(5, 7), 10),\n            day: parseInt(str.slice(8, 10), 10),\n            isDate: true\n        });\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {Time}             The date/time instance\n   */ static fromDateString(aValue) {\n        // Dates should have no timezone.\n        // Google likes to sometimes specify Z on dates\n        // we specifically ignore that to avoid issues.\n        // YYYY-MM-DD\n        // 2012-10-10\n        return new Time({\n            year: strictParseInt(aValue.slice(0, 4)),\n            month: strictParseInt(aValue.slice(5, 7)),\n            day: strictParseInt(aValue.slice(8, 10)),\n            isDate: true\n        });\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {Property=} prop        The property the date belongs to\n   * @return {Time}                 The date/time instance\n   */ static fromDateTimeString(aValue, prop) {\n        if (aValue.length < 19) {\n            throw new Error('invalid date-time value: \"' + aValue + '\"');\n        }\n        let zone;\n        let zoneId;\n        if (aValue[19] && aValue[19] === \"Z\") {\n            zone = Timezone.utcTimezone;\n        } else if (prop) {\n            zoneId = prop.getParameter(\"tzid\");\n            if (prop.parent) {\n                if (prop.parent.name === \"standard\" || prop.parent.name === \"daylight\") {\n                    // Per RFC 5545 3.8.2.4 and 3.8.2.2, start/end date-times within\n                    // these components MUST be specified in local time.\n                    zone = Timezone.localTimezone;\n                } else if (zoneId) {\n                    // If the desired time zone is defined within the component tree,\n                    // fetch its definition and prefer that.\n                    zone = prop.parent.getTimeZoneByID(zoneId);\n                }\n            }\n        }\n        const timeData = {\n            year: strictParseInt(aValue.slice(0, 4)),\n            month: strictParseInt(aValue.slice(5, 7)),\n            day: strictParseInt(aValue.slice(8, 10)),\n            hour: strictParseInt(aValue.slice(11, 13)),\n            minute: strictParseInt(aValue.slice(14, 16)),\n            second: strictParseInt(aValue.slice(17, 19))\n        };\n        // Although RFC 5545 requires that all TZIDs used within a file have a\n        // corresponding time zone definition, we may not be parsing the full file\n        // or we may be dealing with a non-compliant file; in either case, we can\n        // check our own time zone service for the TZID in a last-ditch effort.\n        if (zoneId && !zone) {\n            timeData.timezone = zoneId;\n        }\n        // 2012-10-10T10:10:10(Z)?\n        return new Time(timeData, zone);\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {Property=} prop        The property the date belongs to\n   * @return {Time}                 The date/time instance\n   */ static fromString(aValue, aProperty) {\n        if (aValue.length > 10) {\n            return Time.fromDateTimeString(aValue, aProperty);\n        } else {\n            return Time.fromDateString(aValue);\n        }\n    }\n    /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate             The Javascript Date to read, or null to reset\n   * @param {Boolean} [useUTC=false]  If true, the UTC values of the date will be used\n   */ static fromJSDate(aDate, useUTC) {\n        let tt = new Time();\n        return tt.fromJSDate(aDate, useUTC);\n    }\n    static{\n        /**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {Timezone=} aZone         Timezone this position occurs in\n   */ this.fromData = function fromData(aData, aZone) {\n            let t = new Time();\n            return t.fromData(aData, aZone);\n        };\n    }\n    /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is “floating” - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {Time}\n   */ static now() {\n        return Time.fromJSDate(new Date(), false);\n    }\n    /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {weekDay=} aWeekStart           The week start weekday, used for calculation.\n   * @return {Time}                         The date on which week number 1 starts\n   */ static weekOneStarts(aYear, aWeekStart) {\n        let t = Time.fromData({\n            year: aYear,\n            month: 1,\n            day: 1,\n            isDate: true\n        });\n        let dow = t.dayOfWeek();\n        let wkst = aWeekStart || Time.DEFAULT_WEEK_START;\n        if (dow > Time.THURSDAY) {\n            t.day += 7;\n        }\n        if (wkst > Time.THURSDAY) {\n            t.day -= 7;\n        }\n        t.day -= dow - wkst;\n        return t;\n    }\n    /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */ static getDominicalLetter(yr) {\n        let LTRS = \"GFEDCBA\";\n        let dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n        let isLeap = Time.isLeapYear(yr);\n        if (isLeap) {\n            return LTRS[(dom + 6) % 7] + LTRS[dom];\n        } else {\n            return LTRS[dom];\n        }\n    }\n    static #epochTime = null;\n    /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {Time}\n   * @constant\n   * @instance\n   */ static get epochTime() {\n        if (!this.#epochTime) {\n            this.#epochTime = Time.fromData({\n                year: 1970,\n                month: 1,\n                day: 1,\n                hour: 0,\n                minute: 0,\n                second: 0,\n                isDate: false,\n                timezone: \"Z\"\n            });\n        }\n        return this.#epochTime;\n    }\n    static _cmp_attr(a, b, attr) {\n        if (a[attr] > b[attr]) return 1;\n        if (a[attr] < b[attr]) return -1;\n        return 0;\n    }\n    static{\n        /**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */ this.daysInYearPassedMonth = [\n            [\n                0,\n                31,\n                59,\n                90,\n                120,\n                151,\n                181,\n                212,\n                243,\n                273,\n                304,\n                334,\n                365\n            ],\n            [\n                0,\n                31,\n                60,\n                91,\n                121,\n                152,\n                182,\n                213,\n                244,\n                274,\n                305,\n                335,\n                366\n            ]\n        ];\n    }\n    static{\n        this.SUNDAY = 1;\n    }\n    static{\n        this.MONDAY = 2;\n    }\n    static{\n        this.TUESDAY = 3;\n    }\n    static{\n        this.WEDNESDAY = 4;\n    }\n    static{\n        this.THURSDAY = 5;\n    }\n    static{\n        this.FRIDAY = 6;\n    }\n    static{\n        this.SATURDAY = 7;\n    }\n    static{\n        /**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */ this.DEFAULT_WEEK_START = 2 // MONDAY\n        ;\n    }\n    /**\n   * Creates a new ICAL.Time instance.\n   *\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {Timezone} zone         timezone this position occurs in\n   */ constructor(data, zone){\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icaltime\"\n   */ this.icalclass = \"icaltime\";\n        this._cachedUnixTime = null;\n        /**\n   * The timezone for this time.\n   * @type {Timezone}\n   */ this.zone = null;\n        /**\n   * Internal uses to indicate that a change has been made and the next read\n   * operation must attempt to normalize the value (for example changing the\n   * day to 33).\n   *\n   * @type {Boolean}\n   * @private\n   */ this._pendingNormalization = false;\n        this.wrappedJSObject = this;\n        let time = this._time = Object.create(null);\n        /* time defaults */ time.year = 0;\n        time.month = 1;\n        time.day = 1;\n        time.hour = 0;\n        time.minute = 0;\n        time.second = 0;\n        time.isDate = false;\n        this.fromData(data, zone);\n    }\n    /**\n   * The type name, to be used in the jCal object. This value may change and\n   * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n   * @type {String}\n   * @default \"date-time\"\n   */ get icaltype() {\n        return this.isDate ? \"date\" : \"date-time\";\n    }\n    /**\n   * Returns a clone of the time object.\n   *\n   * @return {Time}              The cloned object\n   */ clone() {\n        return new Time(this._time, this.zone);\n    }\n    /**\n   * Reset the time instance to epoch time\n   */ reset() {\n        this.fromData(Time.epochTime);\n        this.zone = Timezone.utcTimezone;\n    }\n    /**\n   * Reset the time instance to the given date/time values.\n   *\n   * @param {Number} year             The year to set\n   * @param {Number} month            The month to set\n   * @param {Number} day              The day to set\n   * @param {Number} hour             The hour to set\n   * @param {Number} minute           The minute to set\n   * @param {Number} second           The second to set\n   * @param {Timezone} timezone       The timezone to set\n   */ resetTo(year, month, day, hour, minute, second, timezone) {\n        this.fromData({\n            year: year,\n            month: month,\n            day: day,\n            hour: hour,\n            minute: minute,\n            second: second,\n            zone: timezone\n        });\n    }\n    /**\n   * Set up the current instance from the Javascript date value.\n   *\n   * @param {?Date} aDate             The Javascript Date to read, or null to reset\n   * @param {Boolean} [useUTC=false]  If true, the UTC values of the date will be used\n   */ fromJSDate(aDate, useUTC) {\n        if (!aDate) {\n            this.reset();\n        } else {\n            if (useUTC) {\n                this.zone = Timezone.utcTimezone;\n                this.year = aDate.getUTCFullYear();\n                this.month = aDate.getUTCMonth() + 1;\n                this.day = aDate.getUTCDate();\n                this.hour = aDate.getUTCHours();\n                this.minute = aDate.getUTCMinutes();\n                this.second = aDate.getUTCSeconds();\n            } else {\n                this.zone = Timezone.localTimezone;\n                this.year = aDate.getFullYear();\n                this.month = aDate.getMonth() + 1;\n                this.day = aDate.getDate();\n                this.hour = aDate.getHours();\n                this.minute = aDate.getMinutes();\n                this.second = aDate.getSeconds();\n            }\n        }\n        this._cachedUnixTime = null;\n        return this;\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {Timezone=} aZone         Timezone this position occurs in\n   */ fromData(aData, aZone) {\n        if (aData) {\n            for (let [key, value] of Object.entries(aData)){\n                // ical type cannot be set\n                if (key === \"icaltype\") continue;\n                this[key] = value;\n            }\n        }\n        if (aZone) {\n            this.zone = aZone;\n        }\n        if (aData && !(\"isDate\" in aData)) {\n            this.isDate = !(\"hour\" in aData);\n        } else if (aData && \"isDate\" in aData) {\n            this.isDate = aData.isDate;\n        }\n        if (aData && \"timezone\" in aData) {\n            let zone = TimezoneService.get(aData.timezone);\n            this.zone = zone || Timezone.localTimezone;\n        }\n        if (aData && \"zone\" in aData) {\n            this.zone = aData.zone;\n        }\n        if (!this.zone) {\n            this.zone = Timezone.localTimezone;\n        }\n        this._cachedUnixTime = null;\n        return this;\n    }\n    /**\n   * Calculate the day of week.\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {weekDay}\n   */ dayOfWeek(aWeekStart) {\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n        if (dowCacheKey in Time._dowCache) {\n            return Time._dowCache[dowCacheKey];\n        }\n        // Using Zeller's algorithm\n        let q = this.day;\n        let m = this.month + (this.month < 3 ? 12 : 0);\n        let Y = this.year - (this.month < 3 ? 1 : 0);\n        let h = q + Y + trunc((m + 1) * 26 / 10) + trunc(Y / 4);\n        {\n            h += trunc(Y / 100) * 6 + trunc(Y / 400);\n        }\n        // Normalize to 1 = wkst\n        h = (h + 7 - firstDow) % 7 + 1;\n        Time._dowCache[dowCacheKey] = h;\n        return h;\n    }\n    /**\n   * Calculate the day of year.\n   * @return {Number}\n   */ dayOfYear() {\n        let is_leap = Time.isLeapYear(this.year) ? 1 : 0;\n        let diypm = Time.daysInYearPassedMonth;\n        return diypm[is_leap][this.month - 1] + this.day;\n    }\n    /**\n   * Returns a copy of the current date/time, rewound to the start of the\n   * week. The resulting ICAL.Time instance is of icaltype date, even if this\n   * is a date-time.\n   *\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Time}      The start of the week (cloned)\n   */ startOfWeek(aWeekStart) {\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let result = this.clone();\n        result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, shifted to the end of the week.\n   * The resulting ICAL.Time instance is of icaltype date, even if this is a\n   * date-time.\n   *\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Time}      The end of the week (cloned)\n   */ endOfWeek(aWeekStart) {\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let result = this.clone();\n        result.day += (7 - this.dayOfWeek() + firstDow - Time.SUNDAY) % 7;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, rewound to the start of the\n   * month. The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The start of the month (cloned)\n   */ startOfMonth() {\n        let result = this.clone();\n        result.day = 1;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, shifted to the end of the\n   * month.  The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The end of the month (cloned)\n   */ endOfMonth() {\n        let result = this.clone();\n        result.day = Time.daysInMonth(result.month, result.year);\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, rewound to the start of the\n   * year. The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The start of the year (cloned)\n   */ startOfYear() {\n        let result = this.clone();\n        result.day = 1;\n        result.month = 1;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, shifted to the end of the\n   * year.  The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The end of the year (cloned)\n   */ endOfYear() {\n        let result = this.clone();\n        result.day = 31;\n        result.month = 12;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * First calculates the start of the week, then returns the day of year for\n   * this date. If the day falls into the previous year, the day is zero or negative.\n   *\n   * @param {weekDay=} aFirstDayOfWeek\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}     The calculated day of year\n   */ startDoyWeek(aFirstDayOfWeek) {\n        let firstDow = aFirstDayOfWeek || Time.SUNDAY;\n        let delta = this.dayOfWeek() - firstDow;\n        if (delta < 0) delta += 7;\n        return this.dayOfYear() - delta;\n    }\n    /**\n   * Get the dominical letter for the current year. Letters range from A - G\n   * for common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */ getDominicalLetter() {\n        return Time.getDominicalLetter(this.year);\n    }\n    /**\n   * Finds the nthWeekDay relative to the current month (not day).  The\n   * returned value is a day relative the month that this month belongs to so\n   * 1 would indicate the first of the month and 40 would indicate a day in\n   * the following month.\n   *\n   * @param {Number} aDayOfWeek   Day of the week see the day name constants\n   * @param {Number} aPos         Nth occurrence of a given week day values\n   *        of 1 and 0 both indicate the first weekday of that type. aPos may\n   *        be either positive or negative\n   *\n   * @return {Number} numeric value indicating a day relative\n   *                   to the current month of this time object\n   */ nthWeekDay(aDayOfWeek, aPos) {\n        let daysInMonth = Time.daysInMonth(this.month, this.year);\n        let weekday;\n        let pos = aPos;\n        let start = 0;\n        let otherDay = this.clone();\n        if (pos >= 0) {\n            otherDay.day = 1;\n            // because 0 means no position has been given\n            // 1 and 0 indicate the same day.\n            if (pos != 0) {\n                // remove the extra numeric value\n                pos--;\n            }\n            // set current start offset to current day.\n            start = otherDay.day;\n            // find the current day of week\n            let startDow = otherDay.dayOfWeek();\n            // calculate the difference between current\n            // day of the week and desired day of the week\n            let offset = aDayOfWeek - startDow;\n            // if the offset goes into the past\n            // week we add 7 so it goes into the next\n            // week. We only want to go forward in time here.\n            if (offset < 0) // this is really important otherwise we would\n            // end up with dates from in the past.\n            offset += 7;\n            // add offset to start so start is the same\n            // day of the week as the desired day of week.\n            start += offset;\n            // because we are going to add (and multiply)\n            // the numeric value of the day we subtract it\n            // from the start position so not to add it twice.\n            start -= aDayOfWeek;\n            // set week day\n            weekday = aDayOfWeek;\n        } else {\n            // then we set it to the last day in the current month\n            otherDay.day = daysInMonth;\n            // find the ends weekday\n            let endDow = otherDay.dayOfWeek();\n            pos++;\n            weekday = endDow - aDayOfWeek;\n            if (weekday < 0) {\n                weekday += 7;\n            }\n            weekday = daysInMonth - weekday;\n        }\n        weekday += pos * 7;\n        return start + weekday;\n    }\n    /**\n   * Checks if current time is the nth weekday, relative to the current\n   * month.  Will always return false when rule resolves outside of current\n   * month.\n   *\n   * @param {weekDay} aDayOfWeek                 Day of week to check\n   * @param {Number} aPos                        Relative position\n   * @return {Boolean}                           True, if it is the nth weekday\n   */ isNthWeekDay(aDayOfWeek, aPos) {\n        let dow = this.dayOfWeek();\n        if (aPos === 0 && dow === aDayOfWeek) {\n            return true;\n        }\n        // get pos\n        let day = this.nthWeekDay(aDayOfWeek, aPos);\n        if (day === this.day) {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Calculates the ISO 8601 week number. The first week of a year is the\n   * week that contains the first Thursday. The year can have 53 weeks, if\n   * January 1st is a Friday.\n   *\n   * Note there are regions where the first week of the year is the one that\n   * starts on January 1st, which may offset the week number. Also, if a\n   * different week start is specified, this will also affect the week\n   * number.\n   *\n   * @see Time.weekOneStarts\n   * @param {weekDay} aWeekStart                  The weekday the week starts with\n   * @return {Number}                             The ISO week number\n   */ weekNumber(aWeekStart) {\n        let wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n        if (wnCacheKey in Time._wnCache) {\n            return Time._wnCache[wnCacheKey];\n        }\n        // This function courtesty of Julian Bucknall, published under the MIT license\n        // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n        // plus some fixes to be able to use different week starts.\n        let week1;\n        let dt = this.clone();\n        dt.isDate = true;\n        let isoyear = this.year;\n        if (dt.month == 12 && dt.day > 25) {\n            week1 = Time.weekOneStarts(isoyear + 1, aWeekStart);\n            if (dt.compare(week1) < 0) {\n                week1 = Time.weekOneStarts(isoyear, aWeekStart);\n            } else {\n                isoyear++;\n            }\n        } else {\n            week1 = Time.weekOneStarts(isoyear, aWeekStart);\n            if (dt.compare(week1) < 0) {\n                week1 = Time.weekOneStarts(--isoyear, aWeekStart);\n            }\n        }\n        let daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n        let answer = trunc(daysBetween / 7) + 1;\n        Time._wnCache[wnCacheKey] = answer;\n        return answer;\n    }\n    /**\n   * Adds the duration to the current time. The instance is modified in\n   * place.\n   *\n   * @param {Duration} aDuration         The duration to add\n   */ addDuration(aDuration) {\n        let mult = aDuration.isNegative ? -1 : 1;\n        // because of the duration optimizations it is much\n        // more efficient to grab all the values up front\n        // then set them directly (which will avoid a normalization call).\n        // So we don't actually normalize until we need it.\n        let second = this.second;\n        let minute = this.minute;\n        let hour = this.hour;\n        let day = this.day;\n        second += mult * aDuration.seconds;\n        minute += mult * aDuration.minutes;\n        hour += mult * aDuration.hours;\n        day += mult * aDuration.days;\n        day += mult * 7 * aDuration.weeks;\n        this.second = second;\n        this.minute = minute;\n        this.hour = hour;\n        this.day = day;\n        this._cachedUnixTime = null;\n    }\n    /**\n   * Subtract the date details (_excluding_ timezone).  Useful for finding\n   * the relative difference between two time objects excluding their\n   * timezone differences.\n   *\n   * @param {Time} aDate     The date to subtract\n   * @return {Duration}      The difference as a duration\n   */ subtractDate(aDate) {\n        let unixTime = this.toUnixTime() + this.utcOffset();\n        let other = aDate.toUnixTime() + aDate.utcOffset();\n        return Duration.fromSeconds(unixTime - other);\n    }\n    /**\n   * Subtract the date details, taking timezones into account.\n   *\n   * @param {Time} aDate  The date to subtract\n   * @return {Duration}   The difference in duration\n   */ subtractDateTz(aDate) {\n        let unixTime = this.toUnixTime();\n        let other = aDate.toUnixTime();\n        return Duration.fromSeconds(unixTime - other);\n    }\n    /**\n   * Compares the ICAL.Time instance with another one.\n   *\n   * @param {Duration} aOther        The instance to compare with\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compare(other) {\n        let a = this.toUnixTime();\n        let b = other.toUnixTime();\n        if (a > b) return 1;\n        if (b > a) return -1;\n        return 0;\n    }\n    /**\n   * Compares only the date part of this instance with another one.\n   *\n   * @param {Duration} other              The instance to compare with\n   * @param {Timezone} tz                 The timezone to compare in\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compareDateOnlyTz(other, tz) {\n        let a = this.convertToZone(tz);\n        let b = other.convertToZone(tz);\n        let rc = 0;\n        if ((rc = Time._cmp_attr(a, b, \"year\")) != 0) return rc;\n        if ((rc = Time._cmp_attr(a, b, \"month\")) != 0) return rc;\n        if ((rc = Time._cmp_attr(a, b, \"day\")) != 0) return rc;\n        return rc;\n    }\n    /**\n   * Convert the instance into another timezone. The returned ICAL.Time\n   * instance is always a copy.\n   *\n   * @param {Timezone} zone      The zone to convert to\n   * @return {Time}              The copy, converted to the zone\n   */ convertToZone(zone) {\n        let copy = this.clone();\n        let zone_equals = this.zone.tzid == zone.tzid;\n        if (!this.isDate && !zone_equals) {\n            Timezone.convert_time(copy, this.zone, zone);\n        }\n        copy.zone = zone;\n        return copy;\n    }\n    /**\n   * Calculates the UTC offset of the current date/time in the timezone it is\n   * in.\n   *\n   * @return {Number}     UTC offset in seconds\n   */ utcOffset() {\n        if (this.zone == Timezone.localTimezone || this.zone == Timezone.utcTimezone) {\n            return 0;\n        } else {\n            return this.zone.utcOffset(this);\n        }\n    }\n    /**\n   * Returns an RFC 5545 compliant ical representation of this object.\n   *\n   * @return {String} ical date/date-time\n   */ toICALString() {\n        let string = this.toString();\n        if (string.length > 10) {\n            return design$1.icalendar.value[\"date-time\"].toICAL(string);\n        } else {\n            return design$1.icalendar.value.date.toICAL(string);\n        }\n    }\n    /**\n   * The string representation of this date/time, in jCal form\n   * (including : and - separators).\n   * @return {String}\n   */ toString() {\n        let result = this.year + \"-\" + pad2(this.month) + \"-\" + pad2(this.day);\n        if (!this.isDate) {\n            result += \"T\" + pad2(this.hour) + \":\" + pad2(this.minute) + \":\" + pad2(this.second);\n            if (this.zone === Timezone.utcTimezone) {\n                result += \"Z\";\n            }\n        }\n        return result;\n    }\n    /**\n   * Converts the current instance to a Javascript date\n   * @return {Date}\n   */ toJSDate() {\n        if (this.zone == Timezone.localTimezone) {\n            if (this.isDate) {\n                return new Date(this.year, this.month - 1, this.day);\n            } else {\n                return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n            }\n        } else {\n            return new Date(this.toUnixTime() * 1000);\n        }\n    }\n    _normalize() {\n        if (this._time.isDate) {\n            this._time.hour = 0;\n            this._time.minute = 0;\n            this._time.second = 0;\n        }\n        this.adjust(0, 0, 0, 0);\n        return this;\n    }\n    /**\n   * Adjust the date/time by the given offset\n   *\n   * @param {Number} aExtraDays       The extra amount of days\n   * @param {Number} aExtraHours      The extra amount of hours\n   * @param {Number} aExtraMinutes    The extra amount of minutes\n   * @param {Number} aExtraSeconds    The extra amount of seconds\n   * @param {Number=} aTime           The time to adjust, defaults to the\n   *                                    current instance.\n   */ adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n        let minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;\n        let second, minute, hour, day;\n        let daysInMonth;\n        let time = aTime || this._time;\n        if (!time.isDate) {\n            second = time.second + aExtraSeconds;\n            time.second = second % 60;\n            minutesOverflow = trunc(second / 60);\n            if (time.second < 0) {\n                time.second += 60;\n                minutesOverflow--;\n            }\n            minute = time.minute + aExtraMinutes + minutesOverflow;\n            time.minute = minute % 60;\n            hoursOverflow = trunc(minute / 60);\n            if (time.minute < 0) {\n                time.minute += 60;\n                hoursOverflow--;\n            }\n            hour = time.hour + aExtraHours + hoursOverflow;\n            time.hour = hour % 24;\n            daysOverflow = trunc(hour / 24);\n            if (time.hour < 0) {\n                time.hour += 24;\n                daysOverflow--;\n            }\n        }\n        // Adjust month and year first, because we need to know what month the day\n        // is in before adjusting it.\n        if (time.month > 12) {\n            yearsOverflow = trunc((time.month - 1) / 12);\n        } else if (time.month < 1) {\n            yearsOverflow = trunc(time.month / 12) - 1;\n        }\n        time.year += yearsOverflow;\n        time.month -= 12 * yearsOverflow;\n        // Now take care of the days (and adjust month if needed)\n        day = time.day + aExtraDays + daysOverflow;\n        if (day > 0) {\n            for(;;){\n                daysInMonth = Time.daysInMonth(time.month, time.year);\n                if (day <= daysInMonth) {\n                    break;\n                }\n                time.month++;\n                if (time.month > 12) {\n                    time.year++;\n                    time.month = 1;\n                }\n                day -= daysInMonth;\n            }\n        } else {\n            while(day <= 0){\n                if (time.month == 1) {\n                    time.year--;\n                    time.month = 12;\n                } else {\n                    time.month--;\n                }\n                day += Time.daysInMonth(time.month, time.year);\n            }\n        }\n        time.day = day;\n        this._cachedUnixTime = null;\n        return this;\n    }\n    /**\n   * Sets up the current instance from unix time, the number of seconds since\n   * January 1st, 1970.\n   *\n   * @param {Number} seconds      The seconds to set up with\n   */ fromUnixTime(seconds) {\n        this.zone = Timezone.utcTimezone;\n        // We could use `fromJSDate` here, but this is about twice as fast.\n        // We could also clone `epochTime` and use `adjust` for a more\n        // ical.js-centric approach, but this is about 100 times as fast.\n        let date = new Date(seconds * 1000);\n        this.year = date.getUTCFullYear();\n        this.month = date.getUTCMonth() + 1;\n        this.day = date.getUTCDate();\n        if (this._time.isDate) {\n            this.hour = 0;\n            this.minute = 0;\n            this.second = 0;\n        } else {\n            this.hour = date.getUTCHours();\n            this.minute = date.getUTCMinutes();\n            this.second = date.getUTCSeconds();\n        }\n        this._cachedUnixTime = null;\n    }\n    /**\n   * Converts the current instance to seconds since January 1st 1970.\n   *\n   * @return {Number}         Seconds since 1970\n   */ toUnixTime() {\n        if (this._cachedUnixTime !== null) {\n            return this._cachedUnixTime;\n        }\n        let offset = this.utcOffset();\n        // we use the offset trick to ensure\n        // that we are getting the actual UTC time\n        let ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset);\n        // seconds\n        this._cachedUnixTime = ms / 1000;\n        return this._cachedUnixTime;\n    }\n    /**\n   * Converts time to into Object which can be serialized then re-created\n   * using the constructor.\n   *\n   * @example\n   * // toJSON will automatically be called\n   * var json = JSON.stringify(mytime);\n   *\n   * var deserialized = JSON.parse(json);\n   *\n   * var time = new ICAL.Time(deserialized);\n   *\n   * @return {Object}\n   */ toJSON() {\n        let copy = [\n            \"year\",\n            \"month\",\n            \"day\",\n            \"hour\",\n            \"minute\",\n            \"second\",\n            \"isDate\"\n        ];\n        let result = Object.create(null);\n        let i = 0;\n        let len = copy.length;\n        let prop;\n        for(; i < len; i++){\n            prop = copy[i];\n            result[prop] = this[prop];\n        }\n        if (this.zone) {\n            result.timezone = this.zone.tzid;\n        }\n        return result;\n    }\n}\n(function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n        Object.defineProperty(Time.prototype, attr, {\n            get: function getTimeAttr() {\n                if (this._pendingNormalization) {\n                    this._normalize();\n                    this._pendingNormalization = false;\n                }\n                return this._time[attr];\n            },\n            set: function setTimeAttr(val) {\n                // Check if isDate will be set and if was not set to normalize date.\n                // This avoids losing days when seconds, minutes and hours are zeroed\n                // what normalize will do when time is a date.\n                if (attr === \"isDate\" && val && !this._time.isDate) {\n                    this.adjust(0, 0, 0, 0);\n                }\n                this._cachedUnixTime = null;\n                this._pendingNormalization = true;\n                this._time[attr] = val;\n            }\n        });\n    }\n    defineAttr(\"year\");\n    defineAttr(\"month\");\n    defineAttr(\"day\");\n    defineAttr(\"hour\");\n    defineAttr(\"minute\");\n    defineAttr(\"second\");\n    defineAttr(\"isDate\");\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").parserState} parserState\n * Imports the 'parserState' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n */ const CHAR = /[^ \\t]/;\nconst VALUE_DELIMITER = \":\";\nconst PARAM_DELIMITER = \";\";\nconst PARAM_NAME_DELIMITER = \"=\";\nconst DEFAULT_VALUE_TYPE$1 = \"unknown\";\nconst DEFAULT_PARAM_TYPE = \"text\";\nconst RFC6868_REPLACE_MAP$1 = {\n    \"^'\": '\"',\n    \"^n\": \"\\n\",\n    \"^^\": \"^\"\n};\n/**\n * Parses iCalendar or vCard data into a raw jCal object. Consult\n * documentation on the {@tutorial layers|layers of parsing} for more\n * details.\n *\n * @function ICAL.parse\n * @memberof ICAL\n * @variation function\n * @todo Fix the API to be more clear on the return type\n * @param {String} input      The string data to parse\n * @return {Object|Object[]}  A single jCal object, or an array thereof\n */ function parse(input) {\n    let state = {};\n    let root = state.component = [];\n    state.stack = [\n        root\n    ];\n    parse._eachLine(input, function(err, line) {\n        parse._handleContentLine(line, state);\n    });\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n        throw new ParserError(\"invalid ical body. component began but did not end\");\n    }\n    state = null;\n    return root.length == 1 ? root[0] : root;\n}\n/**\n * Parse an iCalendar property value into the jCal for a single property\n *\n * @function ICAL.parse.property\n * @param {String} str\n *   The iCalendar property string to parse\n * @param {designSet=} designSet\n *   The design data to use for this property\n * @return {Object}\n *   The jCal Object containing the property\n */ parse.property = function(str, designSet) {\n    let state = {\n        component: [\n            [],\n            []\n        ],\n        designSet: designSet || design$1.defaultSet\n    };\n    parse._handleContentLine(str, state);\n    return state.component[1][0];\n};\n/**\n * Convenience method to parse a component. You can use ICAL.parse() directly\n * instead.\n *\n * @function ICAL.parse.component\n * @see ICAL.parse(function)\n * @param {String} str    The iCalendar component string to parse\n * @return {Object}       The jCal Object containing the component\n */ parse.component = function(str) {\n    return parse(str);\n};\n/**\n * An error that occurred during parsing.\n *\n * @param {String} message        The error message\n * @memberof ICAL.parse\n * @extends {Error}\n */ class ParserError extends Error {\n    constructor(...args){\n        super(...args);\n        this.name = this.constructor.name;\n    }\n}\n// classes & constants\nparse.ParserError = ParserError;\n/**\n * Handles a single line of iCalendar/vCard, updating the state.\n *\n * @private\n * @function ICAL.parse._handleContentLine\n * @param {String} line          The content line to process\n * @param {parserState} state    The current state of the line parsing\n */ parse._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    let valuePos = line.indexOf(VALUE_DELIMITER);\n    let paramPos = line.indexOf(PARAM_DELIMITER);\n    let lastParamIndex;\n    let lastValuePos;\n    // name of property or begin/end\n    let name;\n    let value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    let params = {};\n    /**\n   * Different property cases\n   *\n   *\n   * 1. RRULE:FREQ=foo\n   *    // FREQ= is not a param but the value\n   *\n   * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n   *    // ROLE= is a param because : has not happened yet\n   */ // when the parameter delimiter is after the\n    // value delimiter then it is not a parameter.\n    if (paramPos !== -1 && valuePos !== -1) {\n        // when the parameter delimiter is after the\n        // value delimiter then it is not a parameter.\n        if (paramPos > valuePos) {\n            paramPos = -1;\n        }\n    }\n    let parsedParams;\n    if (paramPos !== -1) {\n        name = line.slice(0, Math.max(0, paramPos)).toLowerCase();\n        parsedParams = parse._parseParameters(line.slice(Math.max(0, paramPos)), 0, state.designSet);\n        if (parsedParams[2] == -1) {\n            throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n        }\n        params = parsedParams[0];\n        lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n        if ((lastValuePos = line.slice(Math.max(0, lastParamIndex)).indexOf(VALUE_DELIMITER)) !== -1) {\n            value = line.slice(Math.max(0, lastParamIndex + lastValuePos + 1));\n        } else {\n            throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n        }\n    } else if (valuePos !== -1) {\n        // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n        name = line.slice(0, Math.max(0, valuePos)).toLowerCase();\n        value = line.slice(Math.max(0, valuePos + 1));\n        if (name === \"begin\") {\n            let newComponent = [\n                value.toLowerCase(),\n                [],\n                []\n            ];\n            if (state.stack.length === 1) {\n                state.component.push(newComponent);\n            } else {\n                state.component[2].push(newComponent);\n            }\n            state.stack.push(state.component);\n            state.component = newComponent;\n            if (!state.designSet) {\n                state.designSet = design$1.getDesignSet(state.component[0]);\n            }\n            return;\n        } else if (name === \"end\") {\n            state.component = state.stack.pop();\n            return;\n        }\n    // If it is not begin/end, then this is a property with an empty value,\n    // which should be considered valid.\n    } else {\n        /**\n     * Invalid line.\n     * The rational to throw an error is we will\n     * never be certain that the rest of the file\n     * is sane and it is unlikely that we can serialize\n     * the result correctly either.\n     */ throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n    }\n    let valueType;\n    let multiValue = false;\n    let structuredValue = false;\n    let propertyDetails;\n    let splitName;\n    let ungroupedName;\n    // fetch the ungrouped part of the name\n    if (state.designSet.propertyGroups && name.indexOf(\".\") !== -1) {\n        splitName = name.split(\".\");\n        params.group = splitName[0];\n        ungroupedName = splitName[1];\n    } else {\n        ungroupedName = name;\n    }\n    if (ungroupedName in state.designSet.property) {\n        propertyDetails = state.designSet.property[ungroupedName];\n        if (\"multiValue\" in propertyDetails) {\n            multiValue = propertyDetails.multiValue;\n        }\n        if (\"structuredValue\" in propertyDetails) {\n            structuredValue = propertyDetails.structuredValue;\n        }\n        if (value && \"detectType\" in propertyDetails) {\n            valueType = propertyDetails.detectType(value);\n        }\n    }\n    // attempt to determine value\n    if (!valueType) {\n        if (!(\"value\" in params)) {\n            if (propertyDetails) {\n                valueType = propertyDetails.defaultType;\n            } else {\n                valueType = DEFAULT_VALUE_TYPE$1;\n            }\n        } else {\n            // possible to avoid this?\n            valueType = params.value.toLowerCase();\n        }\n    }\n    delete params.value;\n    /**\n   * Note on `var result` juggling:\n   *\n   * I observed that building the array in pieces has adverse\n   * effects on performance, so where possible we inline the creation.\n   * It is a little ugly but resulted in ~2000 additional ops/sec.\n   */ let result;\n    if (multiValue && structuredValue) {\n        value = parse._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n        result = [\n            ungroupedName,\n            params,\n            valueType,\n            value\n        ];\n    } else if (multiValue) {\n        result = [\n            ungroupedName,\n            params,\n            valueType\n        ];\n        parse._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n        value = parse._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n        result = [\n            ungroupedName,\n            params,\n            valueType,\n            value\n        ];\n    } else {\n        value = parse._parseValue(value, valueType, state.designSet, false);\n        result = [\n            ungroupedName,\n            params,\n            valueType,\n            value\n        ];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === \"vcard\" && state.component[1].length === 0 && !(name === \"version\" && value === \"4.0\")) {\n        state.designSet = design$1.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n};\n/**\n * Parse a value from the raw value into the jCard/jCal value.\n *\n * @private\n * @function ICAL.parse._parseValue\n * @param {String} value          Original value\n * @param {String} type           Type of value\n * @param {Object} designSet      The design data to use for this value\n * @return {Object} varies on type\n */ parse._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && \"fromICAL\" in designSet.value[type]) {\n        return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n};\n/**\n * Parse parameters from a string to object.\n *\n * @function ICAL.parse._parseParameters\n * @private\n * @param {String} line           A single unfolded line\n * @param {Number} start         Position to start looking for properties\n * @param {Object} designSet      The design data to use for this property\n * @return {Object} key/value pairs\n */ parse._parseParameters = function(line, start, designSet) {\n    let lastParam = start;\n    let pos = 0;\n    let delim = PARAM_NAME_DELIMITER;\n    let result = {};\n    let name, lcname;\n    let value, valuePos = -1;\n    let type, multiValue, mvdelim;\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n    while(pos !== false && (pos = line.indexOf(delim, pos + 1)) !== -1){\n        name = line.slice(lastParam + 1, pos);\n        if (name.length == 0) {\n            throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n        }\n        lcname = name.toLowerCase();\n        mvdelim = false;\n        multiValue = false;\n        if (lcname in designSet.param && designSet.param[lcname].valueType) {\n            type = designSet.param[lcname].valueType;\n        } else {\n            type = DEFAULT_PARAM_TYPE;\n        }\n        if (lcname in designSet.param) {\n            multiValue = designSet.param[lcname].multiValue;\n            if (designSet.param[lcname].multiValueSeparateDQuote) {\n                mvdelim = parse._rfc6868Escape('\"' + multiValue + '\"');\n            }\n        }\n        let nextChar = line[pos + 1];\n        if (nextChar === '\"') {\n            valuePos = pos + 2;\n            pos = line.indexOf('\"', valuePos);\n            if (multiValue && pos != -1) {\n                let extendedValue = true;\n                while(extendedValue){\n                    if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                        pos = line.indexOf('\"', pos + 3);\n                    } else {\n                        extendedValue = false;\n                    }\n                }\n            }\n            if (pos === -1) {\n                throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n            }\n            value = line.slice(valuePos, pos);\n            lastParam = line.indexOf(PARAM_DELIMITER, pos);\n            let propValuePos = line.indexOf(VALUE_DELIMITER, pos);\n            // if either no next parameter or delimeter in property value, let's stop here\n            if (lastParam === -1 || propValuePos !== -1 && lastParam > propValuePos) {\n                pos = false;\n            }\n        } else {\n            valuePos = pos + 1;\n            // move to next \";\"\n            let nextPos = line.indexOf(PARAM_DELIMITER, valuePos);\n            let propValuePos = line.indexOf(VALUE_DELIMITER, valuePos);\n            if (propValuePos !== -1 && nextPos > propValuePos) {\n                // this is a delimiter in the property value, let's stop here\n                nextPos = propValuePos;\n                pos = false;\n            } else if (nextPos === -1) {\n                // no \";\"\n                if (propValuePos === -1) {\n                    nextPos = line.length;\n                } else {\n                    nextPos = propValuePos;\n                }\n                pos = false;\n            } else {\n                lastParam = nextPos;\n                pos = nextPos;\n            }\n            value = line.slice(valuePos, nextPos);\n        }\n        const length_before = value.length;\n        value = parse._rfc6868Escape(value);\n        valuePos += length_before - value.length;\n        if (multiValue) {\n            let delimiter = mvdelim || multiValue;\n            value = parse._parseMultiValue(value, delimiter, type, [], null, designSet);\n        } else {\n            value = parse._parseValue(value, type, designSet);\n        }\n        if (multiValue && lcname in result) {\n            if (Array.isArray(result[lcname])) {\n                result[lcname].push(value);\n            } else {\n                result[lcname] = [\n                    result[lcname],\n                    value\n                ];\n            }\n        } else {\n            result[lcname] = value;\n        }\n    }\n    return [\n        result,\n        value,\n        valuePos\n    ];\n};\n/**\n * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n * hackers can disable the rfc6868 parsing if the really need to.\n *\n * @function ICAL.parse._rfc6868Escape\n * @param {String} val        The value to escape\n * @return {String}           The escaped value\n */ parse._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n        return RFC6868_REPLACE_MAP$1[x];\n    });\n};\n/**\n * Parse a multi value string. This function is used either for parsing\n * actual multi-value property's values, or for handling parameter values. It\n * can be used for both multi-value properties and structured value properties.\n *\n * @private\n * @function ICAL.parse._parseMultiValue\n * @param {String} buffer           The buffer containing the full value\n * @param {String} delim            The multi-value delimiter\n * @param {String} type             The value type to be parsed\n * @param {Array.<?>} result        The array to append results to, varies on value type\n * @param {String} innerMulti       The inner delimiter to split each value with\n * @param {designSet} designSet     The design data for this value\n * @return {?|Array.<?>}            Either an array of results, or the first result\n */ parse._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    let pos = 0;\n    let lastPos = 0;\n    let value;\n    if (delim.length === 0) {\n        return buffer;\n    }\n    // split each piece\n    while((pos = unescapedIndexOf(buffer, delim, lastPos)) !== -1){\n        value = buffer.slice(lastPos, pos);\n        if (innerMulti) {\n            value = parse._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n        } else {\n            value = parse._parseValue(value, type, designSet, structuredValue);\n        }\n        result.push(value);\n        lastPos = pos + delim.length;\n    }\n    // on the last piece take the rest of string\n    value = buffer.slice(lastPos);\n    if (innerMulti) {\n        value = parse._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n        value = parse._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n    return result.length == 1 ? result[0] : result;\n};\n/**\n * Process a complete buffer of iCalendar/vCard data line by line, correctly\n * unfolding content. Each line will be processed with the given callback\n *\n * @private\n * @function ICAL.parse._eachLine\n * @param {String} buffer                         The buffer to process\n * @param {function(?String, String)} callback    The callback for each line\n */ parse._eachLine = function(buffer, callback) {\n    let len = buffer.length;\n    let lastPos = buffer.search(CHAR);\n    let pos = lastPos;\n    let line;\n    let firstChar;\n    let newlineOffset;\n    do {\n        pos = buffer.indexOf(\"\\n\", lastPos) + 1;\n        if (pos > 1 && buffer[pos - 2] === \"\\r\") {\n            newlineOffset = 2;\n        } else {\n            newlineOffset = 1;\n        }\n        if (pos === 0) {\n            pos = len;\n            newlineOffset = 0;\n        }\n        firstChar = buffer[lastPos];\n        if (firstChar === \" \" || firstChar === \"\t\") {\n            // add to line\n            line += buffer.slice(lastPos + 1, pos - newlineOffset);\n        } else {\n            if (line) callback(null, line);\n            // push line\n            line = buffer.slice(lastPos, pos - newlineOffset);\n        }\n        lastPos = pos;\n    }while (pos !== len);\n    // extra ending line\n    line = line.trim();\n    if (line.length) callback(null, line);\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ const OPTIONS = [\n    \"tzid\",\n    \"location\",\n    \"tznames\",\n    \"latitude\",\n    \"longitude\"\n];\n/**\n * Timezone representation.\n *\n * @example\n * var vcalendar;\n * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n *\n * var timezone = new ICAL.Timezone({\n *   component: timezoneComp,\n *   tzid\n * });\n *\n * @memberof ICAL\n */ class Timezone {\n    static _compare_change_fn(a, b) {\n        if (a.year < b.year) return -1;\n        else if (a.year > b.year) return 1;\n        if (a.month < b.month) return -1;\n        else if (a.month > b.month) return 1;\n        if (a.day < b.day) return -1;\n        else if (a.day > b.day) return 1;\n        if (a.hour < b.hour) return -1;\n        else if (a.hour > b.hour) return 1;\n        if (a.minute < b.minute) return -1;\n        else if (a.minute > b.minute) return 1;\n        if (a.second < b.second) return -1;\n        else if (a.second > b.second) return 1;\n        return 0;\n    }\n    /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {Time} tt                  The time to convert\n   * @param {Timezone} from_zone       The source zone to convert from\n   * @param {Timezone} to_zone         The target zone to convert to\n   * @return {Time}                    The converted date/time object\n   */ static convert_time(tt, from_zone, to_zone) {\n        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == Timezone.localTimezone || to_zone == Timezone.localTimezone) {\n            tt.zone = to_zone;\n            return tt;\n        }\n        let utcOffset = from_zone.utcOffset(tt);\n        tt.adjust(0, 0, 0, -utcOffset);\n        utcOffset = to_zone.utcOffset(tt);\n        tt.adjust(0, 0, 0, utcOffset);\n        return null;\n    }\n    /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {Component|Object} aData options for class\n   * @param {String|Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */ static fromData(aData) {\n        let tt = new Timezone();\n        return tt.fromData(aData);\n    }\n    /**\n   * The instance describing the UTC timezone\n   * @type {Timezone}\n   * @constant\n   * @instance\n   */ static #utcTimezone = null;\n    static get utcTimezone() {\n        if (!this.#utcTimezone) {\n            this.#utcTimezone = Timezone.fromData({\n                tzid: \"UTC\"\n            });\n        }\n        return this.#utcTimezone;\n    }\n    /**\n   * The instance describing the local timezone\n   * @type {Timezone}\n   * @constant\n   * @instance\n   */ static #localTimezone = null;\n    static get localTimezone() {\n        if (!this.#localTimezone) {\n            this.#localTimezone = Timezone.fromData({\n                tzid: \"floating\"\n            });\n        }\n        return this.#localTimezone;\n    }\n    /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */ static adjust_change(change, days, hours, minutes, seconds) {\n        return Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n    }\n    static{\n        this._minimumExpansionYear = -1;\n    }\n    static{\n        this.EXTRA_COVERAGE = 5;\n    }\n    /**\n   * Creates a new ICAL.Timezone instance, by passing in a tzid and component.\n   *\n   * @param {Component|Object} data options for class\n   * @param {String|Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */ constructor(data){\n        /**\n   * Timezone identifier\n   * @type {String}\n   */ this.tzid = \"\";\n        /**\n   * Timezone location\n   * @type {String}\n   */ this.location = \"\";\n        /**\n   * Alternative timezone name, for the string representation\n   * @type {String}\n   */ this.tznames = \"\";\n        /**\n   * The primary latitude for the timezone.\n   * @type {Number}\n   */ this.latitude = 0.0;\n        /**\n   * The primary longitude for the timezone.\n   * @type {Number}\n   */ this.longitude = 0.0;\n        /**\n   * The vtimezone component for this timezone.\n   * @type {Component}\n   */ this.component = null;\n        /**\n   * The year this timezone has been expanded to. All timezone transition\n   * dates until this year are known and can be used for calculation\n   *\n   * @private\n   * @type {Number}\n   */ this.expandedUntilYear = 0;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icaltimezone\"\n   */ this.icalclass = \"icaltimezone\";\n        this.wrappedJSObject = this;\n        this.fromData(data);\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Component|Object} aData options for class\n   * @param {String|Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */ fromData(aData) {\n        this.expandedUntilYear = 0;\n        this.changes = [];\n        if (aData instanceof Component) {\n            // Either a component is passed directly\n            this.component = aData;\n        } else {\n            // Otherwise the component may be in the data object\n            if (aData && \"component\" in aData) {\n                if (typeof aData.component == \"string\") {\n                    // If a string was passed, parse it as a component\n                    let jCal = parse(aData.component);\n                    this.component = new Component(jCal);\n                } else if (aData.component instanceof Component) {\n                    // If it was a component already, then just set it\n                    this.component = aData.component;\n                } else {\n                    // Otherwise just null out the component\n                    this.component = null;\n                }\n            }\n            // Copy remaining passed properties\n            for (let prop of OPTIONS){\n                if (aData && prop in aData) {\n                    this[prop] = aData[prop];\n                }\n            }\n        }\n        // If we have a component but no TZID, attempt to get it from the\n        // component's properties.\n        if (this.component instanceof Component && !this.tzid) {\n            this.tzid = this.component.getFirstPropertyValue(\"tzid\");\n        }\n        return this;\n    }\n    /**\n   * Finds the utcOffset the given time would occur in this timezone.\n   *\n   * @param {Time} tt         The time to check for\n   * @return {Number}         utc offset in seconds\n   */ utcOffset(tt) {\n        if (this == Timezone.utcTimezone || this == Timezone.localTimezone) {\n            return 0;\n        }\n        this._ensureCoverage(tt.year);\n        if (!this.changes.length) {\n            return 0;\n        }\n        let tt_change = {\n            year: tt.year,\n            month: tt.month,\n            day: tt.day,\n            hour: tt.hour,\n            minute: tt.minute,\n            second: tt.second\n        };\n        let change_num = this._findNearbyChange(tt_change);\n        let change_num_to_use = -1;\n        let step = 1;\n        // TODO: replace with bin search?\n        for(;;){\n            let change = clone(this.changes[change_num], true);\n            if (change.utcOffset < change.prevUtcOffset) {\n                Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n            } else {\n                Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n            }\n            let cmp = Timezone._compare_change_fn(tt_change, change);\n            if (cmp >= 0) {\n                change_num_to_use = change_num;\n            } else {\n                step = -1;\n            }\n            if (step == -1 && change_num_to_use != -1) {\n                break;\n            }\n            change_num += step;\n            if (change_num < 0) {\n                return 0;\n            }\n            if (change_num >= this.changes.length) {\n                break;\n            }\n        }\n        let zone_change = this.changes[change_num_to_use];\n        let utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n        if (utcOffset_change < 0 && change_num_to_use > 0) {\n            let tmp_change = clone(zone_change, true);\n            Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n            if (Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n                let prev_zone_change = this.changes[change_num_to_use - 1];\n                let want_daylight = false; // TODO\n                if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n                    zone_change = prev_zone_change;\n                }\n            }\n        }\n        // TODO return is_daylight?\n        return zone_change.utcOffset;\n    }\n    _findNearbyChange(change) {\n        // find the closest match\n        let idx = binsearchInsert(this.changes, change, Timezone._compare_change_fn);\n        if (idx >= this.changes.length) {\n            return this.changes.length - 1;\n        }\n        return idx;\n    }\n    _ensureCoverage(aYear) {\n        if (Timezone._minimumExpansionYear == -1) {\n            let today = Time.now();\n            Timezone._minimumExpansionYear = today.year;\n        }\n        let changesEndYear = aYear;\n        if (changesEndYear < Timezone._minimumExpansionYear) {\n            changesEndYear = Timezone._minimumExpansionYear;\n        }\n        changesEndYear += Timezone.EXTRA_COVERAGE;\n        if (!this.changes.length || this.expandedUntilYear < aYear) {\n            let subcomps = this.component.getAllSubcomponents();\n            let compLen = subcomps.length;\n            let compIdx = 0;\n            for(; compIdx < compLen; compIdx++){\n                this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n            }\n            this.changes.sort(Timezone._compare_change_fn);\n            this.expandedUntilYear = changesEndYear;\n        }\n    }\n    _expandComponent(aComponent, aYear, changes) {\n        if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n            return null;\n        }\n        let dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n        let change;\n        function convert_tzoffset(offset) {\n            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n        }\n        function init_changes() {\n            let changebase = {};\n            changebase.is_daylight = aComponent.name == \"daylight\";\n            changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n            changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n            return changebase;\n        }\n        if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n            change = init_changes();\n            change.year = dtstart.year;\n            change.month = dtstart.month;\n            change.day = dtstart.day;\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n            Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            changes.push(change);\n        } else {\n            let props = aComponent.getAllProperties(\"rdate\");\n            for (let rdate of props){\n                let time = rdate.getFirstValue();\n                change = init_changes();\n                change.year = time.year;\n                change.month = time.month;\n                change.day = time.day;\n                if (time.isDate) {\n                    change.hour = dtstart.hour;\n                    change.minute = dtstart.minute;\n                    change.second = dtstart.second;\n                    if (dtstart.zone != Timezone.utcTimezone) {\n                        Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                    }\n                } else {\n                    change.hour = time.hour;\n                    change.minute = time.minute;\n                    change.second = time.second;\n                    if (time.zone != Timezone.utcTimezone) {\n                        Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                    }\n                }\n                changes.push(change);\n            }\n            let rrule = aComponent.getFirstProperty(\"rrule\");\n            if (rrule) {\n                rrule = rrule.getFirstValue();\n                change = init_changes();\n                if (rrule.until && rrule.until.zone == Timezone.utcTimezone) {\n                    rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n                    rrule.until.zone = Timezone.localTimezone;\n                }\n                let iterator = rrule.iterator(dtstart);\n                let occ;\n                while(occ = iterator.next()){\n                    change = init_changes();\n                    if (occ.year > aYear || !occ) {\n                        break;\n                    }\n                    change.year = occ.year;\n                    change.month = occ.month;\n                    change.day = occ.day;\n                    change.hour = occ.hour;\n                    change.minute = occ.minute;\n                    change.second = occ.second;\n                    change.isDate = occ.isDate;\n                    Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                    changes.push(change);\n                }\n            }\n        }\n        return changes;\n    }\n    /**\n   * The string representation of this timezone.\n   * @return {String}\n   */ toString() {\n        return this.tznames ? this.tznames : this.tzid;\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ let zones = null;\n/**\n * @classdesc\n * Singleton class to contain timezones.  Right now it is all manual registry in\n * the future we may use this class to download timezone information or handle\n * loading pre-expanded timezones.\n *\n * @exports module:ICAL.TimezoneService\n * @memberof ICAL\n */ const TimezoneService = {\n    get count () {\n        if (zones === null) {\n            return 0;\n        }\n        return Object.keys(zones).length;\n    },\n    reset: function() {\n        zones = Object.create(null);\n        let utc = Timezone.utcTimezone;\n        zones.Z = utc;\n        zones.UTC = utc;\n        zones.GMT = utc;\n    },\n    _hard_reset: function() {\n        zones = null;\n    },\n    /**\n   * Checks if timezone id has been registered.\n   *\n   * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n   * @return {Boolean}        False, when not present\n   */ has: function(tzid) {\n        if (zones === null) {\n            return false;\n        }\n        return !!zones[tzid];\n    },\n    /**\n   * Returns a timezone by its tzid if present.\n   *\n   * @param {String} tzid               Timezone identifier (e.g. America/Los_Angeles)\n   * @return {Timezone | undefined}     The timezone, or undefined if not found\n   */ get: function(tzid) {\n        if (zones === null) {\n            this.reset();\n        }\n        return zones[tzid];\n    },\n    /**\n   * Registers a timezone object or component.\n   *\n   * @param {Component|Timezone} timezone\n   *        The initialized zone or vtimezone.\n   *\n   * @param {String=} name\n   *        The name of the timezone. Defaults to the component's TZID if not\n   *        passed.\n   */ register: function(timezone, name) {\n        if (zones === null) {\n            this.reset();\n        }\n        // This avoids a breaking change by the change of argument order\n        // TODO remove in v3\n        if (typeof timezone === \"string\" && name instanceof Timezone) {\n            [timezone, name] = [\n                name,\n                timezone\n            ];\n        }\n        if (!name) {\n            if (timezone instanceof Timezone) {\n                name = timezone.tzid;\n            } else {\n                if (timezone.name === \"vtimezone\") {\n                    timezone = new Timezone(timezone);\n                    name = timezone.tzid;\n                }\n            }\n        }\n        if (!name) {\n            throw new TypeError(\"Neither a timezone nor a name was passed\");\n        }\n        if (timezone instanceof Timezone) {\n            zones[name] = timezone;\n        } else {\n            throw new TypeError(\"timezone must be ICAL.Timezone or ICAL.Component\");\n        }\n    },\n    /**\n   * Removes a timezone by its tzid from the list.\n   *\n   * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n   * @return {?Timezone}      The removed timezone, or null if not registered\n   */ remove: function(tzid) {\n        if (zones === null) {\n            return null;\n        }\n        return delete zones[tzid];\n    }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Helper functions used in various places within ical.js\n * @module ICAL.helpers\n */ /**\n * Compiles a list of all referenced TZIDs in all subcomponents and\n * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n * are referenced by a component, but a VTIMEZONE does not exist,\n * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n *\n * @param {Component} vcal     The top-level VCALENDAR component.\n * @return {Component}         The ICAL.Component that was passed in.\n */ function updateTimezones(vcal) {\n    let allsubs, properties, vtimezones, reqTzid, i;\n    if (!vcal || vcal.name !== \"vcalendar\") {\n        //not a top-level vcalendar component\n        return vcal;\n    }\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for(i = 0; i < allsubs.length; i++){\n        if (allsubs[i].name === \"vtimezone\") {\n            let tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n            vtimezones[tzid] = allsubs[i];\n        } else {\n            properties = properties.concat(allsubs[i].getAllProperties());\n        }\n    }\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for(i = 0; i < properties.length; i++){\n        let tzid = properties[i].getParameter(\"tzid\");\n        if (tzid) {\n            reqTzid[tzid] = true;\n        }\n    }\n    //delete any vtimezones that are not on the reqTzid list.\n    for (let [tzid, comp] of Object.entries(vtimezones)){\n        if (!reqTzid[tzid]) {\n            vcal.removeSubcomponent(comp);\n        }\n    }\n    //create any missing, but registered timezones\n    for (let tzid of Object.keys(reqTzid)){\n        if (!vtimezones[tzid] && TimezoneService.has(tzid)) {\n            vcal.addSubcomponent(TimezoneService.get(tzid).component);\n        }\n    }\n    return vcal;\n}\n/**\n * Checks if the given type is of the number type and also NaN.\n *\n * @param {Number} number     The number to check\n * @return {Boolean}          True, if the number is strictly NaN\n */ function isStrictlyNaN(number) {\n    return typeof number === \"number\" && isNaN(number);\n}\n/**\n * Parses a string value that is expected to be an integer, when the valid is\n * not an integer throws a decoration error.\n *\n * @param {String} string     Raw string input\n * @return {Number}           Parsed integer\n */ function strictParseInt(string) {\n    let result = parseInt(string, 10);\n    if (isStrictlyNaN(result)) {\n        throw new Error('Could not extract integer from \"' + string + '\"');\n    }\n    return result;\n}\n/**\n * Creates or returns a class instance of a given type with the initialization\n * data if the data is not already an instance of the given type.\n *\n * @example\n * var time = new ICAL.Time(...);\n * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n *\n * (result instanceof ICAL.Time)\n * // => true\n *\n * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n * (result isntanceof ICAL.Time)\n * // => true\n *\n *\n * @param {Object} data       object initialization data\n * @param {Object} type       object type (like ICAL.Time)\n * @return {?}                An instance of the found type.\n */ function formatClassType(data, type) {\n    if (typeof data === \"undefined\") {\n        return undefined;\n    }\n    if (data instanceof type) {\n        return data;\n    }\n    return new type(data);\n}\n/**\n * Identical to indexOf but will only match values when they are not preceded\n * by a backslash character.\n *\n * @param {String} buffer         String to search\n * @param {String} search         Value to look for\n * @param {Number} pos            Start position\n * @return {Number}               The position, or -1 if not found\n */ function unescapedIndexOf(buffer, search, pos) {\n    while((pos = buffer.indexOf(search, pos)) !== -1){\n        if (pos > 0 && buffer[pos - 1] === \"\\\\\") {\n            pos += 1;\n        } else {\n            return pos;\n        }\n    }\n    return -1;\n}\n/**\n * Find the index for insertion using binary search.\n *\n * @param {Array} list            The list to search\n * @param {?} seekVal             The value to insert\n * @param {function(?,?)} cmpfunc The comparison func, that can\n *                                  compare two seekVals\n * @return {Number}               The insert position\n */ function binsearchInsert(list, seekVal, cmpfunc) {\n    if (!list.length) return 0;\n    let low = 0, high = list.length - 1, mid, cmpval;\n    while(low <= high){\n        mid = low + Math.floor((high - low) / 2);\n        cmpval = cmpfunc(seekVal, list[mid]);\n        if (cmpval < 0) high = mid - 1;\n        else if (cmpval > 0) low = mid + 1;\n        else break;\n    }\n    if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0) return mid + 1;\n    else return mid;\n}\n/**\n * Clone the passed object or primitive. By default a shallow clone will be\n * executed.\n *\n * @param {*} aSrc            The thing to clone\n * @param {Boolean=} aDeep    If true, a deep clone will be performed\n * @return {*}                The copy of the thing\n */ function clone(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n        return aSrc;\n    } else if (aSrc instanceof Date) {\n        return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n        return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n        let arr = [];\n        for(let i = 0; i < aSrc.length; i++){\n            arr.push(aDeep ? clone(aSrc[i], true) : aSrc[i]);\n        }\n        return arr;\n    } else {\n        let obj = {};\n        for (let [name, value] of Object.entries(aSrc)){\n            if (aDeep) {\n                obj[name] = clone(value, true);\n            } else {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n}\n/**\n * Performs iCalendar line folding. A line ending character is inserted and\n * the next line begins with a whitespace.\n *\n * @example\n * SUMMARY:This line will be fold\n *  ed right in the middle of a word.\n *\n * @param {String} aLine      The line to fold\n * @return {String}           The folded line\n */ function foldline(aLine) {\n    let result = \"\";\n    let line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while(line.length){\n        let cp = line.codePointAt(pos);\n        if (cp < 128) ++line_length;\n        else if (cp < 2048) line_length += 2; //needs 2 UTF-8 bytes\n        else if (cp < 65536) line_length += 3;\n        else line_length += 4; //cp is less than 1114112\n        if (line_length < ICALmodule.foldLength + 1) pos += cp > 65535 ? 2 : 1;\n        else {\n            result += ICALmodule.newLineChar + \" \" + line.slice(0, Math.max(0, pos));\n            line = line.slice(Math.max(0, pos));\n            pos = line_length = 0;\n        }\n    }\n    return result.slice(ICALmodule.newLineChar.length + 1);\n}\n/**\n * Pads the given string or number with zeros so it will have at least two\n * characters.\n *\n * @param {String|Number} data    The string or number to pad\n * @return {String}               The number padded as a string\n */ function pad2(data) {\n    if (typeof data !== \"string\") {\n        // handle fractions.\n        if (typeof data === \"number\") {\n            data = parseInt(data);\n        }\n        data = String(data);\n    }\n    let len = data.length;\n    switch(len){\n        case 0:\n            return \"00\";\n        case 1:\n            return \"0\" + data;\n        default:\n            return data;\n    }\n}\n/**\n * Truncates the given number, correctly handling negative numbers.\n *\n * @param {Number} number     The number to truncate\n * @return {Number}           The truncated number\n */ function trunc(number) {\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n}\n/**\n * Poor-man's cross-browser object extension. Doesn't support all the\n * features, but enough for our usage. Note that the target's properties are\n * not overwritten with the source properties.\n *\n * @example\n * var child = ICAL.helpers.extend(parent, {\n *   \"bar\": 123\n * });\n *\n * @param {Object} source     The object to extend\n * @param {Object} target     The object to extend with\n * @return {Object}           Returns the target.\n */ function extend(source, target) {\n    for(let key in source){\n        let descr = Object.getOwnPropertyDescriptor(source, key);\n        if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n            Object.defineProperty(target, key, descr);\n        }\n    }\n    return target;\n}\nvar helpers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    updateTimezones: updateTimezones,\n    isStrictlyNaN: isStrictlyNaN,\n    strictParseInt: strictParseInt,\n    formatClassType: formatClassType,\n    unescapedIndexOf: unescapedIndexOf,\n    binsearchInsert: binsearchInsert,\n    clone: clone,\n    foldline: foldline,\n    pad2: pad2,\n    trunc: trunc,\n    extend: extend\n});\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This class represents the \"utc-offset\" value type, with various calculation and manipulation\n * methods.\n *\n * @memberof ICAL\n */ class UtcOffset {\n    /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {Duration}         The created utc-offset instance\n   */ static fromString(aString) {\n        // -05:00\n        let options = {};\n        //TODO: support seconds per rfc5545 ?\n        options.factor = aString[0] === \"+\" ? 1 : -1;\n        options.hours = strictParseInt(aString.slice(1, 3));\n        options.minutes = strictParseInt(aString.slice(4, 6));\n        return new UtcOffset(options);\n    }\n    /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */ static fromSeconds(aSeconds) {\n        let instance = new UtcOffset();\n        instance.fromSeconds(aSeconds);\n        return instance;\n    }\n    /**\n   * Creates a new ICAL.UtcOffset instance.\n   *\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */ constructor(aData){\n        /**\n   * The hours in the utc-offset\n   * @type {Number}\n   */ this.hours = 0;\n        /**\n   * The minutes in the utc-offset\n   * @type {Number}\n   */ this.minutes = 0;\n        /**\n   * The sign of the utc offset, 1 for positive offset, -1 for negative\n   * offsets.\n   * @type {Number}\n   */ this.factor = 1;\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"utc-offset\"\n   */ this.icaltype = \"utc-offset\";\n        this.fromData(aData);\n    }\n    /**\n   * Returns a clone of the utc offset object.\n   *\n   * @return {UtcOffset}     The cloned object\n   */ clone() {\n        return UtcOffset.fromSeconds(this.toSeconds());\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */ fromData(aData) {\n        if (aData) {\n            for (let [key, value] of Object.entries(aData)){\n                this[key] = value;\n            }\n        }\n        this._normalize();\n    }\n    /**\n   * Sets up the current instance from the given seconds value. The seconds\n   * value is truncated to the minute. Offsets are wrapped when the world\n   * ends, the hour after UTC+14:00 is UTC-12:00.\n   *\n   * @param {Number} aSeconds         The seconds to convert into an offset\n   */ fromSeconds(aSeconds) {\n        let secs = Math.abs(aSeconds);\n        this.factor = aSeconds < 0 ? -1 : 1;\n        this.hours = trunc(secs / 3600);\n        secs -= this.hours * 3600;\n        this.minutes = trunc(secs / 60);\n        return this;\n    }\n    /**\n   * Convert the current offset to a value in seconds\n   *\n   * @return {Number}                 The offset in seconds\n   */ toSeconds() {\n        return this.factor * (60 * this.minutes + 3600 * this.hours);\n    }\n    /**\n   * Compare this utc offset with another one.\n   *\n   * @param {UtcOffset} other             The other offset to compare with\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compare(other) {\n        let a = this.toSeconds();\n        let b = other.toSeconds();\n        return (a > b) - (b > a);\n    }\n    _normalize() {\n        // Range: 97200 seconds (with 1 hour inbetween)\n        let secs = this.toSeconds();\n        let factor = this.factor;\n        while(secs < -43200){\n            secs += 97200;\n        }\n        while(secs > 50400){\n            secs -= 97200;\n        }\n        this.fromSeconds(secs);\n        // Avoid changing the factor when on zero seconds\n        if (secs == 0) {\n            this.factor = factor;\n        }\n    }\n    /**\n   * The iCalendar string representation of this utc-offset.\n   * @return {String}\n   */ toICALString() {\n        return design$1.icalendar.value[\"utc-offset\"].toICAL(this.toString());\n    }\n    /**\n   * The string representation of this utc-offset.\n   * @return {String}\n   */ toString() {\n        return (this.factor == 1 ? \"+\" : \"-\") + pad2(this.hours) + \":\" + pad2(this.minutes);\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Describes a vCard time, which has slight differences to the ICAL.Time.\n * Properties can be null if not specified, for example for dates with\n * reduced accuracy or truncation.\n *\n * Note that currently not all methods are correctly re-implemented for\n * VCardTime. For example, comparison will have undefined results when some\n * members are null.\n *\n * Also, normalization is not yet implemented for this class!\n *\n * @memberof ICAL\n * @extends {ICAL.Time}\n */ class VCardTime extends Time {\n    /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {VCardTime}        The date/time instance\n   */ static fromDateAndOrTimeString(aValue, aIcalType) {\n        function part(v, s, e) {\n            return v ? strictParseInt(v.slice(s, s + e)) : null;\n        }\n        let parts = aValue.split(\"T\");\n        let dt = parts[0], tmz = parts[1];\n        let splitzone = tmz ? design$1.vcard.value.time._splitZone(tmz) : [];\n        let zone = splitzone[0], tm = splitzone[1];\n        let dtlen = dt ? dt.length : 0;\n        let tmlen = tm ? tm.length : 0;\n        let hasDashDate = dt && dt[0] == \"-\" && dt[1] == \"-\";\n        let hasDashTime = tm && tm[0] == \"-\";\n        let o = {\n            year: hasDashDate ? null : part(dt, 0, 4),\n            month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n            day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n            hour: hasDashTime ? null : part(tm, 0, 2),\n            minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n            second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n        };\n        if (zone == \"Z\") {\n            zone = Timezone.utcTimezone;\n        } else if (zone && zone[3] == \":\") {\n            zone = UtcOffset.fromString(zone);\n        } else {\n            zone = null;\n        }\n        return new VCardTime(o, zone, aIcalType);\n    }\n    /**\n   * Creates a new ICAL.VCardTime instance.\n   *\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {Timezone|UtcOffset} zone               The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */ constructor(data, zone, icaltype){\n        super(data, zone);\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"vcardtime\"\n   */ this.icalclass = \"vcardtime\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @type {String}\n   * @default \"date-and-or-time\"\n   */ this.icaltype = \"date-and-or-time\";\n        this.icaltype = icaltype || \"date-and-or-time\";\n    }\n    /**\n   * Returns a clone of the vcard date/time object.\n   *\n   * @return {VCardTime}     The cloned object\n   */ clone() {\n        return new VCardTime(this._time, this.zone, this.icaltype);\n    }\n    _normalize() {\n        return this;\n    }\n    /**\n   * @inheritdoc\n   */ utcOffset() {\n        if (this.zone instanceof UtcOffset) {\n            return this.zone.toSeconds();\n        } else {\n            return Time.prototype.utcOffset.apply(this, arguments);\n        }\n    }\n    /**\n   * Returns an RFC 6350 compliant representation of this object.\n   *\n   * @return {String}         vcard date/time string\n   */ toICALString() {\n        return design$1.vcard.value[this.icaltype].toICAL(this.toString());\n    }\n    /**\n   * The string representation of this date/time, in jCard form\n   * (including : and - separators).\n   * @return {String}\n   */ toString() {\n        let y = this.year, m = this.month, d = this.day;\n        let h = this.hour, mm = this.minute, s = this.second;\n        let hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n        let hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n        let datepart = (hasYear ? pad2(y) + (hasMonth || hasDay ? \"-\" : \"\") : hasMonth || hasDay ? \"--\" : \"\") + (hasMonth ? pad2(m) : \"\") + (hasDay ? \"-\" + pad2(d) : \"\");\n        let timepart = (hasHour ? pad2(h) : \"-\") + (hasHour && hasMinute ? \":\" : \"\") + (hasMinute ? pad2(mm) : \"\") + (!hasHour && !hasMinute ? \"-\" : \"\") + (hasMinute && hasSecond ? \":\" : \"\") + (hasSecond ? pad2(s) : \"\");\n        let zone;\n        if (this.zone === Timezone.utcTimezone) {\n            zone = \"Z\";\n        } else if (this.zone instanceof UtcOffset) {\n            zone = this.zone.toString();\n        } else if (this.zone === Timezone.localTimezone) {\n            zone = \"\";\n        } else if (this.zone instanceof Timezone) {\n            let offset = UtcOffset.fromSeconds(this.zone.utcOffset(this));\n            zone = offset.toString();\n        } else {\n            zone = \"\";\n        }\n        switch(this.icaltype){\n            case \"time\":\n                return timepart + zone;\n            case \"date-and-or-time\":\n            case \"date-time\":\n                return datepart + (timepart == \"--\" ? \"\" : \"T\" + timepart + zone);\n            case \"date\":\n                return datepart;\n        }\n        return null;\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").weekDay} weekDay\n * Imports the 'weekDay' type from the \"types.js\" module\n */ /**\n * An iterator for a single recurrence rule. This class usually doesn't have to be instanciated\n * directly, the convenience method {@link ICAL.Recur#iterator} can be used.\n *\n * @memberof ICAL\n */ class RecurIterator {\n    static{\n        this._indexMap = {\n            \"BYSECOND\": 0,\n            \"BYMINUTE\": 1,\n            \"BYHOUR\": 2,\n            \"BYDAY\": 3,\n            \"BYMONTHDAY\": 4,\n            \"BYYEARDAY\": 5,\n            \"BYWEEKNO\": 6,\n            \"BYMONTH\": 7,\n            \"BYSETPOS\": 8\n        };\n    }\n    static{\n        this._expandMap = {\n            \"SECONDLY\": [\n                1,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1\n            ],\n            \"MINUTELY\": [\n                2,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1\n            ],\n            \"HOURLY\": [\n                2,\n                2,\n                1,\n                1,\n                1,\n                1,\n                1,\n                1\n            ],\n            \"DAILY\": [\n                2,\n                2,\n                2,\n                1,\n                1,\n                1,\n                1,\n                1\n            ],\n            \"WEEKLY\": [\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                1,\n                1\n            ],\n            \"MONTHLY\": [\n                2,\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                1\n            ],\n            \"YEARLY\": [\n                2,\n                2,\n                2,\n                2,\n                2,\n                2,\n                2,\n                2\n            ]\n        };\n    }\n    static{\n        this.UNKNOWN = 0;\n    }\n    static{\n        this.CONTRACT = 1;\n    }\n    static{\n        this.EXPAND = 2;\n    }\n    static{\n        this.ILLEGAL = 3;\n    }\n    /**\n   * Creates a new ICAL.RecurIterator instance. The options object may contain additional members\n   * when resuming iteration from a previous run.\n   *\n   * @param {Object} options                The iterator options\n   * @param {Recur} options.rule            The rule to iterate.\n   * @param {Time} options.dtstart          The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */ constructor(options){\n        /**\n   * True when iteration is finished.\n   * @type {Boolean}\n   */ this.completed = false;\n        /**\n   * The rule that is being iterated\n   * @type {Recur}\n   */ this.rule = null;\n        /**\n   * The start date of the event being iterated.\n   * @type {Time}\n   */ this.dtstart = null;\n        /**\n   * The last occurrence that was returned from the\n   * {@link RecurIterator#next} method.\n   * @type {Time}\n   */ this.last = null;\n        /**\n   * The sequence number from the occurrence\n   * @type {Number}\n   */ this.occurrence_number = 0;\n        /**\n   * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n   * @type {Object}\n   * @private\n   */ this.by_indices = null;\n        /**\n   * If true, the iterator has already been initialized\n   * @type {Boolean}\n   * @private\n   */ this.initialized = false;\n        /**\n   * The initializd by-data.\n   * @type {Object}\n   * @private\n   */ this.by_data = null;\n        /**\n   * The expanded yeardays\n   * @type {Array}\n   * @private\n   */ this.days = null;\n        /**\n   * The index in the {@link ICAL.RecurIterator#days} array.\n   * @type {Number}\n   * @private\n   */ this.days_index = 0;\n        this.fromData(options);\n    }\n    /**\n   * Initialize the recurrence iterator from the passed data object. This\n   * method is usually not called directly, you can initialize the iterator\n   * through the constructor.\n   *\n   * @param {Object} options                The iterator options\n   * @param {Recur} options.rule            The rule to iterate.\n   * @param {Time} options.dtstart          The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */ fromData(options) {\n        this.rule = formatClassType(options.rule, Recur);\n        if (!this.rule) {\n            throw new Error(\"iterator requires a (ICAL.Recur) rule\");\n        }\n        this.dtstart = formatClassType(options.dtstart, Time);\n        if (!this.dtstart) {\n            throw new Error(\"iterator requires a (ICAL.Time) dtstart\");\n        }\n        if (options.by_data) {\n            this.by_data = options.by_data;\n        } else {\n            this.by_data = clone(this.rule.parts, true);\n        }\n        if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n        this.days = options.days || [];\n        if (options.last) {\n            this.last = formatClassType(options.last, Time);\n        }\n        this.by_indices = options.by_indices;\n        if (!this.by_indices) {\n            this.by_indices = {\n                \"BYSECOND\": 0,\n                \"BYMINUTE\": 0,\n                \"BYHOUR\": 0,\n                \"BYDAY\": 0,\n                \"BYMONTH\": 0,\n                \"BYWEEKNO\": 0,\n                \"BYMONTHDAY\": 0\n            };\n        }\n        this.initialized = options.initialized || false;\n        if (!this.initialized) {\n            try {\n                this.init();\n            } catch (e) {\n                if (e instanceof InvalidRecurrenceRuleError) {\n                    // Init may error if there are no possible recurrence instances from\n                    // the rule, but we don't want to bubble this error up. Instead, we\n                    // create an empty iterator.\n                    this.completed = true;\n                } else {\n                    // Propagate other errors to consumers.\n                    throw e;\n                }\n            }\n        }\n    }\n    /**\n   * Initialize the iterator\n   * @private\n   */ init() {\n        this.initialized = true;\n        this.last = this.dtstart.clone();\n        let parts = this.by_data;\n        if (\"BYDAY\" in parts) {\n            // libical does this earlier when the rule is loaded, but we postpone to\n            // now so we can preserve the original order.\n            this.sort_byday_rules(parts.BYDAY);\n        }\n        // If the BYYEARDAY appares, no other date rule part may appear\n        if (\"BYYEARDAY\" in parts) {\n            if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n                throw new Error(\"Invalid BYYEARDAY rule\");\n            }\n        }\n        // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n        if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n            throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n        }\n        // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n        // BYWEEKNO may appear.\n        if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n            throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n        }\n        // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n        // BYYEARDAY may appear.\n        if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n            throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n        }\n        // BYYEARDAY may only appear in YEARLY rules\n        if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n            throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n        }\n        this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n        this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n        this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n        this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n        this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n        if (this.rule.freq == \"WEEKLY\") {\n            if (\"BYDAY\" in parts) {\n                let [, dow] = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n                let wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n                if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n                    // Initial time is after first day of BYDAY data\n                    this.last.day += wkdy;\n                }\n            } else {\n                let dayName = Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n                parts.BYDAY = [\n                    dayName\n                ];\n            }\n        }\n        if (this.rule.freq == \"YEARLY\") {\n            // Some yearly recurrence rules may be specific enough to not actually\n            // occur on a yearly basis, e.g. the 29th day of February or the fifth\n            // Monday of a given month. The standard isn't clear on the intended\n            // behavior in these cases, but `libical` at least will iterate until it\n            // finds a matching year.\n            // CAREFUL: Some rules may specify an occurrence that can never happen,\n            // e.g. the first Monday of April so long as it falls on the 15th\n            // through the 21st. Detecting these is non-trivial, so ensure that we\n            // stop iterating at some point.\n            const untilYear = this.rule.until ? this.rule.until.year : 20000;\n            while(this.last.year <= untilYear){\n                this.expand_year_days(this.last.year);\n                if (this.days.length > 0) {\n                    break;\n                }\n                this.increment_year(this.rule.interval);\n            }\n            if (this.days.length == 0) {\n                throw new InvalidRecurrenceRuleError();\n            }\n            this._nextByYearDay();\n        }\n        if (this.rule.freq == \"MONTHLY\") {\n            if (this.has_by_data(\"BYDAY\")) {\n                let tempLast = null;\n                let initLast = this.last.clone();\n                let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n                // Check every weekday in BYDAY with relative dow and pos.\n                for (let bydow of this.by_data.BYDAY){\n                    this.last = initLast.clone();\n                    let [pos, dow] = this.ruleDayOfWeek(bydow);\n                    let dayOfMonth = this.last.nthWeekDay(dow, pos);\n                    // If |pos| >= 6, the byday is invalid for a monthly rule.\n                    if (pos >= 6 || pos <= -6) {\n                        throw new Error(\"Malformed values in BYDAY part\");\n                    }\n                    // If a Byday with pos=+/-5 is not in the current month it\n                    // must be searched in the next months.\n                    if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n                        // Skip if we have already found a \"last\" in this month.\n                        if (tempLast && tempLast.month == initLast.month) {\n                            continue;\n                        }\n                        while(dayOfMonth > daysInMonth || dayOfMonth <= 0){\n                            this.increment_month();\n                            daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n                            dayOfMonth = this.last.nthWeekDay(dow, pos);\n                        }\n                    }\n                    this.last.day = dayOfMonth;\n                    if (!tempLast || this.last.compare(tempLast) < 0) {\n                        tempLast = this.last.clone();\n                    }\n                }\n                this.last = tempLast.clone();\n                //XXX: This feels like a hack, but we need to initialize\n                //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n                //     this case. It accepts a special flag which will avoid incrementing\n                //     the initial value without the flag days that match the start time\n                //     would be missed.\n                if (this.has_by_data(\"BYMONTHDAY\")) {\n                    this._byDayAndMonthDay(true);\n                }\n                if (this.last.day > daysInMonth || this.last.day == 0) {\n                    throw new Error(\"Malformed values in BYDAY part\");\n                }\n            } else if (this.has_by_data(\"BYMONTHDAY\")) {\n                // Change the day value so that normalisation won't change the month.\n                this.last.day = 1;\n                // Get a sorted list of days in the starting month that match the rule.\n                let normalized = this.normalizeByMonthDayRules(this.last.year, this.last.month, this.rule.parts.BYMONTHDAY).filter((d)=>d >= this.last.day);\n                if (normalized.length) {\n                    // There's at least one valid day, use it.\n                    this.last.day = normalized[0];\n                    this.by_data.BYMONTHDAY = normalized;\n                } else {\n                    // There's no occurrence in this month, find the next valid month.\n                    // The longest possible sequence of skipped months is February-April-June,\n                    // so we might need to call next_month up to three times.\n                    if (!this.next_month() && !this.next_month() && !this.next_month()) {\n                        throw new Error(\"No possible occurrences\");\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Retrieve the next occurrence from the iterator.\n   * @return {Time}\n   */ next(again = false) {\n        let before = this.last ? this.last.clone() : null;\n        if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n            this.completed = true;\n        }\n        if (this.completed) {\n            return null;\n        }\n        if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n            // First of all, give the instance that was initialized\n            this.occurrence_number++;\n            return this.last;\n        }\n        let valid;\n        do {\n            valid = 1;\n            switch(this.rule.freq){\n                case \"SECONDLY\":\n                    this.next_second();\n                    break;\n                case \"MINUTELY\":\n                    this.next_minute();\n                    break;\n                case \"HOURLY\":\n                    this.next_hour();\n                    break;\n                case \"DAILY\":\n                    this.next_day();\n                    break;\n                case \"WEEKLY\":\n                    this.next_week();\n                    break;\n                case \"MONTHLY\":\n                    valid = this.next_month();\n                    break;\n                case \"YEARLY\":\n                    this.next_year();\n                    break;\n                default:\n                    return null;\n            }\n        }while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);\n        if (this.last.compare(before) == 0) {\n            if (again) {\n                throw new Error(\"Same occurrence found twice, protecting you from death by recursion\");\n            }\n            this.next(true);\n        }\n        if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n            this.completed = true;\n            return null;\n        } else {\n            this.occurrence_number++;\n            return this.last;\n        }\n    }\n    next_second() {\n        return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    }\n    increment_second(inc) {\n        return this.increment_generic(inc, \"second\", 60, \"minute\");\n    }\n    next_minute() {\n        return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n    }\n    increment_minute(inc) {\n        return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    }\n    next_hour() {\n        return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n    }\n    increment_hour(inc) {\n        this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    }\n    next_day() {\n        let this_freq = this.rule.freq == \"DAILY\";\n        if (this.next_hour() == 0) {\n            return 0;\n        }\n        if (this_freq) {\n            this.increment_monthday(this.rule.interval);\n        } else {\n            this.increment_monthday(1);\n        }\n        return 0;\n    }\n    next_week() {\n        let end_of_data = 0;\n        if (this.next_weekday_by_week() == 0) {\n            return end_of_data;\n        }\n        if (this.has_by_data(\"BYWEEKNO\")) {\n            this.by_indices.BYWEEKNO++;\n            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n                this.by_indices.BYWEEKNO = 0;\n                end_of_data = 1;\n            }\n            // HACK should be first month of the year\n            this.last.month = 1;\n            this.last.day = 1;\n            let week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n            this.last.day += 7 * week_no;\n            if (end_of_data) {\n                this.increment_year(1);\n            }\n        } else {\n            // Jump to the next week\n            this.increment_monthday(7 * this.rule.interval);\n        }\n        return end_of_data;\n    }\n    /**\n   * Normalize each by day rule for a given year/month.\n   * Takes into account ordering and negative rules\n   *\n   * @private\n   * @param {Number} year         Current year.\n   * @param {Number} month        Current month.\n   * @param {Array}  rules        Array of rules.\n   *\n   * @return {Array} sorted and normalized rules.\n   *                 Negative rules will be expanded to their\n   *                 correct positive values for easier processing.\n   */ normalizeByMonthDayRules(year, month, rules) {\n        let daysInMonth = Time.daysInMonth(month, year);\n        // XXX: This is probably bad for performance to allocate\n        //      a new array for each month we scan, if possible\n        //      we should try to optimize this...\n        let newRules = [];\n        let ruleIdx = 0;\n        let len = rules.length;\n        let rule;\n        for(; ruleIdx < len; ruleIdx++){\n            rule = parseInt(rules[ruleIdx], 10);\n            if (isNaN(rule)) {\n                throw new Error(\"Invalid BYMONTHDAY value\");\n            }\n            // if this rule falls outside of given\n            // month discard it.\n            if (Math.abs(rule) > daysInMonth) {\n                continue;\n            }\n            // negative case\n            if (rule < 0) {\n                // we add (not subtract it is a negative number)\n                // one from the rule because 1 === last day of month\n                rule = daysInMonth + (rule + 1);\n            } else if (rule === 0) {\n                continue;\n            }\n            // only add unique items...\n            if (newRules.indexOf(rule) === -1) {\n                newRules.push(rule);\n            }\n        }\n        // unique and sort\n        return newRules.sort(function(a, b) {\n            return a - b;\n        });\n    }\n    /**\n   * NOTES:\n   * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n   * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n   * both conditions match a given date (this.last.day) iteration stops.\n   *\n   * @private\n   * @param {Boolean=} isInit     When given true will not increment the\n   *                                current day (this.last).\n   */ _byDayAndMonthDay(isInit) {\n        let byMonthDay; // setup in initMonth\n        let byDay = this.by_data.BYDAY;\n        let date;\n        let dateIdx = 0;\n        let dateLen; // setup in initMonth\n        let dayLen = byDay.length;\n        // we are not valid by default\n        let dataIsValid = 0;\n        let daysInMonth;\n        let self = this;\n        // we need a copy of this, because a DateTime gets normalized\n        // automatically if the day is out of range. At some points we\n        // set the last day to 0 to start counting.\n        let lastDay = this.last.day;\n        function initMonth() {\n            daysInMonth = Time.daysInMonth(self.last.month, self.last.year);\n            byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n            dateLen = byMonthDay.length;\n            // For the case of more than one occurrence in one month\n            // we have to be sure to start searching after the last\n            // found date or at the last BYMONTHDAY, unless we are\n            // initializing the iterator because in this case we have\n            // to consider the last found date too.\n            while(byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1){\n                dateIdx++;\n            }\n        }\n        function nextMonth() {\n            // since the day is incremented at the start\n            // of the loop below, we need to start at 0\n            lastDay = 0;\n            self.increment_month();\n            dateIdx = 0;\n            initMonth();\n        }\n        initMonth();\n        // should come after initMonth\n        if (isInit) {\n            lastDay -= 1;\n        }\n        // Use a counter to avoid an infinite loop with malformed rules.\n        // Stop checking after 4 years so we consider also a leap year.\n        let monthsCounter = 48;\n        while(!dataIsValid && monthsCounter){\n            monthsCounter--;\n            // increment the current date. This is really\n            // important otherwise we may fall into the infinite\n            // loop trap. The initial date takes care of the case\n            // where the current date is the date we are looking\n            // for.\n            date = lastDay + 1;\n            if (date > daysInMonth) {\n                nextMonth();\n                continue;\n            }\n            // find next date\n            let next = byMonthDay[dateIdx++];\n            // this logic is dependent on the BYMONTHDAYS\n            // being in order (which is done by #normalizeByMonthDayRules)\n            if (next >= date) {\n                // if the next month day is in the future jump to it.\n                lastDay = next;\n            } else {\n                // in this case the 'next' monthday has past\n                // we must move to the month.\n                nextMonth();\n                continue;\n            }\n            // Now we can loop through the day rules to see\n            // if one matches the current month date.\n            for(let dayIdx = 0; dayIdx < dayLen; dayIdx++){\n                let parts = this.ruleDayOfWeek(byDay[dayIdx]);\n                let pos = parts[0];\n                let dow = parts[1];\n                this.last.day = lastDay;\n                if (this.last.isNthWeekDay(dow, pos)) {\n                    // when we find the valid one we can mark\n                    // the conditions as met and break the loop.\n                    // (Because we have this condition above\n                    //  it will also break the parent loop).\n                    dataIsValid = 1;\n                    break;\n                }\n            }\n            // It is completely possible that the combination\n            // cannot be matched in the current month.\n            // When we reach the end of possible combinations\n            // in the current month we iterate to the next one.\n            // since dateIdx is incremented right after getting\n            // \"next\", we don't need dateLen -1 here.\n            if (!dataIsValid && dateIdx === dateLen) {\n                nextMonth();\n                continue;\n            }\n        }\n        if (monthsCounter <= 0) {\n            // Checked 4 years without finding a Byday that matches\n            // a Bymonthday. Maybe the rule is not correct.\n            throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n        }\n        return dataIsValid;\n    }\n    next_month() {\n        let data_valid = 1;\n        if (this.next_hour() == 0) {\n            return data_valid;\n        }\n        if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n            data_valid = this._byDayAndMonthDay();\n        } else if (this.has_by_data(\"BYDAY\")) {\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            let setpos = 0;\n            let setpos_total = 0;\n            if (this.has_by_data(\"BYSETPOS\")) {\n                let last_day = this.last.day;\n                for(let day = 1; day <= daysInMonth; day++){\n                    this.last.day = day;\n                    if (this.is_day_in_byday(this.last)) {\n                        setpos_total++;\n                        if (day <= last_day) {\n                            setpos++;\n                        }\n                    }\n                }\n                this.last.day = last_day;\n            }\n            data_valid = 0;\n            let day;\n            for(day = this.last.day + 1; day <= daysInMonth; day++){\n                this.last.day = day;\n                if (this.is_day_in_byday(this.last)) {\n                    if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n                        data_valid = 1;\n                        break;\n                    }\n                }\n            }\n            if (day > daysInMonth) {\n                this.last.day = 1;\n                this.increment_month();\n                if (this.is_day_in_byday(this.last)) {\n                    if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n                        data_valid = 1;\n                    }\n                } else {\n                    data_valid = 0;\n                }\n            }\n        } else if (this.has_by_data(\"BYMONTHDAY\")) {\n            this.by_indices.BYMONTHDAY++;\n            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n                this.by_indices.BYMONTHDAY = 0;\n                this.increment_month();\n                if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n                    return 0;\n                }\n            }\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            let day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n            if (day < 0) {\n                day = daysInMonth + day + 1;\n            }\n            if (day > daysInMonth) {\n                this.last.day = 1;\n                data_valid = this.is_day_in_byday(this.last);\n            } else {\n                this.last.day = day;\n            }\n        } else {\n            this.increment_month();\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n                data_valid = 0;\n            } else {\n                this.last.day = this.by_data.BYMONTHDAY[0];\n            }\n        }\n        return data_valid;\n    }\n    next_weekday_by_week() {\n        let end_of_data = 0;\n        if (this.next_hour() == 0) {\n            return end_of_data;\n        }\n        if (!this.has_by_data(\"BYDAY\")) {\n            return 1;\n        }\n        for(;;){\n            let tt = new Time();\n            this.by_indices.BYDAY++;\n            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n                this.by_indices.BYDAY = 0;\n                end_of_data = 1;\n            }\n            let coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n            let parts = this.ruleDayOfWeek(coded_day);\n            let dow = parts[1];\n            dow -= this.rule.wkst;\n            if (dow < 0) {\n                dow += 7;\n            }\n            tt.year = this.last.year;\n            tt.month = this.last.month;\n            tt.day = this.last.day;\n            let startOfWeek = tt.startDoyWeek(this.rule.wkst);\n            if (dow + startOfWeek < 1) {\n                // The selected date is in the previous year\n                if (!end_of_data) {\n                    continue;\n                }\n            }\n            let next = Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n            /**\n       * The normalization horrors below are due to\n       * the fact that when the year/month/day changes\n       * it can effect the other operations that come after.\n       */ this.last.year = next.year;\n            this.last.month = next.month;\n            this.last.day = next.day;\n            return end_of_data;\n        }\n    }\n    next_year() {\n        if (this.next_hour() == 0) {\n            return 0;\n        }\n        if (++this.days_index == this.days.length) {\n            this.days_index = 0;\n            do {\n                this.increment_year(this.rule.interval);\n                if (this.has_by_data(\"BYMONTHDAY\")) {\n                    this.by_data.BYMONTHDAY = this.normalizeByMonthDayRules(this.last.year, this.last.month, this.rule.parts.BYMONTHDAY);\n                }\n                this.expand_year_days(this.last.year);\n            }while (this.days.length == 0);\n        }\n        this._nextByYearDay();\n        return 1;\n    }\n    _nextByYearDay() {\n        let doy = this.days[this.days_index];\n        let year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        let next = Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    }\n    /**\n   * @param dow (eg: '1TU', '-1MO')\n   * @param {weekDay=} aWeekStart The week start weekday\n   * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n   */ ruleDayOfWeek(dow, aWeekStart) {\n        let matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n        if (matches) {\n            let pos = parseInt(matches[1] || 0, 10);\n            dow = Recur.icalDayToNumericDay(matches[2], aWeekStart);\n            return [\n                pos,\n                dow\n            ];\n        } else {\n            return [\n                0,\n                0\n            ];\n        }\n    }\n    next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n        let has_by_rule = aRuleType in this.by_data;\n        let this_freq = this.rule.freq == aInterval;\n        let end_of_data = 0;\n        if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n            return end_of_data;\n        }\n        if (has_by_rule) {\n            this.by_indices[aRuleType]++;\n            let dta = this.by_data[aRuleType];\n            if (this.by_indices[aRuleType] == dta.length) {\n                this.by_indices[aRuleType] = 0;\n                end_of_data = 1;\n            }\n            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n        } else if (this_freq) {\n            this[\"increment_\" + aDateAttr](this.rule.interval);\n        }\n        if (has_by_rule && end_of_data && this_freq) {\n            this[\"increment_\" + aFollowingAttr](1);\n        }\n        return end_of_data;\n    }\n    increment_monthday(inc) {\n        for(let i = 0; i < inc; i++){\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            this.last.day++;\n            if (this.last.day > daysInMonth) {\n                this.last.day -= daysInMonth;\n                this.increment_month();\n            }\n        }\n    }\n    increment_month() {\n        this.last.day = 1;\n        if (this.has_by_data(\"BYMONTH\")) {\n            this.by_indices.BYMONTH++;\n            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n                this.by_indices.BYMONTH = 0;\n                this.increment_year(1);\n            }\n            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n        } else {\n            if (this.rule.freq == \"MONTHLY\") {\n                this.last.month += this.rule.interval;\n            } else {\n                this.last.month++;\n            }\n            this.last.month--;\n            let years = trunc(this.last.month / 12);\n            this.last.month %= 12;\n            this.last.month++;\n            if (years != 0) {\n                this.increment_year(years);\n            }\n        }\n        if (this.has_by_data(\"BYMONTHDAY\")) {\n            this.by_data.BYMONTHDAY = this.normalizeByMonthDayRules(this.last.year, this.last.month, this.rule.parts.BYMONTHDAY);\n        }\n    }\n    increment_year(inc) {\n        // Don't jump into the next month if this.last is Feb 29.\n        this.last.day = 1;\n        this.last.year += inc;\n    }\n    increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n        this.last[aDateAttr] += inc;\n        let nextunit = trunc(this.last[aDateAttr] / aFactor);\n        this.last[aDateAttr] %= aFactor;\n        if (nextunit != 0) {\n            this[\"increment_\" + aNextIncrement](nextunit);\n        }\n    }\n    has_by_data(aRuleType) {\n        return aRuleType in this.rule.parts;\n    }\n    expand_year_days(aYear) {\n        let t = new Time();\n        this.days = [];\n        // We need our own copy with a few keys set\n        let parts = {};\n        let rules = [\n            \"BYDAY\",\n            \"BYWEEKNO\",\n            \"BYMONTHDAY\",\n            \"BYMONTH\",\n            \"BYYEARDAY\"\n        ];\n        for (let part of rules){\n            if (part in this.rule.parts) {\n                parts[part] = this.rule.parts[part];\n            }\n        }\n        if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n            let valid = 1;\n            let validWeeks = {};\n            t.year = aYear;\n            t.isDate = true;\n            for(let monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++){\n                let month = this.by_data.BYMONTH[monthIdx];\n                t.month = month;\n                t.day = 1;\n                let first_week = t.weekNumber(this.rule.wkst);\n                t.day = Time.daysInMonth(month, aYear);\n                let last_week = t.weekNumber(this.rule.wkst);\n                for(monthIdx = first_week; monthIdx < last_week; monthIdx++){\n                    validWeeks[monthIdx] = 1;\n                }\n            }\n            for(let weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++){\n                let weekno = this.by_data.BYWEEKNO[weekIdx];\n                if (weekno < 52) {\n                    valid &= validWeeks[weekIdx];\n                } else {\n                    valid = 0;\n                }\n            }\n            if (valid) {\n                delete parts.BYMONTH;\n            } else {\n                delete parts.BYWEEKNO;\n            }\n        }\n        let partCount = Object.keys(parts).length;\n        if (partCount == 0) {\n            let t1 = this.dtstart.clone();\n            t1.year = this.last.year;\n            this.days.push(t1.dayOfYear());\n        } else if (partCount == 1 && \"BYMONTH\" in parts) {\n            for (let month of this.by_data.BYMONTH){\n                let t2 = this.dtstart.clone();\n                t2.year = aYear;\n                t2.month = month;\n                t2.isDate = true;\n                this.days.push(t2.dayOfYear());\n            }\n        } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n            for (let monthday of this.by_data.BYMONTHDAY){\n                let t3 = this.dtstart.clone();\n                if (monthday < 0) {\n                    let daysInMonth = Time.daysInMonth(t3.month, aYear);\n                    monthday = monthday + daysInMonth + 1;\n                }\n                t3.day = monthday;\n                t3.year = aYear;\n                t3.isDate = true;\n                this.days.push(t3.dayOfYear());\n            }\n        } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n            for (let month of this.by_data.BYMONTH){\n                let daysInMonth = Time.daysInMonth(month, aYear);\n                for (let monthday of this.by_data.BYMONTHDAY){\n                    if (monthday < 0) {\n                        monthday = monthday + daysInMonth + 1;\n                    }\n                    t.day = monthday;\n                    t.month = month;\n                    t.year = aYear;\n                    t.isDate = true;\n                    this.days.push(t.dayOfYear());\n                }\n            }\n        } else if (partCount == 1 && \"BYWEEKNO\" in parts) ;\n        else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) ;\n        else if (partCount == 1 && \"BYDAY\" in parts) {\n            this.days = this.days.concat(this.expand_by_day(aYear));\n        } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n            for (let month of this.by_data.BYMONTH){\n                let daysInMonth = Time.daysInMonth(month, aYear);\n                t.year = aYear;\n                t.month = month;\n                t.day = 1;\n                t.isDate = true;\n                let first_dow = t.dayOfWeek();\n                let doy_offset = t.dayOfYear() - 1;\n                t.day = daysInMonth;\n                let last_dow = t.dayOfWeek();\n                if (this.has_by_data(\"BYSETPOS\")) {\n                    let by_month_day = [];\n                    for(let day = 1; day <= daysInMonth; day++){\n                        t.day = day;\n                        if (this.is_day_in_byday(t)) {\n                            by_month_day.push(day);\n                        }\n                    }\n                    for(let spIndex = 0; spIndex < by_month_day.length; spIndex++){\n                        if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                            this.days.push(doy_offset + by_month_day[spIndex]);\n                        }\n                    }\n                } else {\n                    for (let coded_day of this.by_data.BYDAY){\n                        let bydayParts = this.ruleDayOfWeek(coded_day);\n                        let pos = bydayParts[0];\n                        let dow = bydayParts[1];\n                        let month_day;\n                        let first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n                        let last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n                        if (pos == 0) {\n                            for(let day = first_matching_day; day <= daysInMonth; day += 7){\n                                this.days.push(doy_offset + day);\n                            }\n                        } else if (pos > 0) {\n                            month_day = first_matching_day + (pos - 1) * 7;\n                            if (month_day <= daysInMonth) {\n                                this.days.push(doy_offset + month_day);\n                            }\n                        } else {\n                            month_day = last_matching_day + (pos + 1) * 7;\n                            if (month_day > 0) {\n                                this.days.push(doy_offset + month_day);\n                            }\n                        }\n                    }\n                }\n            }\n            // Return dates in order of occurrence (1,2,3,...) instead\n            // of by groups of weekdays (1,8,15,...,2,9,16,...).\n            this.days.sort(function(a, b) {\n                return a - b;\n            }); // Comparator function allows to sort numbers.\n        } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n            let expandedDays = this.expand_by_day(aYear);\n            for (let day of expandedDays){\n                let tt = Time.fromDayOfYear(day, aYear);\n                if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n                    this.days.push(day);\n                }\n            }\n        } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n            let expandedDays = this.expand_by_day(aYear);\n            for (let day of expandedDays){\n                let tt = Time.fromDayOfYear(day, aYear);\n                if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n                    this.days.push(day);\n                }\n            }\n        } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n            let expandedDays = this.expand_by_day(aYear);\n            for (let day of expandedDays){\n                let tt = Time.fromDayOfYear(day, aYear);\n                let weekno = tt.weekNumber(this.rule.wkst);\n                if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n                    this.days.push(day);\n                }\n            }\n        } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) ;\n        else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n            this.days = this.days.concat(this.by_data.BYYEARDAY);\n        } else {\n            this.days = [];\n        }\n        let daysInYear = Time.isLeapYear(aYear) ? 366 : 365;\n        this.days.sort((a, b)=>{\n            if (a < 0) a += daysInYear + 1;\n            if (b < 0) b += daysInYear + 1;\n            return a - b;\n        });\n        return 0;\n    }\n    expand_by_day(aYear) {\n        let days_list = [];\n        let tmp = this.last.clone();\n        tmp.year = aYear;\n        tmp.month = 1;\n        tmp.day = 1;\n        tmp.isDate = true;\n        let start_dow = tmp.dayOfWeek();\n        tmp.month = 12;\n        tmp.day = 31;\n        tmp.isDate = true;\n        let end_dow = tmp.dayOfWeek();\n        let end_year_day = tmp.dayOfYear();\n        for (let day of this.by_data.BYDAY){\n            let parts = this.ruleDayOfWeek(day);\n            let pos = parts[0];\n            let dow = parts[1];\n            if (pos == 0) {\n                let tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n                for(let doy = tmp_start_doy; doy <= end_year_day; doy += 7){\n                    days_list.push(doy);\n                }\n            } else if (pos > 0) {\n                let first;\n                if (dow >= start_dow) {\n                    first = dow - start_dow + 1;\n                } else {\n                    first = dow - start_dow + 8;\n                }\n                days_list.push(first + (pos - 1) * 7);\n            } else {\n                let last;\n                pos = -pos;\n                if (dow <= end_dow) {\n                    last = end_year_day - end_dow + dow;\n                } else {\n                    last = end_year_day - end_dow + dow - 7;\n                }\n                days_list.push(last - (pos - 1) * 7);\n            }\n        }\n        return days_list;\n    }\n    is_day_in_byday(tt) {\n        if (this.by_data.BYDAY) {\n            for (let day of this.by_data.BYDAY){\n                let parts = this.ruleDayOfWeek(day);\n                let pos = parts[0];\n                let dow = parts[1];\n                let this_dow = tt.dayOfWeek();\n                if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    /**\n   * Checks if given value is in BYSETPOS.\n   *\n   * @private\n   * @param {Numeric} aPos position to check for.\n   * @return {Boolean} false unless BYSETPOS rules exist\n   *                   and the given value is present in rules.\n   */ check_set_position(aPos) {\n        if (this.has_by_data(\"BYSETPOS\")) {\n            let idx = this.by_data.BYSETPOS.indexOf(aPos);\n            // negative numbers are not false-y\n            return idx !== -1;\n        }\n        return false;\n    }\n    sort_byday_rules(aRules) {\n        for(let i = 0; i < aRules.length; i++){\n            for(let j = 0; j < i; j++){\n                let one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n                let two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n                if (one > two) {\n                    let tmp = aRules[i];\n                    aRules[i] = aRules[j];\n                    aRules[j] = tmp;\n                }\n            }\n        }\n    }\n    check_contract_restriction(aRuleType, v) {\n        let indexMapValue = RecurIterator._indexMap[aRuleType];\n        let ruleMapValue = RecurIterator._expandMap[this.rule.freq][indexMapValue];\n        let pass = false;\n        if (aRuleType in this.by_data && ruleMapValue == RecurIterator.CONTRACT) {\n            let ruleType = this.by_data[aRuleType];\n            for (let bydata of ruleType){\n                if (bydata == v) {\n                    pass = true;\n                    break;\n                }\n            }\n        } else {\n            // Not a contracting byrule or has no data, test passes\n            pass = true;\n        }\n        return pass;\n    }\n    check_contracting_rules() {\n        let dow = this.last.dayOfWeek();\n        let weekNo = this.last.weekNumber(this.rule.wkst);\n        let doy = this.last.dayOfYear();\n        return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n    }\n    setup_defaults(aRuleType, req, deftime) {\n        let indexMapValue = RecurIterator._indexMap[aRuleType];\n        let ruleMapValue = RecurIterator._expandMap[this.rule.freq][indexMapValue];\n        if (ruleMapValue != RecurIterator.CONTRACT) {\n            if (!(aRuleType in this.by_data)) {\n                this.by_data[aRuleType] = [\n                    deftime\n                ];\n            }\n            if (this.rule.freq != req) {\n                return this.by_data[aRuleType][0];\n            }\n        }\n        return deftime;\n    }\n    /**\n   * Convert iterator into a serialize-able object.  Will preserve current\n   * iteration sequence to ensure the seamless continuation of the recurrence\n   * rule.\n   * @return {Object}\n   */ toJSON() {\n        let result = Object.create(null);\n        result.initialized = this.initialized;\n        result.rule = this.rule.toJSON();\n        result.dtstart = this.dtstart.toJSON();\n        result.by_data = this.by_data;\n        result.days = this.days;\n        result.last = this.last.toJSON();\n        result.by_indices = this.by_indices;\n        result.occurrence_number = this.occurrence_number;\n        return result;\n    }\n}\n/**\n * An error indicating that a recurrence rule is invalid and produces no\n * occurrences.\n *\n * @extends {Error}\n * @class\n */ class InvalidRecurrenceRuleError extends Error {\n    constructor(){\n        super(\"Recurrence rule has no valid occurrences\");\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").weekDay} weekDay\n * Imports the 'weekDay' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").frequencyValues} frequencyValues\n * Imports the 'frequencyValues' type from the \"types.js\" module\n */ const VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\nconst VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\nconst DOW_MAP = {\n    SU: Time.SUNDAY,\n    MO: Time.MONDAY,\n    TU: Time.TUESDAY,\n    WE: Time.WEDNESDAY,\n    TH: Time.THURSDAY,\n    FR: Time.FRIDAY,\n    SA: Time.SATURDAY\n};\nconst REVERSE_DOW_MAP = Object.fromEntries(Object.entries(DOW_MAP).map((entry)=>entry.reverse()));\nconst ALLOWED_FREQ = [\n    \"SECONDLY\",\n    \"MINUTELY\",\n    \"HOURLY\",\n    \"DAILY\",\n    \"WEEKLY\",\n    \"MONTHLY\",\n    \"YEARLY\"\n];\n/**\n * This class represents the \"recur\" value type, used for example by RRULE. It provides methods to\n * calculate occurrences among others.\n *\n * @memberof ICAL\n */ class Recur {\n    /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {Recur}                The created recurrence instance\n   */ static fromString(string) {\n        let data = this._stringToData(string, false);\n        return new Recur(data);\n    }\n    /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {frequencyValues=} aData.freq               The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {weekDay=} aData.wkst                       The week start value\n   * @param {Time=} aData.until                         The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */ static fromData(aData) {\n        return new Recur(aData);\n    }\n    /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @private\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {Recur}            The recurrence instance\n   */ static _stringToData(string, fmtIcal) {\n        let dict = Object.create(null);\n        // split is slower in FF but fast enough.\n        // v8 however this is faster then manual split?\n        let values = string.split(\";\");\n        let len = values.length;\n        for(let i = 0; i < len; i++){\n            let parts = values[i].split(\"=\");\n            let ucname = parts[0].toUpperCase();\n            let lcname = parts[0].toLowerCase();\n            let name = fmtIcal ? lcname : ucname;\n            let value = parts[1];\n            if (ucname in partDesign) {\n                let partArr = value.split(\",\");\n                let partSet = new Set();\n                for (let part of partArr){\n                    partSet.add(partDesign[ucname](part));\n                }\n                partArr = [\n                    ...partSet\n                ];\n                dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n            } else if (ucname in optionDesign) {\n                optionDesign[ucname](value, dict, fmtIcal);\n            } else {\n                // Don't swallow unknown values. Just set them as they are.\n                dict[lcname] = value;\n            }\n        }\n        return dict;\n    }\n    /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */ static icalDayToNumericDay(string, aWeekStart) {\n        //XXX: this is here so we can deal\n        //     with possibly invalid string values.\n        let firstDow = aWeekStart || Time.SUNDAY;\n        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n    }\n    /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */ static numericDayToIcalDay(num, aWeekStart) {\n        //XXX: this is here so we can deal with possibly invalid number values.\n        //     Also, this allows consistent mapping between day numbers and day\n        //     names for external users.\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let dow = num + firstDow - Time.SUNDAY;\n        if (dow > 7) {\n            dow -= 7;\n        }\n        return REVERSE_DOW_MAP[dow];\n    }\n    /**\n   * Create a new instance of the Recur class.\n   *\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {frequencyValues=} data.freq                The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {weekDay=} data.wkst                        The week start value\n   * @param {Time=} data.until                          The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */ constructor(data){\n        /**\n   * An object holding the BY-parts of the recurrence rule\n   * @memberof ICAL.Recur\n   * @typedef {Object} byParts\n   * @property {Array.<Number>=} BYSECOND            The seconds for the BYSECOND part\n   * @property {Array.<Number>=} BYMINUTE            The minutes for the BYMINUTE part\n   * @property {Array.<Number>=} BYHOUR              The hours for the BYHOUR part\n   * @property {Array.<String>=} BYDAY               The BYDAY values\n   * @property {Array.<Number>=} BYMONTHDAY          The days for the BYMONTHDAY part\n   * @property {Array.<Number>=} BYYEARDAY           The days for the BYYEARDAY part\n   * @property {Array.<Number>=} BYWEEKNO            The weeks for the BYWEEKNO part\n   * @property {Array.<Number>=} BYMONTH             The month for the BYMONTH part\n   * @property {Array.<Number>=} BYSETPOS            The positionals for the BYSETPOS part\n   */ /**\n   * An object holding the BY-parts of the recurrence rule\n   * @type {byParts}\n   */ this.parts = null;\n        /**\n   * The interval value for the recurrence rule.\n   * @type {Number}\n   */ this.interval = 1;\n        /**\n   * The week start day\n   *\n   * @type {weekDay}\n   * @default ICAL.Time.MONDAY\n   */ this.wkst = Time.MONDAY;\n        /**\n   * The end of the recurrence\n   * @type {?Time}\n   */ this.until = null;\n        /**\n   * The maximum number of occurrences\n   * @type {?Number}\n   */ this.count = null;\n        /**\n   * The frequency value.\n   * @type {frequencyValues}\n   */ this.freq = null;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icalrecur\"\n   */ this.icalclass = \"icalrecur\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"recur\"\n   */ this.icaltype = \"recur\";\n        this.wrappedJSObject = this;\n        this.parts = {};\n        if (data && typeof data === \"object\") {\n            this.fromData(data);\n        }\n    }\n    /**\n   * Create a new iterator for this recurrence rule. The passed start date\n   * must be the start date of the event, not the start of the range to\n   * search in.\n   *\n   * @example\n   * let recur = comp.getFirstPropertyValue('rrule');\n   * let dtstart = comp.getFirstPropertyValue('dtstart');\n   * let iter = recur.iterator(dtstart);\n   * for (let next = iter.next(); next; next = iter.next()) {\n   *   if (next.compare(rangeStart) < 0) {\n   *     continue;\n   *   }\n   *   console.log(next.toString());\n   * }\n   *\n   * @param {Time} aStart        The item's start date\n   * @return {RecurIterator}     The recurrence iterator\n   */ iterator(aStart) {\n        return new RecurIterator({\n            rule: this,\n            dtstart: aStart\n        });\n    }\n    /**\n   * Returns a clone of the recurrence object.\n   *\n   * @return {Recur}      The cloned object\n   */ clone() {\n        return new Recur(this.toJSON());\n    }\n    /**\n   * Checks if the current rule is finite, i.e. has a count or until part.\n   *\n   * @return {Boolean}        True, if the rule is finite\n   */ isFinite() {\n        return !!(this.count || this.until);\n    }\n    /**\n   * Checks if the current rule has a count part, and not limited by an until\n   * part.\n   *\n   * @return {Boolean}        True, if the rule is by count\n   */ isByCount() {\n        return !!(this.count && !this.until);\n    }\n    /**\n   * Adds a component (part) to the recurrence rule. This is not a component\n   * in the sense of {@link ICAL.Component}, but a part of the recurrence\n   * rule, i.e. BYMONTH.\n   *\n   * @param {String} aType            The name of the component part\n   * @param {Array|String} aValue     The component value\n   */ addComponent(aType, aValue) {\n        let ucname = aType.toUpperCase();\n        if (ucname in this.parts) {\n            this.parts[ucname].push(aValue);\n        } else {\n            this.parts[ucname] = [\n                aValue\n            ];\n        }\n    }\n    /**\n   * Sets the component value for the given by-part.\n   *\n   * @param {String} aType        The component part name\n   * @param {Array} aValues       The component values\n   */ setComponent(aType, aValues) {\n        this.parts[aType.toUpperCase()] = aValues.slice();\n    }\n    /**\n   * Gets (a copy) of the requested component value.\n   *\n   * @param {String} aType        The component part name\n   * @return {Array}              The component part value\n   */ getComponent(aType) {\n        let ucname = aType.toUpperCase();\n        return ucname in this.parts ? this.parts[ucname].slice() : [];\n    }\n    /**\n   * Retrieves the next occurrence after the given recurrence id. See the\n   * guide on {@tutorial terminology} for more details.\n   *\n   * NOTE: Currently, this method iterates all occurrences from the start\n   * date. It should not be called in a loop for performance reasons. If you\n   * would like to get more than one occurrence, you can iterate the\n   * occurrences manually, see the example on the\n   * {@link ICAL.Recur#iterator iterator} method.\n   *\n   * @param {Time} aStartTime        The start of the event series\n   * @param {Time} aRecurrenceId     The date of the last occurrence\n   * @return {Time}                  The next occurrence after\n   */ getNextOccurrence(aStartTime, aRecurrenceId) {\n        let iter = this.iterator(aStartTime);\n        let next;\n        do {\n            next = iter.next();\n        }while (next && next.compare(aRecurrenceId) <= 0);\n        if (next && aRecurrenceId.zone) {\n            next.zone = aRecurrenceId.zone;\n        }\n        return next;\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {frequencyValues=} data.freq                The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {weekDay=} data.wkst                        The week start value\n   * @param {Time=} data.until                          The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */ fromData(data) {\n        for(let key in data){\n            let uckey = key.toUpperCase();\n            if (uckey in partDesign) {\n                if (Array.isArray(data[key])) {\n                    this.parts[uckey] = data[key];\n                } else {\n                    this.parts[uckey] = [\n                        data[key]\n                    ];\n                }\n            } else {\n                this[key] = data[key];\n            }\n        }\n        if (this.interval && typeof this.interval != \"number\") {\n            optionDesign.INTERVAL(this.interval, this);\n        }\n        if (this.wkst && typeof this.wkst != \"number\") {\n            this.wkst = Recur.icalDayToNumericDay(this.wkst);\n        }\n        if (this.until && !(this.until instanceof Time)) {\n            this.until = Time.fromString(this.until);\n        }\n    }\n    /**\n   * The jCal representation of this recurrence type.\n   * @return {Object}\n   */ toJSON() {\n        let res = Object.create(null);\n        res.freq = this.freq;\n        if (this.count) {\n            res.count = this.count;\n        }\n        if (this.interval > 1) {\n            res.interval = this.interval;\n        }\n        for (let [k, kparts] of Object.entries(this.parts)){\n            if (Array.isArray(kparts) && kparts.length == 1) {\n                res[k.toLowerCase()] = kparts[0];\n            } else {\n                res[k.toLowerCase()] = clone(kparts);\n            }\n        }\n        if (this.until) {\n            res.until = this.until.toString();\n        }\n        if (\"wkst\" in this && this.wkst !== Time.DEFAULT_WEEK_START) {\n            res.wkst = Recur.numericDayToIcalDay(this.wkst);\n        }\n        return res;\n    }\n    /**\n   * The string representation of this recurrence rule.\n   * @return {String}\n   */ toString() {\n        // TODO retain order\n        let str = \"FREQ=\" + this.freq;\n        if (this.count) {\n            str += \";COUNT=\" + this.count;\n        }\n        if (this.interval > 1) {\n            str += \";INTERVAL=\" + this.interval;\n        }\n        for (let [k, v] of Object.entries(this.parts)){\n            str += \";\" + k + \"=\" + v;\n        }\n        if (this.until) {\n            str += \";UNTIL=\" + this.until.toICALString();\n        }\n        if (\"wkst\" in this && this.wkst !== Time.DEFAULT_WEEK_START) {\n            str += \";WKST=\" + Recur.numericDayToIcalDay(this.wkst);\n        }\n        return str;\n    }\n}\nfunction parseNumericValue(type, min, max, value) {\n    let result = value;\n    if (value[0] === \"+\") {\n        result = value.slice(1);\n    }\n    result = strictParseInt(result);\n    if (min !== undefined && value < min) {\n        throw new Error(type + ': invalid value \"' + value + '\" must be > ' + min);\n    }\n    if (max !== undefined && value > max) {\n        throw new Error(type + ': invalid value \"' + value + '\" must be < ' + min);\n    }\n    return result;\n}\nconst optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n        // yes this is actually equal or faster then regex.\n        // upside here is we can enumerate the valid values.\n        if (ALLOWED_FREQ.indexOf(value) !== -1) {\n            dict.freq = value;\n        } else {\n            throw new Error('invalid frequency \"' + value + '\" expected: \"' + ALLOWED_FREQ.join(\", \") + '\"');\n        }\n    },\n    COUNT: function(value, dict, fmtIcal) {\n        dict.count = strictParseInt(value);\n    },\n    INTERVAL: function(value, dict, fmtIcal) {\n        dict.interval = strictParseInt(value);\n        if (dict.interval < 1) {\n            // 0 or negative values are not allowed, some engines seem to generate\n            // it though. Assume 1 instead.\n            dict.interval = 1;\n        }\n    },\n    UNTIL: function(value, dict, fmtIcal) {\n        if (value.length > 10) {\n            dict.until = design$1.icalendar.value[\"date-time\"].fromICAL(value);\n        } else {\n            dict.until = design$1.icalendar.value.date.fromICAL(value);\n        }\n        if (!fmtIcal) {\n            dict.until = Time.fromString(dict.until);\n        }\n    },\n    WKST: function(value, dict, fmtIcal) {\n        if (VALID_DAY_NAMES.test(value)) {\n            dict.wkst = Recur.icalDayToNumericDay(value);\n        } else {\n            throw new Error('invalid WKST value \"' + value + '\"');\n        }\n    }\n};\nconst partDesign = {\n    BYSECOND: parseNumericValue.bind(undefined, \"BYSECOND\", 0, 60),\n    BYMINUTE: parseNumericValue.bind(undefined, \"BYMINUTE\", 0, 59),\n    BYHOUR: parseNumericValue.bind(undefined, \"BYHOUR\", 0, 23),\n    BYDAY: function(value) {\n        if (VALID_BYDAY_PART.test(value)) {\n            return value;\n        } else {\n            throw new Error('invalid BYDAY value \"' + value + '\"');\n        }\n    },\n    BYMONTHDAY: parseNumericValue.bind(undefined, \"BYMONTHDAY\", -31, 31),\n    BYYEARDAY: parseNumericValue.bind(undefined, \"BYYEARDAY\", -366, 366),\n    BYWEEKNO: parseNumericValue.bind(undefined, \"BYWEEKNO\", -53, 53),\n    BYMONTH: parseNumericValue.bind(undefined, \"BYMONTH\", 1, 12),\n    BYSETPOS: parseNumericValue.bind(undefined, \"BYSETPOS\", -366, 366)\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").jCalComponent} jCalComponent\n * Imports the 'occurrenceDetails' type from the \"types.js\" module\n */ /**\n * This class represents the \"period\" value type, with various calculation and manipulation methods.\n *\n * @memberof ICAL\n */ class Period {\n    /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {Property} prop         The property this period will be on\n   * @return {Period}               The created period instance\n   */ static fromString(str, prop) {\n        let parts = str.split(\"/\");\n        if (parts.length !== 2) {\n            throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n        }\n        let options = {\n            start: Time.fromDateTimeString(parts[0], prop)\n        };\n        let end = parts[1];\n        if (Duration.isValueString(end)) {\n            options.duration = Duration.fromString(end);\n        } else {\n            options.end = Time.fromDateTimeString(end, prop);\n        }\n        return new Period(options);\n    }\n    /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {Time=} aData.start             The start of the period\n   * @param {Time=} aData.end               The end of the period\n   * @param {Duration=} aData.duration      The duration of the period\n   * @return {Period}                       The period instance\n   */ static fromData(aData) {\n        return new Period(aData);\n    }\n    /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {jCalComponent} aData           The jCal data array\n   * @param {Property} aProp                The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {Period}                       The period instance\n   */ static fromJSON(aData, aProp, aLenient) {\n        function fromDateOrDateTimeString(aValue, dateProp) {\n            if (aLenient) {\n                return Time.fromString(aValue, dateProp);\n            } else {\n                return Time.fromDateTimeString(aValue, dateProp);\n            }\n        }\n        if (Duration.isValueString(aData[1])) {\n            return Period.fromData({\n                start: fromDateOrDateTimeString(aData[0], aProp),\n                duration: Duration.fromString(aData[1])\n            });\n        } else {\n            return Period.fromData({\n                start: fromDateOrDateTimeString(aData[0], aProp),\n                end: fromDateOrDateTimeString(aData[1], aProp)\n            });\n        }\n    }\n    /**\n   * Creates a new ICAL.Period instance. The passed data object cannot contain both and end date and\n   * a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {Time=} aData.start             The start of the period\n   * @param {Time=} aData.end               The end of the period\n   * @param {Duration=} aData.duration      The duration of the period\n   */ constructor(aData){\n        /**\n   * The start of the period\n   * @type {Time}\n   */ this.start = null;\n        /**\n   * The end of the period\n   * @type {Time}\n   */ this.end = null;\n        /**\n   * The duration of the period\n   * @type {Duration}\n   */ this.duration = null;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icalperiod\"\n   */ this.icalclass = \"icalperiod\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"period\"\n   */ this.icaltype = \"period\";\n        this.wrappedJSObject = this;\n        if (aData && \"start\" in aData) {\n            if (aData.start && !(aData.start instanceof Time)) {\n                throw new TypeError(\".start must be an instance of ICAL.Time\");\n            }\n            this.start = aData.start;\n        }\n        if (aData && aData.end && aData.duration) {\n            throw new Error(\"cannot accept both end and duration\");\n        }\n        if (aData && \"end\" in aData) {\n            if (aData.end && !(aData.end instanceof Time)) {\n                throw new TypeError(\".end must be an instance of ICAL.Time\");\n            }\n            this.end = aData.end;\n        }\n        if (aData && \"duration\" in aData) {\n            if (aData.duration && !(aData.duration instanceof Duration)) {\n                throw new TypeError(\".duration must be an instance of ICAL.Duration\");\n            }\n            this.duration = aData.duration;\n        }\n    }\n    /**\n   * Returns a clone of the duration object.\n   *\n   * @return {Period}      The cloned object\n   */ clone() {\n        return Period.fromData({\n            start: this.start ? this.start.clone() : null,\n            end: this.end ? this.end.clone() : null,\n            duration: this.duration ? this.duration.clone() : null\n        });\n    }\n    /**\n   * Calculates the duration of the period, either directly or by subtracting\n   * start from end date.\n   *\n   * @return {Duration}      The calculated duration\n   */ getDuration() {\n        if (this.duration) {\n            return this.duration;\n        } else {\n            return this.end.subtractDate(this.start);\n        }\n    }\n    /**\n   * Calculates the end date of the period, either directly or by adding\n   * duration to start date.\n   *\n   * @return {Time}          The calculated end date\n   */ getEnd() {\n        if (this.end) {\n            return this.end;\n        } else {\n            let end = this.start.clone();\n            end.addDuration(this.duration);\n            return end;\n        }\n    }\n    /**\n   * The string representation of this period.\n   * @return {String}\n   */ toString() {\n        return this.start + \"/\" + (this.end || this.duration);\n    }\n    /**\n   * The jCal representation of this period type.\n   * @return {Object}\n   */ toJSON() {\n        return [\n            this.start.toString(),\n            (this.end || this.duration).toString()\n        ];\n    }\n    /**\n   * The iCalendar string representation of this period.\n   * @return {String}\n   */ toICALString() {\n        return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n */ /** @module ICAL.design */ const FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\nconst TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\nconst FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\nconst TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\nfunction createTextType(fromNewline, toNewline) {\n    let result = {\n        matches: /.*/,\n        fromICAL: function(aValue, structuredEscape) {\n            return replaceNewline(aValue, fromNewline, structuredEscape);\n        },\n        toICAL: function(aValue, structuredEscape) {\n            let regEx = toNewline;\n            if (structuredEscape) regEx = new RegExp(regEx.source + \"|\" + structuredEscape, regEx.flags);\n            return aValue.replace(regEx, function(str) {\n                switch(str){\n                    case \"\\\\\":\n                        return \"\\\\\\\\\";\n                    case \";\":\n                        return \"\\\\;\";\n                    case \",\":\n                        return \"\\\\,\";\n                    case \"\\n\":\n                        return \"\\\\n\";\n                    /* c8 ignore next 2 */ default:\n                        return str;\n                }\n            });\n        }\n    };\n    return result;\n}\n// default types used multiple times\nconst DEFAULT_TYPE_TEXT = {\n    defaultType: \"text\"\n};\nconst DEFAULT_TYPE_TEXT_MULTI = {\n    defaultType: \"text\",\n    multiValue: \",\"\n};\nconst DEFAULT_TYPE_TEXT_STRUCTURED = {\n    defaultType: \"text\",\n    structuredValue: \";\"\n};\nconst DEFAULT_TYPE_INTEGER = {\n    defaultType: \"integer\"\n};\nconst DEFAULT_TYPE_DATETIME_DATE = {\n    defaultType: \"date-time\",\n    allowedTypes: [\n        \"date-time\",\n        \"date\"\n    ]\n};\nconst DEFAULT_TYPE_DATETIME = {\n    defaultType: \"date-time\"\n};\nconst DEFAULT_TYPE_URI = {\n    defaultType: \"uri\"\n};\nconst DEFAULT_TYPE_UTCOFFSET = {\n    defaultType: \"utc-offset\"\n};\nconst DEFAULT_TYPE_RECUR = {\n    defaultType: \"recur\"\n};\nconst DEFAULT_TYPE_DATE_ANDOR_TIME = {\n    defaultType: \"date-and-or-time\",\n    allowedTypes: [\n        \"date-time\",\n        \"date\",\n        \"text\"\n    ]\n};\nfunction replaceNewlineReplace(string) {\n    switch(string){\n        case \"\\\\\\\\\":\n            return \"\\\\\";\n        case \"\\\\;\":\n            return \";\";\n        case \"\\\\,\":\n            return \",\";\n        case \"\\\\n\":\n        case \"\\\\N\":\n            return \"\\n\";\n        /* c8 ignore next 2 */ default:\n            return string;\n    }\n}\nfunction replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf(\"\\\\\") === -1) {\n        return value;\n    }\n    if (structuredEscape) newline = new RegExp(newline.source + \"|\\\\\\\\\" + structuredEscape, newline.flags);\n    return value.replace(newline, replaceNewlineReplace);\n}\nlet commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n};\nlet commonValues = {\n    \"boolean\": {\n        values: [\n            \"TRUE\",\n            \"FALSE\"\n        ],\n        fromICAL: function(aValue) {\n            switch(aValue){\n                case \"TRUE\":\n                    return true;\n                case \"FALSE\":\n                    return false;\n                default:\n                    //TODO: parser warning\n                    return false;\n            }\n        },\n        toICAL: function(aValue) {\n            if (aValue) {\n                return \"TRUE\";\n            }\n            return \"FALSE\";\n        }\n    },\n    float: {\n        matches: /^[+-]?\\d+\\.\\d+$/,\n        fromICAL: function(aValue) {\n            let parsed = parseFloat(aValue);\n            if (isStrictlyNaN(parsed)) {\n                // TODO: parser warning\n                return 0.0;\n            }\n            return parsed;\n        },\n        toICAL: function(aValue) {\n            return String(aValue);\n        }\n    },\n    integer: {\n        fromICAL: function(aValue) {\n            let parsed = parseInt(aValue);\n            if (isStrictlyNaN(parsed)) {\n                return 0;\n            }\n            return parsed;\n        },\n        toICAL: function(aValue) {\n            return String(aValue);\n        }\n    },\n    \"utc-offset\": {\n        toICAL: function(aValue) {\n            if (aValue.length < 7) {\n                // no seconds\n                // -0500\n                return aValue.slice(0, 3) + aValue.slice(4, 6);\n            } else {\n                // seconds\n                // -050000\n                return aValue.slice(0, 3) + aValue.slice(4, 6) + aValue.slice(7, 9);\n            }\n        },\n        fromICAL: function(aValue) {\n            if (aValue.length < 6) {\n                // no seconds\n                // -05:00\n                return aValue.slice(0, 3) + \":\" + aValue.slice(3, 5);\n            } else {\n                // seconds\n                // -05:00:00\n                return aValue.slice(0, 3) + \":\" + aValue.slice(3, 5) + \":\" + aValue.slice(5, 7);\n            }\n        },\n        decorate: function(aValue) {\n            return UtcOffset.fromString(aValue);\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    }\n};\nlet icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enforce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n    // CN just wants a param-value\n    // \"CN\": { ... }\n    \"cutype\": {\n        values: [\n            \"INDIVIDUAL\",\n            \"GROUP\",\n            \"RESOURCE\",\n            \"ROOM\",\n            \"UNKNOWN\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"delegated-from\": {\n        valueType: \"cal-address\",\n        multiValue: \",\",\n        multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n        valueType: \"cal-address\",\n        multiValue: \",\",\n        multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n        values: [\n            \"8BIT\",\n            \"BASE64\"\n        ]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n        values: [\n            \"FREE\",\n            \"BUSY\",\n            \"BUSY-UNAVAILABLE\",\n            \"BUSY-TENTATIVE\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n        valueType: \"cal-address\",\n        multiValue: \",\",\n        multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n        // TODO These values are actually different per-component\n        values: [\n            \"NEEDS-ACTION\",\n            \"ACCEPTED\",\n            \"DECLINED\",\n            \"TENTATIVE\",\n            \"DELEGATED\",\n            \"COMPLETED\",\n            \"IN-PROCESS\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"range\": {\n        values: [\n            \"THISANDFUTURE\"\n        ]\n    },\n    \"related\": {\n        values: [\n            \"START\",\n            \"END\"\n        ]\n    },\n    \"reltype\": {\n        values: [\n            \"PARENT\",\n            \"CHILD\",\n            \"SIBLING\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"role\": {\n        values: [\n            \"REQ-PARTICIPANT\",\n            \"CHAIR\",\n            \"OPT-PARTICIPANT\",\n            \"NON-PARTICIPANT\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"rsvp\": {\n        values: [\n            \"TRUE\",\n            \"FALSE\"\n        ]\n    },\n    \"sent-by\": {\n        valueType: \"cal-address\"\n    },\n    \"tzid\": {\n        matches: /^\\//\n    },\n    \"value\": {\n        // since the value here is a 'type' lowercase is used.\n        values: [\n            \"binary\",\n            \"boolean\",\n            \"cal-address\",\n            \"date\",\n            \"date-time\",\n            \"duration\",\n            \"float\",\n            \"integer\",\n            \"period\",\n            \"recur\",\n            \"text\",\n            \"time\",\n            \"uri\",\n            \"utc-offset\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    }\n};\n// When adding a value here, be sure to add it to the parameter types!\nconst icalValues = extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n    uri: {\n    },\n    \"binary\": {\n        decorate: function(aString) {\n            return Binary.fromString(aString);\n        },\n        undecorate: function(aBinary) {\n            return aBinary.toString();\n        }\n    },\n    \"cal-address\": {\n    },\n    \"date\": {\n        decorate: function(aValue, aProp) {\n            if (design.strict) {\n                return Time.fromDateString(aValue, aProp);\n            } else {\n                return Time.fromString(aValue, aProp);\n            }\n        },\n        /**\n     * undecorates a time object.\n     */ undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            // from: 20120901\n            // to: 2012-09-01\n            if (!design.strict && aValue.length >= 15) {\n                // This is probably a date-time, e.g. 20120901T130000Z\n                return icalValues[\"date-time\"].fromICAL(aValue);\n            } else {\n                return aValue.slice(0, 4) + \"-\" + aValue.slice(4, 6) + \"-\" + aValue.slice(6, 8);\n            }\n        },\n        toICAL: function(aValue) {\n            // from: 2012-09-01\n            // to: 20120901\n            let len = aValue.length;\n            if (len == 10) {\n                return aValue.slice(0, 4) + aValue.slice(5, 7) + aValue.slice(8, 10);\n            } else if (len >= 19) {\n                return icalValues[\"date-time\"].toICAL(aValue);\n            } else {\n                //TODO: serialize warning?\n                return aValue;\n            }\n        }\n    },\n    \"date-time\": {\n        fromICAL: function(aValue) {\n            // from: 20120901T130000\n            // to: 2012-09-01T13:00:00\n            if (!design.strict && aValue.length == 8) {\n                // This is probably a date, e.g. 20120901\n                return icalValues.date.fromICAL(aValue);\n            } else {\n                let result = aValue.slice(0, 4) + \"-\" + aValue.slice(4, 6) + \"-\" + aValue.slice(6, 8) + \"T\" + aValue.slice(9, 11) + \":\" + aValue.slice(11, 13) + \":\" + aValue.slice(13, 15);\n                if (aValue[15] && aValue[15] === \"Z\") {\n                    result += \"Z\";\n                }\n                return result;\n            }\n        },\n        toICAL: function(aValue) {\n            // from: 2012-09-01T13:00:00\n            // to: 20120901T130000\n            let len = aValue.length;\n            if (len == 10 && !design.strict) {\n                return icalValues.date.toICAL(aValue);\n            } else if (len >= 19) {\n                let result = aValue.slice(0, 4) + aValue.slice(5, 7) + // grab the (DDTHH) segment\n                aValue.slice(8, 13) + // MM\n                aValue.slice(14, 16) + // SS\n                aValue.slice(17, 19);\n                if (aValue[19] && aValue[19] === \"Z\") {\n                    result += \"Z\";\n                }\n                return result;\n            } else {\n                // TODO: error\n                return aValue;\n            }\n        },\n        decorate: function(aValue, aProp) {\n            if (design.strict) {\n                return Time.fromDateTimeString(aValue, aProp);\n            } else {\n                return Time.fromString(aValue, aProp);\n            }\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    },\n    duration: {\n        decorate: function(aValue) {\n            return Duration.fromString(aValue);\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    },\n    period: {\n        fromICAL: function(string) {\n            let parts = string.split(\"/\");\n            parts[0] = icalValues[\"date-time\"].fromICAL(parts[0]);\n            if (!Duration.isValueString(parts[1])) {\n                parts[1] = icalValues[\"date-time\"].fromICAL(parts[1]);\n            }\n            return parts;\n        },\n        toICAL: function(parts) {\n            parts = parts.slice();\n            if (!design.strict && parts[0].length == 10) {\n                parts[0] = icalValues.date.toICAL(parts[0]);\n            } else {\n                parts[0] = icalValues[\"date-time\"].toICAL(parts[0]);\n            }\n            if (!Duration.isValueString(parts[1])) {\n                if (!design.strict && parts[1].length == 10) {\n                    parts[1] = icalValues.date.toICAL(parts[1]);\n                } else {\n                    parts[1] = icalValues[\"date-time\"].toICAL(parts[1]);\n                }\n            }\n            return parts.join(\"/\");\n        },\n        decorate: function(aValue, aProp) {\n            return Period.fromJSON(aValue, aProp, !design.strict);\n        },\n        undecorate: function(aValue) {\n            return aValue.toJSON();\n        }\n    },\n    recur: {\n        fromICAL: function(string) {\n            return Recur._stringToData(string, true);\n        },\n        toICAL: function(data) {\n            let str = \"\";\n            for (let [k, val] of Object.entries(data)){\n                if (k == \"until\") {\n                    if (val.length > 10) {\n                        val = icalValues[\"date-time\"].toICAL(val);\n                    } else {\n                        val = icalValues.date.toICAL(val);\n                    }\n                } else if (k == \"wkst\") {\n                    if (typeof val === \"number\") {\n                        val = Recur.numericDayToIcalDay(val);\n                    }\n                } else if (Array.isArray(val)) {\n                    val = val.join(\",\");\n                }\n                str += k.toUpperCase() + \"=\" + val + \";\";\n            }\n            return str.slice(0, Math.max(0, str.length - 1));\n        },\n        decorate: function decorate(aValue) {\n            return Recur.fromData(aValue);\n        },\n        undecorate: function(aRecur) {\n            return aRecur.toJSON();\n        }\n    },\n    time: {\n        fromICAL: function(aValue) {\n            // from: MMHHSS(Z)?\n            // to: HH:MM:SS(Z)?\n            if (aValue.length < 6) {\n                // TODO: parser exception?\n                return aValue;\n            }\n            // HH::MM::SSZ?\n            let result = aValue.slice(0, 2) + \":\" + aValue.slice(2, 4) + \":\" + aValue.slice(4, 6);\n            if (aValue[6] === \"Z\") {\n                result += \"Z\";\n            }\n            return result;\n        },\n        toICAL: function(aValue) {\n            // from: HH:MM:SS(Z)?\n            // to: MMHHSS(Z)?\n            if (aValue.length < 8) {\n                //TODO: error\n                return aValue;\n            }\n            let result = aValue.slice(0, 2) + aValue.slice(3, 5) + aValue.slice(6, 8);\n            if (aValue[8] === \"Z\") {\n                result += \"Z\";\n            }\n            return result;\n        }\n    }\n});\nlet icalProperties = extend(commonProperties, {\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": {\n        defaultType: \"uri\"\n    },\n    \"attendee\": {\n        defaultType: \"cal-address\"\n    },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": {\n        defaultType: \"duration\"\n    },\n    \"exdate\": {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ],\n        multiValue: \",\"\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": {\n        defaultType: \"period\",\n        multiValue: \",\"\n    },\n    \"geo\": {\n        defaultType: \"float\",\n        structuredValue: \";\"\n    },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": {\n        defaultType: \"cal-address\"\n    },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\",\n            \"period\"\n        ],\n        multiValue: \",\",\n        detectType: function(string) {\n            if (string.indexOf(\"/\") !== -1) {\n                return \"period\";\n            }\n            return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n        }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": {\n        defaultType: \"duration\",\n        allowedTypes: [\n            \"duration\",\n            \"date-time\"\n        ]\n    },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n});\n// When adding a value here, be sure to add it to the parameter types!\nconst vcardValues = extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    date: {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            if (aValue.length == 8) {\n                return icalValues.date.fromICAL(aValue);\n            } else if (aValue[0] == \"-\" && aValue.length == 6) {\n                return aValue.slice(0, 4) + \"-\" + aValue.slice(4);\n            } else {\n                return aValue;\n            }\n        },\n        toICAL: function(aValue) {\n            if (aValue.length == 10) {\n                return icalValues.date.toICAL(aValue);\n            } else if (aValue[0] == \"-\" && aValue.length == 7) {\n                return aValue.slice(0, 4) + aValue.slice(5);\n            } else {\n                return aValue;\n            }\n        }\n    },\n    time: {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            let splitzone = vcardValues.time._splitZone(aValue, true);\n            let zone = splitzone[0], value = splitzone[1];\n            //console.log(\"SPLIT: \",splitzone);\n            if (value.length == 6) {\n                value = value.slice(0, 2) + \":\" + value.slice(2, 4) + \":\" + value.slice(4, 6);\n            } else if (value.length == 4 && value[0] != \"-\") {\n                value = value.slice(0, 2) + \":\" + value.slice(2, 4);\n            } else if (value.length == 5) {\n                value = value.slice(0, 3) + \":\" + value.slice(3, 5);\n            }\n            if (zone.length == 5 && (zone[0] == \"-\" || zone[0] == \"+\")) {\n                zone = zone.slice(0, 3) + \":\" + zone.slice(3);\n            }\n            return value + zone;\n        },\n        toICAL: function(aValue) {\n            let splitzone = vcardValues.time._splitZone(aValue);\n            let zone = splitzone[0], value = splitzone[1];\n            if (value.length == 8) {\n                value = value.slice(0, 2) + value.slice(3, 5) + value.slice(6, 8);\n            } else if (value.length == 5 && value[0] != \"-\") {\n                value = value.slice(0, 2) + value.slice(3, 5);\n            } else if (value.length == 6) {\n                value = value.slice(0, 3) + value.slice(4, 6);\n            }\n            if (zone.length == 6 && (zone[0] == \"-\" || zone[0] == \"+\")) {\n                zone = zone.slice(0, 3) + zone.slice(4);\n            }\n            return value + zone;\n        },\n        _splitZone: function(aValue, isFromIcal) {\n            let lastChar = aValue.length - 1;\n            let signChar = aValue.length - (isFromIcal ? 5 : 6);\n            let sign = aValue[signChar];\n            let zone, value;\n            if (aValue[lastChar] == \"Z\") {\n                zone = aValue[lastChar];\n                value = aValue.slice(0, Math.max(0, lastChar));\n            } else if (aValue.length > 6 && (sign == \"-\" || sign == \"+\")) {\n                zone = aValue.slice(signChar);\n                value = aValue.slice(0, Math.max(0, signChar));\n            } else {\n                zone = \"\";\n                value = aValue;\n            }\n            return [\n                zone,\n                value\n            ];\n        }\n    },\n    \"date-time\": {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            return vcardValues[\"date-and-or-time\"].fromICAL(aValue);\n        },\n        toICAL: function(aValue) {\n            return vcardValues[\"date-and-or-time\"].toICAL(aValue);\n        }\n    },\n    \"date-and-or-time\": {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            let parts = aValue.split(\"T\");\n            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : \"\") + (parts[1] ? \"T\" + vcardValues.time.fromICAL(parts[1]) : \"\");\n        },\n        toICAL: function(aValue) {\n            let parts = aValue.split(\"T\");\n            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? \"T\" + vcardValues.time.toICAL(parts[1]) : \"\");\n        }\n    },\n    timestamp: icalValues[\"date-time\"],\n    \"language-tag\": {\n        matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    },\n    \"phone-number\": {\n        fromICAL: function(aValue) {\n            return Array.from(aValue).filter(function(c) {\n                return c === \"\\\\\" ? undefined : c;\n            }).join(\"\");\n        },\n        toICAL: function(aValue) {\n            return Array.from(aValue).map(function(c) {\n                return c === \",\" || c === \";\" ? \"\\\\\" + c : c;\n            }).join(\"\");\n        }\n    }\n});\nlet vcardParams = {\n    \"type\": {\n        valueType: \"text\",\n        multiValue: \",\"\n    },\n    \"value\": {\n        // since the value here is a 'type' lowercase is used.\n        values: [\n            \"text\",\n            \"uri\",\n            \"date\",\n            \"time\",\n            \"date-time\",\n            \"date-and-or-time\",\n            \"timestamp\",\n            \"boolean\",\n            \"integer\",\n            \"float\",\n            \"utc-offset\",\n            \"language-tag\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    }\n};\nlet vcardProperties = extend(commonProperties, {\n    \"adr\": {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": {\n        defaultType: \"language-tag\"\n    },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": {\n        defaultType: \"text\",\n        structuredValue: \";\"\n    },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": {\n        defaultType: \"timestamp\"\n    },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": {\n        defaultType: \"uri\",\n        allowedTypes: [\n            \"uri\",\n            \"text\"\n        ]\n    },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": {\n        defaultType: \"text\",\n        allowedTypes: [\n            \"text\",\n            \"utc-offset\",\n            \"uri\"\n        ]\n    },\n    \"xml\": DEFAULT_TYPE_TEXT\n});\nlet vcard3Values = extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": vcardValues[\"phone-number\"],\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n        toICAL: function(aValue) {\n            return aValue.slice(0, 7);\n        },\n        fromICAL: function(aValue) {\n            return aValue.slice(0, 7);\n        },\n        decorate: function(aValue) {\n            return UtcOffset.fromString(aValue);\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    }\n});\nlet vcard3Params = {\n    \"type\": {\n        valueType: \"text\",\n        multiValue: \",\"\n    },\n    \"value\": {\n        // since the value here is a 'type' lowercase is used.\n        values: [\n            \"text\",\n            \"uri\",\n            \"date\",\n            \"date-time\",\n            \"phone-number\",\n            \"time\",\n            \"boolean\",\n            \"integer\",\n            \"float\",\n            \"utc-offset\",\n            \"vcard\",\n            \"binary\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    }\n};\nlet vcard3Properties = extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"uri\"\n        ]\n    },\n    bday: {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ],\n        detectType: function(string) {\n            return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n        }\n    },\n    adr: {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    label: DEFAULT_TYPE_TEXT,\n    tel: {\n        defaultType: \"phone-number\"\n    },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n    tz: {\n        defaultType: \"utc-offset\",\n        allowedTypes: [\n            \"utc-offset\",\n            \"text\"\n        ]\n    },\n    geo: {\n        defaultType: \"float\",\n        structuredValue: \";\"\n    },\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"uri\"\n        ]\n    },\n    agent: {\n        defaultType: \"vcard\",\n        allowedTypes: [\n            \"vcard\",\n            \"text\",\n            \"uri\"\n        ]\n    },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ],\n        detectType: function(string) {\n            return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n        }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"uri\"\n        ]\n    },\n    class: DEFAULT_TYPE_TEXT,\n    key: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"text\"\n        ]\n    }\n});\n/**\n * iCalendar design set\n * @type {designSet}\n */ let icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties,\n    propertyGroups: false\n};\n/**\n * vCard 4.0 design set\n * @type {designSet}\n */ let vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties,\n    propertyGroups: true\n};\n/**\n * vCard 3.0 design set\n * @type {designSet}\n */ let vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties,\n    propertyGroups: true\n};\n/**\n * The design data, used by the parser to determine types for properties and\n * other metadata needed to produce correct jCard/jCal data.\n *\n * @alias ICAL.design\n * @exports module:ICAL.design\n */ const design = {\n    /**\n   * Can be set to false to make the parser more lenient.\n   */ strict: true,\n    /**\n   * The default set for new properties and components if none is specified.\n   * @type {designSet}\n   */ defaultSet: icalSet,\n    /**\n   * The default type for unknown properties\n   * @type {String}\n   */ defaultType: \"unknown\",\n    /**\n   * Holds the design set for known top-level components\n   *\n   * @type {Object}\n   * @property {designSet} vcard       vCard VCARD\n   * @property {designSet} vevent      iCalendar VEVENT\n   * @property {designSet} vtodo       iCalendar VTODO\n   * @property {designSet} vjournal    iCalendar VJOURNAL\n   * @property {designSet} valarm      iCalendar VALARM\n   * @property {designSet} vtimezone   iCalendar VTIMEZONE\n   * @property {designSet} daylight    iCalendar DAYLIGHT\n   * @property {designSet} standard    iCalendar STANDARD\n   *\n   * @example\n   * let propertyName = 'fn';\n   * let componentDesign = ICAL.design.components.vcard;\n   * let propertyDetails = componentDesign.property[propertyName];\n   * if (propertyDetails.defaultType == 'text') {\n   *   // Yep, sure is...\n   * }\n   */ components: {\n        vcard: vcardSet,\n        vcard3: vcard3Set,\n        vevent: icalSet,\n        vtodo: icalSet,\n        vjournal: icalSet,\n        valarm: icalSet,\n        vtimezone: icalSet,\n        daylight: icalSet,\n        standard: icalSet\n    },\n    /**\n   * The design set for iCalendar (rfc5545/rfc7265) components.\n   * @type {designSet}\n   */ icalendar: icalSet,\n    /**\n   * The design set for vCard (rfc6350/rfc7095) components.\n   * @type {designSet}\n   */ vcard: vcardSet,\n    /**\n   * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n   * @type {designSet}\n   */ vcard3: vcard3Set,\n    /**\n   * Gets the design set for the given component name.\n   *\n   * @param {String} componentName        The name of the component\n   * @return {designSet}      The design set for the component\n   */ getDesignSet: function(componentName) {\n        let isInDesign = componentName && componentName in design.components;\n        return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n};\nvar design$1 = design;\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n */ const LINE_ENDING = \"\\r\\n\";\nconst DEFAULT_VALUE_TYPE = \"unknown\";\nconst RFC6868_REPLACE_MAP = {\n    '\"': \"^'\",\n    \"\\n\": \"^n\",\n    \"^\": \"^^\"\n};\n/**\n * Convert a full jCal/jCard array into a iCalendar/vCard string.\n *\n * @function ICAL.stringify\n * @variation function\n * @param {Array} jCal    The jCal/jCard document\n * @return {String}       The stringified iCalendar/vCard document\n */ function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n        // This is a single component\n        jCal = [\n            jCal\n        ];\n    }\n    let i = 0;\n    let len = jCal.length;\n    let result = \"\";\n    for(; i < len; i++){\n        result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n    return result;\n}\n/**\n * Converts an jCal component array into a ICAL string.\n * Recursive will resolve sub-components.\n *\n * Exact component/property order is not saved all\n * properties will come before subcomponents.\n *\n * @function ICAL.stringify.component\n * @param {Array} component\n *        jCal/jCard fragment of a component\n * @param {designSet} designSet\n *        The design data to use for this component\n * @return {String}       The iCalendar/vCard string\n */ stringify.component = function(component, designSet) {\n    let name = component[0].toUpperCase();\n    let result = \"BEGIN:\" + name + LINE_ENDING;\n    let props = component[1];\n    let propIdx = 0;\n    let propLen = props.length;\n    let designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === \"vcard\" && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n        designSetName = \"vcard3\";\n    }\n    designSet = designSet || design$1.getDesignSet(designSetName);\n    for(; propIdx < propLen; propIdx++){\n        result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    let comps = component[2] || [];\n    let compIdx = 0;\n    let compLen = comps.length;\n    for(; compIdx < compLen; compIdx++){\n        result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n    result += \"END:\" + name;\n    return result;\n};\n/**\n * Converts a single jCal/jCard property to a iCalendar/vCard string.\n *\n * @function ICAL.stringify.property\n * @param {Array} property\n *        jCal/jCard property array\n * @param {designSet} designSet\n *        The design data to use for this property\n * @param {Boolean} noFold\n *        If true, the line is not folded\n * @return {String}       The iCalendar/vCard string\n */ stringify.property = function(property, designSet, noFold) {\n    let name = property[0].toUpperCase();\n    let jsName = property[0];\n    let params = property[1];\n    if (!designSet) {\n        designSet = design$1.defaultSet;\n    }\n    let groupName = params.group;\n    let line;\n    if (designSet.propertyGroups && groupName) {\n        line = groupName.toUpperCase() + \".\" + name;\n    } else {\n        line = name;\n    }\n    for (let [paramName, value] of Object.entries(params)){\n        if (designSet.propertyGroups && paramName == \"group\") {\n            continue;\n        }\n        let paramDesign = designSet.param[paramName];\n        let multiValue = paramDesign && paramDesign.multiValue;\n        if (multiValue && Array.isArray(value)) {\n            value = value.map(function(val) {\n                val = stringify._rfc6868Unescape(val);\n                val = stringify.paramPropertyValue(val, paramDesign.multiValueSeparateDQuote);\n                return val;\n            });\n            value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n            value = stringify._rfc6868Unescape(value);\n            value = stringify.paramPropertyValue(value);\n        }\n        line += \";\" + paramName.toUpperCase() + \"=\" + value;\n    }\n    if (property.length === 3) {\n        // If there are no values, we must assume a blank value\n        return line + \":\";\n    }\n    let valueType = property[2];\n    let propDetails;\n    let multiValue = false;\n    let structuredValue = false;\n    let isDefault = false;\n    if (jsName in designSet.property) {\n        propDetails = designSet.property[jsName];\n        if (\"multiValue\" in propDetails) {\n            multiValue = propDetails.multiValue;\n        }\n        if (\"structuredValue\" in propDetails && Array.isArray(property[3])) {\n            structuredValue = propDetails.structuredValue;\n        }\n        if (\"defaultType\" in propDetails) {\n            if (valueType === propDetails.defaultType) {\n                isDefault = true;\n            }\n        } else {\n            if (valueType === DEFAULT_VALUE_TYPE) {\n                isDefault = true;\n            }\n        }\n    } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n            isDefault = true;\n        }\n    }\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n        // value will never contain ;/:/, so we don't escape it here.\n        line += \";VALUE=\" + valueType.toUpperCase();\n    }\n    line += \":\";\n    if (multiValue && structuredValue) {\n        line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n    } else if (multiValue) {\n        line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n    } else if (structuredValue) {\n        line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n    } else {\n        line += stringify.value(property[3], valueType, designSet, false);\n    }\n    return noFold ? line : foldline(line);\n};\n/**\n * Handles escaping of property values that may contain:\n *\n *    COLON (:), SEMICOLON (;), or COMMA (,)\n *\n * If any of the above are present the result is wrapped\n * in double quotes.\n *\n * @function ICAL.stringify.paramPropertyValue\n * @param {String} value      Raw property value\n * @param {boolean} force     If value should be escaped even when unnecessary\n * @return {String}           Given or escaped value when needed\n */ stringify.paramPropertyValue = function(value, force) {\n    if (!force && value.indexOf(\",\") === -1 && value.indexOf(\":\") === -1 && value.indexOf(\";\") === -1) {\n        return value;\n    }\n    return '\"' + value + '\"';\n};\n/**\n * Converts an array of ical values into a single\n * string based on a type and a delimiter value (like \",\").\n *\n * @function ICAL.stringify.multiValue\n * @param {Array} values      List of values to convert\n * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n * @param {String} type       Lowecase ical value type\n *        (like boolean, date-time, etc..)\n * @param {?String} innerMulti If set, each value will again be processed\n *        Used for structured values\n * @param {designSet} designSet\n *        The design data to use for this property\n *\n * @return {String}           iCalendar/vCard string for value\n */ stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    let result = \"\";\n    let len = values.length;\n    let i = 0;\n    for(; i < len; i++){\n        if (innerMulti && Array.isArray(values[i])) {\n            result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n        } else {\n            result += stringify.value(values[i], type, designSet, structuredValue);\n        }\n        if (i !== len - 1) {\n            result += delim;\n        }\n    }\n    return result;\n};\n/**\n * Processes a single ical value runs the associated \"toICAL\" method from the\n * design value type if available to convert the value.\n *\n * @function ICAL.stringify.value\n * @param {String|Number} value       A formatted value\n * @param {String} type               Lowercase iCalendar/vCard value type\n *  (like boolean, date-time, etc..)\n * @return {String}                   iCalendar/vCard value for single value\n */ stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && \"toICAL\" in designSet.value[type]) {\n        return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n};\n/**\n * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n * hackers can disable the rfc6868 parsing if the really need to.\n *\n * @param {String} val        The value to unescape\n * @return {String}           The escaped value\n */ stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n        return RFC6868_REPLACE_MAP[x];\n    });\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ const NAME_INDEX$1 = 0;\nconst PROP_INDEX = 1;\nconst TYPE_INDEX = 2;\nconst VALUE_INDEX = 3;\n/**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").Geo} Geo\n * Imports the 'Geo' type from the \"types.js\" module\n */ /**\n * Provides a layer on top of the raw jCal object for manipulating a single property, with its\n * parameters and value.\n *\n * @memberof ICAL\n */ class Property {\n    /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str            The iCalendar string to parse\n   * @param {designSet=} designSet  The design data to use for this property\n   * @return {Property}             The created iCalendar property\n   */ static fromString(str, designSet) {\n        return new Property(parse.property(str, designSet));\n    }\n    /**\n   * Creates a new ICAL.Property instance.\n   *\n   * It is important to note that mutations done in the wrapper directly mutate the jCal object used\n   * to initialize.\n   *\n   * Can also be used to create new properties by passing the name of the property (as a String).\n   *\n   * @param {Array|String} jCal         Raw jCal representation OR the new name of the property\n   * @param {Component=} parent         Parent component\n   */ constructor(jCal, parent){\n        this._parent = parent || null;\n        if (typeof jCal === \"string\") {\n            // We are creating the property by name and need to detect the type\n            this.jCal = [\n                jCal,\n                {},\n                design$1.defaultType\n            ];\n            this.jCal[TYPE_INDEX] = this.getDefaultType();\n        } else {\n            this.jCal = jCal;\n        }\n        this._updateType();\n    }\n    /**\n   * The value type for this property\n   * @type {String}\n   */ get type() {\n        return this.jCal[TYPE_INDEX];\n    }\n    /**\n   * The name of this property, in lowercase.\n   * @type {String}\n   */ get name() {\n        return this.jCal[NAME_INDEX$1];\n    }\n    /**\n   * The parent component for this property.\n   * @type {Component}\n   */ get parent() {\n        return this._parent;\n    }\n    set parent(p) {\n        // Before setting the parent, check if the design set has changed. If it\n        // has, we later need to update the type if it was unknown before.\n        let designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n        this._parent = p;\n        if (this.type == design$1.defaultType && designSetChanged) {\n            this.jCal[TYPE_INDEX] = this.getDefaultType();\n            this._updateType();\n        }\n    }\n    /**\n   * The design set for this property, e.g. icalendar vs vcard\n   *\n   * @type {designSet}\n   * @private\n   */ get _designSet() {\n        return this.parent ? this.parent._designSet : design$1.defaultSet;\n    }\n    /**\n   * Updates the type metadata from the current jCal type and design set.\n   *\n   * @private\n   */ _updateType() {\n        let designSet = this._designSet;\n        if (this.type in designSet.value) {\n            if (\"decorate\" in designSet.value[this.type]) {\n                this.isDecorated = true;\n            } else {\n                this.isDecorated = false;\n            }\n            if (this.name in designSet.property) {\n                this.isMultiValue = \"multiValue\" in designSet.property[this.name];\n                this.isStructuredValue = \"structuredValue\" in designSet.property[this.name];\n            }\n        }\n    }\n    /**\n   * Hydrate a single value. The act of hydrating means turning the raw jCal\n   * value into a potentially wrapped object, for example {@link ICAL.Time}.\n   *\n   * @private\n   * @param {Number} index        The index of the value to hydrate\n   * @return {?Object}             The decorated value.\n   */ _hydrateValue(index) {\n        if (this._values && this._values[index]) {\n            return this._values[index];\n        }\n        // for the case where there is no value.\n        if (this.jCal.length <= VALUE_INDEX + index) {\n            return null;\n        }\n        if (this.isDecorated) {\n            if (!this._values) {\n                this._values = [];\n            }\n            return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n        } else {\n            return this.jCal[VALUE_INDEX + index];\n        }\n    }\n    /**\n   * Decorate a single value, returning its wrapped object. This is used by\n   * the hydrate function to actually wrap the value.\n   *\n   * @private\n   * @param {?} value         The value to decorate\n   * @return {Object}         The decorated value\n   */ _decorate(value) {\n        return this._designSet.value[this.type].decorate(value, this);\n    }\n    /**\n   * Undecorate a single value, returning its raw jCal data.\n   *\n   * @private\n   * @param {Object} value         The value to undecorate\n   * @return {?}                   The undecorated value\n   */ _undecorate(value) {\n        return this._designSet.value[this.type].undecorate(value, this);\n    }\n    /**\n   * Sets the value at the given index while also hydrating it. The passed\n   * value can either be a decorated or undecorated value.\n   *\n   * @private\n   * @param {?} value             The value to set\n   * @param {Number} index        The index to set it at\n   */ _setDecoratedValue(value, index) {\n        if (!this._values) {\n            this._values = [];\n        }\n        if (typeof value === \"object\" && \"icaltype\" in value) {\n            // decorated value\n            this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n            this._values[index] = value;\n        } else {\n            // undecorated value\n            this.jCal[VALUE_INDEX + index] = value;\n            this._values[index] = this._decorate(value);\n        }\n    }\n    /**\n   * Gets a parameter on the property.\n   *\n   * @param {String}        name   Parameter name (lowercase)\n   * @return {Array|String}        Parameter value\n   */ getParameter(name) {\n        if (name in this.jCal[PROP_INDEX]) {\n            return this.jCal[PROP_INDEX][name];\n        } else {\n            return undefined;\n        }\n    }\n    /**\n   * Gets first parameter on the property.\n   *\n   * @param {String}        name   Parameter name (lowercase)\n   * @return {String}        Parameter value\n   */ getFirstParameter(name) {\n        let parameters = this.getParameter(name);\n        if (Array.isArray(parameters)) {\n            return parameters[0];\n        }\n        return parameters;\n    }\n    /**\n   * Sets a parameter on the property.\n   *\n   * @param {String}       name     The parameter name\n   * @param {Array|String} value    The parameter value\n   */ setParameter(name, value) {\n        let lcname = name.toLowerCase();\n        if (typeof value === \"string\" && lcname in this._designSet.param && \"multiValue\" in this._designSet.param[lcname]) {\n            value = [\n                value\n            ];\n        }\n        this.jCal[PROP_INDEX][name] = value;\n    }\n    /**\n   * Removes a parameter\n   *\n   * @param {String} name     The parameter name\n   */ removeParameter(name) {\n        delete this.jCal[PROP_INDEX][name];\n    }\n    /**\n   * Get the default type based on this property's name.\n   *\n   * @return {String}     The default type for this property\n   */ getDefaultType() {\n        let name = this.jCal[NAME_INDEX$1];\n        let designSet = this._designSet;\n        if (name in designSet.property) {\n            let details = designSet.property[name];\n            if (\"defaultType\" in details) {\n                return details.defaultType;\n            }\n        }\n        return design$1.defaultType;\n    }\n    /**\n   * Sets type of property and clears out any existing values of the current\n   * type.\n   *\n   * @param {String} type     New iCAL type (see design.*.values)\n   */ resetType(type) {\n        this.removeAllValues();\n        this.jCal[TYPE_INDEX] = type;\n        this._updateType();\n    }\n    /**\n   * Finds the first property value.\n   *\n   * @return {Binary | Duration | Period |\n   * Recur | Time | UtcOffset | Geo | string | null}         First property value\n   */ getFirstValue() {\n        return this._hydrateValue(0);\n    }\n    /**\n   * Gets all values on the property.\n   *\n   * NOTE: this creates an array during each call.\n   *\n   * @return {Array}          List of values\n   */ getValues() {\n        let len = this.jCal.length - VALUE_INDEX;\n        if (len < 1) {\n            // it is possible for a property to have no value.\n            return [];\n        }\n        let i = 0;\n        let result = [];\n        for(; i < len; i++){\n            result[i] = this._hydrateValue(i);\n        }\n        return result;\n    }\n    /**\n   * Removes all values from this property\n   */ removeAllValues() {\n        if (this._values) {\n            this._values.length = 0;\n        }\n        this.jCal.length = 3;\n    }\n    /**\n   * Sets the values of the property.  Will overwrite the existing values.\n   * This can only be used for multi-value properties.\n   *\n   * @param {Array} values    An array of values\n   */ setValues(values) {\n        if (!this.isMultiValue) {\n            throw new Error(this.name + \": does not not support mulitValue.\\n\" + \"override isMultiValue\");\n        }\n        let len = values.length;\n        let i = 0;\n        this.removeAllValues();\n        if (len > 0 && typeof values[0] === \"object\" && \"icaltype\" in values[0]) {\n            this.resetType(values[0].icaltype);\n        }\n        if (this.isDecorated) {\n            for(; i < len; i++){\n                this._setDecoratedValue(values[i], i);\n            }\n        } else {\n            for(; i < len; i++){\n                this.jCal[VALUE_INDEX + i] = values[i];\n            }\n        }\n    }\n    /**\n   * Sets the current value of the property. If this is a multi-value\n   * property, all other values will be removed.\n   *\n   * @param {String|Object} value     New property value.\n   */ setValue(value) {\n        this.removeAllValues();\n        if (typeof value === \"object\" && \"icaltype\" in value) {\n            this.resetType(value.icaltype);\n        }\n        if (this.isDecorated) {\n            this._setDecoratedValue(value, 0);\n        } else {\n            this.jCal[VALUE_INDEX] = value;\n        }\n    }\n    /**\n   * Returns the Object representation of this component. The returned object\n   * is a live jCal object and should be cloned if modified.\n   * @return {Object}\n   */ toJSON() {\n        return this.jCal;\n    }\n    /**\n   * The string representation of this component.\n   * @return {String}\n   */ toICALString() {\n        return stringify.property(this.jCal, this._designSet, true);\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").Geo} Geo\n * Imports the 'Geo' type from the \"types.js\" module\n */ const NAME_INDEX = 0;\nconst PROPERTY_INDEX = 1;\nconst COMPONENT_INDEX = 2;\n/**\n * Wraps a jCal component, adding convenience methods to add, remove and update subcomponents and\n * properties.\n *\n * @memberof ICAL\n */ class Component {\n    /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */ static fromString(str) {\n        return new Component(parse.component(str));\n    }\n    /**\n   * Creates a new Component instance.\n   *\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {Component=} parent     Parent component to associate\n   */ constructor(jCal, parent){\n        /**\n   * Hydrated properties are inserted into the _properties array at the same\n   * position as in the jCal array, so it is possible that the array contains\n   * undefined values for unhydrdated properties. To avoid iterating the\n   * array when checking if all properties have been hydrated, we save the\n   * count here.\n   *\n   * @type {Number}\n   * @private\n   */ this._hydratedPropertyCount = 0;\n        /**\n   * The same count as for _hydratedPropertyCount, but for subcomponents\n   *\n   * @type {Number}\n   * @private\n   */ this._hydratedComponentCount = 0;\n        /**\n   * A cache of hydrated time zone objects which may be used by consumers, keyed\n   * by time zone ID.\n   *\n   * @type {Map}\n   * @private\n   */ this._timezoneCache = null;\n        /**\n   * @private\n   */ this._components = null;\n        /**\n   * @private\n   */ this._properties = null;\n        if (typeof jCal === \"string\") {\n            // jCal spec (name, properties, components)\n            jCal = [\n                jCal,\n                [],\n                []\n            ];\n        }\n        // mostly for legacy reasons.\n        this.jCal = jCal;\n        this.parent = parent || null;\n        if (!this.parent && this.name === \"vcalendar\") {\n            this._timezoneCache = new Map();\n        }\n    }\n    /**\n   * The name of this component\n   *\n   * @type {String}\n   */ get name() {\n        return this.jCal[NAME_INDEX];\n    }\n    /**\n   * The design set for this component, e.g. icalendar vs vcard\n   *\n   * @type {designSet}\n   * @private\n   */ get _designSet() {\n        let parentDesign = this.parent && this.parent._designSet;\n        return parentDesign || design$1.getDesignSet(this.name);\n    }\n    /**\n   * @private\n   */ _hydrateComponent(index) {\n        if (!this._components) {\n            this._components = [];\n            this._hydratedComponentCount = 0;\n        }\n        if (this._components[index]) {\n            return this._components[index];\n        }\n        let comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n        this._hydratedComponentCount++;\n        return this._components[index] = comp;\n    }\n    /**\n   * @private\n   */ _hydrateProperty(index) {\n        if (!this._properties) {\n            this._properties = [];\n            this._hydratedPropertyCount = 0;\n        }\n        if (this._properties[index]) {\n            return this._properties[index];\n        }\n        let prop = new Property(this.jCal[PROPERTY_INDEX][index], this);\n        this._hydratedPropertyCount++;\n        return this._properties[index] = prop;\n    }\n    /**\n   * Finds first sub component, optionally filtered by name.\n   *\n   * @param {String=} name        Optional name to filter by\n   * @return {?Component}     The found subcomponent\n   */ getFirstSubcomponent(name) {\n        if (name) {\n            let i = 0;\n            let comps = this.jCal[COMPONENT_INDEX];\n            let len = comps.length;\n            for(; i < len; i++){\n                if (comps[i][NAME_INDEX] === name) {\n                    let result = this._hydrateComponent(i);\n                    return result;\n                }\n            }\n        } else {\n            if (this.jCal[COMPONENT_INDEX].length) {\n                return this._hydrateComponent(0);\n            }\n        }\n        // ensure we return a value (strict mode)\n        return null;\n    }\n    /**\n   * Finds all sub components, optionally filtering by name.\n   *\n   * @param {String=} name            Optional name to filter by\n   * @return {Component[]}       The found sub components\n   */ getAllSubcomponents(name) {\n        let jCalLen = this.jCal[COMPONENT_INDEX].length;\n        let i = 0;\n        if (name) {\n            let comps = this.jCal[COMPONENT_INDEX];\n            let result = [];\n            for(; i < jCalLen; i++){\n                if (name === comps[i][NAME_INDEX]) {\n                    result.push(this._hydrateComponent(i));\n                }\n            }\n            return result;\n        } else {\n            if (!this._components || this._hydratedComponentCount !== jCalLen) {\n                for(; i < jCalLen; i++){\n                    this._hydrateComponent(i);\n                }\n            }\n            return this._components || [];\n        }\n    }\n    /**\n   * Returns true when a named property exists.\n   *\n   * @param {String} name     The property name\n   * @return {Boolean}        True, when property is found\n   */ hasProperty(name) {\n        let props = this.jCal[PROPERTY_INDEX];\n        let len = props.length;\n        let i = 0;\n        for(; i < len; i++){\n            // 0 is property name\n            if (props[i][NAME_INDEX] === name) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Finds the first property, optionally with the given name.\n   *\n   * @param {String=} name        Lowercase property name\n   * @return {?Property}     The found property\n   */ getFirstProperty(name) {\n        if (name) {\n            let i = 0;\n            let props = this.jCal[PROPERTY_INDEX];\n            let len = props.length;\n            for(; i < len; i++){\n                if (props[i][NAME_INDEX] === name) {\n                    let result = this._hydrateProperty(i);\n                    return result;\n                }\n            }\n        } else {\n            if (this.jCal[PROPERTY_INDEX].length) {\n                return this._hydrateProperty(0);\n            }\n        }\n        return null;\n    }\n    /**\n   * Returns first property's value, if available.\n   *\n   * @param {String=} name                    Lowercase property name\n   * @return {Binary | Duration | Period |\n   * Recur | Time | UtcOffset | Geo | string | null}         The found property value.\n   */ getFirstPropertyValue(name) {\n        let prop = this.getFirstProperty(name);\n        if (prop) {\n            return prop.getFirstValue();\n        }\n        return null;\n    }\n    /**\n   * Get all properties in the component, optionally filtered by name.\n   *\n   * @param {String=} name        Lowercase property name\n   * @return {Property[]}    List of properties\n   */ getAllProperties(name) {\n        let jCalLen = this.jCal[PROPERTY_INDEX].length;\n        let i = 0;\n        if (name) {\n            let props = this.jCal[PROPERTY_INDEX];\n            let result = [];\n            for(; i < jCalLen; i++){\n                if (name === props[i][NAME_INDEX]) {\n                    result.push(this._hydrateProperty(i));\n                }\n            }\n            return result;\n        } else {\n            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n                for(; i < jCalLen; i++){\n                    this._hydrateProperty(i);\n                }\n            }\n            return this._properties || [];\n        }\n    }\n    /**\n   * @private\n   */ _removeObjectByIndex(jCalIndex, cache, index) {\n        cache = cache || [];\n        // remove cached version\n        if (cache[index]) {\n            let obj = cache[index];\n            if (\"parent\" in obj) {\n                obj.parent = null;\n            }\n        }\n        cache.splice(index, 1);\n        // remove it from the jCal\n        this.jCal[jCalIndex].splice(index, 1);\n    }\n    /**\n   * @private\n   */ _removeObject(jCalIndex, cache, nameOrObject) {\n        let i = 0;\n        let objects = this.jCal[jCalIndex];\n        let len = objects.length;\n        let cached = this[cache];\n        if (typeof nameOrObject === \"string\") {\n            for(; i < len; i++){\n                if (objects[i][NAME_INDEX] === nameOrObject) {\n                    this._removeObjectByIndex(jCalIndex, cached, i);\n                    return true;\n                }\n            }\n        } else if (cached) {\n            for(; i < len; i++){\n                if (cached[i] && cached[i] === nameOrObject) {\n                    this._removeObjectByIndex(jCalIndex, cached, i);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n   * @private\n   */ _removeAllObjects(jCalIndex, cache, name) {\n        let cached = this[cache];\n        // Unfortunately we have to run through all children to reset their\n        // parent property.\n        let objects = this.jCal[jCalIndex];\n        let i = objects.length - 1;\n        // descending search required because splice\n        // is used and will effect the indices.\n        for(; i >= 0; i--){\n            if (!name || objects[i][NAME_INDEX] === name) {\n                this._removeObjectByIndex(jCalIndex, cached, i);\n            }\n        }\n    }\n    /**\n   * Adds a single sub component.\n   *\n   * @param {Component} component        The component to add\n   * @return {Component}                 The passed in component\n   */ addSubcomponent(component) {\n        if (!this._components) {\n            this._components = [];\n            this._hydratedComponentCount = 0;\n        }\n        if (component.parent) {\n            component.parent.removeSubcomponent(component);\n        }\n        let idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n        this._components[idx - 1] = component;\n        this._hydratedComponentCount++;\n        component.parent = this;\n        return component;\n    }\n    /**\n   * Removes a single component by name or the instance of a specific\n   * component.\n   *\n   * @param {Component|String} nameOrComp    Name of component, or component\n   * @return {Boolean}                            True when comp is removed\n   */ removeSubcomponent(nameOrComp) {\n        let removed = this._removeObject(COMPONENT_INDEX, \"_components\", nameOrComp);\n        if (removed) {\n            this._hydratedComponentCount--;\n        }\n        return removed;\n    }\n    /**\n   * Removes all components or (if given) all components by a particular\n   * name.\n   *\n   * @param {String=} name            Lowercase component name\n   */ removeAllSubcomponents(name) {\n        let removed = this._removeAllObjects(COMPONENT_INDEX, \"_components\", name);\n        this._hydratedComponentCount = 0;\n        return removed;\n    }\n    /**\n   * Adds an {@link ICAL.Property} to the component.\n   *\n   * @param {Property} property      The property to add\n   * @return {Property}              The passed in property\n   */ addProperty(property) {\n        if (!(property instanceof Property)) {\n            throw new TypeError(\"must be instance of ICAL.Property\");\n        }\n        if (!this._properties) {\n            this._properties = [];\n            this._hydratedPropertyCount = 0;\n        }\n        if (property.parent) {\n            property.parent.removeProperty(property);\n        }\n        let idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n        this._properties[idx - 1] = property;\n        this._hydratedPropertyCount++;\n        property.parent = this;\n        return property;\n    }\n    /**\n   * Helper method to add a property with a value to the component.\n   *\n   * @param {String}               name         Property name to add\n   * @param {String|Number|Object} value        Property value\n   * @return {Property}                    The created property\n   */ addPropertyWithValue(name, value) {\n        let prop = new Property(name);\n        prop.setValue(value);\n        this.addProperty(prop);\n        return prop;\n    }\n    /**\n   * Helper method that will update or create a property of the given name\n   * and sets its value. If multiple properties with the given name exist,\n   * only the first is updated.\n   *\n   * @param {String}               name         Property name to update\n   * @param {String|Number|Object} value        Property value\n   * @return {Property}                    The created property\n   */ updatePropertyWithValue(name, value) {\n        let prop = this.getFirstProperty(name);\n        if (prop) {\n            prop.setValue(value);\n        } else {\n            prop = this.addPropertyWithValue(name, value);\n        }\n        return prop;\n    }\n    /**\n   * Removes a single property by name or the instance of the specific\n   * property.\n   *\n   * @param {String|Property} nameOrProp     Property name or instance to remove\n   * @return {Boolean}                            True, when deleted\n   */ removeProperty(nameOrProp) {\n        let removed = this._removeObject(PROPERTY_INDEX, \"_properties\", nameOrProp);\n        if (removed) {\n            this._hydratedPropertyCount--;\n        }\n        return removed;\n    }\n    /**\n   * Removes all properties associated with this component, optionally\n   * filtered by name.\n   *\n   * @param {String=} name        Lowercase property name\n   * @return {Boolean}            True, when deleted\n   */ removeAllProperties(name) {\n        let removed = this._removeAllObjects(PROPERTY_INDEX, \"_properties\", name);\n        this._hydratedPropertyCount = 0;\n        return removed;\n    }\n    /**\n   * Returns the Object representation of this component. The returned object\n   * is a live jCal object and should be cloned if modified.\n   * @return {Object}\n   */ toJSON() {\n        return this.jCal;\n    }\n    /**\n   * The string representation of this component.\n   * @return {String}\n   */ toString() {\n        return stringify.component(this.jCal, this._designSet);\n    }\n    /**\n   * Retrieve a time zone definition from the component tree, if any is present.\n   * If the tree contains no time zone definitions or the TZID cannot be\n   * matched, returns null.\n   *\n   * @param {String} tzid     The ID of the time zone to retrieve\n   * @return {Timezone}  The time zone corresponding to the ID, or null\n   */ getTimeZoneByID(tzid) {\n        // VTIMEZONE components can only appear as a child of the VCALENDAR\n        // component; walk the tree if we're not the root.\n        if (this.parent) {\n            return this.parent.getTimeZoneByID(tzid);\n        }\n        // If there is no time zone cache, we are probably parsing an incomplete\n        // file and will have no time zone definitions.\n        if (!this._timezoneCache) {\n            return null;\n        }\n        if (this._timezoneCache.has(tzid)) {\n            return this._timezoneCache.get(tzid);\n        }\n        // If the time zone is not already cached, hydrate it from the\n        // subcomponents.\n        const zones = this.getAllSubcomponents(\"vtimezone\");\n        for (const zone of zones){\n            if (zone.getFirstProperty(\"tzid\").getFirstValue() === tzid) {\n                const hydratedZone = new Timezone({\n                    component: zone,\n                    tzid: tzid\n                });\n                this._timezoneCache.set(tzid, hydratedZone);\n                return hydratedZone;\n            }\n        }\n        // Per the standard, we should always have a time zone defined in a file\n        // for any referenced TZID, but don't blow up if the file is invalid.\n        return null;\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Primary class for expanding recurring rules.  Can take multiple rrules, rdates, exdate(s) and\n * iterate (in order) over each next occurrence.\n *\n * Once initialized this class can also be serialized saved and continue iteration from the last\n * point.\n *\n * NOTE: it is intended that this class is to be used with {@link ICAL.Event} which handles recurrence\n * exceptions.\n *\n * @example\n * // assuming event is a parsed ical component\n * var event;\n *\n * var expand = new ICAL.RecurExpansion({\n *   component: event,\n *   dtstart: event.getFirstPropertyValue('dtstart')\n * });\n *\n * // remember there are infinite rules so it is a good idea to limit the scope of the iterations\n * // then resume later on.\n *\n * // next is always an ICAL.Time or null\n * var next;\n *\n * while (someCondition && (next = expand.next())) {\n *   // do something with next\n * }\n *\n * // save instance for later\n * var json = JSON.stringify(expand);\n *\n * //...\n *\n * // NOTE: if the component's properties have changed you will need to rebuild the class and start\n * // over. This only works when the component's recurrence info is the same.\n * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n *\n * @memberof ICAL\n */ class RecurExpansion {\n    /**\n   * Creates a new ICAL.RecurExpansion instance.\n   *\n   * The options object can be filled with the specified initial values. It can also contain\n   * additional members, as a result of serializing a previous expansion state, as shown in the\n   * example.\n   *\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {Time} options.dtstart\n   *        Start time of the event\n   * @param {Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */ constructor(options){\n        /**\n   * True when iteration is fully completed.\n   * @type {Boolean}\n   */ this.complete = false;\n        /**\n   * Array of rrule iterators.\n   *\n   * @type {RecurIterator[]}\n   * @private\n   */ this.ruleIterators = null;\n        /**\n   * Array of rdate instances.\n   *\n   * @type {Time[]}\n   * @private\n   */ this.ruleDates = null;\n        /**\n   * Array of exdate instances.\n   *\n   * @type {Time[]}\n   * @private\n   */ this.exDates = null;\n        /**\n   * Current position in ruleDates array.\n   * @type {Number}\n   * @private\n   */ this.ruleDateInc = 0;\n        /**\n   * Current position in exDates array\n   * @type {Number}\n   * @private\n   */ this.exDateInc = 0;\n        /**\n   * Current negative date.\n   *\n   * @type {Time}\n   * @private\n   */ this.exDate = null;\n        /**\n   * Current additional date.\n   *\n   * @type {Time}\n   * @private\n   */ this.ruleDate = null;\n        /**\n   * Start date of recurring rules.\n   *\n   * @type {Time}\n   */ this.dtstart = null;\n        /**\n   * Last expanded time\n   *\n   * @type {Time}\n   */ this.last = null;\n        this.ruleDates = [];\n        this.exDates = [];\n        this.fromData(options);\n    }\n    /**\n   * Initialize the recurrence expansion from the data object. The options\n   * object may also contain additional members, see the\n   * {@link ICAL.RecurExpansion constructor} for more details.\n   *\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {Time} options.dtstart\n   *        Start time of the event\n   * @param {Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */ fromData(options) {\n        let start = formatClassType(options.dtstart, Time);\n        if (!start) {\n            throw new Error(\".dtstart (ICAL.Time) must be given\");\n        } else {\n            this.dtstart = start;\n        }\n        if (options.component) {\n            this._init(options.component);\n        } else {\n            this.last = formatClassType(options.last, Time) || start.clone();\n            if (!options.ruleIterators) {\n                throw new Error(\".ruleIterators or .component must be given\");\n            }\n            this.ruleIterators = options.ruleIterators.map(function(item) {\n                return formatClassType(item, RecurIterator);\n            });\n            this.ruleDateInc = options.ruleDateInc;\n            this.exDateInc = options.exDateInc;\n            if (options.ruleDates) {\n                this.ruleDates = options.ruleDates.map((item)=>formatClassType(item, Time));\n                this.ruleDate = this.ruleDates[this.ruleDateInc];\n            }\n            if (options.exDates) {\n                this.exDates = options.exDates.map((item)=>formatClassType(item, Time));\n                this.exDate = this.exDates[this.exDateInc];\n            }\n            if (typeof options.complete !== \"undefined\") {\n                this.complete = options.complete;\n            }\n        }\n    }\n    /**\n   * Retrieve the next occurrence in the series.\n   * @return {Time}\n   */ next() {\n        let iter;\n        let next;\n        let compare;\n        let maxTries = 500;\n        let currentTry = 0;\n        while(true){\n            if (currentTry++ > maxTries) {\n                throw new Error(\"max tries have occurred, rule may be impossible to fulfill.\");\n            }\n            next = this.ruleDate;\n            iter = this._nextRecurrenceIter(this.last);\n            // no more matches\n            // because we increment the rule day or rule\n            // _after_ we choose a value this should be\n            // the only spot where we need to worry about the\n            // end of events.\n            if (!next && !iter) {\n                // there are no more iterators or rdates\n                this.complete = true;\n                break;\n            }\n            // no next rule day or recurrence rule is first.\n            if (!next || iter && next.compare(iter.last) > 0) {\n                // must be cloned, recur will reuse the time element.\n                next = iter.last.clone();\n                // move to next so we can continue\n                iter.next();\n            }\n            // if the ruleDate is still next increment it.\n            if (this.ruleDate === next) {\n                this._nextRuleDay();\n            }\n            this.last = next;\n            // check the negative rules\n            if (this.exDate) {\n                compare = this.exDate.compare(this.last);\n                if (compare < 0) {\n                    this._nextExDay();\n                }\n                // if the current rule is excluded skip it.\n                if (compare === 0) {\n                    this._nextExDay();\n                    continue;\n                }\n            }\n            //XXX: The spec states that after we resolve the final\n            //     list of dates we execute exdate this seems somewhat counter\n            //     intuitive to what I have seen most servers do so for now\n            //     I exclude based on the original date not the one that may\n            //     have been modified by the exception.\n            return this.last;\n        }\n    }\n    /**\n   * Converts object into a serialize-able format. This format can be passed\n   * back into the expansion to resume iteration.\n   * @return {Object}\n   */ toJSON() {\n        function toJSON(item) {\n            return item.toJSON();\n        }\n        let result = Object.create(null);\n        result.ruleIterators = this.ruleIterators.map(toJSON);\n        if (this.ruleDates) {\n            result.ruleDates = this.ruleDates.map(toJSON);\n        }\n        if (this.exDates) {\n            result.exDates = this.exDates.map(toJSON);\n        }\n        result.ruleDateInc = this.ruleDateInc;\n        result.exDateInc = this.exDateInc;\n        result.last = this.last.toJSON();\n        result.dtstart = this.dtstart.toJSON();\n        result.complete = this.complete;\n        return result;\n    }\n    /**\n   * Extract all dates from the properties in the given component. The\n   * properties will be filtered by the property name.\n   *\n   * @private\n   * @param {Component} component             The component to search in\n   * @param {String} propertyName             The property name to search for\n   * @return {Time[]}                         The extracted dates.\n   */ _extractDates(component, propertyName) {\n        let result = [];\n        let props = component.getAllProperties(propertyName);\n        for(let i = 0, len = props.length; i < len; i++){\n            for (let prop of props[i].getValues()){\n                let idx = binsearchInsert(result, prop, (a, b)=>a.compare(b));\n                // ordered insert\n                result.splice(idx, 0, prop);\n            }\n        }\n        return result;\n    }\n    /**\n   * Initialize the recurrence expansion.\n   *\n   * @private\n   * @param {Component} component    The component to initialize from.\n   */ _init(component) {\n        this.ruleIterators = [];\n        this.last = this.dtstart.clone();\n        // to provide api consistency non-recurring\n        // events can also use the iterator though it will\n        // only return a single time.\n        if (!component.hasProperty(\"rdate\") && !component.hasProperty(\"rrule\") && !component.hasProperty(\"recurrence-id\")) {\n            this.ruleDate = this.last.clone();\n            this.complete = true;\n            return;\n        }\n        if (component.hasProperty(\"rdate\")) {\n            this.ruleDates = this._extractDates(component, \"rdate\");\n            // special hack for cases where first rdate is prior\n            // to the start date. We only check for the first rdate.\n            // This is mostly for google's crazy recurring date logic\n            // (contacts birthdays).\n            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n                this.ruleDateInc = 0;\n                this.last = this.ruleDates[0].clone();\n            } else {\n                this.ruleDateInc = binsearchInsert(this.ruleDates, this.last, (a, b)=>a.compare(b));\n            }\n            this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n        if (component.hasProperty(\"rrule\")) {\n            let rules = component.getAllProperties(\"rrule\");\n            let i = 0;\n            let len = rules.length;\n            let rule;\n            let iter;\n            for(; i < len; i++){\n                rule = rules[i].getFirstValue();\n                iter = rule.iterator(this.dtstart);\n                this.ruleIterators.push(iter);\n                // increment to the next occurrence so future\n                // calls to next return times beyond the initial iteration.\n                // XXX: I find this suspicious might be a bug?\n                iter.next();\n            }\n        }\n        if (component.hasProperty(\"exdate\")) {\n            this.exDates = this._extractDates(component, \"exdate\");\n            // if we have a .last day we increment the index to beyond it.\n            this.exDateInc = binsearchInsert(this.exDates, this.last, (a, b)=>a.compare(b));\n            this.exDate = this.exDates[this.exDateInc];\n        }\n    }\n    /**\n   * Advance to the next exdate\n   * @private\n   */ _nextExDay() {\n        this.exDate = this.exDates[++this.exDateInc];\n    }\n    /**\n   * Advance to the next rule date\n   * @private\n   */ _nextRuleDay() {\n        this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    }\n    /**\n   * Find and return the recurrence rule with the most recent event and\n   * return it.\n   *\n   * @private\n   * @return {?RecurIterator}    Found iterator.\n   */ _nextRecurrenceIter() {\n        let iters = this.ruleIterators;\n        if (iters.length === 0) {\n            return null;\n        }\n        let len = iters.length;\n        let iter;\n        let iterTime;\n        let iterIdx = 0;\n        let chosenIter;\n        // loop through each iterator\n        for(; iterIdx < len; iterIdx++){\n            iter = iters[iterIdx];\n            iterTime = iter.last;\n            // if iteration is complete\n            // then we must exclude it from\n            // the search and remove it.\n            if (iter.completed) {\n                len--;\n                if (iterIdx !== 0) {\n                    iterIdx--;\n                }\n                iters.splice(iterIdx, 1);\n                continue;\n            }\n            // find the most recent possible choice\n            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n                // that iterator is saved\n                chosenIter = iter;\n            }\n        }\n        // the chosen iterator is returned but not mutated\n        // this iterator contains the most recent event.\n        return chosenIter;\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").frequencyValues} frequencyValues\n * Imports the 'frequencyValues' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").occurrenceDetails} occurrenceDetails\n * Imports the 'occurrenceDetails' type from the \"types.js\" module\n */ /**\n * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n * object, followed by the component/property layer. The highest level is the\n * event representation, which this class is part of. See the\n * {@tutorial layers} guide for more details.\n *\n * @memberof ICAL\n */ class Event {\n    /**\n   * Creates a new ICAL.Event instance.\n   *\n   * @param {Component=} component              The ICAL.Component to base this event on\n   * @param {Object} [options]                  Options for this event\n   * @param {Boolean=} options.strictExceptions  When true, will verify exceptions are related by\n   *                                              their UUID\n   * @param {Array<Component|Event>=} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */ constructor(component, options){\n        /**\n   * List of related event exceptions.\n   *\n   * @type {Event[]}\n   */ this.exceptions = null;\n        /**\n   * When true, will verify exceptions are related by their UUID.\n   *\n   * @type {Boolean}\n   */ this.strictExceptions = false;\n        if (!(component instanceof Component)) {\n            options = component;\n            component = null;\n        }\n        if (component) {\n            this.component = component;\n        } else {\n            this.component = new Component(\"vevent\");\n        }\n        this._rangeExceptionCache = Object.create(null);\n        this.exceptions = Object.create(null);\n        this.rangeExceptions = [];\n        if (options && options.strictExceptions) {\n            this.strictExceptions = options.strictExceptions;\n        }\n        if (options && options.exceptions) {\n            options.exceptions.forEach(this.relateException, this);\n        } else if (this.component.parent && !this.isRecurrenceException()) {\n            this.component.parent.getAllSubcomponents(\"vevent\").forEach(function(event) {\n                if (event.hasProperty(\"recurrence-id\")) {\n                    this.relateException(event);\n                }\n            }, this);\n        }\n    }\n    static{\n        this.THISANDFUTURE = \"THISANDFUTURE\";\n    }\n    /**\n   * Relates a given event exception to this object.  If the given component\n   * does not share the UID of this event it cannot be related and will throw\n   * an exception.\n   *\n   * If this component is an exception it cannot have other exceptions\n   * related to it.\n   *\n   * @param {Component|Event} obj       Component or event\n   */ relateException(obj) {\n        if (this.isRecurrenceException()) {\n            throw new Error(\"cannot relate exception to exceptions\");\n        }\n        if (obj instanceof Component) {\n            obj = new Event(obj);\n        }\n        if (this.strictExceptions && obj.uid !== this.uid) {\n            throw new Error(\"attempted to relate unrelated exception\");\n        }\n        let id = obj.recurrenceId.toString();\n        // we don't sort or manage exceptions directly\n        // here the recurrence expander handles that.\n        this.exceptions[id] = obj;\n        // index RANGE=THISANDFUTURE exceptions so we can\n        // look them up later in getOccurrenceDetails.\n        if (obj.modifiesFuture()) {\n            let item = [\n                obj.recurrenceId.toUnixTime(),\n                id\n            ];\n            // we keep them sorted so we can find the nearest\n            // value later on...\n            let idx = binsearchInsert(this.rangeExceptions, item, compareRangeException);\n            this.rangeExceptions.splice(idx, 0, item);\n        }\n    }\n    /**\n   * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n   * value.\n   *\n   * @return {Boolean}        True, when exception is within range\n   */ modifiesFuture() {\n        if (!this.component.hasProperty(\"recurrence-id\")) {\n            return false;\n        }\n        let range = this.component.getFirstProperty(\"recurrence-id\").getParameter(\"range\");\n        return range === Event.THISANDFUTURE;\n    }\n    /**\n   * Finds the range exception nearest to the given date.\n   *\n   * @param {Time} time   usually an occurrence time of an event\n   * @return {?Event}     the related event/exception or null\n   */ findRangeException(time) {\n        if (!this.rangeExceptions.length) {\n            return null;\n        }\n        let utc = time.toUnixTime();\n        let idx = binsearchInsert(this.rangeExceptions, [\n            utc\n        ], compareRangeException);\n        idx -= 1;\n        // occurs before\n        if (idx < 0) {\n            return null;\n        }\n        let rangeItem = this.rangeExceptions[idx];\n        /* c8 ignore next 4 */ if (utc < rangeItem[0]) {\n            // sanity check only\n            return null;\n        }\n        return rangeItem[1];\n    }\n    /**\n   * Returns the occurrence details based on its start time.  If the\n   * occurrence has an exception will return the details for that exception.\n   *\n   * NOTE: this method is intend to be used in conjunction\n   *       with the {@link ICAL.Event#iterator iterator} method.\n   *\n   * @param {Time} occurrence               time occurrence\n   * @return {occurrenceDetails}            Information about the occurrence\n   */ getOccurrenceDetails(occurrence) {\n        let id = occurrence.toString();\n        let utcId = occurrence.convertToZone(Timezone.utcTimezone).toString();\n        let item;\n        let result = {\n            //XXX: Clone?\n            recurrenceId: occurrence\n        };\n        if (id in this.exceptions) {\n            item = result.item = this.exceptions[id];\n            result.startDate = item.startDate;\n            result.endDate = item.endDate;\n            result.item = item;\n        } else if (utcId in this.exceptions) {\n            item = this.exceptions[utcId];\n            result.startDate = item.startDate;\n            result.endDate = item.endDate;\n            result.item = item;\n        } else {\n            // range exceptions (RANGE=THISANDFUTURE) have a\n            // lower priority then direct exceptions but\n            // must be accounted for first. Their item is\n            // always the first exception with the range prop.\n            let rangeExceptionId = this.findRangeException(occurrence);\n            let end;\n            if (rangeExceptionId) {\n                let exception = this.exceptions[rangeExceptionId];\n                // range exception must modify standard time\n                // by the difference (if any) in start/end times.\n                result.item = exception;\n                let startDiff = this._rangeExceptionCache[rangeExceptionId];\n                if (!startDiff) {\n                    let original = exception.recurrenceId.clone();\n                    let newStart = exception.startDate.clone();\n                    // zones must be same otherwise subtract may be incorrect.\n                    original.zone = newStart.zone;\n                    startDiff = newStart.subtractDate(original);\n                    this._rangeExceptionCache[rangeExceptionId] = startDiff;\n                }\n                let start = occurrence.clone();\n                start.zone = exception.startDate.zone;\n                start.addDuration(startDiff);\n                end = start.clone();\n                end.addDuration(exception.duration);\n                result.startDate = start;\n                result.endDate = end;\n            } else {\n                // no range exception standard expansion\n                end = occurrence.clone();\n                end.addDuration(this.duration);\n                result.endDate = end;\n                result.startDate = occurrence;\n                result.item = this;\n            }\n        }\n        return result;\n    }\n    /**\n   * Builds a recur expansion instance for a specific point in time (defaults\n   * to startDate).\n   *\n   * @param {Time=} startTime     Starting point for expansion\n   * @return {RecurExpansion}    Expansion object\n   */ iterator(startTime) {\n        return new RecurExpansion({\n            component: this.component,\n            dtstart: startTime || this.startDate\n        });\n    }\n    /**\n   * Checks if the event is recurring\n   *\n   * @return {Boolean}        True, if event is recurring\n   */ isRecurring() {\n        let comp = this.component;\n        return comp.hasProperty(\"rrule\") || comp.hasProperty(\"rdate\");\n    }\n    /**\n   * Checks if the event describes a recurrence exception. See\n   * {@tutorial terminology} for details.\n   *\n   * @return {Boolean}    True, if the event describes a recurrence exception\n   */ isRecurrenceException() {\n        return this.component.hasProperty(\"recurrence-id\");\n    }\n    /**\n   * Returns the types of recurrences this event may have.\n   *\n   * Returned as an object with the following possible keys:\n   *\n   *    - YEARLY\n   *    - MONTHLY\n   *    - WEEKLY\n   *    - DAILY\n   *    - MINUTELY\n   *    - SECONDLY\n   *\n   * @return {Object.<frequencyValues, Boolean>}\n   *          Object of recurrence flags\n   */ getRecurrenceTypes() {\n        let rules = this.component.getAllProperties(\"rrule\");\n        let i = 0;\n        let len = rules.length;\n        let result = Object.create(null);\n        for(; i < len; i++){\n            let value = rules[i].getFirstValue();\n            result[value.freq] = true;\n        }\n        return result;\n    }\n    /**\n   * The uid of this event\n   * @type {String}\n   */ get uid() {\n        return this._firstProp(\"uid\");\n    }\n    set uid(value) {\n        this._setProp(\"uid\", value);\n    }\n    /**\n   * The start date\n   * @type {Time}\n   */ get startDate() {\n        return this._firstProp(\"dtstart\");\n    }\n    set startDate(value) {\n        this._setTime(\"dtstart\", value);\n    }\n    /**\n   * The end date. This can be the result directly from the property, or the\n   * end date calculated from start date and duration. Setting the property\n   * will remove any duration properties.\n   * @type {Time}\n   */ get endDate() {\n        let endDate = this._firstProp(\"dtend\");\n        if (!endDate) {\n            let duration = this._firstProp(\"duration\");\n            endDate = this.startDate.clone();\n            if (duration) {\n                endDate.addDuration(duration);\n            } else if (endDate.isDate) {\n                endDate.day += 1;\n            }\n        }\n        return endDate;\n    }\n    set endDate(value) {\n        if (this.component.hasProperty(\"duration\")) {\n            this.component.removeProperty(\"duration\");\n        }\n        this._setTime(\"dtend\", value);\n    }\n    /**\n   * The duration. This can be the result directly from the property, or the\n   * duration calculated from start date and end date. Setting the property\n   * will remove any `dtend` properties.\n   * @type {Duration}\n   */ get duration() {\n        let duration = this._firstProp(\"duration\");\n        if (!duration) {\n            return this.endDate.subtractDateTz(this.startDate);\n        }\n        return duration;\n    }\n    set duration(value) {\n        if (this.component.hasProperty(\"dtend\")) {\n            this.component.removeProperty(\"dtend\");\n        }\n        this._setProp(\"duration\", value);\n    }\n    /**\n   * The location of the event.\n   * @type {String}\n   */ get location() {\n        return this._firstProp(\"location\");\n    }\n    set location(value) {\n        this._setProp(\"location\", value);\n    }\n    /**\n   * The attendees in the event\n   * @type {Property[]}\n   */ get attendees() {\n        //XXX: This is way lame we should have a better\n        //     data structure for this later.\n        return this.component.getAllProperties(\"attendee\");\n    }\n    /**\n   * The event summary\n   * @type {String}\n   */ get summary() {\n        return this._firstProp(\"summary\");\n    }\n    set summary(value) {\n        this._setProp(\"summary\", value);\n    }\n    /**\n   * The event description.\n   * @type {String}\n   */ get description() {\n        return this._firstProp(\"description\");\n    }\n    set description(value) {\n        this._setProp(\"description\", value);\n    }\n    /**\n   * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n   * @type {String}\n   */ get color() {\n        return this._firstProp(\"color\");\n    }\n    set color(value) {\n        this._setProp(\"color\", value);\n    }\n    /**\n   * The organizer value as an uri. In most cases this is a mailto: uri, but\n   * it can also be something else, like urn:uuid:...\n   * @type {String}\n   */ get organizer() {\n        return this._firstProp(\"organizer\");\n    }\n    set organizer(value) {\n        this._setProp(\"organizer\", value);\n    }\n    /**\n   * The sequence value for this event. Used for scheduling\n   * see {@tutorial terminology}.\n   * @type {Number}\n   */ get sequence() {\n        return this._firstProp(\"sequence\");\n    }\n    set sequence(value) {\n        this._setProp(\"sequence\", value);\n    }\n    /**\n   * The recurrence id for this event. See {@tutorial terminology} for details.\n   * @type {Time}\n   */ get recurrenceId() {\n        return this._firstProp(\"recurrence-id\");\n    }\n    set recurrenceId(value) {\n        this._setTime(\"recurrence-id\", value);\n    }\n    /**\n   * Set/update a time property's value.\n   * This will also update the TZID of the property.\n   *\n   * TODO: this method handles the case where we are switching\n   * from a known timezone to an implied timezone (one without TZID).\n   * This does _not_ handle the case of moving between a known\n   *  (by TimezoneService) timezone to an unknown timezone...\n   *\n   * We will not add/remove/update the VTIMEZONE subcomponents\n   *  leading to invalid ICAL data...\n   * @private\n   * @param {String} propName     The property name\n   * @param {Time} time           The time to set\n   */ _setTime(propName, time) {\n        let prop = this.component.getFirstProperty(propName);\n        if (!prop) {\n            prop = new Property(propName);\n            this.component.addProperty(prop);\n        }\n        // utc and local don't get a tzid\n        if (time.zone === Timezone.localTimezone || time.zone === Timezone.utcTimezone) {\n            // remove the tzid\n            prop.removeParameter(\"tzid\");\n        } else {\n            prop.setParameter(\"tzid\", time.zone.tzid);\n        }\n        prop.setValue(time);\n    }\n    _setProp(name, value) {\n        this.component.updatePropertyWithValue(name, value);\n    }\n    _firstProp(name) {\n        return this.component.getFirstPropertyValue(name);\n    }\n    /**\n   * The string representation of this event.\n   * @return {String}\n   */ toString() {\n        return this.component.toString();\n    }\n}\nfunction compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * The ComponentParser is used to process a String or jCal Object,\n * firing callbacks for various found components, as well as completion.\n *\n * @example\n * var options = {\n *   // when false no events will be emitted for type\n *   parseEvent: true,\n *   parseTimezone: true\n * };\n *\n * var parser = new ICAL.ComponentParser(options);\n *\n * parser.onevent(eventComponent) {\n *   //...\n * }\n *\n * // ontimezone, etc...\n *\n * parser.oncomplete = function() {\n *\n * };\n *\n * parser.process(stringOrComponent);\n *\n * @memberof ICAL\n */ class ComponentParser {\n    /**\n   * Creates a new ICAL.ComponentParser instance.\n   *\n   * @param {Object=} options                   Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */ constructor(options){\n        /**\n   * When true, parse events\n   *\n   * @type {Boolean}\n   */ this.parseEvent = true;\n        /**\n   * When true, parse timezones\n   *\n   * @type {Boolean}\n   */ this.parseTimezone = true;\n        /* SAX like events here for reference */ /**\n   * Fired when parsing is complete\n   * @callback\n   */ this.oncomplete = /* c8 ignore next */ function() {};\n        /**\n   * Fired if an error occurs during parsing.\n   *\n   * @callback\n   * @param {Error} err details of error\n   */ this.onerror = /* c8 ignore next */ function(err) {};\n        /**\n   * Fired when a top level component (VTIMEZONE) is found\n   *\n   * @callback\n   * @param {Timezone} component     Timezone object\n   */ this.ontimezone = /* c8 ignore next */ function(component) {};\n        /**\n   * Fired when a top level component (VEVENT) is found.\n   *\n   * @callback\n   * @param {Event} component    Top level component\n   */ this.onevent = /* c8 ignore next */ function(component) {};\n        if (typeof options === \"undefined\") {\n            options = {};\n        }\n        for (let [key, value] of Object.entries(options)){\n            this[key] = value;\n        }\n    }\n    /**\n   * Process a string or parse ical object.  This function itself will return\n   * nothing but will start the parsing process.\n   *\n   * Events must be registered prior to calling this method.\n   *\n   * @param {Component|String|Object} ical      The component to process,\n   *        either in its final form, as a jCal Object, or string representation\n   */ process(ical) {\n        //TODO: this is sync now in the future we will have a incremental parser.\n        if (typeof ical === \"string\") {\n            ical = parse(ical);\n        }\n        if (!(ical instanceof Component)) {\n            ical = new Component(ical);\n        }\n        let components = ical.getAllSubcomponents();\n        let i = 0;\n        let len = components.length;\n        let component;\n        for(; i < len; i++){\n            component = components[i];\n            switch(component.name){\n                case \"vtimezone\":\n                    if (this.parseTimezone) {\n                        let tzid = component.getFirstPropertyValue(\"tzid\");\n                        if (tzid) {\n                            this.ontimezone(new Timezone({\n                                tzid: tzid,\n                                component: component\n                            }));\n                        }\n                    }\n                    break;\n                case \"vevent\":\n                    if (this.parseEvent) {\n                        this.onevent(new Event(component));\n                    }\n                    break;\n                default:\n                    continue;\n            }\n        }\n        //XXX: ideally we should do a \"nextTick\" here\n        //     so in all cases this is actually async.\n        this.oncomplete();\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * The main ICAL module. Provides access to everything else.\n *\n * @alias ICAL\n * @namespace ICAL\n * @property {ICAL.design} design\n * @property {ICAL.helpers} helpers\n */ var ICALmodule = {\n    /**\n   * The number of characters before iCalendar line folding should occur\n   * @type {Number}\n   * @default 75\n   */ foldLength: 75,\n    debug: false,\n    /**\n   * The character(s) to be used for a newline. The default value is provided by\n   * rfc5545.\n   * @type {String}\n   * @default \"\\r\\n\"\n   */ newLineChar: \"\\r\\n\",\n    Binary,\n    Component,\n    ComponentParser,\n    Duration,\n    Event,\n    Period,\n    Property,\n    Recur,\n    RecurExpansion,\n    RecurIterator,\n    Time,\n    Timezone,\n    TimezoneService,\n    UtcOffset,\n    VCardTime,\n    parse,\n    stringify,\n    design: design$1,\n    helpers\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWNhbC5qcy9kaXN0L2ljYWwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7MENBRzBDLEdBRTFDOzs7O0NBSUMsR0FDRCxNQUFNQTtJQUNKOzs7OztHQUtDLEdBQ0QsT0FBT0MsV0FBV0MsT0FBTyxFQUFFO1FBQ3pCLE9BQU8sSUFBSUYsT0FBT0U7SUFDcEI7SUFFQTs7OztHQUlDLEdBQ0RDLFlBQVlDLE1BQU0sQ0FBRTtRQUlwQjs7OztHQUlDLFFBQ0RDLFdBQVc7UUFSVCxJQUFJLENBQUNDLEtBQUssR0FBR0Y7SUFDZjtJQVNBOzs7O0dBSUMsR0FDREcsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDQyxXQUFXLENBQUMsSUFBSSxDQUFDRixLQUFLO0lBQ3BDO0lBRUE7Ozs7O0dBS0MsR0FDREcsZ0JBQWdCTCxNQUFNLEVBQUU7UUFDdEIsSUFBSSxDQUFDRSxLQUFLLEdBQUcsSUFBSSxDQUFDSSxXQUFXLENBQUNOO0lBQ2hDO0lBRUFNLFlBQVlDLElBQUksRUFBRTtRQUNoQixnQ0FBZ0M7UUFDaEMsbURBQW1EO1FBQ25ELGtDQUFrQztRQUNsQyw2QkFBNkI7UUFDN0IsdUVBQXVFO1FBQ3ZFLDBDQUEwQztRQUMxQyx1RUFBdUU7UUFDdkUsdURBQXVEO1FBQ3ZELHlEQUF5RDtRQUN6RCxrREFBa0Q7UUFDbEQsMEJBQTBCO1FBQzFCLDRCQUE0QjtRQUM1QixpREFBaUQ7UUFDakQsd0JBQXdCO1FBQ3hCLEdBQUc7UUFDSCxJQUFJQyxNQUFNLCtCQUNBO1FBQ1YsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsTUFBTUMsSUFBSSxHQUN4Q0MsS0FBSyxHQUNMQyxNQUFNLElBQ05DLFVBQVUsRUFBRTtRQUVkLElBQUksQ0FBQ2IsTUFBTTtZQUNULE9BQU9BO1FBQ1Q7UUFFQSxHQUFHO1lBQ0RFLEtBQUtGLEtBQUtjLFVBQVUsQ0FBQ0o7WUFDckJQLEtBQUtILEtBQUtjLFVBQVUsQ0FBQ0o7WUFD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WTBmLFVBQVUsQ0FBQ2h2QixFQUFFO1lBRXpCLE9BQVFzUCxVQUFVekosSUFBSTtnQkFDcEIsS0FBSztvQkFDSCxJQUFJLElBQUksQ0FBQ2d6QixhQUFhLEVBQUU7d0JBQ3RCLElBQUlsc0IsT0FBTzJDLFVBQVU4RSxxQkFBcUIsQ0FBQzt3QkFDM0MsSUFBSXpILE1BQU07NEJBQ1IsSUFBSSxDQUFDcXNCLFVBQVUsQ0FBQyxJQUFJdnpCLFNBQVM7Z0NBQzNCa0gsTUFBTUE7Z0NBQ04yQyxXQUFXQTs0QkFDYjt3QkFDRjtvQkFDRjtvQkFDQTtnQkFDRixLQUFLO29CQUNILElBQUksSUFBSSxDQUFDc3BCLFVBQVUsRUFBRTt3QkFDbkIsSUFBSSxDQUFDSyxPQUFPLENBQUMsSUFBSS9DLE1BQU01bUI7b0JBQ3pCO29CQUNBO2dCQUNGO29CQUNFO1lBQ0o7UUFDRjtRQUVBLDZDQUE2QztRQUM3Qyw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDd3BCLFVBQVU7SUFDakI7QUFDRjtBQUVBOzs7MENBRzBDLEdBRTFDOzs7Ozs7O0NBT0MsR0FDRCxJQUFJdGYsYUFBYTtJQUNmOzs7O0dBSUMsR0FDREMsWUFBWTtJQUVaMmYsT0FBTztJQUVQOzs7OztHQUtDLEdBQ0QxZixhQUFhO0lBRWIvYTtJQUNBdVY7SUFDQXlrQjtJQUNBMTNCO0lBQ0FpMUI7SUFDQWhOO0lBQ0ErSDtJQUNBNVQ7SUFDQXVYO0lBQ0F0WTtJQUNBclk7SUFDQXdCO0lBQ0E4RDtJQUNBNlE7SUFDQUc7SUFFQXJMO0lBQ0E0Z0I7SUFFQTFELFFBQVF2ZjtJQUNSb047QUFDRjtBQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1dGR5Ly4vbm9kZV9tb2R1bGVzL2ljYWwuanMvZGlzdC9pY2FsLmpzP2MxMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgQklOQVJZIHZhbHVlIHR5cGUsIHdoaWNoIGNvbnRhaW5zIGV4dHJhIG1ldGhvZHMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAqXG4gKiBAbWVtYmVyb2YgSUNBTFxuICovXG5jbGFzcyBCaW5hcnkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGJpbmFyeSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhU3RyaW5nICAgICAgICBUaGUgYmluYXJ5IHZhbHVlIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCaW5hcnl9ICAgICAgICAgICAgICAgVGhlIGJpbmFyeSB2YWx1ZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoYVN0cmluZykge1xuICAgIHJldHVybiBuZXcgQmluYXJ5KGFTdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5CaW5hcnkgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIGJpbmFyeSBkYXRhIGZvciB0aGlzIHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhVmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gYVZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgKiBAZGVmYXVsdCBcImJpbmFyeVwiXG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgaWNhbHR5cGUgPSBcImJpbmFyeVwiO1xuXG4gIC8qKlxuICAgKiBCYXNlNjQgZGVjb2RlIHRoZSBjdXJyZW50IHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBUaGUgYmFzZTY0LWRlY29kZWQgdmFsdWVcbiAgICovXG4gIGRlY29kZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9iNjRfZGVjb2RlKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgdGhlIHBhc3NlZCBwYXJhbWV0ZXIgd2l0aCBiYXNlNjQgYW5kIHNldHMgdGhlIGludGVybmFsXG4gICAqIHZhbHVlIHRvIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICBUaGUgcmF3IGJpbmFyeSB2YWx1ZSB0byBlbmNvZGVcbiAgICovXG4gIHNldEVuY29kZWRWYWx1ZShhVmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5fYjY0X2VuY29kZShhVmFsdWUpO1xuICB9XG5cbiAgX2I2NF9lbmNvZGUoZGF0YSkge1xuICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBCYXlyb24gR3VldmFyYVxuICAgIC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG4gICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgIC8vICsgICBpbXByb3ZlZCBieTogUmFmYcWCIEt1a2F3c2tpIChodHRwOi8va3VrYXdza2kucGwpXG4gICAgLy8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZW5jb2RlKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG4gICAgLy8gKiAgICAgcmV0dXJucyAxOiAnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PSdcbiAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgIC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcbiAgICAvL2lmICh0eXBlb2YgdGhpcy53aW5kb3dbJ2F0b2InXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgLy99XG4gICAgbGV0IGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiArXG4gICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgbGV0IG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgIGFjID0gMCxcbiAgICAgIGVuYyA9IFwiXCIsXG4gICAgICB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgIGgxID0gYml0cyA+PiAxOCAmIDB4M2Y7XG4gICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgaDQgPSBiaXRzICYgMHgzZjtcblxuICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgIGxldCByID0gZGF0YS5sZW5ndGggJSAzO1xuXG4gICAgcmV0dXJuIChyID8gZW5jLnNsaWNlKDAsIHIgLSAzKSA6IGVuYykgKyAnPT09Jy5zbGljZShyIHx8IDMpO1xuXG4gIH1cblxuICBfYjY0X2RlY29kZShkYXRhKSB7XG4gICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgIC8vICsgICAgICBpbnB1dCBieTogQW1hbiBHdXB0YVxuICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgIC8vICsgICAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgICAvLyArICAgYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgIC8vICogICAgIGV4YW1wbGUgMTogYmFzZTY0X2RlY29kZSgnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PScpO1xuICAgIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG4gICAgLy8gbW96aWxsYSBoYXMgdGhpcyBuYXRpdmVcbiAgICAvLyAtIGJ1dCBicmVha3MgaW4gMi4wLjAuMTIhXG4gICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydidG9hJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgIHJldHVybiBidG9hKGRhdGEpO1xuICAgIC8vfVxuICAgIGxldCBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgIGxldCBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICBhYyA9IDAsXG4gICAgICBkZWMgPSBcIlwiLFxuICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhICs9ICcnO1xuXG4gICAgZG8geyAvLyB1bnBhY2sgZm91ciBoZXhldHMgaW50byB0aHJlZSBvY3RldHMgdXNpbmcgaW5kZXggcG9pbnRzIGluIGI2NFxuICAgICAgaDEgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcbiAgICAgIGgyID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICBoMyA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgaDQgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcblxuICAgICAgYml0cyA9IGgxIDw8IDE4IHwgaDIgPDwgMTIgfCBoMyA8PCA2IHwgaDQ7XG5cbiAgICAgIG8xID0gYml0cyA+PiAxNiAmIDB4ZmY7XG4gICAgICBvMiA9IGJpdHMgPj4gOCAmIDB4ZmY7XG4gICAgICBvMyA9IGJpdHMgJiAweGZmO1xuXG4gICAgICBpZiAoaDMgPT0gNjQpIHtcbiAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEpO1xuICAgICAgfSBlbHNlIGlmIChoNCA9PSA2NCkge1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yLCBvMyk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgIGRlYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICByZXR1cm4gZGVjO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuY29uc3QgRFVSQVRJT05fTEVUVEVSUyA9IC8oW1BEV0hNVFNdezEsMX0pLztcbmNvbnN0IERBVEFfUFJPUFNfVE9fQ09QWSA9IFtcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJpc05lZ2F0aXZlXCJdO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJkdXJhdGlvblwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIER1cmF0aW9uIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc2Vjb25kcyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgIFRoZSBzZWNvbmRzIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgZnJvbVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn0gICAgICAgICAgICAgVGhlIG5ld2x5IGNyZWF0ZWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tU2Vjb25kcyhhU2Vjb25kcykge1xuICAgIHJldHVybiAobmV3IER1cmF0aW9uKCkpLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBpQ2FsZW5kYXIgZHVyYXRpb24gdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFRoZSByYXcgaWNhbCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gaWNhbCB0eXBlXG4gICAqL1xuICBzdGF0aWMgaXNWYWx1ZVN0cmluZyhzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZ1swXSA9PT0gJ1AnIHx8IHN0cmluZ1sxXSA9PT0gJ1AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLkR1cmF0aW9ufSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0ciAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgICAgICAgIFRoZSBjcmVhdGVkIGR1cmF0aW9uIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhhU3RyKSB7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbGV0IGRpY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaHVua3MgPSAwO1xuXG4gICAgd2hpbGUgKChwb3MgPSBhU3RyLnNlYXJjaChEVVJBVElPTl9MRVRURVJTKSkgIT09IC0xKSB7XG4gICAgICBsZXQgdHlwZSA9IGFTdHJbcG9zXTtcbiAgICAgIGxldCBudW1lcmljID0gYVN0ci5zbGljZSgwLCBNYXRoLm1heCgwLCBwb3MpKTtcbiAgICAgIGFTdHIgPSBhU3RyLnNsaWNlKHBvcyArIDEpO1xuXG4gICAgICBjaHVua3MgKz0gcGFyc2VEdXJhdGlvbkNodW5rKHR5cGUsIG51bWVyaWMsIGRpY3QpO1xuICAgIH1cblxuICAgIGlmIChjaHVua3MgPCAyKSB7XG4gICAgICAvLyBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IGEgY2h1bmsgd2l0aCBcIlBcIiBhbmQgc29tZSB1bml0IGNodW5rXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBOb3QgZW5vdWdoIGR1cmF0aW9uIGNvbXBvbmVudHMgaW4gXCInICsgYVN0ciArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbihkaWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuRHVyYXRpb24gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VycyAgICAgICAgIER1cmF0aW9uIGluIGhvdXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzTmVnYXRpdmUgICBJZiB0cnVlLCB0aGUgZHVyYXRpb24gaXMgbmVnYXRpdmVcbiAgICogQHJldHVybiB7RHVyYXRpb259ICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVhZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRhKGFEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbihhRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLkR1cmF0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLndlZWtzICAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXlzICAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VycyAgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubWludXRlcyAgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kcyAgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBkYXRhLmlzTmVnYXRpdmUgICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdlZWtzIGluIHRoaXMgZHVyYXRpb25cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgd2Vla3MgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF5cyBpbiB0aGlzIGR1cmF0aW9uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGRheXMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF5cyBpbiB0aGlzIGR1cmF0aW9uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGhvdXJzID0gMDtcblxuICAvKipcbiAgICogVGhlIG1pbnV0ZXMgaW4gdGhpcyBkdXJhdGlvblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBtaW51dGVzID0gMDtcblxuICAvKipcbiAgICogVGhlIHNlY29uZHMgaW4gdGhpcyBkdXJhdGlvblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBzZWNvbmRzID0gMDtcblxuICAvKipcbiAgICogVGhlIHNlY29uZHMgaW4gdGhpcyBkdXJhdGlvblxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlzTmVnYXRpdmUgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcImljYWxkdXJhdGlvblwiXG4gICAqL1xuICBpY2FsY2xhc3MgPSBcImljYWxkdXJhdGlvblwiO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwiZHVyYXRpb25cIlxuICAgKi9cbiAgaWNhbHR5cGUgPSBcImR1cmF0aW9uXCI7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgZHVyYXRpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn0gICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21EYXRhKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiB2YWx1ZSBleHByZXNzZWQgYXMgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIGxldCBzZWNvbmRzID0gdGhpcy5zZWNvbmRzICsgNjAgKiB0aGlzLm1pbnV0ZXMgKyAzNjAwICogdGhpcy5ob3VycyArXG4gICAgICAgICAgICAgICAgICA4NjQwMCAqIHRoaXMuZGF5cyArIDcgKiA4NjQwMCAqIHRoaXMud2Vla3M7XG4gICAgcmV0dXJuICh0aGlzLmlzTmVnYXRpdmUgPyAtc2Vjb25kcyA6IHNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBwYXNzZWQgc2Vjb25kcyB2YWx1ZSBpbnRvIHRoaXMgZHVyYXRpb24gb2JqZWN0LiBBZnRlcndhcmRzLFxuICAgKiBtZW1iZXJzIGxpa2Uge0BsaW5rIElDQUwuRHVyYXRpb24jZGF5cyBkYXlzfSBhbmQge0BsaW5rIElDQUwuRHVyYXRpb24jd2Vla3Mgd2Vla3N9IHdpbGwgYmUgc2V0IHVwXG4gICAqIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgIFRoZSBkdXJhdGlvbiB2YWx1ZSBpbiBzZWNvbmRzXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgICAgICAgICAgUmV0dXJucyB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBmcm9tU2Vjb25kcyhhU2Vjb25kcykge1xuICAgIGxldCBzZWNzID0gTWF0aC5hYnMoYVNlY29uZHMpO1xuXG4gICAgdGhpcy5pc05lZ2F0aXZlID0gKGFTZWNvbmRzIDwgMCk7XG4gICAgdGhpcy5kYXlzID0gdHJ1bmMoc2VjcyAvIDg2NDAwKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBmbGF0IG51bWJlciBvZiB3ZWVrcywgdXNlIHRoZW0uXG4gICAgaWYgKHRoaXMuZGF5cyAlIDcgPT0gMCkge1xuICAgICAgdGhpcy53ZWVrcyA9IHRoaXMuZGF5cyAvIDc7XG4gICAgICB0aGlzLmRheXMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndlZWtzID0gMDtcbiAgICB9XG5cbiAgICBzZWNzIC09ICh0aGlzLmRheXMgKyA3ICogdGhpcy53ZWVrcykgKiA4NjQwMDtcblxuICAgIHRoaXMuaG91cnMgPSB0cnVuYyhzZWNzIC8gMzYwMCk7XG4gICAgc2VjcyAtPSB0aGlzLmhvdXJzICogMzYwMDtcblxuICAgIHRoaXMubWludXRlcyA9IHRydW5jKHNlY3MgLyA2MCk7XG4gICAgc2VjcyAtPSB0aGlzLm1pbnV0ZXMgKiA2MDtcblxuICAgIHRoaXMuc2Vjb25kcyA9IHNlY3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEud2Vla3MgICAgICAgICBEdXJhdGlvbiBpbiB3ZWVrc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzICAgICAgIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKi9cbiAgZnJvbURhdGEoYURhdGEpIHtcbiAgICBmb3IgKGxldCBwcm9wIG9mIERBVEFfUFJPUFNfVE9fQ09QWSkge1xuICAgICAgaWYgKGFEYXRhICYmIHByb3AgaW4gYURhdGEpIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IGFEYXRhW3Byb3BdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgZHVyYXRpb24gaW5zdGFuY2UgdG8gdGhlIGRlZmF1bHQgdmFsdWVzLCBpLmUuIFBUMFNcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMud2Vla3MgPSAwO1xuICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgdGhpcy5ob3VycyA9IDA7XG4gICAgdGhpcy5taW51dGVzID0gMDtcbiAgICB0aGlzLnNlY29uZHMgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSBkdXJhdGlvbiBpbnN0YW5jZSB3aXRoIGFub3RoZXIgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBhT3RoZXIgICAgICAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAqL1xuICBjb21wYXJlKGFPdGhlcikge1xuICAgIGxldCB0aGlzU2Vjb25kcyA9IHRoaXMudG9TZWNvbmRzKCk7XG4gICAgbGV0IG90aGVyU2Vjb25kcyA9IGFPdGhlci50b1NlY29uZHMoKTtcbiAgICByZXR1cm4gKHRoaXNTZWNvbmRzID4gb3RoZXJTZWNvbmRzKSAtICh0aGlzU2Vjb25kcyA8IG90aGVyU2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgZHVyYXRpb24gaW5zdGFuY2UuIEZvciBleGFtcGxlLCBhIGR1cmF0aW9uIHdpdGggYSB2YWx1ZVxuICAgKiBvZiA2MSBzZWNvbmRzIHdpbGwgYmUgbm9ybWFsaXplZCB0byAxIG1pbnV0ZSBhbmQgMSBzZWNvbmQuXG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgdGhpcy5mcm9tU2Vjb25kcyh0aGlzLnRvU2Vjb25kcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLnRvU2Vjb25kcygpID09IDApIHtcbiAgICAgIHJldHVybiBcIlBUMFNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKSBzdHIgKz0gXCItXCI7XG4gICAgICBzdHIgKz0gXCJQXCI7XG4gICAgICBpZiAodGhpcy53ZWVrcykgc3RyICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICAgIGlmICh0aGlzLmRheXMpIHN0ciArPSB0aGlzLmRheXMgKyBcIkRcIjtcblxuICAgICAgaWYgKHRoaXMuaG91cnMgfHwgdGhpcy5taW51dGVzIHx8IHRoaXMuc2Vjb25kcykge1xuICAgICAgICBzdHIgKz0gXCJUXCI7XG4gICAgICAgIGlmICh0aGlzLmhvdXJzKSBzdHIgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgICAgICBpZiAodGhpcy5taW51dGVzKSBzdHIgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgICAgIGlmICh0aGlzLnNlY29uZHMpIHN0ciArPSB0aGlzLnNlY29uZHMgKyBcIlNcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSUNBTFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBhIGNodW5rIG9mIGEgZHVyYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXR0ZXIgdHlwZSBvZiBkdXJhdGlvbiBjaHVua1xuICogQHBhcmFtIHtTdHJpbmd9IG51bWJlciBudW1lcmljIHZhbHVlIG9yIC0vK1xuICogQHBhcmFtIHtPYmplY3R9IGRpY3QgdGFyZ2V0IHRvIGFzc2lnbiB2YWx1ZXMgdG9cbiAqL1xuZnVuY3Rpb24gcGFyc2VEdXJhdGlvbkNodW5rKGxldHRlciwgbnVtYmVyLCBvYmplY3QpIHtcbiAgbGV0IHR5cGU7XG4gIHN3aXRjaCAobGV0dGVyKSB7XG4gICAgY2FzZSAnUCc6XG4gICAgICBpZiAobnVtYmVyICYmIG51bWJlciA9PT0gJy0nKSB7XG4gICAgICAgIG9iamVjdC5pc05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdC5pc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBwZXJpb2RcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0QnOlxuICAgICAgdHlwZSA9ICdkYXlzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1cnOlxuICAgICAgdHlwZSA9ICd3ZWVrcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdIJzpcbiAgICAgIHR5cGUgPSAnaG91cnMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTSc6XG4gICAgICB0eXBlID0gJ21pbnV0ZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUyc6XG4gICAgICB0eXBlID0gJ3NlY29uZHMnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIE5vdCBhIHZhbGlkIGNodW5rXG4gICAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFudW1iZXIgJiYgbnVtYmVyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBNaXNzaW5nIG51bWJlciBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG51bSA9IHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgIGlmIChpc1N0cmljdGx5TmFOKG51bSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IEludmFsaWQgbnVtYmVyIFwiJyArIG51bWJlciArICdcIiBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG4gICAgb2JqZWN0W3R5cGVdID0gbnVtO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKlxuICogQGlnbm9yZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikud2Vla0RheX0gd2Vla0RheVxuICogSW1wb3J0cyB0aGUgJ3dlZWtEYXknIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogaUNhbGVuZGFyIFRpbWUgcmVwcmVzZW50YXRpb24gKHNpbWlsYXIgdG8gSlMgRGF0ZSBvYmplY3QpLiAgRnVsbHlcbiAqIGluZGVwZW5kZW50IG9mIHN5c3RlbSAoT1MpIHRpbWV6b25lIC8gdGltZS4gIFVubGlrZSBKUyBEYXRlLCB0aGUgbW9udGhcbiAqIEphbnVhcnkgaXMgMSwgbm90IHplcm8uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gKiAgIHllYXI6IDIwMTIsXG4gKiAgIG1vbnRoOiAxMCxcbiAqICAgZGF5OiAxMVxuICogICBtaW51dGU6IDAsXG4gKiAgIHNlY29uZDogMCxcbiAqICAgaXNEYXRlOiBmYWxzZVxuICogfSk7XG4gKlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4qL1xuY2xhc3MgVGltZSB7XG4gIHN0YXRpYyBfZG93Q2FjaGUgPSB7fTtcbiAgc3RhdGljIF93bkNhY2hlID0ge307XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRheXMgaW4gdGhlIGdpdmVuIG1vbnRoXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aCAgICAgIFRoZSBtb250aCB0byBjaGVja1xuICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICBUaGUgeWVhciB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoXG4gICAqL1xuICBzdGF0aWMgZGF5c0luTW9udGgobW9udGgsIHllYXIpIHtcbiAgICBsZXQgX2RheXNJbk1vbnRoID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuICAgIGxldCBkYXlzID0gMzA7XG5cbiAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHJldHVybiBkYXlzO1xuXG4gICAgZGF5cyA9IF9kYXlzSW5Nb250aFttb250aF07XG5cbiAgICBpZiAobW9udGggPT0gMikge1xuICAgICAgZGF5cyArPSBUaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqL1xuICBzdGF0aWMgaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgaWYgKHllYXIgPD0gMTc1Mikge1xuICAgICAgcmV0dXJuICgoeWVhciAlIDQpID09IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCgoeWVhciAlIDQgPT0gMCkgJiYgKHllYXIgJSAxMDAgIT0gMCkpIHx8ICh5ZWFyICUgNDAwID09IDApKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IElDQUwuVGltZSBmcm9tIHRoZSBkYXkgb2YgeWVhciBhbmQgeWVhci4gVGhlIGRhdGUgaXMgcmV0dXJuZWRcbiAgICogaW4gZmxvYXRpbmcgdGltZXpvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZZZWFyICAgICBUaGUgZGF5IG9mIHllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgIFRoZSB5ZWFyIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgaW5cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIGluc3RhbmNlIHdpdGggdGhlIGNhbGN1bGF0ZWQgZGF0ZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXlPZlllYXIoYURheU9mWWVhciwgYVllYXIpIHtcbiAgICBsZXQgeWVhciA9IGFZZWFyO1xuICAgIGxldCBkb3kgPSBhRGF5T2ZZZWFyO1xuICAgIGxldCB0dCA9IG5ldyBUaW1lKCk7XG4gICAgdHQuYXV0b19ub3JtYWxpemUgPSBmYWxzZTtcbiAgICBsZXQgaXNfbGVhcCA9IChUaW1lLmlzTGVhcFllYXIoeWVhcikgPyAxIDogMCk7XG5cbiAgICBpZiAoZG95IDwgMSkge1xuICAgICAgeWVhci0tO1xuICAgICAgaXNfbGVhcCA9IChUaW1lLmlzTGVhcFllYXIoeWVhcikgPyAxIDogMCk7XG4gICAgICBkb3kgKz0gVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgcmV0dXJuIFRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgIH0gZWxzZSBpZiAoZG95ID4gVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdKSB7XG4gICAgICBpc19sZWFwID0gKFRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcbiAgICAgIGRveSAtPSBUaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVsxMl07XG4gICAgICB5ZWFyKys7XG4gICAgICByZXR1cm4gVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfVxuXG4gICAgdHQueWVhciA9IHllYXI7XG4gICAgdHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IG1vbnRoID0gMTE7IG1vbnRoID49IDA7IG1vbnRoLS0pIHtcbiAgICAgIGlmIChkb3kgPiBUaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF0pIHtcbiAgICAgICAgdHQubW9udGggPSBtb250aCArIDE7XG4gICAgICAgIHR0LmRheSA9IGRveSAtIFRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdW21vbnRoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHQuYXV0b19ub3JtYWxpemUgPSB0cnVlO1xuICAgIHJldHVybiB0dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAgICAgICAgICAgICAgICBVc2Uge0BsaW5rIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZ30gaW5zdGVhZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5ndjIoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lKHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHN0ci5zbGljZSgwLCA0KSwgMTApLFxuICAgICAgbW9udGg6IHBhcnNlSW50KHN0ci5zbGljZSg1LCA3KSwgMTApLFxuICAgICAgZGF5OiBwYXJzZUludChzdHIuc2xpY2UoOCwgMTApLCAxMCksXG4gICAgICBpc0RhdGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVN0cmluZyhhVmFsdWUpIHtcbiAgICAvLyBEYXRlcyBzaG91bGQgaGF2ZSBubyB0aW1lem9uZS5cbiAgICAvLyBHb29nbGUgbGlrZXMgdG8gc29tZXRpbWVzIHNwZWNpZnkgWiBvbiBkYXRlc1xuICAgIC8vIHdlIHNwZWNpZmljYWxseSBpZ25vcmUgdGhhdCB0byBhdm9pZCBpc3N1ZXMuXG5cbiAgICAvLyBZWVlZLU1NLUREXG4gICAgLy8gMjAxMi0xMC0xMFxuICAgIHJldHVybiBuZXcgVGltZSh7XG4gICAgICB5ZWFyOiBzdHJpY3RQYXJzZUludChhVmFsdWUuc2xpY2UoMCwgNCkpLFxuICAgICAgbW9udGg6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSg1LCA3KSksXG4gICAgICBkYXk6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSg4LCAxMCkpLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUtdGltZSBzdHJpbmcsIGUuZ1xuICAgKiAyMDE1LTAxLTAyVDAzOjA0OjA1LiBJZiBhIHByb3BlcnR5IGlzIHNwZWNpZmllZCwgdGhlIHRpbWV6b25lIGlzIHNldCB1cFxuICAgKiBmcm9tIHRoZSBwcm9wZXJ0eSdzIFRaSUQgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5PX0gcHJvcCAgICAgICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBwcm9wKSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPCAxOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBkYXRlLXRpbWUgdmFsdWU6IFwiJyArIGFWYWx1ZSArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHpvbmU7XG4gICAgbGV0IHpvbmVJZDtcblxuICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgem9uZSA9IFRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgIH0gZWxzZSBpZiAocHJvcCkge1xuICAgICAgem9uZUlkID0gcHJvcC5nZXRQYXJhbWV0ZXIoJ3R6aWQnKTtcblxuICAgICAgaWYgKHByb3AucGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9wLnBhcmVudC5uYW1lID09PSAnc3RhbmRhcmQnIHx8IHByb3AucGFyZW50Lm5hbWUgPT09ICdkYXlsaWdodCcpIHtcbiAgICAgICAgICAvLyBQZXIgUkZDIDU1NDUgMy44LjIuNCBhbmQgMy44LjIuMiwgc3RhcnQvZW5kIGRhdGUtdGltZXMgd2l0aGluXG4gICAgICAgICAgLy8gdGhlc2UgY29tcG9uZW50cyBNVVNUIGJlIHNwZWNpZmllZCBpbiBsb2NhbCB0aW1lLlxuICAgICAgICAgIHpvbmUgPSBUaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgICB9IGVsc2UgaWYgKHpvbmVJZCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZXNpcmVkIHRpbWUgem9uZSBpcyBkZWZpbmVkIHdpdGhpbiB0aGUgY29tcG9uZW50IHRyZWUsXG4gICAgICAgICAgLy8gZmV0Y2ggaXRzIGRlZmluaXRpb24gYW5kIHByZWZlciB0aGF0LlxuICAgICAgICAgIHpvbmUgPSBwcm9wLnBhcmVudC5nZXRUaW1lWm9uZUJ5SUQoem9uZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRpbWVEYXRhID0ge1xuICAgICAgeWVhcjogc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnNsaWNlKDAsIDQpKSxcbiAgICAgIG1vbnRoOiBzdHJpY3RQYXJzZUludChhVmFsdWUuc2xpY2UoNSwgNykpLFxuICAgICAgZGF5OiBzdHJpY3RQYXJzZUludChhVmFsdWUuc2xpY2UoOCwgMTApKSxcbiAgICAgIGhvdXI6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSgxMSwgMTMpKSxcbiAgICAgIG1pbnV0ZTogc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnNsaWNlKDE0LCAxNikpLFxuICAgICAgc2Vjb25kOiBzdHJpY3RQYXJzZUludChhVmFsdWUuc2xpY2UoMTcsIDE5KSksXG4gICAgfTtcblxuICAgIC8vIEFsdGhvdWdoIFJGQyA1NTQ1IHJlcXVpcmVzIHRoYXQgYWxsIFRaSURzIHVzZWQgd2l0aGluIGEgZmlsZSBoYXZlIGFcbiAgICAvLyBjb3JyZXNwb25kaW5nIHRpbWUgem9uZSBkZWZpbml0aW9uLCB3ZSBtYXkgbm90IGJlIHBhcnNpbmcgdGhlIGZ1bGwgZmlsZVxuICAgIC8vIG9yIHdlIG1heSBiZSBkZWFsaW5nIHdpdGggYSBub24tY29tcGxpYW50IGZpbGU7IGluIGVpdGhlciBjYXNlLCB3ZSBjYW5cbiAgICAvLyBjaGVjayBvdXIgb3duIHRpbWUgem9uZSBzZXJ2aWNlIGZvciB0aGUgVFpJRCBpbiBhIGxhc3QtZGl0Y2ggZWZmb3J0LlxuICAgIGlmICh6b25lSWQgJiYgIXpvbmUpIHtcbiAgICAgIHRpbWVEYXRhLnRpbWV6b25lID0gem9uZUlkO1xuICAgIH1cblxuICAgIC8vIDIwMTItMTAtMTBUMTA6MTA6MTAoWik/XG4gICAgcmV0dXJuIG5ldyBUaW1lKHRpbWVEYXRhLCB6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBvciBkYXRlLXRpbWUgc3RyaW5nLFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5PX0gcHJvcCAgICAgICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgcmV0dXJuIFRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFRpbWUuZnJvbURhdGVTdHJpbmcoYVZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBEYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gez9EYXRlfSBhRGF0ZSAgICAgICAgICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlVVRDPWZhbHNlXSAgSWYgdHJ1ZSwgdGhlIFVUQyB2YWx1ZXMgb2YgdGhlIGRhdGUgd2lsbCBiZSB1c2VkXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgbGV0IHR0ID0gbmV3IFRpbWUoKTtcbiAgICByZXR1cm4gdHQuZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5tb250aCAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGUgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXMgb3Bwb3NlZCB0byBhIGRhdGUtdGltZSlcbiAgICogQHBhcmFtIHtUaW1lem9uZT19IGFab25lICAgICAgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0YSA9IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgIGxldCB0ID0gbmV3IFRpbWUoKTtcbiAgICByZXR1cm4gdC5mcm9tRGF0YShhRGF0YSwgYVpvbmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSBjdXJyZW50IG1vbWVudC5cbiAgICogVGhlIGluc3RhbmNlIGlzIOKAnGZsb2F0aW5n4oCdIC0gaGFzIG5vIHRpbWV6b25lIHJlbGF0aW9uLlxuICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2UgY29uc2lkZXJpbmcgdGhlIHRpbWUgem9uZSwgY2FsbFxuICAgKiBJQ0FMLlRpbWUuZnJvbUpTRGF0ZShuZXcgRGF0ZSgpLCB0cnVlKVxuICAgKiBAcmV0dXJuIHtUaW1lfVxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRlIG9uIHdoaWNoIElTTyB3ZWVrIG51bWJlciAxIHN0YXJ0cy5cbiAgICpcbiAgICogQHNlZSBUaW1lI3dlZWtOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFXZWVrU3RhcnQgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIHVzZWQgZm9yIGNhbGN1bGF0aW9uLlxuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF0ZSBvbiB3aGljaCB3ZWVrIG51bWJlciAxIHN0YXJ0c1xuICAgKi9cbiAgc3RhdGljIHdlZWtPbmVTdGFydHMoYVllYXIsIGFXZWVrU3RhcnQpIHtcbiAgICBsZXQgdCA9IFRpbWUuZnJvbURhdGEoe1xuICAgICAgeWVhcjogYVllYXIsXG4gICAgICBtb250aDogMSxcbiAgICAgIGRheTogMSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgbGV0IGRvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgbGV0IHdrc3QgPSBhV2Vla1N0YXJ0IHx8IFRpbWUuREVGQVVMVF9XRUVLX1NUQVJUO1xuICAgIGlmIChkb3cgPiBUaW1lLlRIVVJTREFZKSB7XG4gICAgICB0LmRheSArPSA3O1xuICAgIH1cbiAgICBpZiAod2tzdCA+IFRpbWUuVEhVUlNEQVkpIHtcbiAgICAgIHQuZGF5IC09IDc7XG4gICAgfVxuXG4gICAgdC5kYXkgLT0gZG93IC0gd2tzdDtcblxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGdpdmVuIHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gRyBmb3JcbiAgICogY29tbW9uIHllYXJzLCBhbmQgQUcgdG8gR0YgZm9yIGxlYXAgeWVhcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgZG9taW5pY2FsIGxldHRlci5cbiAgICovXG4gIHN0YXRpYyBnZXREb21pbmljYWxMZXR0ZXIoeXIpIHtcbiAgICBsZXQgTFRSUyA9IFwiR0ZFRENCQVwiO1xuICAgIGxldCBkb20gPSAoeXIgKyAoeXIgLyA0IHwgMCkgKyAoeXIgLyA0MDAgfCAwKSAtICh5ciAvIDEwMCB8IDApIC0gMSkgJSA3O1xuICAgIGxldCBpc0xlYXAgPSBUaW1lLmlzTGVhcFllYXIoeXIpO1xuICAgIGlmIChpc0xlYXApIHtcbiAgICAgIHJldHVybiBMVFJTWyhkb20gKyA2KSAlIDddICsgTFRSU1tkb21dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTFRSU1tkb21dO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyAjZXBvY2hUaW1lID0gbnVsbDtcbiAgLyoqXG4gICAqIEphbnVhcnkgMXN0LCAxOTcwIGFzIGFuIElDQUwuVGltZS5cbiAgICogQHR5cGUge1RpbWV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBnZXQgZXBvY2hUaW1lKCkge1xuICAgIGlmICghdGhpcy4jZXBvY2hUaW1lKSB7XG4gICAgICB0aGlzLiNlcG9jaFRpbWUgPSBUaW1lLmZyb21EYXRhKHtcbiAgICAgICAgeWVhcjogMTk3MCxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMSxcbiAgICAgICAgaG91cjogMCxcbiAgICAgICAgbWludXRlOiAwLFxuICAgICAgICBzZWNvbmQ6IDAsXG4gICAgICAgIGlzRGF0ZTogZmFsc2UsXG4gICAgICAgIHRpbWV6b25lOiBcIlpcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNlcG9jaFRpbWU7XG4gIH1cblxuICBzdGF0aWMgX2NtcF9hdHRyKGEsIGIsIGF0dHIpIHtcbiAgICBpZiAoYVthdHRyXSA+IGJbYXR0cl0pIHJldHVybiAxO1xuICAgIGlmIChhW2F0dHJdIDwgYlthdHRyXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXlzIHRoYXQgaGF2ZSBwYXNzZWQgaW4gdGhlIHllYXIgYWZ0ZXIgYSBnaXZlbiBtb250aC4gVGhlIGFycmF5IGhhc1xuICAgKiB0d28gbWVtYmVycywgb25lIGJlaW5nIGFuIGFycmF5IG9mIHBhc3NlZCBkYXlzIGZvciBub24tbGVhcCB5ZWFycywgdGhlXG4gICAqIG90aGVyIGFuYWxvZyBmb3IgbGVhcCB5ZWFycy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGlzTGVhcFllYXIgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICogdmFyIHBhc3NlZERheXMgPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzTGVhcFllYXJdW21vbnRoXTtcbiAgICogQHR5cGUge0FycmF5LjxBcnJheS48TnVtYmVyPj59XG4gICAqL1xuICBzdGF0aWMgZGF5c0luWWVhclBhc3NlZE1vbnRoID0gW1xuICAgIFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XSxcbiAgICBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzUsIDM2Nl1cbiAgXTtcblxuICBzdGF0aWMgU1VOREFZID0gMTtcbiAgc3RhdGljIE1PTkRBWSA9IDI7XG4gIHN0YXRpYyBUVUVTREFZID0gMztcbiAgc3RhdGljIFdFRE5FU0RBWSA9IDQ7XG4gIHN0YXRpYyBUSFVSU0RBWSA9IDU7XG4gIHN0YXRpYyBGUklEQVkgPSA2O1xuICBzdGF0aWMgU0FUVVJEQVkgPSA3O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB3ZWVrZGF5IGZvciB0aGUgV0tTVCBwYXJ0LlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgKi9cbiAgc3RhdGljIERFRkFVTFRfV0VFS19TVEFSVCA9IDI7IC8vIE1PTkRBWVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1vbnRoICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1pbnV0ZSAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGRhdGEuaXNEYXRlICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGUgKGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAqIEBwYXJhbSB7VGltZXpvbmV9IHpvbmUgICAgICAgICB0aW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgem9uZSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICBsZXQgdGltZSA9IHRoaXMuX3RpbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyogdGltZSBkZWZhdWx0cyAqL1xuICAgIHRpbWUueWVhciA9IDA7XG4gICAgdGltZS5tb250aCA9IDE7XG4gICAgdGltZS5kYXkgPSAxO1xuICAgIHRpbWUuaG91ciA9IDA7XG4gICAgdGltZS5taW51dGUgPSAwO1xuICAgIHRpbWUuc2Vjb25kID0gMDtcbiAgICB0aW1lLmlzRGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5mcm9tRGF0YShkYXRhLCB6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwiaWNhbHRpbWVcIlxuICAgKi9cbiAgaWNhbGNsYXNzID0gXCJpY2FsdGltZVwiO1xuICBfY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC4gVGhpcyB2YWx1ZSBtYXkgY2hhbmdlIGFuZFxuICAgKiBpcyBzdHJpY3RseSBkZWZpbmVkIGJ5IHRoZSB7QGxpbmsgSUNBTC5UaW1lI2lzRGF0ZSBpc0RhdGV9IG1lbWJlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJkYXRlLXRpbWVcIlxuICAgKi9cbiAgZ2V0IGljYWx0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGF0ZSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lem9uZSBmb3IgdGhpcyB0aW1lLlxuICAgKiBAdHlwZSB7VGltZXpvbmV9XG4gICAqL1xuICB6b25lID0gbnVsbDtcblxuICAvKipcbiAgICogSW50ZXJuYWwgdXNlcyB0byBpbmRpY2F0ZSB0aGF0IGEgY2hhbmdlIGhhcyBiZWVuIG1hZGUgYW5kIHRoZSBuZXh0IHJlYWRcbiAgICogb3BlcmF0aW9uIG11c3QgYXR0ZW1wdCB0byBub3JtYWxpemUgdGhlIHZhbHVlIChmb3IgZXhhbXBsZSBjaGFuZ2luZyB0aGVcbiAgICogZGF5IHRvIDMzKS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVuZGluZ05vcm1hbGl6YXRpb24gPSBmYWxzZTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB0aW1lIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWUodGhpcy5fdGltZSwgdGhpcy56b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGltZSBpbnN0YW5jZSB0byBlcG9jaCB0aW1lXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmZyb21EYXRhKFRpbWUuZXBvY2hUaW1lKTtcbiAgICB0aGlzLnpvbmUgPSBUaW1lem9uZS51dGNUaW1lem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGltZSBpbnN0YW5jZSB0byB0aGUgZ2l2ZW4gZGF0ZS90aW1lIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aCAgICAgICAgICAgIFRoZSBtb250aCB0byBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheSAgICAgICAgICAgICAgVGhlIGRheSB0byBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXIgICAgICAgICAgICAgVGhlIGhvdXIgdG8gc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW51dGUgICAgICAgICAgIFRoZSBtaW51dGUgdG8gc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgICAgICAgICAgIFRoZSBzZWNvbmQgdG8gc2V0XG4gICAqIEBwYXJhbSB7VGltZXpvbmV9IHRpbWV6b25lICAgICAgIFRoZSB0aW1lem9uZSB0byBzZXRcbiAgICovXG4gIHJlc2V0VG8oeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIHRpbWV6b25lKSB7XG4gICAgdGhpcy5mcm9tRGF0YSh7XG4gICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgZGF5OiBkYXksXG4gICAgICBob3VyOiBob3VyLFxuICAgICAgbWludXRlOiBtaW51dGUsXG4gICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgIHpvbmU6IHRpbWV6b25lXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdGhlIEphdmFzY3JpcHQgZGF0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHs/RGF0ZX0gYURhdGUgICAgICAgICAgICAgVGhlIEphdmFzY3JpcHQgRGF0ZSB0byByZWFkLCBvciBudWxsIHRvIHJlc2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZVVUQz1mYWxzZV0gIElmIHRydWUsIHRoZSBVVEMgdmFsdWVzIG9mIHRoZSBkYXRlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgaWYgKCFhRGF0ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodXNlVVRDKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IFRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgICB0aGlzLnllYXIgPSBhRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB0aGlzLmhvdXIgPSBhRGF0ZS5nZXRVVENIb3VycygpO1xuICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnpvbmUgPSBUaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgICB0aGlzLnllYXIgPSBhRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB0aGlzLmhvdXIgPSBhRGF0ZS5nZXRIb3VycygpO1xuICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5tb250aCAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGUgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXMgb3Bwb3NlZCB0byBhIGRhdGUtdGltZSlcbiAgICogQHBhcmFtIHtUaW1lem9uZT19IGFab25lICAgICAgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgIGlmIChhRGF0YSkge1xuICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFEYXRhKSkge1xuICAgICAgICAgIC8vIGljYWwgdHlwZSBjYW5ub3QgYmUgc2V0XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ2ljYWx0eXBlJykgY29udGludWU7XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhWm9uZSkge1xuICAgICAgdGhpcy56b25lID0gYVpvbmU7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICEoXCJpc0RhdGVcIiBpbiBhRGF0YSkpIHtcbiAgICAgIHRoaXMuaXNEYXRlID0gIShcImhvdXJcIiBpbiBhRGF0YSk7XG4gICAgfSBlbHNlIGlmIChhRGF0YSAmJiAoXCJpc0RhdGVcIiBpbiBhRGF0YSkpIHtcbiAgICAgIHRoaXMuaXNEYXRlID0gYURhdGEuaXNEYXRlO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiBcInRpbWV6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgIGxldCB6b25lID0gVGltZXpvbmVTZXJ2aWNlLmdldChcbiAgICAgICAgYURhdGEudGltZXpvbmVcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuem9uZSA9IHpvbmUgfHwgVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgXCJ6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgIHRoaXMuem9uZSA9IGFEYXRhLnpvbmU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnpvbmUpIHtcbiAgICAgIHRoaXMuem9uZSA9IFRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHdlZWsuXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHt3ZWVrRGF5fVxuICAgKi9cbiAgZGF5T2ZXZWVrKGFXZWVrU3RhcnQpIHtcbiAgICBsZXQgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IFRpbWUuU1VOREFZO1xuICAgIGxldCBkb3dDYWNoZUtleSA9ICh0aGlzLnllYXIgPDwgMTIpICsgKHRoaXMubW9udGggPDwgOCkgKyAodGhpcy5kYXkgPDwgMykgKyBmaXJzdERvdztcbiAgICBpZiAoZG93Q2FjaGVLZXkgaW4gVGltZS5fZG93Q2FjaGUpIHtcbiAgICAgIHJldHVybiBUaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV07XG4gICAgfVxuXG4gICAgLy8gVXNpbmcgWmVsbGVyJ3MgYWxnb3JpdGhtXG4gICAgbGV0IHEgPSB0aGlzLmRheTtcbiAgICBsZXQgbSA9IHRoaXMubW9udGggKyAodGhpcy5tb250aCA8IDMgPyAxMiA6IDApO1xuICAgIGxldCBZID0gdGhpcy55ZWFyIC0gKHRoaXMubW9udGggPCAzID8gMSA6IDApO1xuXG4gICAgbGV0IGggPSAocSArIFkgKyB0cnVuYygoKG0gKyAxKSAqIDI2KSAvIDEwKSArIHRydW5jKFkgLyA0KSk7XG4gICAgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgaCArPSB0cnVuYyhZIC8gMTAwKSAqIDYgKyB0cnVuYyhZIC8gNDAwKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgdG8gMSA9IHdrc3RcbiAgICBoID0gKChoICsgNyAtIGZpcnN0RG93KSAlIDcpICsgMTtcbiAgICBUaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV0gPSBoO1xuICAgIHJldHVybiBoO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHllYXIuXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGRheU9mWWVhcigpIHtcbiAgICBsZXQgaXNfbGVhcCA9IChUaW1lLmlzTGVhcFllYXIodGhpcy55ZWFyKSA/IDEgOiAwKTtcbiAgICBsZXQgZGl5cG0gPSBUaW1lLmRheXNJblllYXJQYXNzZWRNb250aDtcbiAgICByZXR1cm4gZGl5cG1baXNfbGVhcF1bdGhpcy5tb250aCAtIDFdICsgdGhpcy5kYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCByZXdvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICogd2Vlay4gVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZiB0aGlzXG4gICAqIGlzIGEgZGF0ZS10aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3dlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICogQHJldHVybiB7VGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIHdlZWsgKGNsb25lZClcbiAgICovXG4gIHN0YXJ0T2ZXZWVrKGFXZWVrU3RhcnQpIHtcbiAgICBsZXQgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IFRpbWUuU1VOREFZO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgcmVzdWx0LmRheSAtPSAoKHRoaXMuZGF5T2ZXZWVrKCkgKyA3IC0gZmlyc3REb3cpICUgNyk7XG4gICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCBzaGlmdGVkIHRvIHRoZSBlbmQgb2YgdGhlIHdlZWsuXG4gICAqIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpcyBpcyBhXG4gICAqIGRhdGUtdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgd2VlayAoY2xvbmVkKVxuICAgKi9cbiAgZW5kT2ZXZWVrKGFXZWVrU3RhcnQpIHtcbiAgICBsZXQgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IFRpbWUuU1VOREFZO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgcmVzdWx0LmRheSArPSAoNyAtIHRoaXMuZGF5T2ZXZWVrKCkgKyBmaXJzdERvdyAtIFRpbWUuU1VOREFZKSAlIDc7XG4gICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCByZXdvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICogbW9udGguIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICpcbiAgICogQHJldHVybiB7VGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAqL1xuICBzdGFydE9mTW9udGgoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXN1bHQuZGF5ID0gMTtcbiAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICogbW9udGguICBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICovXG4gIGVuZE9mTW9udGgoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXN1bHQuZGF5ID0gVGltZS5kYXlzSW5Nb250aChyZXN1bHQubW9udGgsIHJlc3VsdC55ZWFyKTtcbiAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiB5ZWFyLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgVGhlIHN0YXJ0IG9mIHRoZSB5ZWFyIChjbG9uZWQpXG4gICAqL1xuICBzdGFydE9mWWVhcigpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgIHJlc3VsdC5kYXkgPSAxO1xuICAgIHJlc3VsdC5tb250aCA9IDE7XG4gICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCBzaGlmdGVkIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAqIHllYXIuICBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgKi9cbiAgZW5kT2ZZZWFyKCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgcmVzdWx0LmRheSA9IDMxO1xuICAgIHJlc3VsdC5tb250aCA9IDEyO1xuICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICByZXN1bHQubWludXRlID0gMDtcbiAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcnN0IGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGVuIHJldHVybnMgdGhlIGRheSBvZiB5ZWFyIGZvclxuICAgKiB0aGlzIGRhdGUuIElmIHRoZSBkYXkgZmFsbHMgaW50byB0aGUgcHJldmlvdXMgeWVhciwgdGhlIGRheSBpcyB6ZXJvIG9yIG5lZ2F0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge3dlZWtEYXk9fSBhRmlyc3REYXlPZldlZWtcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBUaGUgY2FsY3VsYXRlZCBkYXkgb2YgeWVhclxuICAgKi9cbiAgc3RhcnREb3lXZWVrKGFGaXJzdERheU9mV2Vlaykge1xuICAgIGxldCBmaXJzdERvdyA9IGFGaXJzdERheU9mV2VlayB8fCBUaW1lLlNVTkRBWTtcbiAgICBsZXQgZGVsdGEgPSB0aGlzLmRheU9mV2VlaygpIC0gZmlyc3REb3c7XG4gICAgaWYgKGRlbHRhIDwgMCkgZGVsdGEgKz0gNztcbiAgICByZXR1cm4gdGhpcy5kYXlPZlllYXIoKSAtIGRlbHRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGN1cnJlbnQgeWVhci4gTGV0dGVycyByYW5nZSBmcm9tIEEgLSBHXG4gICAqIGZvciBjb21tb24geWVhcnMsIGFuZCBBRyB0byBHRiBmb3IgbGVhcCB5ZWFycy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlyICAgICAgICAgICBUaGUgeWVhciB0byByZXRyaWV2ZSB0aGUgbGV0dGVyIGZvclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBkb21pbmljYWwgbGV0dGVyLlxuICAgKi9cbiAgZ2V0RG9taW5pY2FsTGV0dGVyKCkge1xuICAgIHJldHVybiBUaW1lLmdldERvbWluaWNhbExldHRlcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBudGhXZWVrRGF5IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IG1vbnRoIChub3QgZGF5KS4gIFRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBpcyBhIGRheSByZWxhdGl2ZSB0aGUgbW9udGggdGhhdCB0aGlzIG1vbnRoIGJlbG9uZ3MgdG8gc29cbiAgICogMSB3b3VsZCBpbmRpY2F0ZSB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoIGFuZCA0MCB3b3VsZCBpbmRpY2F0ZSBhIGRheSBpblxuICAgKiB0aGUgZm9sbG93aW5nIG1vbnRoLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYURheU9mV2VlayAgIERheSBvZiB0aGUgd2VlayBzZWUgdGhlIGRheSBuYW1lIGNvbnN0YW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgIE50aCBvY2N1cnJlbmNlIG9mIGEgZ2l2ZW4gd2VlayBkYXkgdmFsdWVzXG4gICAqICAgICAgICBvZiAxIGFuZCAwIGJvdGggaW5kaWNhdGUgdGhlIGZpcnN0IHdlZWtkYXkgb2YgdGhhdCB0eXBlLiBhUG9zIG1heVxuICAgKiAgICAgICAgYmUgZWl0aGVyIHBvc2l0aXZlIG9yIG5lZ2F0aXZlXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gbnVtZXJpYyB2YWx1ZSBpbmRpY2F0aW5nIGEgZGF5IHJlbGF0aXZlXG4gICAqICAgICAgICAgICAgICAgICAgIHRvIHRoZSBjdXJyZW50IG1vbnRoIG9mIHRoaXMgdGltZSBvYmplY3RcbiAgICovXG4gIG50aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcykge1xuICAgIGxldCBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgodGhpcy5tb250aCwgdGhpcy55ZWFyKTtcbiAgICBsZXQgd2Vla2RheTtcbiAgICBsZXQgcG9zID0gYVBvcztcblxuICAgIGxldCBzdGFydCA9IDA7XG5cbiAgICBsZXQgb3RoZXJEYXkgPSB0aGlzLmNsb25lKCk7XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIG90aGVyRGF5LmRheSA9IDE7XG5cbiAgICAgIC8vIGJlY2F1c2UgMCBtZWFucyBubyBwb3NpdGlvbiBoYXMgYmVlbiBnaXZlblxuICAgICAgLy8gMSBhbmQgMCBpbmRpY2F0ZSB0aGUgc2FtZSBkYXkuXG4gICAgICBpZiAocG9zICE9IDApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBleHRyYSBudW1lcmljIHZhbHVlXG4gICAgICAgIHBvcy0tO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgY3VycmVudCBzdGFydCBvZmZzZXQgdG8gY3VycmVudCBkYXkuXG4gICAgICBzdGFydCA9IG90aGVyRGF5LmRheTtcblxuICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBkYXkgb2Ygd2Vla1xuICAgICAgbGV0IHN0YXJ0RG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnRcbiAgICAgIC8vIGRheSBvZiB0aGUgd2VlayBhbmQgZGVzaXJlZCBkYXkgb2YgdGhlIHdlZWtcbiAgICAgIGxldCBvZmZzZXQgPSBhRGF5T2ZXZWVrIC0gc3RhcnREb3c7XG5cblxuICAgICAgLy8gaWYgdGhlIG9mZnNldCBnb2VzIGludG8gdGhlIHBhc3RcbiAgICAgIC8vIHdlZWsgd2UgYWRkIDcgc28gaXQgZ29lcyBpbnRvIHRoZSBuZXh0XG4gICAgICAvLyB3ZWVrLiBXZSBvbmx5IHdhbnQgdG8gZ28gZm9yd2FyZCBpbiB0aW1lIGhlcmUuXG4gICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgLy8gdGhpcyBpcyByZWFsbHkgaW1wb3J0YW50IG90aGVyd2lzZSB3ZSB3b3VsZFxuICAgICAgICAvLyBlbmQgdXAgd2l0aCBkYXRlcyBmcm9tIGluIHRoZSBwYXN0LlxuICAgICAgICBvZmZzZXQgKz0gNztcblxuICAgICAgLy8gYWRkIG9mZnNldCB0byBzdGFydCBzbyBzdGFydCBpcyB0aGUgc2FtZVxuICAgICAgLy8gZGF5IG9mIHRoZSB3ZWVrIGFzIHRoZSBkZXNpcmVkIGRheSBvZiB3ZWVrLlxuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuXG4gICAgICAvLyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgKGFuZCBtdWx0aXBseSlcbiAgICAgIC8vIHRoZSBudW1lcmljIHZhbHVlIG9mIHRoZSBkYXkgd2Ugc3VidHJhY3QgaXRcbiAgICAgIC8vIGZyb20gdGhlIHN0YXJ0IHBvc2l0aW9uIHNvIG5vdCB0byBhZGQgaXQgdHdpY2UuXG4gICAgICBzdGFydCAtPSBhRGF5T2ZXZWVrO1xuXG4gICAgICAvLyBzZXQgd2VlayBkYXlcbiAgICAgIHdlZWtkYXkgPSBhRGF5T2ZXZWVrO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHRoZW4gd2Ugc2V0IGl0IHRvIHRoZSBsYXN0IGRheSBpbiB0aGUgY3VycmVudCBtb250aFxuICAgICAgb3RoZXJEYXkuZGF5ID0gZGF5c0luTW9udGg7XG5cbiAgICAgIC8vIGZpbmQgdGhlIGVuZHMgd2Vla2RheVxuICAgICAgbGV0IGVuZERvdyA9IG90aGVyRGF5LmRheU9mV2VlaygpO1xuXG4gICAgICBwb3MrKztcblxuICAgICAgd2Vla2RheSA9IChlbmREb3cgLSBhRGF5T2ZXZWVrKTtcblxuICAgICAgaWYgKHdlZWtkYXkgPCAwKSB7XG4gICAgICAgIHdlZWtkYXkgKz0gNztcbiAgICAgIH1cblxuICAgICAgd2Vla2RheSA9IGRheXNJbk1vbnRoIC0gd2Vla2RheTtcbiAgICB9XG5cbiAgICB3ZWVrZGF5ICs9IHBvcyAqIDc7XG5cbiAgICByZXR1cm4gc3RhcnQgKyB3ZWVrZGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBjdXJyZW50IHRpbWUgaXMgdGhlIG50aCB3ZWVrZGF5LCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgKiBtb250aC4gIFdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSB3aGVuIHJ1bGUgcmVzb2x2ZXMgb3V0c2lkZSBvZiBjdXJyZW50XG4gICAqIG1vbnRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3dlZWtEYXl9IGFEYXlPZldlZWsgICAgICAgICAgICAgICAgIERheSBvZiB3ZWVrIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhUG9zICAgICAgICAgICAgICAgICAgICAgICAgUmVsYXRpdmUgcG9zaXRpb25cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlLCBpZiBpdCBpcyB0aGUgbnRoIHdlZWtkYXlcbiAgICovXG4gIGlzTnRoV2Vla0RheShhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgbGV0IGRvdyA9IHRoaXMuZGF5T2ZXZWVrKCk7XG5cbiAgICBpZiAoYVBvcyA9PT0gMCAmJiBkb3cgPT09IGFEYXlPZldlZWspIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGdldCBwb3NcbiAgICBsZXQgZGF5ID0gdGhpcy5udGhXZWVrRGF5KGFEYXlPZldlZWssIGFQb3MpO1xuXG4gICAgaWYgKGRheSA9PT0gdGhpcy5kYXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBJU08gODYwMSB3ZWVrIG51bWJlci4gVGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyIGlzIHRoZVxuICAgKiB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0IFRodXJzZGF5LiBUaGUgeWVhciBjYW4gaGF2ZSA1MyB3ZWVrcywgaWZcbiAgICogSmFudWFyeSAxc3QgaXMgYSBGcmlkYXkuXG4gICAqXG4gICAqIE5vdGUgdGhlcmUgYXJlIHJlZ2lvbnMgd2hlcmUgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIgaXMgdGhlIG9uZSB0aGF0XG4gICAqIHN0YXJ0cyBvbiBKYW51YXJ5IDFzdCwgd2hpY2ggbWF5IG9mZnNldCB0aGUgd2VlayBudW1iZXIuIEFsc28sIGlmIGFcbiAgICogZGlmZmVyZW50IHdlZWsgc3RhcnQgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYWxzbyBhZmZlY3QgdGhlIHdlZWtcbiAgICogbnVtYmVyLlxuICAgKlxuICAgKiBAc2VlIFRpbWUud2Vla09uZVN0YXJ0c1xuICAgKiBAcGFyYW0ge3dlZWtEYXl9IGFXZWVrU3RhcnQgICAgICAgICAgICAgICAgICBUaGUgd2Vla2RheSB0aGUgd2VlayBzdGFydHMgd2l0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgSVNPIHdlZWsgbnVtYmVyXG4gICAqL1xuICB3ZWVrTnVtYmVyKGFXZWVrU3RhcnQpIHtcbiAgICBsZXQgd25DYWNoZUtleSA9ICh0aGlzLnllYXIgPDwgMTIpICsgKHRoaXMubW9udGggPDwgOCkgKyAodGhpcy5kYXkgPDwgMykgKyBhV2Vla1N0YXJ0O1xuICAgIGlmICh3bkNhY2hlS2V5IGluIFRpbWUuX3duQ2FjaGUpIHtcbiAgICAgIHJldHVybiBUaW1lLl93bkNhY2hlW3duQ2FjaGVLZXldO1xuICAgIH1cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGNvdXJ0ZXN0eSBvZiBKdWxpYW4gQnVja25hbGwsIHB1Ymxpc2hlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgICAvLyBodHRwOi8vd3d3LmJveWV0LmNvbS9hcnRpY2xlcy9wdWJsaXNoZWRhcnRpY2xlcy9jYWxjdWxhdGluZ3RoZWlzb3dlZWtudW1iLmh0bWxcbiAgICAvLyBwbHVzIHNvbWUgZml4ZXMgdG8gYmUgYWJsZSB0byB1c2UgZGlmZmVyZW50IHdlZWsgc3RhcnRzLlxuICAgIGxldCB3ZWVrMTtcblxuICAgIGxldCBkdCA9IHRoaXMuY2xvbmUoKTtcbiAgICBkdC5pc0RhdGUgPSB0cnVlO1xuICAgIGxldCBpc295ZWFyID0gdGhpcy55ZWFyO1xuXG4gICAgaWYgKGR0Lm1vbnRoID09IDEyICYmIGR0LmRheSA+IDI1KSB7XG4gICAgICB3ZWVrMSA9IFRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyICsgMSwgYVdlZWtTdGFydCk7XG4gICAgICBpZiAoZHQuY29tcGFyZSh3ZWVrMSkgPCAwKSB7XG4gICAgICAgIHdlZWsxID0gVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNveWVhcisrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3ZWVrMSA9IFRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgIGlmIChkdC5jb21wYXJlKHdlZWsxKSA8IDApIHtcbiAgICAgICAgd2VlazEgPSBUaW1lLndlZWtPbmVTdGFydHMoLS1pc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGF5c0JldHdlZW4gPSAoZHQuc3VidHJhY3REYXRlKHdlZWsxKS50b1NlY29uZHMoKSAvIDg2NDAwKTtcbiAgICBsZXQgYW5zd2VyID0gdHJ1bmMoZGF5c0JldHdlZW4gLyA3KSArIDE7XG4gICAgVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XSA9IGFuc3dlcjtcbiAgICByZXR1cm4gYW5zd2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGR1cmF0aW9uIHRvIHRoZSBjdXJyZW50IHRpbWUuIFRoZSBpbnN0YW5jZSBpcyBtb2RpZmllZCBpblxuICAgKiBwbGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gYUR1cmF0aW9uICAgICAgICAgVGhlIGR1cmF0aW9uIHRvIGFkZFxuICAgKi9cbiAgYWRkRHVyYXRpb24oYUR1cmF0aW9uKSB7XG4gICAgbGV0IG11bHQgPSAoYUR1cmF0aW9uLmlzTmVnYXRpdmUgPyAtMSA6IDEpO1xuXG4gICAgLy8gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gb3B0aW1pemF0aW9ucyBpdCBpcyBtdWNoXG4gICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gZ3JhYiBhbGwgdGhlIHZhbHVlcyB1cCBmcm9udFxuICAgIC8vIHRoZW4gc2V0IHRoZW0gZGlyZWN0bHkgKHdoaWNoIHdpbGwgYXZvaWQgYSBub3JtYWxpemF0aW9uIGNhbGwpLlxuICAgIC8vIFNvIHdlIGRvbid0IGFjdHVhbGx5IG5vcm1hbGl6ZSB1bnRpbCB3ZSBuZWVkIGl0LlxuICAgIGxldCBzZWNvbmQgPSB0aGlzLnNlY29uZDtcbiAgICBsZXQgbWludXRlID0gdGhpcy5taW51dGU7XG4gICAgbGV0IGhvdXIgPSB0aGlzLmhvdXI7XG4gICAgbGV0IGRheSA9IHRoaXMuZGF5O1xuXG4gICAgc2Vjb25kICs9IG11bHQgKiBhRHVyYXRpb24uc2Vjb25kcztcbiAgICBtaW51dGUgKz0gbXVsdCAqIGFEdXJhdGlvbi5taW51dGVzO1xuICAgIGhvdXIgKz0gbXVsdCAqIGFEdXJhdGlvbi5ob3VycztcbiAgICBkYXkgKz0gbXVsdCAqIGFEdXJhdGlvbi5kYXlzO1xuICAgIGRheSArPSBtdWx0ICogNyAqIGFEdXJhdGlvbi53ZWVrcztcblxuICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuICAgIHRoaXMubWludXRlID0gbWludXRlO1xuICAgIHRoaXMuaG91ciA9IGhvdXI7XG4gICAgdGhpcy5kYXkgPSBkYXk7XG5cbiAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3QgdGhlIGRhdGUgZGV0YWlscyAoX2V4Y2x1ZGluZ18gdGltZXpvbmUpLiAgVXNlZnVsIGZvciBmaW5kaW5nXG4gICAqIHRoZSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHRpbWUgb2JqZWN0cyBleGNsdWRpbmcgdGhlaXJcbiAgICogdGltZXpvbmUgZGlmZmVyZW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZX0gYURhdGUgICAgIFRoZSBkYXRlIHRvIHN1YnRyYWN0XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgICAgIFRoZSBkaWZmZXJlbmNlIGFzIGEgZHVyYXRpb25cbiAgICovXG4gIHN1YnRyYWN0RGF0ZShhRGF0ZSkge1xuICAgIGxldCB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpICsgdGhpcy51dGNPZmZzZXQoKTtcbiAgICBsZXQgb3RoZXIgPSBhRGF0ZS50b1VuaXhUaW1lKCkgKyBhRGF0ZS51dGNPZmZzZXQoKTtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3QgdGhlIGRhdGUgZGV0YWlscywgdGFraW5nIHRpbWV6b25lcyBpbnRvIGFjY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZX0gYURhdGUgIFRoZSBkYXRlIHRvIHN1YnRyYWN0XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgIFRoZSBkaWZmZXJlbmNlIGluIGR1cmF0aW9uXG4gICAqL1xuICBzdWJ0cmFjdERhdGVUeihhRGF0ZSkge1xuICAgIGxldCB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgIGxldCBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKTtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhlIElDQUwuVGltZSBpbnN0YW5jZSB3aXRoIGFub3RoZXIgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBhT3RoZXIgICAgICAgIFRoZSBpbnN0YW5jZSB0byBjb21wYXJlIHdpdGhcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgKi9cbiAgY29tcGFyZShvdGhlcikge1xuICAgIGxldCBhID0gdGhpcy50b1VuaXhUaW1lKCk7XG4gICAgbGV0IGIgPSBvdGhlci50b1VuaXhUaW1lKCk7XG5cbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgIGlmIChiID4gYSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIG9ubHkgdGhlIGRhdGUgcGFydCBvZiB0aGlzIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IG90aGVyICAgICAgICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAqIEBwYXJhbSB7VGltZXpvbmV9IHR6ICAgICAgICAgICAgICAgICBUaGUgdGltZXpvbmUgdG8gY29tcGFyZSBpblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAqL1xuICBjb21wYXJlRGF0ZU9ubHlUeihvdGhlciwgdHopIHtcbiAgICBsZXQgYSA9IHRoaXMuY29udmVydFRvWm9uZSh0eik7XG4gICAgbGV0IGIgPSBvdGhlci5jb252ZXJ0VG9ab25lKHR6KTtcbiAgICBsZXQgcmMgPSAwO1xuXG4gICAgaWYgKChyYyA9IFRpbWUuX2NtcF9hdHRyKGEsIGIsIFwieWVhclwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgIGlmICgocmMgPSBUaW1lLl9jbXBfYXR0cihhLCBiLCBcIm1vbnRoXCIpKSAhPSAwKSByZXR1cm4gcmM7XG4gICAgaWYgKChyYyA9IFRpbWUuX2NtcF9hdHRyKGEsIGIsIFwiZGF5XCIpKSAhPSAwKSByZXR1cm4gcmM7XG5cbiAgICByZXR1cm4gcmM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgaW5zdGFuY2UgaW50byBhbm90aGVyIHRpbWV6b25lLiBUaGUgcmV0dXJuZWQgSUNBTC5UaW1lXG4gICAqIGluc3RhbmNlIGlzIGFsd2F5cyBhIGNvcHkuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZXpvbmV9IHpvbmUgICAgICBUaGUgem9uZSB0byBjb252ZXJ0IHRvXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgICAgICAgICBUaGUgY29weSwgY29udmVydGVkIHRvIHRoZSB6b25lXG4gICAqL1xuICBjb252ZXJ0VG9ab25lKHpvbmUpIHtcbiAgICBsZXQgY29weSA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgem9uZV9lcXVhbHMgPSAodGhpcy56b25lLnR6aWQgPT0gem9uZS50emlkKTtcblxuICAgIGlmICghdGhpcy5pc0RhdGUgJiYgIXpvbmVfZXF1YWxzKSB7XG4gICAgICBUaW1lem9uZS5jb252ZXJ0X3RpbWUoY29weSwgdGhpcy56b25lLCB6b25lKTtcbiAgICB9XG5cbiAgICBjb3B5LnpvbmUgPSB6b25lO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIFVUQyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lIGluIHRoZSB0aW1lem9uZSBpdCBpc1xuICAgKiBpbi5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVVRDIG9mZnNldCBpbiBzZWNvbmRzXG4gICAqL1xuICB1dGNPZmZzZXQoKSB7XG4gICAgaWYgKHRoaXMuem9uZSA9PSBUaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRoaXMuem9uZSA9PSBUaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyA1NTQ1IGNvbXBsaWFudCBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGljYWwgZGF0ZS9kYXRlLXRpbWVcbiAgICovXG4gIHRvSUNBTFN0cmluZygpIHtcbiAgICBsZXQgc3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggPiAxMCkge1xuICAgICAgcmV0dXJuIGRlc2lnbiQxLmljYWxlbmRhci52YWx1ZVsnZGF0ZS10aW1lJ10udG9JQ0FMKHN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZXNpZ24kMS5pY2FsZW5kYXIudmFsdWUuZGF0ZS50b0lDQUwoc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUvdGltZSwgaW4gakNhbCBmb3JtXG4gICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMueWVhciArICctJyArXG4gICAgICAgICAgICAgICAgIHBhZDIodGhpcy5tb250aCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICBwYWQyKHRoaXMuZGF5KTtcblxuICAgIGlmICghdGhpcy5pc0RhdGUpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdUJyArIHBhZDIodGhpcy5ob3VyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICBwYWQyKHRoaXMubWludXRlKSArICc6JyArXG4gICAgICAgICAgICAgICAgICBwYWQyKHRoaXMuc2Vjb25kKTtcblxuICAgICAgaWYgKHRoaXMuem9uZSA9PT0gVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIGEgSmF2YXNjcmlwdCBkYXRlXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0pTRGF0ZSgpIHtcbiAgICBpZiAodGhpcy56b25lID09IFRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgIGlmICh0aGlzLmlzRGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b1VuaXhUaW1lKCkgKiAxMDAwKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplKCkge1xuICAgIGlmICh0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgdGhpcy5fdGltZS5ob3VyID0gMDtcbiAgICAgIHRoaXMuX3RpbWUubWludXRlID0gMDtcbiAgICAgIHRoaXMuX3RpbWUuc2Vjb25kID0gMDtcbiAgICB9XG4gICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3QgdGhlIGRhdGUvdGltZSBieSB0aGUgZ2l2ZW4gb2Zmc2V0XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFEYXlzICAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhSG91cnMgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGhvdXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFNaW51dGVzICAgIFRoZSBleHRyYSBhbW91bnQgb2YgbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhU2Vjb25kcyAgICBUaGUgZXh0cmEgYW1vdW50IG9mIHNlY29uZHNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhVGltZSAgICAgICAgICAgVGhlIHRpbWUgdG8gYWRqdXN0LCBkZWZhdWx0cyB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50IGluc3RhbmNlLlxuICAgKi9cbiAgYWRqdXN0KGFFeHRyYURheXMsIGFFeHRyYUhvdXJzLCBhRXh0cmFNaW51dGVzLCBhRXh0cmFTZWNvbmRzLCBhVGltZSkge1xuXG4gICAgbGV0IG1pbnV0ZXNPdmVyZmxvdywgaG91cnNPdmVyZmxvdyxcbiAgICAgICAgZGF5c092ZXJmbG93ID0gMCwgeWVhcnNPdmVyZmxvdyA9IDA7XG5cbiAgICBsZXQgc2Vjb25kLCBtaW51dGUsIGhvdXIsIGRheTtcbiAgICBsZXQgZGF5c0luTW9udGg7XG5cbiAgICBsZXQgdGltZSA9IGFUaW1lIHx8IHRoaXMuX3RpbWU7XG5cbiAgICBpZiAoIXRpbWUuaXNEYXRlKSB7XG4gICAgICBzZWNvbmQgPSB0aW1lLnNlY29uZCArIGFFeHRyYVNlY29uZHM7XG4gICAgICB0aW1lLnNlY29uZCA9IHNlY29uZCAlIDYwO1xuICAgICAgbWludXRlc092ZXJmbG93ID0gdHJ1bmMoc2Vjb25kIC8gNjApO1xuICAgICAgaWYgKHRpbWUuc2Vjb25kIDwgMCkge1xuICAgICAgICB0aW1lLnNlY29uZCArPSA2MDtcbiAgICAgICAgbWludXRlc092ZXJmbG93LS07XG4gICAgICB9XG5cbiAgICAgIG1pbnV0ZSA9IHRpbWUubWludXRlICsgYUV4dHJhTWludXRlcyArIG1pbnV0ZXNPdmVyZmxvdztcbiAgICAgIHRpbWUubWludXRlID0gbWludXRlICUgNjA7XG4gICAgICBob3Vyc092ZXJmbG93ID0gdHJ1bmMobWludXRlIC8gNjApO1xuICAgICAgaWYgKHRpbWUubWludXRlIDwgMCkge1xuICAgICAgICB0aW1lLm1pbnV0ZSArPSA2MDtcbiAgICAgICAgaG91cnNPdmVyZmxvdy0tO1xuICAgICAgfVxuXG4gICAgICBob3VyID0gdGltZS5ob3VyICsgYUV4dHJhSG91cnMgKyBob3Vyc092ZXJmbG93O1xuXG4gICAgICB0aW1lLmhvdXIgPSBob3VyICUgMjQ7XG4gICAgICBkYXlzT3ZlcmZsb3cgPSB0cnVuYyhob3VyIC8gMjQpO1xuICAgICAgaWYgKHRpbWUuaG91ciA8IDApIHtcbiAgICAgICAgdGltZS5ob3VyICs9IDI0O1xuICAgICAgICBkYXlzT3ZlcmZsb3ctLTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIEFkanVzdCBtb250aCBhbmQgeWVhciBmaXJzdCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgd2hhdCBtb250aCB0aGUgZGF5XG4gICAgLy8gaXMgaW4gYmVmb3JlIGFkanVzdGluZyBpdC5cbiAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICB5ZWFyc092ZXJmbG93ID0gdHJ1bmMoKHRpbWUubW9udGggLSAxKSAvIDEyKTtcbiAgICB9IGVsc2UgaWYgKHRpbWUubW9udGggPCAxKSB7XG4gICAgICB5ZWFyc092ZXJmbG93ID0gdHJ1bmModGltZS5tb250aCAvIDEyKSAtIDE7XG4gICAgfVxuXG4gICAgdGltZS55ZWFyICs9IHllYXJzT3ZlcmZsb3c7XG4gICAgdGltZS5tb250aCAtPSAxMiAqIHllYXJzT3ZlcmZsb3c7XG5cbiAgICAvLyBOb3cgdGFrZSBjYXJlIG9mIHRoZSBkYXlzIChhbmQgYWRqdXN0IG1vbnRoIGlmIG5lZWRlZClcbiAgICBkYXkgPSB0aW1lLmRheSArIGFFeHRyYURheXMgKyBkYXlzT3ZlcmZsb3c7XG5cbiAgICBpZiAoZGF5ID4gMCkge1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgodGltZS5tb250aCwgdGltZS55ZWFyKTtcbiAgICAgICAgaWYgKGRheSA8PSBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZS5tb250aCsrO1xuICAgICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgICAgdGltZS55ZWFyKys7XG4gICAgICAgICAgdGltZS5tb250aCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBkYXkgLT0gZGF5c0luTW9udGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChkYXkgPD0gMCkge1xuICAgICAgICBpZiAodGltZS5tb250aCA9PSAxKSB7XG4gICAgICAgICAgdGltZS55ZWFyLS07XG4gICAgICAgICAgdGltZS5tb250aCA9IDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWUubW9udGgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRheSArPSBUaW1lLmRheXNJbk1vbnRoKHRpbWUubW9udGgsIHRpbWUueWVhcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGltZS5kYXkgPSBkYXk7XG5cbiAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBmcm9tIHVuaXggdGltZSwgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAqIEphbnVhcnkgMXN0LCAxOTcwLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyAgICAgIFRoZSBzZWNvbmRzIHRvIHNldCB1cCB3aXRoXG4gICAqL1xuICBmcm9tVW5peFRpbWUoc2Vjb25kcykge1xuICAgIHRoaXMuem9uZSA9IFRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgIC8vIFdlIGNvdWxkIHVzZSBgZnJvbUpTRGF0ZWAgaGVyZSwgYnV0IHRoaXMgaXMgYWJvdXQgdHdpY2UgYXMgZmFzdC5cbiAgICAvLyBXZSBjb3VsZCBhbHNvIGNsb25lIGBlcG9jaFRpbWVgIGFuZCB1c2UgYGFkanVzdGAgZm9yIGEgbW9yZVxuICAgIC8vIGljYWwuanMtY2VudHJpYyBhcHByb2FjaCwgYnV0IHRoaXMgaXMgYWJvdXQgMTAwIHRpbWVzIGFzIGZhc3QuXG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCk7XG4gICAgdGhpcy55ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIHRoaXMubW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgIHRoaXMuZGF5ID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgaWYgKHRoaXMuX3RpbWUuaXNEYXRlKSB7XG4gICAgICB0aGlzLmhvdXIgPSAwO1xuICAgICAgdGhpcy5taW51dGUgPSAwO1xuICAgICAgdGhpcy5zZWNvbmQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhvdXIgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICB0aGlzLm1pbnV0ZSA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgdGhpcy5zZWNvbmQgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdG8gc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDFzdCAxOTcwLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgU2Vjb25kcyBzaW5jZSAxOTcwXG4gICAqL1xuICB0b1VuaXhUaW1lKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRVbml4VGltZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcblxuICAgIC8vIHdlIHVzZSB0aGUgb2Zmc2V0IHRyaWNrIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgd2UgYXJlIGdldHRpbmcgdGhlIGFjdHVhbCBVVEMgdGltZVxuICAgIGxldCBtcyA9IERhdGUuVVRDKFxuICAgICAgdGhpcy55ZWFyLFxuICAgICAgdGhpcy5tb250aCAtIDEsXG4gICAgICB0aGlzLmRheSxcbiAgICAgIHRoaXMuaG91cixcbiAgICAgIHRoaXMubWludXRlLFxuICAgICAgdGhpcy5zZWNvbmQgLSBvZmZzZXRcbiAgICApO1xuXG4gICAgLy8gc2Vjb25kc1xuICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbXMgLyAxMDAwO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRVbml4VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aW1lIHRvIGludG8gT2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRoZW4gcmUtY3JlYXRlZFxuICAgKiB1c2luZyB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHRvSlNPTiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkXG4gICAqIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkobXl0aW1lKTtcbiAgICpcbiAgICogdmFyIGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAqXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZShkZXNlcmlhbGl6ZWQpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IGNvcHkgPSBbXG4gICAgICAneWVhcicsXG4gICAgICAnbW9udGgnLFxuICAgICAgJ2RheScsXG4gICAgICAnaG91cicsXG4gICAgICAnbWludXRlJyxcbiAgICAgICdzZWNvbmQnLFxuICAgICAgJ2lzRGF0ZSdcbiAgICBdO1xuXG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbiA9IGNvcHkubGVuZ3RoO1xuICAgIGxldCBwcm9wO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcHJvcCA9IGNvcHlbaV07XG4gICAgICByZXN1bHRbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnpvbmUpIHtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHRoaXMuem9uZS50emlkO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuKGZ1bmN0aW9uIHNldHVwTm9ybWFsaXplQXR0cmlidXRlcygpIHtcbiAgLy8gVGhpcyBuZWVkcyB0byBydW4gYmVmb3JlIGFueSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQhXG4gIGZ1bmN0aW9uIGRlZmluZUF0dHIoYXR0cikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lLnByb3RvdHlwZSwgYXR0ciwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXRUaW1lQXR0cigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ05vcm1hbGl6YXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lW2F0dHJdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0VGltZUF0dHIodmFsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGlzRGF0ZSB3aWxsIGJlIHNldCBhbmQgaWYgd2FzIG5vdCBzZXQgdG8gbm9ybWFsaXplIGRhdGUuXG4gICAgICAgIC8vIFRoaXMgYXZvaWRzIGxvc2luZyBkYXlzIHdoZW4gc2Vjb25kcywgbWludXRlcyBhbmQgaG91cnMgYXJlIHplcm9lZFxuICAgICAgICAvLyB3aGF0IG5vcm1hbGl6ZSB3aWxsIGRvIHdoZW4gdGltZSBpcyBhIGRhdGUuXG4gICAgICAgIGlmIChhdHRyID09PSBcImlzRGF0ZVwiICYmIHZhbCAmJiAhdGhpcy5fdGltZS5pc0RhdGUpIHtcbiAgICAgICAgICB0aGlzLmFkanVzdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdGltZVthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgICBkZWZpbmVBdHRyKFwieWVhclwiKTtcbiAgICBkZWZpbmVBdHRyKFwibW9udGhcIik7XG4gICAgZGVmaW5lQXR0cihcImRheVwiKTtcbiAgICBkZWZpbmVBdHRyKFwiaG91clwiKTtcbiAgICBkZWZpbmVBdHRyKFwibWludXRlXCIpO1xuICAgIGRlZmluZUF0dHIoXCJzZWNvbmRcIik7XG4gICAgZGVmaW5lQXR0cihcImlzRGF0ZVwiKTtcbn0pKCk7XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKlxuICogQGlnbm9yZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikucGFyc2VyU3RhdGV9IHBhcnNlclN0YXRlXG4gKiBJbXBvcnRzIHRoZSAncGFyc2VyU3RhdGUnIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikuZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAqIEltcG9ydHMgdGhlICdkZXNpZ25TZXQnIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICovXG5cbmNvbnN0IENIQVIgPSAvW14gXFx0XS87XG5jb25zdCBWQUxVRV9ERUxJTUlURVIgPSAnOic7XG5jb25zdCBQQVJBTV9ERUxJTUlURVIgPSAnOyc7XG5jb25zdCBQQVJBTV9OQU1FX0RFTElNSVRFUiA9ICc9JztcbmNvbnN0IERFRkFVTFRfVkFMVUVfVFlQRSQxID0gJ3Vua25vd24nO1xuY29uc3QgREVGQVVMVF9QQVJBTV9UWVBFID0gJ3RleHQnO1xuY29uc3QgUkZDNjg2OF9SRVBMQUNFX01BUCQxID0geyBcIl4nXCI6ICdcIicsIFwiXm5cIjogXCJcXG5cIiwgXCJeXlwiOiBcIl5cIiB9O1xuXG4vKipcbiAqIFBhcnNlcyBpQ2FsZW5kYXIgb3IgdkNhcmQgZGF0YSBpbnRvIGEgcmF3IGpDYWwgb2JqZWN0LiBDb25zdWx0XG4gKiBkb2N1bWVudGF0aW9uIG9uIHRoZSB7QHR1dG9yaWFsIGxheWVyc3xsYXllcnMgb2YgcGFyc2luZ30gZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKlxuICogQGZ1bmN0aW9uIElDQUwucGFyc2VcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKiBAdmFyaWF0aW9uIGZ1bmN0aW9uXG4gKiBAdG9kbyBGaXggdGhlIEFQSSB0byBiZSBtb3JlIGNsZWFyIG9uIHRoZSByZXR1cm4gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0ICAgICAgVGhlIHN0cmluZyBkYXRhIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtPYmplY3R8T2JqZWN0W119ICBBIHNpbmdsZSBqQ2FsIG9iamVjdCwgb3IgYW4gYXJyYXkgdGhlcmVvZlxuICovXG5mdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICBsZXQgc3RhdGUgPSB7fTtcbiAgbGV0IHJvb3QgPSBzdGF0ZS5jb21wb25lbnQgPSBbXTtcblxuICBzdGF0ZS5zdGFjayA9IFtyb290XTtcblxuICBwYXJzZS5fZWFjaExpbmUoaW5wdXQsIGZ1bmN0aW9uKGVyciwgbGluZSkge1xuICAgIHBhcnNlLl9oYW5kbGVDb250ZW50TGluZShsaW5lLCBzdGF0ZSk7XG4gIH0pO1xuXG5cbiAgLy8gd2hlbiB0aGVyZSBhcmUgc3RpbGwgaXRlbXMgb24gdGhlIHN0YWNrXG4gIC8vIHRocm93IGEgZmF0YWwgZXJyb3IsIGEgY29tcG9uZW50IHdhcyBub3QgY2xvc2VkXG4gIC8vIGNvcnJlY3RseSBpbiB0aGF0IGNhc2UuXG4gIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgJ2ludmFsaWQgaWNhbCBib2R5LiBjb21wb25lbnQgYmVnYW4gYnV0IGRpZCBub3QgZW5kJ1xuICAgICk7XG4gIH1cblxuICBzdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIChyb290Lmxlbmd0aCA9PSAxID8gcm9vdFswXSA6IHJvb3QpO1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIGlDYWxlbmRhciBwcm9wZXJ0eSB2YWx1ZSBpbnRvIHRoZSBqQ2FsIGZvciBhIHNpbmdsZSBwcm9wZXJ0eVxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLnByb3BlcnR5XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiAgIFRoZSBpQ2FsZW5kYXIgcHJvcGVydHkgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0ge2Rlc2lnblNldD19IGRlc2lnblNldFxuICogICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgIFRoZSBqQ2FsIE9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0eVxuICovXG5wYXJzZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0ciwgZGVzaWduU2V0KSB7XG4gIGxldCBzdGF0ZSA9IHtcbiAgICBjb21wb25lbnQ6IFtbXSwgW11dLFxuICAgIGRlc2lnblNldDogZGVzaWduU2V0IHx8IGRlc2lnbiQxLmRlZmF1bHRTZXRcbiAgfTtcbiAgcGFyc2UuX2hhbmRsZUNvbnRlbnRMaW5lKHN0ciwgc3RhdGUpO1xuICByZXR1cm4gc3RhdGUuY29tcG9uZW50WzFdWzBdO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcGFyc2UgYSBjb21wb25lbnQuIFlvdSBjYW4gdXNlIElDQUwucGFyc2UoKSBkaXJlY3RseVxuICogaW5zdGVhZC5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5jb21wb25lbnRcbiAqIEBzZWUgSUNBTC5wYXJzZShmdW5jdGlvbilcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgVGhlIGlDYWxlbmRhciBjb21wb25lbnQgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFRoZSBqQ2FsIE9iamVjdCBjb250YWluaW5nIHRoZSBjb21wb25lbnRcbiAqL1xucGFyc2UuY29tcG9uZW50ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBwYXJzZShzdHIpO1xufTtcblxuXG4vKipcbiAqIEFuIGVycm9yIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHBhcnNpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgICAgICAgIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAbWVtYmVyb2YgSUNBTC5wYXJzZVxuICogQGV4dGVuZHMge0Vycm9yfVxuICovXG5jbGFzcyBQYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbn1cblxuLy8gY2xhc3NlcyAmIGNvbnN0YW50c1xucGFyc2UuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcblxuXG4vKipcbiAqIEhhbmRsZXMgYSBzaW5nbGUgbGluZSBvZiBpQ2FsZW5kYXIvdkNhcmQsIHVwZGF0aW5nIHRoZSBzdGF0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX2hhbmRsZUNvbnRlbnRMaW5lXG4gKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICBUaGUgY29udGVudCBsaW5lIHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7cGFyc2VyU3RhdGV9IHN0YXRlICAgIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBsaW5lIHBhcnNpbmdcbiAqL1xucGFyc2UuX2hhbmRsZUNvbnRlbnRMaW5lID0gZnVuY3Rpb24obGluZSwgc3RhdGUpIHtcbiAgLy8gYnJlYWsgdXAgdGhlIHBhcnRzIG9mIHRoZSBsaW5lXG4gIGxldCB2YWx1ZVBvcyA9IGxpbmUuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIpO1xuICBsZXQgcGFyYW1Qb3MgPSBsaW5lLmluZGV4T2YoUEFSQU1fREVMSU1JVEVSKTtcblxuICBsZXQgbGFzdFBhcmFtSW5kZXg7XG4gIGxldCBsYXN0VmFsdWVQb3M7XG5cbiAgLy8gbmFtZSBvZiBwcm9wZXJ0eSBvciBiZWdpbi9lbmRcbiAgbGV0IG5hbWU7XG4gIGxldCB2YWx1ZTtcbiAgLy8gcGFyYW1zIGlzIG9ubHkgb3ZlcnJpZGRlbiBpZiBwYXJhbVBvcyAhPT0gLTEuXG4gIC8vIHdlIGNhbid0IGRvIHBhcmFtcyA9IHBhcmFtcyB8fCB7fSBsYXRlciBvblxuICAvLyBiZWNhdXNlIGl0IHNhY3JpZmljZXMgb3BzLlxuICBsZXQgcGFyYW1zID0ge307XG5cbiAgLyoqXG4gICAqIERpZmZlcmVudCBwcm9wZXJ0eSBjYXNlc1xuICAgKlxuICAgKlxuICAgKiAxLiBSUlVMRTpGUkVRPWZvb1xuICAgKiAgICAvLyBGUkVRPSBpcyBub3QgYSBwYXJhbSBidXQgdGhlIHZhbHVlXG4gICAqXG4gICAqIDIuIEFUVEVOREVFO1JPTEU9UkVRLVBBUlRJQ0lQQU5UO1xuICAgKiAgICAvLyBST0xFPSBpcyBhIHBhcmFtIGJlY2F1c2UgOiBoYXMgbm90IGhhcHBlbmVkIHlldFxuICAgKi9cbiAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgIC8vIHZhbHVlIGRlbGltaXRlciB0aGVuIGl0IGlzIG5vdCBhIHBhcmFtZXRlci5cblxuICBpZiAoKHBhcmFtUG9zICE9PSAtMSAmJiB2YWx1ZVBvcyAhPT0gLTEpKSB7XG4gICAgLy8gd2hlbiB0aGUgcGFyYW1ldGVyIGRlbGltaXRlciBpcyBhZnRlciB0aGVcbiAgICAvLyB2YWx1ZSBkZWxpbWl0ZXIgdGhlbiBpdCBpcyBub3QgYSBwYXJhbWV0ZXIuXG4gICAgaWYgKHBhcmFtUG9zID4gdmFsdWVQb3MpIHtcbiAgICAgIHBhcmFtUG9zID0gLTE7XG4gICAgfVxuICB9XG5cbiAgbGV0IHBhcnNlZFBhcmFtcztcbiAgaWYgKHBhcmFtUG9zICE9PSAtMSkge1xuICAgIG5hbWUgPSBsaW5lLnNsaWNlKDAsIE1hdGgubWF4KDAsIHBhcmFtUG9zKSkudG9Mb3dlckNhc2UoKTtcbiAgICBwYXJzZWRQYXJhbXMgPSBwYXJzZS5fcGFyc2VQYXJhbWV0ZXJzKGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgcGFyYW1Qb3MpKSwgMCwgc3RhdGUuZGVzaWduU2V0KTtcbiAgICBpZiAocGFyc2VkUGFyYW1zWzJdID09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcnMgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcGFyYW1zID0gcGFyc2VkUGFyYW1zWzBdO1xuICAgIGxhc3RQYXJhbUluZGV4ID0gcGFyc2VkUGFyYW1zWzFdLmxlbmd0aCArIHBhcnNlZFBhcmFtc1syXSArIHBhcmFtUG9zO1xuICAgIGlmICgobGFzdFZhbHVlUG9zID1cbiAgICAgIGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdFBhcmFtSW5kZXgpKS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUikpICE9PSAtMSkge1xuICAgICAgdmFsdWUgPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIGxhc3RQYXJhbUluZGV4ICsgbGFzdFZhbHVlUG9zICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciB2YWx1ZSBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZVBvcyAhPT0gLTEpIHtcbiAgICAvLyB3aXRob3V0IHBhcm1ldGVycyAoQkVHSU46VkNBRU5EQVIsIENMQVNTOlBVQkxJQylcbiAgICBuYW1lID0gbGluZS5zbGljZSgwLCBNYXRoLm1heCgwLCB2YWx1ZVBvcykpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsdWUgPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIHZhbHVlUG9zICsgMSkpO1xuXG4gICAgaWYgKG5hbWUgPT09ICdiZWdpbicpIHtcbiAgICAgIGxldCBuZXdDb21wb25lbnQgPSBbdmFsdWUudG9Mb3dlckNhc2UoKSwgW10sIFtdXTtcbiAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50LnB1c2gobmV3Q29tcG9uZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmNvbXBvbmVudFsyXS5wdXNoKG5ld0NvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLmNvbXBvbmVudCk7XG4gICAgICBzdGF0ZS5jb21wb25lbnQgPSBuZXdDb21wb25lbnQ7XG4gICAgICBpZiAoIXN0YXRlLmRlc2lnblNldCkge1xuICAgICAgICBzdGF0ZS5kZXNpZ25TZXQgPSBkZXNpZ24kMS5nZXREZXNpZ25TZXQoc3RhdGUuY29tcG9uZW50WzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlbmQnKSB7XG4gICAgICBzdGF0ZS5jb21wb25lbnQgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgaXQgaXMgbm90IGJlZ2luL2VuZCwgdGhlbiB0aGlzIGlzIGEgcHJvcGVydHkgd2l0aCBhbiBlbXB0eSB2YWx1ZSxcbiAgICAvLyB3aGljaCBzaG91bGQgYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIGxpbmUuXG4gICAgICogVGhlIHJhdGlvbmFsIHRvIHRocm93IGFuIGVycm9yIGlzIHdlIHdpbGxcbiAgICAgKiBuZXZlciBiZSBjZXJ0YWluIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIGZpbGVcbiAgICAgKiBpcyBzYW5lIGFuZCBpdCBpcyB1bmxpa2VseSB0aGF0IHdlIGNhbiBzZXJpYWxpemVcbiAgICAgKiB0aGUgcmVzdWx0IGNvcnJlY3RseSBlaXRoZXIuXG4gICAgICovXG4gICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgJ2ludmFsaWQgbGluZSAobm8gdG9rZW4gXCI7XCIgb3IgXCI6XCIpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgKTtcbiAgfVxuXG4gIGxldCB2YWx1ZVR5cGU7XG4gIGxldCBtdWx0aVZhbHVlID0gZmFsc2U7XG4gIGxldCBzdHJ1Y3R1cmVkVmFsdWUgPSBmYWxzZTtcbiAgbGV0IHByb3BlcnR5RGV0YWlscztcbiAgbGV0IHNwbGl0TmFtZTtcbiAgbGV0IHVuZ3JvdXBlZE5hbWU7XG5cbiAgLy8gZmV0Y2ggdGhlIHVuZ3JvdXBlZCBwYXJ0IG9mIHRoZSBuYW1lXG4gIGlmIChzdGF0ZS5kZXNpZ25TZXQucHJvcGVydHlHcm91cHMgJiYgbmFtZS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgc3BsaXROYW1lID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHBhcmFtcy5ncm91cCA9IHNwbGl0TmFtZVswXTtcbiAgICB1bmdyb3VwZWROYW1lID0gc3BsaXROYW1lWzFdO1xuICB9IGVsc2Uge1xuICAgIHVuZ3JvdXBlZE5hbWUgPSBuYW1lO1xuICB9XG5cbiAgaWYgKHVuZ3JvdXBlZE5hbWUgaW4gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgcHJvcGVydHlEZXRhaWxzID0gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5W3VuZ3JvdXBlZE5hbWVdO1xuXG4gICAgaWYgKCdtdWx0aVZhbHVlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgIG11bHRpVmFsdWUgPSBwcm9wZXJ0eURldGFpbHMubXVsdGlWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gcHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICBzdHJ1Y3R1cmVkVmFsdWUgPSBwcm9wZXJ0eURldGFpbHMuc3RydWN0dXJlZFZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAmJiAnZGV0ZWN0VHlwZScgaW4gcHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICB2YWx1ZVR5cGUgPSBwcm9wZXJ0eURldGFpbHMuZGV0ZWN0VHlwZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXR0ZW1wdCB0byBkZXRlcm1pbmUgdmFsdWVcbiAgaWYgKCF2YWx1ZVR5cGUpIHtcbiAgICBpZiAoISgndmFsdWUnIGluIHBhcmFtcykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVUeXBlID0gREVGQVVMVF9WQUxVRV9UWVBFJDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBvc3NpYmxlIHRvIGF2b2lkIHRoaXM/XG4gICAgICB2YWx1ZVR5cGUgPSBwYXJhbXMudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGUgcGFyYW1zLnZhbHVlO1xuXG4gIC8qKlxuICAgKiBOb3RlIG9uIGB2YXIgcmVzdWx0YCBqdWdnbGluZzpcbiAgICpcbiAgICogSSBvYnNlcnZlZCB0aGF0IGJ1aWxkaW5nIHRoZSBhcnJheSBpbiBwaWVjZXMgaGFzIGFkdmVyc2VcbiAgICogZWZmZWN0cyBvbiBwZXJmb3JtYW5jZSwgc28gd2hlcmUgcG9zc2libGUgd2UgaW5saW5lIHRoZSBjcmVhdGlvbi5cbiAgICogSXQgaXMgYSBsaXR0bGUgdWdseSBidXQgcmVzdWx0ZWQgaW4gfjIwMDAgYWRkaXRpb25hbCBvcHMvc2VjLlxuICAgKi9cblxuICBsZXQgcmVzdWx0O1xuICBpZiAobXVsdGlWYWx1ZSAmJiBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHBhcnNlLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbXVsdGlWYWx1ZSwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIHJlc3VsdCA9IFt1bmdyb3VwZWROYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICB9IGVsc2UgaWYgKG11bHRpVmFsdWUpIHtcbiAgICByZXN1bHQgPSBbdW5ncm91cGVkTmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGVdO1xuICAgIHBhcnNlLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgcmVzdWx0LCBudWxsLCBzdGF0ZS5kZXNpZ25TZXQsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHBhcnNlLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIHJlc3VsdCA9IFt1bmdyb3VwZWROYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlVmFsdWUodmFsdWUsIHZhbHVlVHlwZSwgc3RhdGUuZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgcmVzdWx0ID0gW3VuZ3JvdXBlZE5hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gIH1cbiAgLy8gcmZjNjM1MCByZXF1aXJlcyB0aGF0IGluIHZDYXJkIDQuMCB0aGUgZmlyc3QgY29tcG9uZW50IGlzIHRoZSBWRVJTSU9OXG4gIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gIGlmIChzdGF0ZS5jb21wb25lbnRbMF0gPT09ICd2Y2FyZCcgJiYgc3RhdGUuY29tcG9uZW50WzFdLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICEobmFtZSA9PT0gJ3ZlcnNpb24nICYmIHZhbHVlID09PSAnNC4wJykpIHtcbiAgICBzdGF0ZS5kZXNpZ25TZXQgPSBkZXNpZ24kMS5nZXREZXNpZ25TZXQoXCJ2Y2FyZDNcIik7XG4gIH1cbiAgc3RhdGUuY29tcG9uZW50WzFdLnB1c2gocmVzdWx0KTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSB2YWx1ZSBmcm9tIHRoZSByYXcgdmFsdWUgaW50byB0aGUgakNhcmQvakNhbCB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlVmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgICAgICBPcmlnaW5hbCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgIFR5cGUgb2YgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNpZ25TZXQgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHZhbHVlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZhcmllcyBvbiB0eXBlXG4gKi9cbnBhcnNlLl9wYXJzZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gIGlmICh0eXBlIGluIGRlc2lnblNldC52YWx1ZSAmJiAnZnJvbUlDQUwnIGluIGRlc2lnblNldC52YWx1ZVt0eXBlXSkge1xuICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0uZnJvbUlDQUwodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBQYXJzZSBwYXJhbWV0ZXJzIGZyb20gYSBzdHJpbmcgdG8gb2JqZWN0LlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZVBhcmFtZXRlcnNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICAgQSBzaW5nbGUgdW5mb2xkZWQgbGluZVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0ICAgICAgICAgUG9zaXRpb24gdG8gc3RhcnQgbG9va2luZyBmb3IgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAqIEByZXR1cm4ge09iamVjdH0ga2V5L3ZhbHVlIHBhaXJzXG4gKi9cbnBhcnNlLl9wYXJzZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihsaW5lLCBzdGFydCwgZGVzaWduU2V0KSB7XG4gIGxldCBsYXN0UGFyYW0gPSBzdGFydDtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBkZWxpbSA9IFBBUkFNX05BTUVfREVMSU1JVEVSO1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGxldCBuYW1lLCBsY25hbWU7XG4gIGxldCB2YWx1ZSwgdmFsdWVQb3MgPSAtMTtcbiAgbGV0IHR5cGUsIG11bHRpVmFsdWUsIG12ZGVsaW07XG5cbiAgLy8gZmluZCB0aGUgbmV4dCAnPScgc2lnblxuICAvLyB1c2UgbGFzdFBhcmFtIGFuZCBwb3MgdG8gZmluZCBuYW1lXG4gIC8vIGNoZWNrIGlmIFwiIGlzIHVzZWQgaWYgc28gZ2V0IHZhbHVlIGZyb20gXCItPlwiXG4gIC8vIHRoZW4gaW5jcmVtZW50IHBvcyB0byBmaW5kIG5leHQgO1xuXG4gIHdoaWxlICgocG9zICE9PSBmYWxzZSkgJiZcbiAgICAgICAgIChwb3MgPSBsaW5lLmluZGV4T2YoZGVsaW0sIHBvcyArIDEpKSAhPT0gLTEpIHtcblxuICAgIG5hbWUgPSBsaW5lLnNsaWNlKGxhc3RQYXJhbSArIDEsIHBvcyk7XG4gICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIkVtcHR5IHBhcmFtZXRlciBuYW1lIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgfVxuICAgIGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBtdmRlbGltID0gZmFsc2U7XG4gICAgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGxjbmFtZSBpbiBkZXNpZ25TZXQucGFyYW0gJiYgZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0udmFsdWVUeXBlKSB7XG4gICAgICB0eXBlID0gZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0udmFsdWVUeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gREVGQVVMVF9QQVJBTV9UWVBFO1xuICAgIH1cblxuICAgIGlmIChsY25hbWUgaW4gZGVzaWduU2V0LnBhcmFtKSB7XG4gICAgICBtdWx0aVZhbHVlID0gZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgIGlmIChkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS5tdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGUpIHtcbiAgICAgICAgbXZkZWxpbSA9IHBhcnNlLl9yZmM2ODY4RXNjYXBlKCdcIicgKyBtdWx0aVZhbHVlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5leHRDaGFyID0gbGluZVtwb3MgKyAxXTtcbiAgICBpZiAobmV4dENoYXIgPT09ICdcIicpIHtcbiAgICAgIHZhbHVlUG9zID0gcG9zICsgMjtcbiAgICAgIHBvcyA9IGxpbmUuaW5kZXhPZignXCInLCB2YWx1ZVBvcyk7XG4gICAgICBpZiAobXVsdGlWYWx1ZSAmJiBwb3MgIT0gLTEpIHtcbiAgICAgICAgICBsZXQgZXh0ZW5kZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgd2hpbGUgKGV4dGVuZGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lW3BvcyArIDFdID09IG11bHRpVmFsdWUgJiYgbGluZVtwb3MgKyAyXSA9PSAnXCInKSB7XG4gICAgICAgICAgICAgIHBvcyA9IGxpbmUuaW5kZXhPZignXCInLCBwb3MgKyAzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuZGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcbiAgICAgICAgICAnaW52YWxpZCBsaW5lIChubyBtYXRjaGluZyBkb3VibGUgcXVvdGUpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGxpbmUuc2xpY2UodmFsdWVQb3MsIHBvcyk7XG4gICAgICBsYXN0UGFyYW0gPSBsaW5lLmluZGV4T2YoUEFSQU1fREVMSU1JVEVSLCBwb3MpO1xuICAgICAgbGV0IHByb3BWYWx1ZVBvcyA9IGxpbmUuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIsIHBvcyk7XG4gICAgICAvLyBpZiBlaXRoZXIgbm8gbmV4dCBwYXJhbWV0ZXIgb3IgZGVsaW1ldGVyIGluIHByb3BlcnR5IHZhbHVlLCBsZXQncyBzdG9wIGhlcmVcbiAgICAgIGlmIChsYXN0UGFyYW0gPT09IC0xIHx8IChwcm9wVmFsdWVQb3MgIT09IC0xICYmIGxhc3RQYXJhbSA+IHByb3BWYWx1ZVBvcykpIHtcbiAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlUG9zID0gcG9zICsgMTtcblxuICAgICAgLy8gbW92ZSB0byBuZXh0IFwiO1wiXG4gICAgICBsZXQgbmV4dFBvcyA9IGxpbmUuaW5kZXhPZihQQVJBTV9ERUxJTUlURVIsIHZhbHVlUG9zKTtcbiAgICAgIGxldCBwcm9wVmFsdWVQb3MgPSBsaW5lLmluZGV4T2YoVkFMVUVfREVMSU1JVEVSLCB2YWx1ZVBvcyk7XG4gICAgICBpZiAocHJvcFZhbHVlUG9zICE9PSAtMSAmJiBuZXh0UG9zID4gcHJvcFZhbHVlUG9zKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBkZWxpbWl0ZXIgaW4gdGhlIHByb3BlcnR5IHZhbHVlLCBsZXQncyBzdG9wIGhlcmVcbiAgICAgICAgbmV4dFBvcyA9IHByb3BWYWx1ZVBvcztcbiAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG5leHRQb3MgPT09IC0xKSB7XG4gICAgICAgIC8vIG5vIFwiO1wiXG4gICAgICAgIGlmIChwcm9wVmFsdWVQb3MgPT09IC0xKSB7XG4gICAgICAgICAgbmV4dFBvcyA9IGxpbmUubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UGFyYW0gPSBuZXh0UG9zO1xuICAgICAgICBwb3MgPSBuZXh0UG9zO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGxpbmUuc2xpY2UodmFsdWVQb3MsIG5leHRQb3MpO1xuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aF9iZWZvcmUgPSB2YWx1ZS5sZW5ndGg7XG4gICAgdmFsdWUgPSBwYXJzZS5fcmZjNjg2OEVzY2FwZSh2YWx1ZSk7XG4gICAgdmFsdWVQb3MgKz0gbGVuZ3RoX2JlZm9yZSAtIHZhbHVlLmxlbmd0aDtcbiAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgbGV0IGRlbGltaXRlciA9IG12ZGVsaW0gfHwgbXVsdGlWYWx1ZTtcbiAgICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgZGVsaW1pdGVyLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZS5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0KTtcbiAgICB9XG5cbiAgICBpZiAobXVsdGlWYWx1ZSAmJiAobGNuYW1lIGluIHJlc3VsdCkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtsY25hbWVdKSkge1xuICAgICAgICByZXN1bHRbbGNuYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsY25hbWVdID0gW1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtsY25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbcmVzdWx0LCB2YWx1ZSwgdmFsdWVQb3NdO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHJmYzY4NjguIEV4cG9zaW5nIHRoaXMgb24gSUNBTC5wYXJzZSBzbyB0aGF0XG4gKiBoYWNrZXJzIGNhbiBkaXNhYmxlIHRoZSByZmM2ODY4IHBhcnNpbmcgaWYgdGhlIHJlYWxseSBuZWVkIHRvLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9yZmM2ODY4RXNjYXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsICAgICAgICBUaGUgdmFsdWUgdG8gZXNjYXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICovXG5wYXJzZS5fcmZjNjg2OEVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsLnJlcGxhY2UoL1xcXlsnbl5dL2csIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gUkZDNjg2OF9SRVBMQUNFX01BUCQxW3hdO1xuICB9KTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBtdWx0aSB2YWx1ZSBzdHJpbmcuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBlaXRoZXIgZm9yIHBhcnNpbmdcbiAqIGFjdHVhbCBtdWx0aS12YWx1ZSBwcm9wZXJ0eSdzIHZhbHVlcywgb3IgZm9yIGhhbmRsaW5nIHBhcmFtZXRlciB2YWx1ZXMuIEl0XG4gKiBjYW4gYmUgdXNlZCBmb3IgYm90aCBtdWx0aS12YWx1ZSBwcm9wZXJ0aWVzIGFuZCBzdHJ1Y3R1cmVkIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZU11bHRpVmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXIgICAgICAgICAgIFRoZSBidWZmZXIgY29udGFpbmluZyB0aGUgZnVsbCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRlbGltICAgICAgICAgICAgVGhlIG11bHRpLXZhbHVlIGRlbGltaXRlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgICAgVGhlIHZhbHVlIHR5cGUgdG8gYmUgcGFyc2VkXG4gKiBAcGFyYW0ge0FycmF5Ljw/Pn0gcmVzdWx0ICAgICAgICBUaGUgYXJyYXkgdG8gYXBwZW5kIHJlc3VsdHMgdG8sIHZhcmllcyBvbiB2YWx1ZSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5uZXJNdWx0aSAgICAgICBUaGUgaW5uZXIgZGVsaW1pdGVyIHRvIHNwbGl0IGVhY2ggdmFsdWUgd2l0aFxuICogQHBhcmFtIHtkZXNpZ25TZXR9IGRlc2lnblNldCAgICAgVGhlIGRlc2lnbiBkYXRhIGZvciB0aGlzIHZhbHVlXG4gKiBAcmV0dXJuIHs/fEFycmF5Ljw/Pn0gICAgICAgICAgICBFaXRoZXIgYW4gYXJyYXkgb2YgcmVzdWx0cywgb3IgdGhlIGZpcnN0IHJlc3VsdFxuICovXG5wYXJzZS5fcGFyc2VNdWx0aVZhbHVlID0gZnVuY3Rpb24oYnVmZmVyLCBkZWxpbSwgdHlwZSwgcmVzdWx0LCBpbm5lck11bHRpLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IGxhc3RQb3MgPSAwO1xuICBsZXQgdmFsdWU7XG4gIGlmIChkZWxpbS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgLy8gc3BsaXQgZWFjaCBwaWVjZVxuICB3aGlsZSAoKHBvcyA9IHVuZXNjYXBlZEluZGV4T2YoYnVmZmVyLCBkZWxpbSwgbGFzdFBvcykpICE9PSAtMSkge1xuICAgIHZhbHVlID0gYnVmZmVyLnNsaWNlKGxhc3RQb3MsIHBvcyk7XG4gICAgaWYgKGlubmVyTXVsdGkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgaW5uZXJNdWx0aSwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZS5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgbGFzdFBvcyA9IHBvcyArIGRlbGltLmxlbmd0aDtcbiAgfVxuXG4gIC8vIG9uIHRoZSBsYXN0IHBpZWNlIHRha2UgdGhlIHJlc3Qgb2Ygc3RyaW5nXG4gIHZhbHVlID0gYnVmZmVyLnNsaWNlKGxhc3RQb3MpO1xuICBpZiAoaW5uZXJNdWx0aSkge1xuICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgaW5uZXJNdWx0aSwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHBhcnNlLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gIH1cbiAgcmVzdWx0LnB1c2godmFsdWUpO1xuXG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYSBjb21wbGV0ZSBidWZmZXIgb2YgaUNhbGVuZGFyL3ZDYXJkIGRhdGEgbGluZSBieSBsaW5lLCBjb3JyZWN0bHlcbiAqIHVuZm9sZGluZyBjb250ZW50LiBFYWNoIGxpbmUgd2lsbCBiZSBwcm9jZXNzZWQgd2l0aCB0aGUgZ2l2ZW4gY2FsbGJhY2tcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX2VhY2hMaW5lXG4gKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBidWZmZXIgdG8gcHJvY2Vzc1xuICogQHBhcmFtIHtmdW5jdGlvbig/U3RyaW5nLCBTdHJpbmcpfSBjYWxsYmFjayAgICBUaGUgY2FsbGJhY2sgZm9yIGVhY2ggbGluZVxuICovXG5wYXJzZS5fZWFjaExpbmUgPSBmdW5jdGlvbihidWZmZXIsIGNhbGxiYWNrKSB7XG4gIGxldCBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICBsZXQgbGFzdFBvcyA9IGJ1ZmZlci5zZWFyY2goQ0hBUik7XG4gIGxldCBwb3MgPSBsYXN0UG9zO1xuICBsZXQgbGluZTtcbiAgbGV0IGZpcnN0Q2hhcjtcblxuICBsZXQgbmV3bGluZU9mZnNldDtcblxuICBkbyB7XG4gICAgcG9zID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIGxhc3RQb3MpICsgMTtcblxuICAgIGlmIChwb3MgPiAxICYmIGJ1ZmZlcltwb3MgLSAyXSA9PT0gJ1xccicpIHtcbiAgICAgIG5ld2xpbmVPZmZzZXQgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdsaW5lT2Zmc2V0ID0gMTtcbiAgICB9XG5cbiAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICBwb3MgPSBsZW47XG4gICAgICBuZXdsaW5lT2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBmaXJzdENoYXIgPSBidWZmZXJbbGFzdFBvc107XG5cbiAgICBpZiAoZmlyc3RDaGFyID09PSAnICcgfHwgZmlyc3RDaGFyID09PSAnXFx0Jykge1xuICAgICAgLy8gYWRkIHRvIGxpbmVcbiAgICAgIGxpbmUgKz0gYnVmZmVyLnNsaWNlKGxhc3RQb3MgKyAxLCBwb3MgLSBuZXdsaW5lT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxpbmUpXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xuICAgICAgLy8gcHVzaCBsaW5lXG4gICAgICBsaW5lID0gYnVmZmVyLnNsaWNlKGxhc3RQb3MsIHBvcyAtIG5ld2xpbmVPZmZzZXQpO1xuICAgIH1cblxuICAgIGxhc3RQb3MgPSBwb3M7XG4gIH0gd2hpbGUgKHBvcyAhPT0gbGVuKTtcblxuICAvLyBleHRyYSBlbmRpbmcgbGluZVxuICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgaWYgKGxpbmUubGVuZ3RoKVxuICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xufTtcblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbmNvbnN0IE9QVElPTlMgPSBbXCJ0emlkXCIsIFwibG9jYXRpb25cIiwgXCJ0em5hbWVzXCIsIFwibGF0aXR1ZGVcIiwgXCJsb25naXR1ZGVcIl07XG5cbi8qKlxuICogVGltZXpvbmUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB2Y2FsZW5kYXI7XG4gKiB2YXIgdGltZXpvbmVDb21wID0gdmNhbGVuZGFyLmdldEZpcnN0U3ViY29tcG9uZW50KCd2dGltZXpvbmUnKTtcbiAqIHZhciB0emlkID0gdGltZXpvbmVDb21wLmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICpcbiAqIHZhciB0aW1lem9uZSA9IG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAqICAgY29tcG9uZW50OiB0aW1lem9uZUNvbXAsXG4gKiAgIHR6aWRcbiAqIH0pO1xuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIFRpbWV6b25lIHtcbiAgc3RhdGljIF9jb21wYXJlX2NoYW5nZV9mbihhLCBiKSB7XG4gICAgaWYgKGEueWVhciA8IGIueWVhcikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEueWVhciA+IGIueWVhcikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5tb250aCA8IGIubW9udGgpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1vbnRoID4gYi5tb250aCkgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5kYXkgPCBiLmRheSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuZGF5ID4gYi5kYXkpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuaG91ciA8IGIuaG91cikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuaG91ciA+IGIuaG91cikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5taW51dGUgPCBiLm1pbnV0ZSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEubWludXRlID4gYi5taW51dGUpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuc2Vjb25kIDwgYi5zZWNvbmQpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnNlY29uZCA+IGIuc2Vjb25kKSByZXR1cm4gMTtcblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGRhdGUvdGltZSBmcm9tIG9uZSB6b25lIHRvIHRoZSBuZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWV9IHR0ICAgICAgICAgICAgICAgICAgVGhlIHRpbWUgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge1RpbWV6b25lfSBmcm9tX3pvbmUgICAgICAgVGhlIHNvdXJjZSB6b25lIHRvIGNvbnZlcnQgZnJvbVxuICAgKiBAcGFyYW0ge1RpbWV6b25lfSB0b196b25lICAgICAgICAgVGhlIHRhcmdldCB6b25lIHRvIGNvbnZlcnQgdG9cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBjb252ZXJ0ZWQgZGF0ZS90aW1lIG9iamVjdFxuICAgKi9cbiAgc3RhdGljIGNvbnZlcnRfdGltZSh0dCwgZnJvbV96b25lLCB0b196b25lKSB7XG4gICAgaWYgKHR0LmlzRGF0ZSB8fFxuICAgICAgICBmcm9tX3pvbmUudHppZCA9PSB0b196b25lLnR6aWQgfHxcbiAgICAgICAgZnJvbV96b25lID09IFRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgdG9fem9uZSA9PSBUaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICB0dC56b25lID0gdG9fem9uZTtcbiAgICAgIHJldHVybiB0dDtcbiAgICB9XG5cbiAgICBsZXQgdXRjT2Zmc2V0ID0gZnJvbV96b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIC0gdXRjT2Zmc2V0KTtcblxuICAgIHV0Y09mZnNldCA9IHRvX3pvbmUudXRjT2Zmc2V0KHR0KTtcbiAgICB0dC5hZGp1c3QoMCwgMCwgMCwgdXRjT2Zmc2V0KTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lem9uZSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fE9iamVjdH0gYURhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8Q29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGFEYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHppZCAgICAgIFRoZSB0aW1lem9uZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0YShhRGF0YSkge1xuICAgIGxldCB0dCA9IG5ldyBUaW1lem9uZSgpO1xuICAgIHJldHVybiB0dC5mcm9tRGF0YShhRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIFVUQyB0aW1lem9uZVxuICAgKiBAdHlwZSB7VGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyAjdXRjVGltZXpvbmUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IHV0Y1RpbWV6b25lKCkge1xuICAgIGlmICghdGhpcy4jdXRjVGltZXpvbmUpIHtcbiAgICAgIHRoaXMuI3V0Y1RpbWV6b25lID0gVGltZXpvbmUuZnJvbURhdGEoe1xuICAgICAgICB0emlkOiBcIlVUQ1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI3V0Y1RpbWV6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBsb2NhbCB0aW1lem9uZVxuICAgKiBAdHlwZSB7VGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyAjbG9jYWxUaW1lem9uZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgbG9jYWxUaW1lem9uZSgpIHtcbiAgICBpZiAoIXRoaXMuI2xvY2FsVGltZXpvbmUpIHtcbiAgICAgIHRoaXMuI2xvY2FsVGltZXpvbmUgPSBUaW1lem9uZS5mcm9tRGF0YSh7XG4gICAgICAgIHR6aWQ6IFwiZmxvYXRpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNsb2NhbFRpbWV6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCBhIHRpbWV6b25lIGNoYW5nZSBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2UgICAgIFRoZSB0aW1lem9uZSBjaGFuZ2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXlzICAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcn0gaG91cnMgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGhvdXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtaW51dGVzICAgIFRoZSBleHRyYSBhbW91bnQgb2YgbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyAgICBUaGUgZXh0cmEgYW1vdW50IG9mIHNlY29uZHNcbiAgICovXG4gIHN0YXRpYyBhZGp1c3RfY2hhbmdlKGNoYW5nZSwgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICByZXR1cm4gVGltZS5wcm90b3R5cGUuYWRqdXN0LmNhbGwoXG4gICAgICBjaGFuZ2UsXG4gICAgICBkYXlzLFxuICAgICAgaG91cnMsXG4gICAgICBtaW51dGVzLFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGNoYW5nZVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgX21pbmltdW1FeHBhbnNpb25ZZWFyID0gLTE7XG4gIHN0YXRpYyBFWFRSQV9DT1ZFUkFHRSA9IDU7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lem9uZSBpbnN0YW5jZSwgYnkgcGFzc2luZyBpbiBhIHR6aWQgYW5kIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR8T2JqZWN0fSBkYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfENvbXBvbmVudH0gZGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGRhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHR6aWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBUaW1lem9uZSBsb2NhdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgbG9jYXRpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZSB0aW1lem9uZSBuYW1lLCBmb3IgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdHpuYW1lcyA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFRoZSBwcmltYXJ5IGxhdGl0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBsYXRpdHVkZSA9IDAuMDtcblxuICAvKipcbiAgICogVGhlIHByaW1hcnkgbG9uZ2l0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBsb25naXR1ZGUgPSAwLjA7XG5cbiAgLyoqXG4gICAqIFRoZSB2dGltZXpvbmUgY29tcG9uZW50IGZvciB0aGlzIHRpbWV6b25lLlxuICAgKiBAdHlwZSB7Q29tcG9uZW50fVxuICAgKi9cbiAgY29tcG9uZW50ID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIHllYXIgdGhpcyB0aW1lem9uZSBoYXMgYmVlbiBleHBhbmRlZCB0by4gQWxsIHRpbWV6b25lIHRyYW5zaXRpb25cbiAgICogZGF0ZXMgdW50aWwgdGhpcyB5ZWFyIGFyZSBrbm93biBhbmQgY2FuIGJlIHVzZWQgZm9yIGNhbGN1bGF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBleHBhbmRlZFVudGlsWWVhciA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJpY2FsdGltZXpvbmVcIlxuICAgKi9cbiAgaWNhbGNsYXNzID0gXCJpY2FsdGltZXpvbmVcIjtcblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR8T2JqZWN0fSBhRGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xDb21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLmxvY2F0aW9uICBUaGUgdGltZXpvbmUgbG9jYXRpb253XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKi9cbiAgZnJvbURhdGEoYURhdGEpIHtcbiAgICB0aGlzLmV4cGFuZGVkVW50aWxZZWFyID0gMDtcbiAgICB0aGlzLmNoYW5nZXMgPSBbXTtcblxuICAgIGlmIChhRGF0YSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgLy8gRWl0aGVyIGEgY29tcG9uZW50IGlzIHBhc3NlZCBkaXJlY3RseVxuICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIGluIHRoZSBkYXRhIG9iamVjdFxuICAgICAgaWYgKGFEYXRhICYmIFwiY29tcG9uZW50XCIgaW4gYURhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhRGF0YS5jb21wb25lbnQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIElmIGEgc3RyaW5nIHdhcyBwYXNzZWQsIHBhcnNlIGl0IGFzIGEgY29tcG9uZW50XG4gICAgICAgICAgbGV0IGpDYWwgPSBwYXJzZShhRGF0YS5jb21wb25lbnQpO1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChqQ2FsKTtcbiAgICAgICAgfSBlbHNlIGlmIChhRGF0YS5jb21wb25lbnQgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcbiAgICAgICAgICAvLyBJZiBpdCB3YXMgYSBjb21wb25lbnQgYWxyZWFkeSwgdGhlbiBqdXN0IHNldCBpdFxuICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gYURhdGEuY29tcG9uZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG51bGwgb3V0IHRoZSBjb21wb25lbnRcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29weSByZW1haW5pbmcgcGFzc2VkIHByb3BlcnRpZXNcbiAgICAgIGZvciAobGV0IHByb3Agb2YgT1BUSU9OUykge1xuICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb25lbnQgYnV0IG5vIFRaSUQsIGF0dGVtcHQgdG8gZ2V0IGl0IGZyb20gdGhlXG4gICAgLy8gY29tcG9uZW50J3MgcHJvcGVydGllcy5cbiAgICBpZiAodGhpcy5jb21wb25lbnQgaW5zdGFuY2VvZiBDb21wb25lbnQgJiYgIXRoaXMudHppZCkge1xuICAgICAgdGhpcy50emlkID0gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIHV0Y09mZnNldCB0aGUgZ2l2ZW4gdGltZSB3b3VsZCBvY2N1ciBpbiB0aGlzIHRpbWV6b25lLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWV9IHR0ICAgICAgICAgVGhlIHRpbWUgdG8gY2hlY2sgZm9yXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICB1dGMgb2Zmc2V0IGluIHNlY29uZHNcbiAgICovXG4gIHV0Y09mZnNldCh0dCkge1xuICAgIGlmICh0aGlzID09IFRpbWV6b25lLnV0Y1RpbWV6b25lIHx8IHRoaXMgPT0gVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdGhpcy5fZW5zdXJlQ292ZXJhZ2UodHQueWVhcik7XG5cbiAgICBpZiAoIXRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxldCB0dF9jaGFuZ2UgPSB7XG4gICAgICB5ZWFyOiB0dC55ZWFyLFxuICAgICAgbW9udGg6IHR0Lm1vbnRoLFxuICAgICAgZGF5OiB0dC5kYXksXG4gICAgICBob3VyOiB0dC5ob3VyLFxuICAgICAgbWludXRlOiB0dC5taW51dGUsXG4gICAgICBzZWNvbmQ6IHR0LnNlY29uZFxuICAgIH07XG5cbiAgICBsZXQgY2hhbmdlX251bSA9IHRoaXMuX2ZpbmROZWFyYnlDaGFuZ2UodHRfY2hhbmdlKTtcbiAgICBsZXQgY2hhbmdlX251bV90b191c2UgPSAtMTtcbiAgICBsZXQgc3RlcCA9IDE7XG5cbiAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmluIHNlYXJjaD9cbiAgICBmb3IgKDs7KSB7XG4gICAgICBsZXQgY2hhbmdlID0gY2xvbmUodGhpcy5jaGFuZ2VzW2NoYW5nZV9udW1dLCB0cnVlKTtcbiAgICAgIGlmIChjaGFuZ2UudXRjT2Zmc2V0IDwgY2hhbmdlLnByZXZVdGNPZmZzZXQpIHtcbiAgICAgICAgVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsIGNoYW5nZS51dGNPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY21wID0gVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgY2hhbmdlKTtcblxuICAgICAgaWYgKGNtcCA+PSAwKSB7XG4gICAgICAgIGNoYW5nZV9udW1fdG9fdXNlID0gY2hhbmdlX251bTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgPT0gLTEgJiYgY2hhbmdlX251bV90b191c2UgIT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZV9udW0gKz0gc3RlcDtcblxuICAgICAgaWYgKGNoYW5nZV9udW0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlX251bSA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB6b25lX2NoYW5nZSA9IHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtX3RvX3VzZV07XG4gICAgbGV0IHV0Y09mZnNldF9jaGFuZ2UgPSB6b25lX2NoYW5nZS51dGNPZmZzZXQgLSB6b25lX2NoYW5nZS5wcmV2VXRjT2Zmc2V0O1xuXG4gICAgaWYgKHV0Y09mZnNldF9jaGFuZ2UgPCAwICYmIGNoYW5nZV9udW1fdG9fdXNlID4gMCkge1xuICAgICAgbGV0IHRtcF9jaGFuZ2UgPSBjbG9uZSh6b25lX2NoYW5nZSwgdHJ1ZSk7XG4gICAgICBUaW1lem9uZS5hZGp1c3RfY2hhbmdlKHRtcF9jaGFuZ2UsIDAsIDAsIDAsIHRtcF9jaGFuZ2UucHJldlV0Y09mZnNldCk7XG5cbiAgICAgIGlmIChUaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4odHRfY2hhbmdlLCB0bXBfY2hhbmdlKSA8IDApIHtcbiAgICAgICAgbGV0IHByZXZfem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2UgLSAxXTtcblxuICAgICAgICBsZXQgd2FudF9kYXlsaWdodCA9IGZhbHNlOyAvLyBUT0RPXG5cbiAgICAgICAgaWYgKHpvbmVfY2hhbmdlLmlzX2RheWxpZ2h0ICE9IHdhbnRfZGF5bGlnaHQgJiZcbiAgICAgICAgICAgIHByZXZfem9uZV9jaGFuZ2UuaXNfZGF5bGlnaHQgPT0gd2FudF9kYXlsaWdodCkge1xuICAgICAgICAgIHpvbmVfY2hhbmdlID0gcHJldl96b25lX2NoYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gcmV0dXJuIGlzX2RheWxpZ2h0P1xuICAgIHJldHVybiB6b25lX2NoYW5nZS51dGNPZmZzZXQ7XG4gIH1cblxuICBfZmluZE5lYXJieUNoYW5nZShjaGFuZ2UpIHtcbiAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IG1hdGNoXG4gICAgbGV0IGlkeCA9IGJpbnNlYXJjaEluc2VydChcbiAgICAgIHRoaXMuY2hhbmdlcyxcbiAgICAgIGNoYW5nZSxcbiAgICAgIFRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mblxuICAgICk7XG5cbiAgICBpZiAoaWR4ID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgX2Vuc3VyZUNvdmVyYWdlKGFZZWFyKSB7XG4gICAgaWYgKFRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhciA9PSAtMSkge1xuICAgICAgbGV0IHRvZGF5ID0gVGltZS5ub3coKTtcbiAgICAgIFRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhciA9IHRvZGF5LnllYXI7XG4gICAgfVxuXG4gICAgbGV0IGNoYW5nZXNFbmRZZWFyID0gYVllYXI7XG4gICAgaWYgKGNoYW5nZXNFbmRZZWFyIDwgVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyKSB7XG4gICAgICBjaGFuZ2VzRW5kWWVhciA9IFRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhcjtcbiAgICB9XG5cbiAgICBjaGFuZ2VzRW5kWWVhciArPSBUaW1lem9uZS5FWFRSQV9DT1ZFUkFHRTtcblxuICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCB8fCB0aGlzLmV4cGFuZGVkVW50aWxZZWFyIDwgYVllYXIpIHtcbiAgICAgIGxldCBzdWJjb21wcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgIGxldCBjb21wTGVuID0gc3ViY29tcHMubGVuZ3RoO1xuICAgICAgbGV0IGNvbXBJZHggPSAwO1xuXG4gICAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgICB0aGlzLl9leHBhbmRDb21wb25lbnQoXG4gICAgICAgICAgc3ViY29tcHNbY29tcElkeF0sIGNoYW5nZXNFbmRZZWFyLCB0aGlzLmNoYW5nZXNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGFuZ2VzLnNvcnQoVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKTtcbiAgICAgIHRoaXMuZXhwYW5kZWRVbnRpbFllYXIgPSBjaGFuZ2VzRW5kWWVhcjtcbiAgICB9XG4gIH1cblxuICBfZXhwYW5kQ29tcG9uZW50KGFDb21wb25lbnQsIGFZZWFyLCBjaGFuZ2VzKSB7XG4gICAgaWYgKCFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwiZHRzdGFydFwiKSB8fFxuICAgICAgICAhYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInR6b2Zmc2V0dG9cIikgfHxcbiAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBkdHN0YXJ0ID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwiZHRzdGFydFwiKS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgbGV0IGNoYW5nZTtcblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRfdHpvZmZzZXQob2Zmc2V0KSB7XG4gICAgICByZXR1cm4gb2Zmc2V0LmZhY3RvciAqIChvZmZzZXQuaG91cnMgKiAzNjAwICsgb2Zmc2V0Lm1pbnV0ZXMgKiA2MCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdF9jaGFuZ2VzKCkge1xuICAgICAgbGV0IGNoYW5nZWJhc2UgPSB7fTtcbiAgICAgIGNoYW5nZWJhc2UuaXNfZGF5bGlnaHQgPSAoYUNvbXBvbmVudC5uYW1lID09IFwiZGF5bGlnaHRcIik7XG4gICAgICBjaGFuZ2ViYXNlLnV0Y09mZnNldCA9IGNvbnZlcnRfdHpvZmZzZXQoXG4gICAgICAgIGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInR6b2Zmc2V0dG9cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICApO1xuXG4gICAgICBjaGFuZ2ViYXNlLnByZXZVdGNPZmZzZXQgPSBjb252ZXJ0X3R6b2Zmc2V0KFxuICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY2hhbmdlYmFzZTtcbiAgICB9XG5cbiAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJycnVsZVwiKSAmJiAhYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJkYXRlXCIpKSB7XG4gICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcbiAgICAgIGNoYW5nZS55ZWFyID0gZHRzdGFydC55ZWFyO1xuICAgICAgY2hhbmdlLm1vbnRoID0gZHRzdGFydC5tb250aDtcbiAgICAgIGNoYW5nZS5kYXkgPSBkdHN0YXJ0LmRheTtcbiAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgY2hhbmdlLnNlY29uZCA9IGR0c3RhcnQuc2Vjb25kO1xuXG4gICAgICBUaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgLWNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcHJvcHMgPSBhQ29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoXCJyZGF0ZVwiKTtcbiAgICAgIGZvciAobGV0IHJkYXRlIG9mIHByb3BzKSB7XG4gICAgICAgIGxldCB0aW1lID0gcmRhdGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcblxuICAgICAgICBjaGFuZ2UueWVhciA9IHRpbWUueWVhcjtcbiAgICAgICAgY2hhbmdlLm1vbnRoID0gdGltZS5tb250aDtcbiAgICAgICAgY2hhbmdlLmRheSA9IHRpbWUuZGF5O1xuXG4gICAgICAgIGlmICh0aW1lLmlzRGF0ZSkge1xuICAgICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICAgIGNoYW5nZS5taW51dGUgPSBkdHN0YXJ0Lm1pbnV0ZTtcbiAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgICBpZiAoZHRzdGFydC56b25lICE9IFRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICBUaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgLWNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlLmhvdXIgPSB0aW1lLmhvdXI7XG4gICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IHRpbWUubWludXRlO1xuICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSB0aW1lLnNlY29uZDtcblxuICAgICAgICAgIGlmICh0aW1lLnpvbmUgIT0gVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgIFRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLCAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcnJ1bGUgPSBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJycnVsZVwiKTtcblxuICAgICAgaWYgKHJydWxlKSB7XG4gICAgICAgIHJydWxlID0gcnJ1bGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcblxuICAgICAgICBpZiAocnJ1bGUudW50aWwgJiYgcnJ1bGUudW50aWwuem9uZSA9PSBUaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgIHJydWxlLnVudGlsLmFkanVzdCgwLCAwLCAwLCBjaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgcnJ1bGUudW50aWwuem9uZSA9IFRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlcmF0b3IgPSBycnVsZS5pdGVyYXRvcihkdHN0YXJ0KTtcblxuICAgICAgICBsZXQgb2NjO1xuICAgICAgICB3aGlsZSAoKG9jYyA9IGl0ZXJhdG9yLm5leHQoKSkpIHtcbiAgICAgICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcbiAgICAgICAgICBpZiAob2NjLnllYXIgPiBhWWVhciB8fCAhb2NjKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2UueWVhciA9IG9jYy55ZWFyO1xuICAgICAgICAgIGNoYW5nZS5tb250aCA9IG9jYy5tb250aDtcbiAgICAgICAgICBjaGFuZ2UuZGF5ID0gb2NjLmRheTtcbiAgICAgICAgICBjaGFuZ2UuaG91ciA9IG9jYy5ob3VyO1xuICAgICAgICAgIGNoYW5nZS5taW51dGUgPSBvY2MubWludXRlO1xuICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSBvY2Muc2Vjb25kO1xuICAgICAgICAgIGNoYW5nZS5pc0RhdGUgPSBvY2MuaXNEYXRlO1xuXG4gICAgICAgICAgVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGltZXpvbmUuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAodGhpcy50em5hbWVzID8gdGhpcy50em5hbWVzIDogdGhpcy50emlkKTtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxubGV0IHpvbmVzID0gbnVsbDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTaW5nbGV0b24gY2xhc3MgdG8gY29udGFpbiB0aW1lem9uZXMuICBSaWdodCBub3cgaXQgaXMgYWxsIG1hbnVhbCByZWdpc3RyeSBpblxuICogdGhlIGZ1dHVyZSB3ZSBtYXkgdXNlIHRoaXMgY2xhc3MgdG8gZG93bmxvYWQgdGltZXpvbmUgaW5mb3JtYXRpb24gb3IgaGFuZGxlXG4gKiBsb2FkaW5nIHByZS1leHBhbmRlZCB0aW1lem9uZXMuXG4gKlxuICogQGV4cG9ydHMgbW9kdWxlOklDQUwuVGltZXpvbmVTZXJ2aWNlXG4gKiBAbWVtYmVyb2YgSUNBTFxuICovXG5jb25zdCBUaW1lem9uZVNlcnZpY2UgPSB7XG4gIGdldCBjb3VudCgpIHtcbiAgICBpZiAoem9uZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh6b25lcykubGVuZ3RoO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB6b25lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IHV0YyA9IFRpbWV6b25lLnV0Y1RpbWV6b25lO1xuXG4gICAgem9uZXMuWiA9IHV0YztcbiAgICB6b25lcy5VVEMgPSB1dGM7XG4gICAgem9uZXMuR01UID0gdXRjO1xuICB9LFxuICBfaGFyZF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgem9uZXMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGltZXpvbmUgaWQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIEZhbHNlLCB3aGVuIG5vdCBwcmVzZW50XG4gICAqL1xuICBoYXM6IGZ1bmN0aW9uKHR6aWQpIHtcbiAgICBpZiAoem9uZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISF6b25lc1t0emlkXTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGlmIHByZXNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0emlkICAgICAgICAgICAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgKiBAcmV0dXJuIHtUaW1lem9uZSB8IHVuZGVmaW5lZH0gICAgIFRoZSB0aW1lem9uZSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbih0emlkKSB7XG4gICAgaWYgKHpvbmVzID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHpvbmVzW3R6aWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSB0aW1lem9uZSBvYmplY3Qgb3IgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudHxUaW1lem9uZX0gdGltZXpvbmVcbiAgICogICAgICAgIFRoZSBpbml0aWFsaXplZCB6b25lIG9yIHZ0aW1lem9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgdGltZXpvbmUuIERlZmF1bHRzIHRvIHRoZSBjb21wb25lbnQncyBUWklEIGlmIG5vdFxuICAgKiAgICAgICAgcGFzc2VkLlxuICAgKi9cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRpbWV6b25lLCBuYW1lKSB7XG4gICAgaWYgKHpvbmVzID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBhdm9pZHMgYSBicmVha2luZyBjaGFuZ2UgYnkgdGhlIGNoYW5nZSBvZiBhcmd1bWVudCBvcmRlclxuICAgIC8vIFRPRE8gcmVtb3ZlIGluIHYzXG4gICAgaWYgKHR5cGVvZiB0aW1lem9uZSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lIGluc3RhbmNlb2YgVGltZXpvbmUpIHtcbiAgICAgIFt0aW1lem9uZSwgbmFtZV0gPSBbbmFtZSwgdGltZXpvbmVdO1xuICAgIH1cblxuICAgIGlmICghbmFtZSkge1xuICAgICAgaWYgKHRpbWV6b25lIGluc3RhbmNlb2YgVGltZXpvbmUpIHtcbiAgICAgICAgbmFtZSA9IHRpbWV6b25lLnR6aWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGltZXpvbmUubmFtZSA9PT0gJ3Z0aW1lem9uZScpIHtcbiAgICAgICAgICB0aW1lem9uZSA9IG5ldyBUaW1lem9uZSh0aW1lem9uZSk7XG4gICAgICAgICAgbmFtZSA9IHRpbWV6b25lLnR6aWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOZWl0aGVyIGEgdGltZXpvbmUgbm9yIGEgbmFtZSB3YXMgcGFzc2VkXCIpO1xuICAgIH1cblxuICAgIGlmICh0aW1lem9uZSBpbnN0YW5jZW9mIFRpbWV6b25lKSB7XG4gICAgICB6b25lc1tuYW1lXSA9IHRpbWV6b25lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aW1lem9uZSBtdXN0IGJlIElDQUwuVGltZXpvbmUgb3IgSUNBTC5Db21wb25lbnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBmcm9tIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgKiBAcmV0dXJuIHs/VGltZXpvbmV9ICAgICAgVGhlIHJlbW92ZWQgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IHJlZ2lzdGVyZWRcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24odHppZCkge1xuICAgIGlmICh6b25lcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIChkZWxldGUgem9uZXNbdHppZF0pO1xuICB9XG59O1xuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMgd2l0aGluIGljYWwuanNcbiAqIEBtb2R1bGUgSUNBTC5oZWxwZXJzXG4gKi9cblxuLyoqXG4gKiBDb21waWxlcyBhIGxpc3Qgb2YgYWxsIHJlZmVyZW5jZWQgVFpJRHMgaW4gYWxsIHN1YmNvbXBvbmVudHMgYW5kXG4gKiByZW1vdmVzIGFueSBleHRyYSBWVElNRVpPTkUgc3ViY29tcG9uZW50cy4gSW4gYWRkaXRpb24sIGlmIGFueSBUWklEc1xuICogYXJlIHJlZmVyZW5jZWQgYnkgYSBjb21wb25lbnQsIGJ1dCBhIFZUSU1FWk9ORSBkb2VzIG5vdCBleGlzdCxcbiAqIGFuIGF0dGVtcHQgd2lsbCBiZSBtYWRlIHRvIGdlbmVyYXRlIGEgVlRJTUVaT05FIHVzaW5nIElDQUwuVGltZXpvbmVTZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSB2Y2FsICAgICBUaGUgdG9wLWxldmVsIFZDQUxFTkRBUiBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtDb21wb25lbnR9ICAgICAgICAgVGhlIElDQUwuQ29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlVGltZXpvbmVzKHZjYWwpIHtcbiAgbGV0IGFsbHN1YnMsIHByb3BlcnRpZXMsIHZ0aW1lem9uZXMsIHJlcVR6aWQsIGk7XG5cbiAgaWYgKCF2Y2FsIHx8IHZjYWwubmFtZSAhPT0gXCJ2Y2FsZW5kYXJcIikge1xuICAgIC8vbm90IGEgdG9wLWxldmVsIHZjYWxlbmRhciBjb21wb25lbnRcbiAgICByZXR1cm4gdmNhbDtcbiAgfVxuXG4gIC8vU3RvcmUgdnRpbWV6b25lIHN1YmNvbXBvbmVudHMgaW4gYW4gb2JqZWN0IHJlZmVyZW5jZSBieSB0emlkLlxuICAvL1N0b3JlIHByb3BlcnRpZXMgZnJvbSBldmVyeXRoaW5nIGVsc2UgaW4gYW5vdGhlciBhcnJheVxuICBhbGxzdWJzID0gdmNhbC5nZXRBbGxTdWJjb21wb25lbnRzKCk7XG4gIHByb3BlcnRpZXMgPSBbXTtcbiAgdnRpbWV6b25lcyA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgYWxsc3Vicy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbGxzdWJzW2ldLm5hbWUgPT09IFwidnRpbWV6b25lXCIpIHtcbiAgICAgIGxldCB0emlkID0gYWxsc3Vic1tpXS5nZXRGaXJzdFByb3BlcnR5KFwidHppZFwiKS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICB2dGltZXpvbmVzW3R6aWRdID0gYWxsc3Vic1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMuY29uY2F0KGFsbHN1YnNbaV0uZ2V0QWxsUHJvcGVydGllcygpKTtcbiAgICB9XG4gIH1cblxuICAvL2NyZWF0ZSBhbiBvYmplY3Qgd2l0aCBvbmUgZW50cnkgZm9yIGVhY2ggcmVxdWlyZWQgdHpcbiAgcmVxVHppZCA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0emlkID0gcHJvcGVydGllc1tpXS5nZXRQYXJhbWV0ZXIoXCJ0emlkXCIpO1xuICAgIGlmICh0emlkKSB7XG4gICAgICByZXFUemlkW3R6aWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvL2RlbGV0ZSBhbnkgdnRpbWV6b25lcyB0aGF0IGFyZSBub3Qgb24gdGhlIHJlcVR6aWQgbGlzdC5cbiAgZm9yIChsZXQgW3R6aWQsIGNvbXBdIG9mIE9iamVjdC5lbnRyaWVzKHZ0aW1lem9uZXMpKSB7XG4gICAgaWYgKCFyZXFUemlkW3R6aWRdKSB7XG4gICAgICB2Y2FsLnJlbW92ZVN1YmNvbXBvbmVudChjb21wKTtcbiAgICB9XG4gIH1cblxuICAvL2NyZWF0ZSBhbnkgbWlzc2luZywgYnV0IHJlZ2lzdGVyZWQgdGltZXpvbmVzXG4gIGZvciAobGV0IHR6aWQgb2YgT2JqZWN0LmtleXMocmVxVHppZCkpIHtcbiAgICBpZiAoIXZ0aW1lem9uZXNbdHppZF0gJiYgVGltZXpvbmVTZXJ2aWNlLmhhcyh0emlkKSkge1xuICAgICAgdmNhbC5hZGRTdWJjb21wb25lbnQoVGltZXpvbmVTZXJ2aWNlLmdldCh0emlkKS5jb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2Y2FsO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdHlwZSBpcyBvZiB0aGUgbnVtYmVyIHR5cGUgYW5kIGFsc28gTmFOLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgICAgIFRoZSBudW1iZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBudW1iZXIgaXMgc3RyaWN0bHkgTmFOXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0bHlOYU4obnVtYmVyKSB7XG4gIHJldHVybiB0eXBlb2YobnVtYmVyKSA9PT0gJ251bWJlcicgJiYgaXNOYU4obnVtYmVyKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLCB3aGVuIHRoZSB2YWxpZCBpc1xuICogbm90IGFuIGludGVnZXIgdGhyb3dzIGEgZGVjb3JhdGlvbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBSYXcgc3RyaW5nIGlucHV0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBQYXJzZWQgaW50ZWdlclxuICovXG5mdW5jdGlvbiBzdHJpY3RQYXJzZUludChzdHJpbmcpIHtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZywgMTApO1xuXG4gIGlmIChpc1N0cmljdGx5TmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ291bGQgbm90IGV4dHJhY3QgaW50ZWdlciBmcm9tIFwiJyArIHN0cmluZyArICdcIidcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIG9yIHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZSBvZiBhIGdpdmVuIHR5cGUgd2l0aCB0aGUgaW5pdGlhbGl6YXRpb25cbiAqIGRhdGEgaWYgdGhlIGRhdGEgaXMgbm90IGFscmVhZHkgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSguLi4pO1xuICogdmFyIHJlc3VsdCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUodGltZSwgSUNBTC5UaW1lKTtcbiAqXG4gKiAocmVzdWx0IGluc3RhbmNlb2YgSUNBTC5UaW1lKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIHJlc3VsdCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoe30sIElDQUwuVGltZSk7XG4gKiAocmVzdWx0IGlzbnRhbmNlb2YgSUNBTC5UaW1lKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICBvYmplY3QgaW5pdGlhbGl6YXRpb24gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGUgICAgICAgb2JqZWN0IHR5cGUgKGxpa2UgSUNBTC5UaW1lKVxuICogQHJldHVybiB7P30gICAgICAgICAgICAgICAgQW4gaW5zdGFuY2Ugb2YgdGhlIGZvdW5kIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdENsYXNzVHlwZShkYXRhLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YoZGF0YSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgdHlwZSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBuZXcgdHlwZShkYXRhKTtcbn1cblxuLyoqXG4gKiBJZGVudGljYWwgdG8gaW5kZXhPZiBidXQgd2lsbCBvbmx5IG1hdGNoIHZhbHVlcyB3aGVuIHRoZXkgYXJlIG5vdCBwcmVjZWRlZFxuICogYnkgYSBiYWNrc2xhc2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXIgICAgICAgICBTdHJpbmcgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoICAgICAgICAgVmFsdWUgdG8gbG9vayBmb3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgICAgICAgICAgICBTdGFydCBwb3NpdGlvblxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgIFRoZSBwb3NpdGlvbiwgb3IgLTEgaWYgbm90IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlZEluZGV4T2YoYnVmZmVyLCBzZWFyY2gsIHBvcykge1xuICB3aGlsZSAoKHBvcyA9IGJ1ZmZlci5pbmRleE9mKHNlYXJjaCwgcG9zKSkgIT09IC0xKSB7XG4gICAgaWYgKHBvcyA+IDAgJiYgYnVmZmVyW3BvcyAtIDFdID09PSAnXFxcXCcpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogRmluZCB0aGUgaW5kZXggZm9yIGluc2VydGlvbiB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgICAgICAgICAgICBUaGUgbGlzdCB0byBzZWFyY2hcbiAqIEBwYXJhbSB7P30gc2Vla1ZhbCAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gaW5zZXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD8sPyl9IGNtcGZ1bmMgVGhlIGNvbXBhcmlzb24gZnVuYywgdGhhdCBjYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgdHdvIHNlZWtWYWxzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIGluc2VydCBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBiaW5zZWFyY2hJbnNlcnQobGlzdCwgc2Vla1ZhbCwgY21wZnVuYykge1xuICBpZiAoIWxpc3QubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuXG4gIGxldCBsb3cgPSAwLCBoaWdoID0gbGlzdC5sZW5ndGggLSAxLFxuICAgICAgbWlkLCBjbXB2YWw7XG5cbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgbWlkID0gbG93ICsgTWF0aC5mbG9vcigoaGlnaCAtIGxvdykgLyAyKTtcbiAgICBjbXB2YWwgPSBjbXBmdW5jKHNlZWtWYWwsIGxpc3RbbWlkXSk7XG5cbiAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgICBsb3cgPSBtaWQgKyAxO1xuICAgIGVsc2VcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKGNtcHZhbCA8IDApXG4gICAgcmV0dXJuIG1pZDsgLy8gaW5zZXJ0aW9uIGlzIGRpc3BsYWNpbmcsIHNvIHVzZSBtaWQgb3V0cmlnaHQuXG4gIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgcmV0dXJuIG1pZCArIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gbWlkO1xufVxuXG4vKipcbiAqIENsb25lIHRoZSBwYXNzZWQgb2JqZWN0IG9yIHByaW1pdGl2ZS4gQnkgZGVmYXVsdCBhIHNoYWxsb3cgY2xvbmUgd2lsbCBiZVxuICogZXhlY3V0ZWQuXG4gKlxuICogQHBhcmFtIHsqfSBhU3JjICAgICAgICAgICAgVGhlIHRoaW5nIHRvIGNsb25lXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGVlcCAgICBJZiB0cnVlLCBhIGRlZXAgY2xvbmUgd2lsbCBiZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgIFRoZSBjb3B5IG9mIHRoZSB0aGluZ1xuICovXG5mdW5jdGlvbiBjbG9uZShhU3JjLCBhRGVlcCkge1xuICBpZiAoIWFTcmMgfHwgdHlwZW9mIGFTcmMgIT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBhU3JjO1xuICB9IGVsc2UgaWYgKGFTcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFTcmMuZ2V0VGltZSgpKTtcbiAgfSBlbHNlIGlmIChcImNsb25lXCIgaW4gYVNyYykge1xuICAgIHJldHVybiBhU3JjLmNsb25lKCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhU3JjKSkge1xuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFTcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKGFEZWVwID8gY2xvbmUoYVNyY1tpXSwgdHJ1ZSkgOiBhU3JjW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgb2JqID0ge307XG4gICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhU3JjKSkge1xuICAgICAgaWYgKGFEZWVwKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IGNsb25lKHZhbHVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgaUNhbGVuZGFyIGxpbmUgZm9sZGluZy4gQSBsaW5lIGVuZGluZyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgYW5kXG4gKiB0aGUgbmV4dCBsaW5lIGJlZ2lucyB3aXRoIGEgd2hpdGVzcGFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogU1VNTUFSWTpUaGlzIGxpbmUgd2lsbCBiZSBmb2xkXG4gKiAgZWQgcmlnaHQgaW4gdGhlIG1pZGRsZSBvZiBhIHdvcmQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFMaW5lICAgICAgVGhlIGxpbmUgdG8gZm9sZFxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGZvbGRlZCBsaW5lXG4gKi9cbmZ1bmN0aW9uIGZvbGRsaW5lKGFMaW5lKSB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgbGluZSA9IGFMaW5lIHx8IFwiXCIsIHBvcyA9IDAsIGxpbmVfbGVuZ3RoID0gMDtcbiAgLy9wb3MgY291bnRzIHBvc2l0aW9uIGluIGxpbmUgZm9yIHRoZSBVVEYtMTYgcHJlc2VudGF0aW9uXG4gIC8vbGluZV9sZW5ndGggY291bnRzIHRoZSBieXRlcyBmb3IgdGhlIFVURi04IHByZXNlbnRhdGlvblxuICB3aGlsZSAobGluZS5sZW5ndGgpIHtcbiAgICBsZXQgY3AgPSBsaW5lLmNvZGVQb2ludEF0KHBvcyk7XG4gICAgaWYgKGNwIDwgMTI4KSArK2xpbmVfbGVuZ3RoO1xuICAgIGVsc2UgaWYgKGNwIDwgMjA0OCkgbGluZV9sZW5ndGggKz0gMjsvL25lZWRzIDIgVVRGLTggYnl0ZXNcbiAgICBlbHNlIGlmIChjcCA8IDY1NTM2KSBsaW5lX2xlbmd0aCArPSAzO1xuICAgIGVsc2UgbGluZV9sZW5ndGggKz0gNDsgLy9jcCBpcyBsZXNzIHRoYW4gMTExNDExMlxuICAgIGlmIChsaW5lX2xlbmd0aCA8IElDQUxtb2R1bGUuZm9sZExlbmd0aCArIDEpXG4gICAgICBwb3MgKz0gY3AgPiA2NTUzNSA/IDIgOiAxO1xuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IElDQUxtb2R1bGUubmV3TGluZUNoYXIgKyBcIiBcIiArIGxpbmUuc2xpY2UoMCwgTWF0aC5tYXgoMCwgcG9zKSk7XG4gICAgICBsaW5lID0gbGluZS5zbGljZShNYXRoLm1heCgwLCBwb3MpKTtcbiAgICAgIHBvcyA9IGxpbmVfbGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5zbGljZShJQ0FMbW9kdWxlLm5ld0xpbmVDaGFyLmxlbmd0aCArIDEpO1xufVxuXG4vKipcbiAqIFBhZHMgdGhlIGdpdmVuIHN0cmluZyBvciBudW1iZXIgd2l0aCB6ZXJvcyBzbyBpdCB3aWxsIGhhdmUgYXQgbGVhc3QgdHdvXG4gKiBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZGF0YSAgICBUaGUgc3RyaW5nIG9yIG51bWJlciB0byBwYWRcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICBUaGUgbnVtYmVyIHBhZGRlZCBhcyBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBwYWQyKGRhdGEpIHtcbiAgaWYgKHR5cGVvZihkYXRhKSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBoYW5kbGUgZnJhY3Rpb25zLlxuICAgIGlmICh0eXBlb2YoZGF0YSkgPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRhID0gcGFyc2VJbnQoZGF0YSk7XG4gICAgfVxuICAgIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gIH1cblxuICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgc3dpdGNoIChsZW4pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gJzAwJztcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJzAnICsgZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVuY2F0ZXMgdGhlIGdpdmVuIG51bWJlciwgY29ycmVjdGx5IGhhbmRsaW5nIG5lZ2F0aXZlIG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAgICAgVGhlIG51bWJlciB0byB0cnVuY2F0ZVxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIHRydW5jYXRlZCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdHJ1bmMobnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpKTtcbn1cblxuLyoqXG4gKiBQb29yLW1hbidzIGNyb3NzLWJyb3dzZXIgb2JqZWN0IGV4dGVuc2lvbi4gRG9lc24ndCBzdXBwb3J0IGFsbCB0aGVcbiAqIGZlYXR1cmVzLCBidXQgZW5vdWdoIGZvciBvdXIgdXNhZ2UuIE5vdGUgdGhhdCB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmVcbiAqIG5vdCBvdmVyd3JpdHRlbiB3aXRoIHRoZSBzb3VyY2UgcHJvcGVydGllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGNoaWxkID0gSUNBTC5oZWxwZXJzLmV4dGVuZChwYXJlbnQsIHtcbiAqICAgXCJiYXJcIjogMTIzXG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlICAgICBUaGUgb2JqZWN0IHRvIGV4dGVuZFxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgICAgVGhlIG9iamVjdCB0byBleHRlbmQgd2l0aFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgUmV0dXJucyB0aGUgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBleHRlbmQoc291cmNlLCB0YXJnZXQpIHtcbiAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgIGxldCBkZXNjciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpO1xuICAgIGlmIChkZXNjciAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgaGVscGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB1cGRhdGVUaW1lem9uZXM6IHVwZGF0ZVRpbWV6b25lcyxcbiAgaXNTdHJpY3RseU5hTjogaXNTdHJpY3RseU5hTixcbiAgc3RyaWN0UGFyc2VJbnQ6IHN0cmljdFBhcnNlSW50LFxuICBmb3JtYXRDbGFzc1R5cGU6IGZvcm1hdENsYXNzVHlwZSxcbiAgdW5lc2NhcGVkSW5kZXhPZjogdW5lc2NhcGVkSW5kZXhPZixcbiAgYmluc2VhcmNoSW5zZXJ0OiBiaW5zZWFyY2hJbnNlcnQsXG4gIGNsb25lOiBjbG9uZSxcbiAgZm9sZGxpbmU6IGZvbGRsaW5lLFxuICBwYWQyOiBwYWQyLFxuICB0cnVuYzogdHJ1bmMsXG4gIGV4dGVuZDogZXh0ZW5kXG59KTtcblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInV0Yy1vZmZzZXRcIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb24gYW5kIG1hbmlwdWxhdGlvblxuICogbWV0aG9kcy5cbiAqXG4gKiBAbWVtYmVyb2YgSUNBTFxuICovXG5jbGFzcyBVdGNPZmZzZXQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhU3RyaW5nICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7RHVyYXRpb259ICAgICAgICAgVGhlIGNyZWF0ZWQgdXRjLW9mZnNldCBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoYVN0cmluZykge1xuICAgIC8vIC0wNTowMFxuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgLy9UT0RPOiBzdXBwb3J0IHNlY29uZHMgcGVyIHJmYzU1NDUgP1xuICAgIG9wdGlvbnMuZmFjdG9yID0gKGFTdHJpbmdbMF0gPT09ICcrJykgPyAxIDogLTE7XG4gICAgb3B0aW9ucy5ob3VycyA9IHN0cmljdFBhcnNlSW50KGFTdHJpbmcuc2xpY2UoMSwgMykpO1xuICAgIG9wdGlvbnMubWludXRlcyA9IHN0cmljdFBhcnNlSW50KGFTdHJpbmcuc2xpY2UoNCwgNikpO1xuXG4gICAgcmV0dXJuIG5ldyBVdGNPZmZzZXQob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGNvbnZlcnRcbiAgICovXG4gIHN0YXRpYyBmcm9tU2Vjb25kcyhhU2Vjb25kcykge1xuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBVdGNPZmZzZXQoKTtcbiAgICBpbnN0YW5jZS5mcm9tU2Vjb25kcyhhU2Vjb25kcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5VdGNPZmZzZXQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICBUaGUgaG91cnMgZm9yIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmZhY3RvciAgVGhlIGZhY3RvciBmb3IgdGhlIHV0Yy1vZmZzZXQsIGVpdGhlciAtMSBvciAxXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhRGF0YSkge1xuICAgIHRoaXMuZnJvbURhdGEoYURhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBob3VycyBpbiB0aGUgdXRjLW9mZnNldFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgaG91cnMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgbWludXRlcyBpbiB0aGUgdXRjLW9mZnNldFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgbWludXRlcyA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBzaWduIG9mIHRoZSB1dGMgb2Zmc2V0LCAxIGZvciBwb3NpdGl2ZSBvZmZzZXQsIC0xIGZvciBuZWdhdGl2ZVxuICAgKiBvZmZzZXRzLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZmFjdG9yID0gMTtcblxuICAvKipcbiAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcInV0Yy1vZmZzZXRcIlxuICAgKi9cbiAgaWNhbHR5cGUgPSBcInV0Yy1vZmZzZXRcIjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB1dGMgb2Zmc2V0IG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7VXRjT2Zmc2V0fSAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBVdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy50b1NlY29uZHMoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VycyAgIFRoZSBob3VycyBmb3IgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzIFRoZSBtaW51dGVzIGluIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICovXG4gIGZyb21EYXRhKGFEYXRhKSB7XG4gICAgaWYgKGFEYXRhKSB7XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYURhdGEpKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHNlY29uZHMgdmFsdWUuIFRoZSBzZWNvbmRzXG4gICAqIHZhbHVlIGlzIHRydW5jYXRlZCB0byB0aGUgbWludXRlLiBPZmZzZXRzIGFyZSB3cmFwcGVkIHdoZW4gdGhlIHdvcmxkXG4gICAqIGVuZHMsIHRoZSBob3VyIGFmdGVyIFVUQysxNDowMCBpcyBVVEMtMTI6MDAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgICAgIFRoZSBzZWNvbmRzIHRvIGNvbnZlcnQgaW50byBhbiBvZmZzZXRcbiAgICovXG4gIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgbGV0IHNlY3MgPSBNYXRoLmFicyhhU2Vjb25kcyk7XG5cbiAgICB0aGlzLmZhY3RvciA9IGFTZWNvbmRzIDwgMCA/IC0xIDogMTtcbiAgICB0aGlzLmhvdXJzID0gdHJ1bmMoc2VjcyAvIDM2MDApO1xuXG4gICAgc2VjcyAtPSAodGhpcy5ob3VycyAqIDM2MDApO1xuICAgIHRoaXMubWludXRlcyA9IHRydW5jKHNlY3MgLyA2MCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgY3VycmVudCBvZmZzZXQgdG8gYSB2YWx1ZSBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgIFRoZSBvZmZzZXQgaW4gc2Vjb25kc1xuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmZhY3RvciAqICg2MCAqIHRoaXMubWludXRlcyArIDM2MDAgKiB0aGlzLmhvdXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIHRoaXMgdXRjIG9mZnNldCB3aXRoIGFub3RoZXIgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge1V0Y09mZnNldH0gb3RoZXIgICAgICAgICAgICAgVGhlIG90aGVyIG9mZnNldCB0byBjb21wYXJlIHdpdGhcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgKi9cbiAgY29tcGFyZShvdGhlcikge1xuICAgIGxldCBhID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICBsZXQgYiA9IG90aGVyLnRvU2Vjb25kcygpO1xuICAgIHJldHVybiAoYSA+IGIpIC0gKGIgPiBhKTtcbiAgfVxuXG4gIF9ub3JtYWxpemUoKSB7XG4gICAgLy8gUmFuZ2U6IDk3MjAwIHNlY29uZHMgKHdpdGggMSBob3VyIGluYmV0d2VlbilcbiAgICBsZXQgc2VjcyA9IHRoaXMudG9TZWNvbmRzKCk7XG4gICAgbGV0IGZhY3RvciA9IHRoaXMuZmFjdG9yO1xuICAgIHdoaWxlIChzZWNzIDwgLTQzMjAwKSB7IC8vID0gVVRDLTEyOjAwXG4gICAgICBzZWNzICs9IDk3MjAwO1xuICAgIH1cbiAgICB3aGlsZSAoc2VjcyA+IDUwNDAwKSB7IC8vID0gVVRDKzE0OjAwXG4gICAgICBzZWNzIC09IDk3MjAwO1xuICAgIH1cblxuICAgIHRoaXMuZnJvbVNlY29uZHMoc2Vjcyk7XG5cbiAgICAvLyBBdm9pZCBjaGFuZ2luZyB0aGUgZmFjdG9yIHdoZW4gb24gemVybyBzZWNvbmRzXG4gICAgaWYgKHNlY3MgPT0gMCkge1xuICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9JQ0FMU3RyaW5nKCkge1xuICAgIHJldHVybiBkZXNpZ24kMS5pY2FsZW5kYXIudmFsdWVbJ3V0Yy1vZmZzZXQnXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZhY3RvciA9PSAxID8gXCIrXCIgOiBcIi1cIikgKyBwYWQyKHRoaXMuaG91cnMpICsgJzonICsgcGFkMih0aGlzLm1pbnV0ZXMpO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIERlc2NyaWJlcyBhIHZDYXJkIHRpbWUsIHdoaWNoIGhhcyBzbGlnaHQgZGlmZmVyZW5jZXMgdG8gdGhlIElDQUwuVGltZS5cbiAqIFByb3BlcnRpZXMgY2FuIGJlIG51bGwgaWYgbm90IHNwZWNpZmllZCwgZm9yIGV4YW1wbGUgZm9yIGRhdGVzIHdpdGhcbiAqIHJlZHVjZWQgYWNjdXJhY3kgb3IgdHJ1bmNhdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgY3VycmVudGx5IG5vdCBhbGwgbWV0aG9kcyBhcmUgY29ycmVjdGx5IHJlLWltcGxlbWVudGVkIGZvclxuICogVkNhcmRUaW1lLiBGb3IgZXhhbXBsZSwgY29tcGFyaXNvbiB3aWxsIGhhdmUgdW5kZWZpbmVkIHJlc3VsdHMgd2hlbiBzb21lXG4gKiBtZW1iZXJzIGFyZSBudWxsLlxuICpcbiAqIEFsc28sIG5vcm1hbGl6YXRpb24gaXMgbm90IHlldCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBjbGFzcyFcbiAqXG4gKiBAbWVtYmVyb2YgSUNBTFxuICogQGV4dGVuZHMge0lDQUwuVGltZX1cbiAqL1xuY2xhc3MgVkNhcmRUaW1lIGV4dGVuZHMgVGltZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVkNhcmRUaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIGFuZC9vciB0aW1lIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYUljYWxUeXBlICBUaGUgdHlwZSBmb3IgdGhpcyBpbnN0YW5jZSwgZS5nLiBkYXRlLWFuZC1vci10aW1lXG4gICAqIEByZXR1cm4ge1ZDYXJkVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIGFJY2FsVHlwZSkge1xuICAgIGZ1bmN0aW9uIHBhcnQodiwgcywgZSkge1xuICAgICAgcmV0dXJuIHYgPyBzdHJpY3RQYXJzZUludCh2LnNsaWNlKHMsIHMgKyBlKSkgOiBudWxsO1xuICAgIH1cbiAgICBsZXQgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICBsZXQgZHQgPSBwYXJ0c1swXSwgdG16ID0gcGFydHNbMV07XG4gICAgbGV0IHNwbGl0em9uZSA9IHRteiA/IGRlc2lnbiQxLnZjYXJkLnZhbHVlLnRpbWUuX3NwbGl0Wm9uZSh0bXopIDogW107XG4gICAgbGV0IHpvbmUgPSBzcGxpdHpvbmVbMF0sIHRtID0gc3BsaXR6b25lWzFdO1xuXG4gICAgbGV0IGR0bGVuID0gZHQgPyBkdC5sZW5ndGggOiAwO1xuICAgIGxldCB0bWxlbiA9IHRtID8gdG0ubGVuZ3RoIDogMDtcblxuICAgIGxldCBoYXNEYXNoRGF0ZSA9IGR0ICYmIGR0WzBdID09ICctJyAmJiBkdFsxXSA9PSAnLSc7XG4gICAgbGV0IGhhc0Rhc2hUaW1lID0gdG0gJiYgdG1bMF0gPT0gJy0nO1xuXG4gICAgbGV0IG8gPSB7XG4gICAgICB5ZWFyOiBoYXNEYXNoRGF0ZSA/IG51bGwgOiBwYXJ0KGR0LCAwLCA0KSxcbiAgICAgIG1vbnRoOiBoYXNEYXNoRGF0ZSAmJiAoZHRsZW4gPT0gNCB8fCBkdGxlbiA9PSA3KSA/IHBhcnQoZHQsIDIsIDIpIDogZHRsZW4gPT0gNyA/IHBhcnQoZHQsIDUsIDIpIDogZHRsZW4gPT0gMTAgPyBwYXJ0KGR0LCA1LCAyKSA6IG51bGwsXG4gICAgICBkYXk6IGR0bGVuID09IDUgPyBwYXJ0KGR0LCAzLCAyKSA6IGR0bGVuID09IDcgJiYgaGFzRGFzaERhdGUgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgOCwgMikgOiBudWxsLFxuXG4gICAgICBob3VyOiBoYXNEYXNoVGltZSA/IG51bGwgOiBwYXJ0KHRtLCAwLCAyKSxcbiAgICAgIG1pbnV0ZTogaGFzRGFzaFRpbWUgJiYgdG1sZW4gPT0gMyA/IHBhcnQodG0sIDEsIDIpIDogdG1sZW4gPiA0ID8gaGFzRGFzaFRpbWUgPyBwYXJ0KHRtLCAxLCAyKSA6IHBhcnQodG0sIDMsIDIpIDogbnVsbCxcbiAgICAgIHNlY29uZDogdG1sZW4gPT0gNCA/IHBhcnQodG0sIDIsIDIpIDogdG1sZW4gPT0gNiA/IHBhcnQodG0sIDQsIDIpIDogdG1sZW4gPT0gOCA/IHBhcnQodG0sIDYsIDIpIDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoem9uZSA9PSAnWicpIHtcbiAgICAgIHpvbmUgPSBUaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9IGVsc2UgaWYgKHpvbmUgJiYgem9uZVszXSA9PSAnOicpIHtcbiAgICAgIHpvbmUgPSBVdGNPZmZzZXQuZnJvbVN0cmluZyh6b25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgem9uZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBWQ2FyZFRpbWUobywgem9uZSwgYUljYWxUeXBlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5WQ2FyZFRpbWUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZm9yIHRoZSB0aW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICAgICAgICAgICAgICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubW9udGggICAgICAgICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICAgICAgICAgICAgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICAgICAgICAgICAgICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubWludXRlICAgICAgICAgICAgICAgICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgICAgICAgICAgICAgICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge1RpbWV6b25lfFV0Y09mZnNldH0gem9uZSAgICAgICAgICAgICAgIFRoZSB0aW1lem9uZSB0byB1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGljYWx0eXBlICAgICAgICAgICAgICAgICAgICAgICBUaGUgdHlwZSBmb3IgdGhpcyBkYXRlL3RpbWUgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCB6b25lLCBpY2FsdHlwZSkge1xuICAgIHN1cGVyKGRhdGEsIHpvbmUpO1xuICAgIHRoaXMuaWNhbHR5cGUgPSBpY2FsdHlwZSB8fCBcImRhdGUtYW5kLW9yLXRpbWVcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwidmNhcmR0aW1lXCJcbiAgICovXG4gIGljYWxjbGFzcyA9IFwidmNhcmR0aW1lXCI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcImRhdGUtYW5kLW9yLXRpbWVcIlxuICAgKi9cbiAgaWNhbHR5cGUgPSBcImRhdGUtYW5kLW9yLXRpbWVcIjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB2Y2FyZCBkYXRlL3RpbWUgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtWQ2FyZFRpbWV9ICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBWQ2FyZFRpbWUodGhpcy5fdGltZSwgdGhpcy56b25lLCB0aGlzLmljYWx0eXBlKTtcbiAgfVxuXG4gIF9ub3JtYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHV0Y09mZnNldCgpIHtcbiAgICBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgVXRjT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLnRvU2Vjb25kcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gVGltZS5wcm90b3R5cGUudXRjT2Zmc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDYzNTAgY29tcGxpYW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgdmNhcmQgZGF0ZS90aW1lIHN0cmluZ1xuICAgKi9cbiAgdG9JQ0FMU3RyaW5nKCkge1xuICAgIHJldHVybiBkZXNpZ24kMS52Y2FyZC52YWx1ZVt0aGlzLmljYWx0eXBlXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZS90aW1lLCBpbiBqQ2FyZCBmb3JtXG4gICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHkgPSB0aGlzLnllYXIsIG0gPSB0aGlzLm1vbnRoLCBkID0gdGhpcy5kYXk7XG4gICAgbGV0IGggPSB0aGlzLmhvdXIsIG1tID0gdGhpcy5taW51dGUsIHMgPSB0aGlzLnNlY29uZDtcblxuICAgIGxldCBoYXNZZWFyID0geSAhPT0gbnVsbCwgaGFzTW9udGggPSBtICE9PSBudWxsLCBoYXNEYXkgPSBkICE9PSBudWxsO1xuICAgIGxldCBoYXNIb3VyID0gaCAhPT0gbnVsbCwgaGFzTWludXRlID0gbW0gIT09IG51bGwsIGhhc1NlY29uZCA9IHMgIT09IG51bGw7XG5cbiAgICBsZXQgZGF0ZXBhcnQgPSAoaGFzWWVhciA/IHBhZDIoeSkgKyAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0nIDogJycpIDogKGhhc01vbnRoIHx8IGhhc0RheSA/ICctLScgOiAnJykpICtcbiAgICAgICAgICAgICAgICAgICAoaGFzTW9udGggPyBwYWQyKG0pIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAoaGFzRGF5ID8gJy0nICsgcGFkMihkKSA6ICcnKTtcbiAgICBsZXQgdGltZXBhcnQgPSAoaGFzSG91ciA/IHBhZDIoaCkgOiAnLScpICsgKGhhc0hvdXIgJiYgaGFzTWludXRlID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAoaGFzTWludXRlID8gcGFkMihtbSkgOiAnJykgKyAoIWhhc0hvdXIgJiYgIWhhc01pbnV0ZSA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgKGhhc01pbnV0ZSAmJiBoYXNTZWNvbmQgPyAnOicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgIChoYXNTZWNvbmQgPyBwYWQyKHMpIDogJycpO1xuXG4gICAgbGV0IHpvbmU7XG4gICAgaWYgKHRoaXMuem9uZSA9PT0gVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgIHpvbmUgPSAnWic7XG4gICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBVdGNPZmZzZXQpIHtcbiAgICAgIHpvbmUgPSB0aGlzLnpvbmUudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSA9PT0gVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgem9uZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgVGltZXpvbmUpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBVdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy56b25lLnV0Y09mZnNldCh0aGlzKSk7XG4gICAgICB6b25lID0gb2Zmc2V0LnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHpvbmUgPSAnJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuaWNhbHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgIHJldHVybiB0aW1lcGFydCArIHpvbmU7XG4gICAgICBjYXNlIFwiZGF0ZS1hbmQtb3ItdGltZVwiOlxuICAgICAgY2FzZSBcImRhdGUtdGltZVwiOlxuICAgICAgICByZXR1cm4gZGF0ZXBhcnQgKyAodGltZXBhcnQgPT0gJy0tJyA/ICcnIDogJ1QnICsgdGltZXBhcnQgKyB6b25lKTtcbiAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgIHJldHVybiBkYXRlcGFydDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS53ZWVrRGF5fSB3ZWVrRGF5XG4gKiBJbXBvcnRzIHRoZSAnd2Vla0RheScgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBBbiBpdGVyYXRvciBmb3IgYSBzaW5nbGUgcmVjdXJyZW5jZSBydWxlLiBUaGlzIGNsYXNzIHVzdWFsbHkgZG9lc24ndCBoYXZlIHRvIGJlIGluc3RhbmNpYXRlZFxuICogZGlyZWN0bHksIHRoZSBjb252ZW5pZW5jZSBtZXRob2Qge0BsaW5rIElDQUwuUmVjdXIjaXRlcmF0b3J9IGNhbiBiZSB1c2VkLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIFJlY3VySXRlcmF0b3Ige1xuICBzdGF0aWMgX2luZGV4TWFwID0ge1xuICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICBcIkJZTUlOVVRFXCI6IDEsXG4gICAgXCJCWUhPVVJcIjogMixcbiAgICBcIkJZREFZXCI6IDMsXG4gICAgXCJCWU1PTlRIREFZXCI6IDQsXG4gICAgXCJCWVlFQVJEQVlcIjogNSxcbiAgICBcIkJZV0VFS05PXCI6IDYsXG4gICAgXCJCWU1PTlRIXCI6IDcsXG4gICAgXCJCWVNFVFBPU1wiOiA4XG4gIH07XG5cbiAgc3RhdGljIF9leHBhbmRNYXAgPSB7XG4gICAgXCJTRUNPTkRMWVwiOiBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJNSU5VVEVMWVwiOiBbMiwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJIT1VSTFlcIjogWzIsIDIsIDEsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiREFJTFlcIjogWzIsIDIsIDIsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiV0VFS0xZXCI6IFsyLCAyLCAyLCAyLCAzLCAzLCAxLCAxXSxcbiAgICBcIk1PTlRITFlcIjogWzIsIDIsIDIsIDIsIDIsIDMsIDMsIDFdLFxuICAgIFwiWUVBUkxZXCI6IFsyLCAyLCAyLCAyLCAyLCAyLCAyLCAyXVxuICB9O1xuXG4gIHN0YXRpYyBVTktOT1dOID0gMDtcbiAgc3RhdGljIENPTlRSQUNUID0gMTtcbiAgc3RhdGljIEVYUEFORCA9IDI7XG4gIHN0YXRpYyBJTExFR0FMID0gMztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlJlY3VySXRlcmF0b3IgaW5zdGFuY2UuIFRoZSBvcHRpb25zIG9iamVjdCBtYXkgY29udGFpbiBhZGRpdGlvbmFsIG1lbWJlcnNcbiAgICogd2hlbiByZXN1bWluZyBpdGVyYXRpb24gZnJvbSBhIHByZXZpb3VzIHJ1bi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgVGhlIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtSZWN1cn0gb3B0aW9ucy5ydWxlICAgICAgICAgICAgVGhlIHJ1bGUgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtUaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgICAgICAgVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBvcHRpb25zLmluaXRpYWxpemVkICBXaGVuIHRydWUsIGFzc3VtZSB0aGF0IG9wdGlvbnMgYXJlXG4gICAqICAgICAgICBmcm9tIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBpdGVyYXRvci4gSW5pdGlhbGl6YXRpb24gd2lsbCBub3QgYmVcbiAgICogICAgICAgIHJlcGVhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZnJvbURhdGEob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIGl0ZXJhdGlvbiBpcyBmaW5pc2hlZC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBjb21wbGV0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIHJ1bGUgdGhhdCBpcyBiZWluZyBpdGVyYXRlZFxuICAgKiBAdHlwZSB7UmVjdXJ9XG4gICAqL1xuICBydWxlID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIGV2ZW50IGJlaW5nIGl0ZXJhdGVkLlxuICAgKiBAdHlwZSB7VGltZX1cbiAgICovXG4gIGR0c3RhcnQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBvY2N1cnJlbmNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlXG4gICAqIHtAbGluayBSZWN1ckl0ZXJhdG9yI25leHR9IG1ldGhvZC5cbiAgICogQHR5cGUge1RpbWV9XG4gICAqL1xuICBsYXN0ID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIHNlcXVlbmNlIG51bWJlciBmcm9tIHRoZSBvY2N1cnJlbmNlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBvY2N1cnJlbmNlX251bWJlciA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRpY2VzIHVzZWQgZm9yIHRoZSB7QGxpbmsgSUNBTC5SZWN1ckl0ZXJhdG9yI2J5X2RhdGF9IG9iamVjdC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ5X2luZGljZXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGUgaXRlcmF0b3IgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsaXpkIGJ5LWRhdGEuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBieV9kYXRhID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGV4cGFuZGVkIHllYXJkYXlzXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRheXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggaW4gdGhlIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjZGF5c30gYXJyYXkuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXlzX2luZGV4ID0gMDtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBpdGVyYXRvciBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuIFRoaXNcbiAgICogbWV0aG9kIGlzIHVzdWFsbHkgbm90IGNhbGxlZCBkaXJlY3RseSwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBpdGVyYXRvclxuICAgKiB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgVGhlIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtSZWN1cn0gb3B0aW9ucy5ydWxlICAgICAgICAgICAgVGhlIHJ1bGUgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtUaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgICAgICAgVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBvcHRpb25zLmluaXRpYWxpemVkICBXaGVuIHRydWUsIGFzc3VtZSB0aGF0IG9wdGlvbnMgYXJlXG4gICAqICAgICAgICBmcm9tIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBpdGVyYXRvci4gSW5pdGlhbGl6YXRpb24gd2lsbCBub3QgYmVcbiAgICogICAgICAgIHJlcGVhdGVkLlxuICAgKi9cbiAgZnJvbURhdGEob3B0aW9ucykge1xuICAgIHRoaXMucnVsZSA9IGZvcm1hdENsYXNzVHlwZShvcHRpb25zLnJ1bGUsIFJlY3VyKTtcblxuICAgIGlmICghdGhpcy5ydWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuUmVjdXIpIHJ1bGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmR0c3RhcnQgPSBmb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5kdHN0YXJ0LCBUaW1lKTtcblxuICAgIGlmICghdGhpcy5kdHN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuVGltZSkgZHRzdGFydCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmJ5X2RhdGEpIHtcbiAgICAgIHRoaXMuYnlfZGF0YSA9IG9wdGlvbnMuYnlfZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ieV9kYXRhID0gY2xvbmUodGhpcy5ydWxlLnBhcnRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcilcbiAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIgPSBvcHRpb25zLm9jY3VycmVuY2VfbnVtYmVyO1xuXG4gICAgdGhpcy5kYXlzID0gb3B0aW9ucy5kYXlzIHx8IFtdO1xuICAgIGlmIChvcHRpb25zLmxhc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IGZvcm1hdENsYXNzVHlwZShvcHRpb25zLmxhc3QsIFRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuYnlfaW5kaWNlcyA9IG9wdGlvbnMuYnlfaW5kaWNlcztcblxuICAgIGlmICghdGhpcy5ieV9pbmRpY2VzKSB7XG4gICAgICB0aGlzLmJ5X2luZGljZXMgPSB7XG4gICAgICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICAgICAgXCJCWU1JTlVURVwiOiAwLFxuICAgICAgICBcIkJZSE9VUlwiOiAwLFxuICAgICAgICBcIkJZREFZXCI6IDAsXG4gICAgICAgIFwiQllNT05USFwiOiAwLFxuICAgICAgICBcIkJZV0VFS05PXCI6IDAsXG4gICAgICAgIFwiQllNT05USERBWVwiOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBvcHRpb25zLmluaXRpYWxpemVkIHx8IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBJbnZhbGlkUmVjdXJyZW5jZVJ1bGVFcnJvcikge1xuICAgICAgICAgIC8vIEluaXQgbWF5IGVycm9yIGlmIHRoZXJlIGFyZSBubyBwb3NzaWJsZSByZWN1cnJlbmNlIGluc3RhbmNlcyBmcm9tXG4gICAgICAgICAgLy8gdGhlIHJ1bGUsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGJ1YmJsZSB0aGlzIGVycm9yIHVwLiBJbnN0ZWFkLCB3ZVxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBpdGVyYXRvci5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUHJvcGFnYXRlIG90aGVyIGVycm9ycyB0byBjb25zdW1lcnMuXG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBpdGVyYXRvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICBsZXQgcGFydHMgPSB0aGlzLmJ5X2RhdGE7XG5cbiAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAvLyBsaWJpY2FsIGRvZXMgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJ1bGUgaXMgbG9hZGVkLCBidXQgd2UgcG9zdHBvbmUgdG9cbiAgICAgIC8vIG5vdyBzbyB3ZSBjYW4gcHJlc2VydmUgdGhlIG9yaWdpbmFsIG9yZGVyLlxuICAgICAgdGhpcy5zb3J0X2J5ZGF5X3J1bGVzKHBhcnRzLkJZREFZKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgQllZRUFSREFZIGFwcGFyZXMsIG5vIG90aGVyIGRhdGUgcnVsZSBwYXJ0IG1heSBhcHBlYXJcbiAgICBpZiAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgaWYgKFwiQllNT05USFwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cyB8fFxuICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzIHx8IFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEJZWUVBUkRBWSBydWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJZV0VFS05PIGFuZCBCWU1PTlRIREFZIHJ1bGUgcGFydHMgbWF5IG5vdCBib3RoIGFwcGVhclxuICAgIGlmIChcIkJZV0VFS05PXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJZV0VFS05PIGRvZXMgbm90IGZpdCB0byBCWU1PTlRIREFZXCIpO1xuICAgIH1cblxuICAgIC8vIEZvciBNT05USExZIHJlY3VycmVuY2VzIChGUkVRPU1PTlRITFkpIG5laXRoZXIgQllZRUFSREFZIG5vclxuICAgIC8vIEJZV0VFS05PIG1heSBhcHBlYXIuXG4gICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiICYmXG4gICAgICAgIChcIkJZWUVBUkRBWVwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvciBNT05USExZIHJlY3VycmVuY2VzIG5laXRoZXIgQllZRUFSREFZIG5vciBCWVdFRUtOTyBtYXkgYXBwZWFyXCIpO1xuICAgIH1cblxuICAgIC8vIEZvciBXRUVLTFkgcmVjdXJyZW5jZXMgKEZSRVE9V0VFS0xZKSBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yXG4gICAgLy8gQllZRUFSREFZIG1heSBhcHBlYXIuXG4gICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiV0VFS0xZXCIgJiZcbiAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3IgV0VFS0xZIHJlY3VycmVuY2VzIG5laXRoZXIgQllNT05USERBWSBub3IgQllZRUFSREFZIG1heSBhcHBlYXJcIik7XG4gICAgfVxuXG4gICAgLy8gQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcbiAgICBpZiAodGhpcy5ydWxlLmZyZXEgIT0gXCJZRUFSTFlcIiAmJiBcIkJZWUVBUkRBWVwiIGluIHBhcnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1wiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3Quc2Vjb25kID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZU0VDT05EXCIsIFwiU0VDT05ETFlcIiwgdGhpcy5kdHN0YXJ0LnNlY29uZCk7XG4gICAgdGhpcy5sYXN0Lm1pbnV0ZSA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsIHRoaXMuZHRzdGFydC5taW51dGUpO1xuICAgIHRoaXMubGFzdC5ob3VyID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZSE9VUlwiLCBcIkhPVVJMWVwiLCB0aGlzLmR0c3RhcnQuaG91cik7XG4gICAgdGhpcy5sYXN0LmRheSA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1PTlRIREFZXCIsIFwiREFJTFlcIiwgdGhpcy5kdHN0YXJ0LmRheSk7XG4gICAgdGhpcy5sYXN0Lm1vbnRoID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhcIiwgXCJNT05USExZXCIsIHRoaXMuZHRzdGFydC5tb250aCk7XG5cbiAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJXRUVLTFlcIikge1xuICAgICAgaWYgKFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBsZXQgWywgZG93XSA9IHRoaXMucnVsZURheU9mV2VlayhwYXJ0cy5CWURBWVswXSwgdGhpcy5ydWxlLndrc3QpO1xuICAgICAgICBsZXQgd2tkeSA9IGRvdyAtIHRoaXMubGFzdC5kYXlPZldlZWsodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICBpZiAoKHRoaXMubGFzdC5kYXlPZldlZWsodGhpcy5ydWxlLndrc3QpIDwgZG93ICYmIHdrZHkgPj0gMCkgfHwgd2tkeSA8IDApIHtcbiAgICAgICAgICAvLyBJbml0aWFsIHRpbWUgaXMgYWZ0ZXIgZmlyc3QgZGF5IG9mIEJZREFZIGRhdGFcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IHdrZHk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXlOYW1lID0gUmVjdXIubnVtZXJpY0RheVRvSWNhbERheSh0aGlzLmR0c3RhcnQuZGF5T2ZXZWVrKCkpO1xuICAgICAgICBwYXJ0cy5CWURBWSA9IFtkYXlOYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJZRUFSTFlcIikge1xuICAgICAgLy8gU29tZSB5ZWFybHkgcmVjdXJyZW5jZSBydWxlcyBtYXkgYmUgc3BlY2lmaWMgZW5vdWdoIHRvIG5vdCBhY3R1YWxseVxuICAgICAgLy8gb2NjdXIgb24gYSB5ZWFybHkgYmFzaXMsIGUuZy4gdGhlIDI5dGggZGF5IG9mIEZlYnJ1YXJ5IG9yIHRoZSBmaWZ0aFxuICAgICAgLy8gTW9uZGF5IG9mIGEgZ2l2ZW4gbW9udGguIFRoZSBzdGFuZGFyZCBpc24ndCBjbGVhciBvbiB0aGUgaW50ZW5kZWRcbiAgICAgIC8vIGJlaGF2aW9yIGluIHRoZXNlIGNhc2VzLCBidXQgYGxpYmljYWxgIGF0IGxlYXN0IHdpbGwgaXRlcmF0ZSB1bnRpbCBpdFxuICAgICAgLy8gZmluZHMgYSBtYXRjaGluZyB5ZWFyLlxuICAgICAgLy8gQ0FSRUZVTDogU29tZSBydWxlcyBtYXkgc3BlY2lmeSBhbiBvY2N1cnJlbmNlIHRoYXQgY2FuIG5ldmVyIGhhcHBlbixcbiAgICAgIC8vIGUuZy4gdGhlIGZpcnN0IE1vbmRheSBvZiBBcHJpbCBzbyBsb25nIGFzIGl0IGZhbGxzIG9uIHRoZSAxNXRoXG4gICAgICAvLyB0aHJvdWdoIHRoZSAyMXN0LiBEZXRlY3RpbmcgdGhlc2UgaXMgbm9uLXRyaXZpYWwsIHNvIGVuc3VyZSB0aGF0IHdlXG4gICAgICAvLyBzdG9wIGl0ZXJhdGluZyBhdCBzb21lIHBvaW50LlxuICAgICAgY29uc3QgdW50aWxZZWFyID0gdGhpcy5ydWxlLnVudGlsID8gdGhpcy5ydWxlLnVudGlsLnllYXIgOiAyMDAwMDtcbiAgICAgIHdoaWxlICh0aGlzLmxhc3QueWVhciA8PSB1bnRpbFllYXIpIHtcbiAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgaWYgKHRoaXMuZGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcih0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXlzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVjdXJyZW5jZVJ1bGVFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiKSB7XG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIGxldCB0ZW1wTGFzdCA9IG51bGw7XG4gICAgICAgIGxldCBpbml0TGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuXG4gICAgICAgIC8vIENoZWNrIGV2ZXJ5IHdlZWtkYXkgaW4gQllEQVkgd2l0aCByZWxhdGl2ZSBkb3cgYW5kIHBvcy5cbiAgICAgICAgZm9yIChsZXQgYnlkb3cgb2YgdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgdGhpcy5sYXN0ID0gaW5pdExhc3QuY2xvbmUoKTtcbiAgICAgICAgICBsZXQgW3BvcywgZG93XSA9IHRoaXMucnVsZURheU9mV2VlayhieWRvdyk7XG4gICAgICAgICAgbGV0IGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG5cbiAgICAgICAgICAvLyBJZiB8cG9zfCA+PSA2LCB0aGUgYnlkYXkgaXMgaW52YWxpZCBmb3IgYSBtb250aGx5IHJ1bGUuXG4gICAgICAgICAgaWYgKHBvcyA+PSA2IHx8IHBvcyA8PSAtNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgQnlkYXkgd2l0aCBwb3M9Ky8tNSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgbW9udGggaXRcbiAgICAgICAgICAvLyBtdXN0IGJlIHNlYXJjaGVkIGluIHRoZSBuZXh0IG1vbnRocy5cbiAgICAgICAgICBpZiAoZGF5T2ZNb250aCA+IGRheXNJbk1vbnRoIHx8IGRheU9mTW9udGggPD0gMCkge1xuICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSBoYXZlIGFscmVhZHkgZm91bmQgYSBcImxhc3RcIiBpbiB0aGlzIG1vbnRoLlxuICAgICAgICAgICAgaWYgKHRlbXBMYXN0ICYmIHRlbXBMYXN0Lm1vbnRoID09IGluaXRMYXN0Lm1vbnRoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgICAgICAgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgICAgICBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlPZk1vbnRoO1xuICAgICAgICAgIGlmICghdGVtcExhc3QgfHwgdGhpcy5sYXN0LmNvbXBhcmUodGVtcExhc3QpIDwgMCkge1xuICAgICAgICAgICAgdGVtcExhc3QgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0ID0gdGVtcExhc3QuY2xvbmUoKTtcblxuICAgICAgICAvL1hYWDogVGhpcyBmZWVscyBsaWtlIGEgaGFjaywgYnV0IHdlIG5lZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAvLyAgICAgdGhlIEJZTU9OVEhEQVkgY2FzZSBjb3JyZWN0bHkgYW5kIGJ5RGF5QW5kTW9udGhEYXkgaGFuZGxlc1xuICAgICAgICAvLyAgICAgdGhpcyBjYXNlLiBJdCBhY2NlcHRzIGEgc3BlY2lhbCBmbGFnIHdoaWNoIHdpbGwgYXZvaWQgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vICAgICB0aGUgaW5pdGlhbCB2YWx1ZSB3aXRob3V0IHRoZSBmbGFnIGRheXMgdGhhdCBtYXRjaCB0aGUgc3RhcnQgdGltZVxuICAgICAgICAvLyAgICAgd291bGQgYmUgbWlzc2VkLlxuICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YSgnQllNT05USERBWScpKSB7XG4gICAgICAgICAgdGhpcy5fYnlEYXlBbmRNb250aERheSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGggfHwgdGhpcy5sYXN0LmRheSA9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWU1PTlRIREFZXCIpKSB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgZGF5IHZhbHVlIHNvIHRoYXQgbm9ybWFsaXNhdGlvbiB3b24ndCBjaGFuZ2UgdGhlIG1vbnRoLlxuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcblxuICAgICAgICAvLyBHZXQgYSBzb3J0ZWQgbGlzdCBvZiBkYXlzIGluIHRoZSBzdGFydGluZyBtb250aCB0aGF0IG1hdGNoIHRoZSBydWxlLlxuICAgICAgICBsZXQgbm9ybWFsaXplZCA9IHRoaXMubm9ybWFsaXplQnlNb250aERheVJ1bGVzKFxuICAgICAgICAgIHRoaXMubGFzdC55ZWFyLFxuICAgICAgICAgIHRoaXMubGFzdC5tb250aCxcbiAgICAgICAgICB0aGlzLnJ1bGUucGFydHMuQllNT05USERBWVxuICAgICAgICApLmZpbHRlcihkID0+IGQgPj0gdGhpcy5sYXN0LmRheSk7XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBhdCBsZWFzdCBvbmUgdmFsaWQgZGF5LCB1c2UgaXQuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IG5vcm1hbGl6ZWRbMF07XG4gICAgICAgICAgdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkgPSBub3JtYWxpemVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gb2NjdXJyZW5jZSBpbiB0aGlzIG1vbnRoLCBmaW5kIHRoZSBuZXh0IHZhbGlkIG1vbnRoLlxuICAgICAgICAgIC8vIFRoZSBsb25nZXN0IHBvc3NpYmxlIHNlcXVlbmNlIG9mIHNraXBwZWQgbW9udGhzIGlzIEZlYnJ1YXJ5LUFwcmlsLUp1bmUsXG4gICAgICAgICAgLy8gc28gd2UgbWlnaHQgbmVlZCB0byBjYWxsIG5leHRfbW9udGggdXAgdG8gdGhyZWUgdGltZXMuXG4gICAgICAgICAgaWYgKCF0aGlzLm5leHRfbW9udGgoKSAmJiAhdGhpcy5uZXh0X21vbnRoKCkgJiYgIXRoaXMubmV4dF9tb250aCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwb3NzaWJsZSBvY2N1cnJlbmNlc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIG5leHQgb2NjdXJyZW5jZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICogQHJldHVybiB7VGltZX1cbiAgICovXG4gIG5leHQoYWdhaW4gPSBmYWxzZSkge1xuICAgIGxldCBiZWZvcmUgPSAodGhpcy5sYXN0ID8gdGhpcy5sYXN0LmNsb25lKCkgOiBudWxsKTtcblxuICAgIGlmICgodGhpcy5ydWxlLmNvdW50ICYmIHRoaXMub2NjdXJyZW5jZV9udW1iZXIgPj0gdGhpcy5ydWxlLmNvdW50KSB8fFxuICAgICAgICAodGhpcy5ydWxlLnVudGlsICYmIHRoaXMubGFzdC5jb21wYXJlKHRoaXMucnVsZS51bnRpbCkgPiAwKSkge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub2NjdXJyZW5jZV9udW1iZXIgPT0gMCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLmR0c3RhcnQpID49IDApIHtcbiAgICAgIC8vIEZpcnN0IG9mIGFsbCwgZ2l2ZSB0aGUgaW5zdGFuY2UgdGhhdCB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgIHJldHVybiB0aGlzLmxhc3Q7XG4gICAgfVxuXG4gICAgbGV0IHZhbGlkO1xuICAgIGRvIHtcbiAgICAgIHZhbGlkID0gMTtcblxuICAgICAgc3dpdGNoICh0aGlzLnJ1bGUuZnJlcSkge1xuICAgICAgY2FzZSBcIlNFQ09ORExZXCI6XG4gICAgICAgIHRoaXMubmV4dF9zZWNvbmQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTUlOVVRFTFlcIjpcbiAgICAgICAgdGhpcy5uZXh0X21pbnV0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIT1VSTFlcIjpcbiAgICAgICAgdGhpcy5uZXh0X2hvdXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREFJTFlcIjpcbiAgICAgICAgdGhpcy5uZXh0X2RheSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJXRUVLTFlcIjpcbiAgICAgICAgdGhpcy5uZXh0X3dlZWsoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTU9OVEhMWVwiOlxuICAgICAgICB2YWxpZCA9IHRoaXMubmV4dF9tb250aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJZRUFSTFlcIjpcbiAgICAgICAgdGhpcy5uZXh0X3llYXIoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCF0aGlzLmNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkgfHxcbiAgICAgICAgICAgICB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCB8fFxuICAgICAgICAgICAgICF2YWxpZCk7XG5cbiAgICBpZiAodGhpcy5sYXN0LmNvbXBhcmUoYmVmb3JlKSA9PSAwKSB7XG4gICAgICBpZiAoYWdhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2FtZSBvY2N1cnJlbmNlIGZvdW5kIHR3aWNlLCBwcm90ZWN0aW5nIHlvdSBmcm9tIGRlYXRoIGJ5IHJlY3Vyc2lvblwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ydWxlLnVudGlsICYmIHRoaXMubGFzdC5jb21wYXJlKHRoaXMucnVsZS51bnRpbCkgPiAwKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICB9XG4gIH1cblxuICBuZXh0X3NlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIFwic2Vjb25kXCIsIFwibWludXRlXCIpO1xuICB9XG5cbiAgaW5jcmVtZW50X3NlY29uZChpbmMpIHtcbiAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwic2Vjb25kXCIsIDYwLCBcIm1pbnV0ZVwiKTtcbiAgfVxuXG4gIG5leHRfbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLm5leHRfZ2VuZXJpYyhcIkJZTUlOVVRFXCIsIFwiTUlOVVRFTFlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVcIiwgXCJob3VyXCIsIFwibmV4dF9zZWNvbmRcIik7XG4gIH1cblxuICBpbmNyZW1lbnRfbWludXRlKGluYykge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJtaW51dGVcIiwgNjAsIFwiaG91clwiKTtcbiAgfVxuXG4gIG5leHRfaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWUhPVVJcIiwgXCJIT1VSTFlcIiwgXCJob3VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibW9udGhkYXlcIiwgXCJuZXh0X21pbnV0ZVwiKTtcbiAgfVxuXG4gIGluY3JlbWVudF9ob3VyKGluYykge1xuICAgIHRoaXMuaW5jcmVtZW50X2dlbmVyaWMoaW5jLCBcImhvdXJcIiwgMjQsIFwibW9udGhkYXlcIik7XG4gIH1cblxuICBuZXh0X2RheSgpIHtcbiAgICBsZXQgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiREFJTFlcIik7XG5cbiAgICBpZiAodGhpcy5uZXh0X2hvdXIoKSA9PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpc19mcmVxKSB7XG4gICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIG5leHRfd2VlaygpIHtcbiAgICBsZXQgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgaWYgKHRoaXMubmV4dF93ZWVrZGF5X2J5X3dlZWsoKSA9PSAwKSB7XG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWVdFRUtOT1wiKSkge1xuICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PKys7XG5cbiAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPT0gdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPSAwO1xuICAgICAgICBlbmRfb2ZfZGF0YSA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIEhBQ0sgc2hvdWxkIGJlIGZpcnN0IG1vbnRoIG9mIHRoZSB5ZWFyXG4gICAgICB0aGlzLmxhc3QubW9udGggPSAxO1xuICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG5cbiAgICAgIGxldCB3ZWVrX25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOT107XG5cbiAgICAgIHRoaXMubGFzdC5kYXkgKz0gNyAqIHdlZWtfbm87XG5cbiAgICAgIGlmIChlbmRfb2ZfZGF0YSkge1xuICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKdW1wIHRvIHRoZSBuZXh0IHdlZWtcbiAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoZGF5KDcgKiB0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgZWFjaCBieSBkYXkgcnVsZSBmb3IgYSBnaXZlbiB5ZWFyL21vbnRoLlxuICAgKiBUYWtlcyBpbnRvIGFjY291bnQgb3JkZXJpbmcgYW5kIG5lZ2F0aXZlIHJ1bGVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgICAgQ3VycmVudCB5ZWFyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICAgIEN1cnJlbnQgbW9udGguXG4gICAqIEBwYXJhbSB7QXJyYXl9ICBydWxlcyAgICAgICAgQXJyYXkgb2YgcnVsZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3J0ZWQgYW5kIG5vcm1hbGl6ZWQgcnVsZXMuXG4gICAqICAgICAgICAgICAgICAgICBOZWdhdGl2ZSBydWxlcyB3aWxsIGJlIGV4cGFuZGVkIHRvIHRoZWlyXG4gICAqICAgICAgICAgICAgICAgICBjb3JyZWN0IHBvc2l0aXZlIHZhbHVlcyBmb3IgZWFzaWVyIHByb2Nlc3NpbmcuXG4gICAqL1xuICBub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMoeWVhciwgbW9udGgsIHJ1bGVzKSB7XG4gICAgbGV0IGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aChtb250aCwgeWVhcik7XG5cbiAgICAvLyBYWFg6IFRoaXMgaXMgcHJvYmFibHkgYmFkIGZvciBwZXJmb3JtYW5jZSB0byBhbGxvY2F0ZVxuICAgIC8vICAgICAgYSBuZXcgYXJyYXkgZm9yIGVhY2ggbW9udGggd2Ugc2NhbiwgaWYgcG9zc2libGVcbiAgICAvLyAgICAgIHdlIHNob3VsZCB0cnkgdG8gb3B0aW1pemUgdGhpcy4uLlxuICAgIGxldCBuZXdSdWxlcyA9IFtdO1xuXG4gICAgbGV0IHJ1bGVJZHggPSAwO1xuICAgIGxldCBsZW4gPSBydWxlcy5sZW5ndGg7XG4gICAgbGV0IHJ1bGU7XG5cbiAgICBmb3IgKDsgcnVsZUlkeCA8IGxlbjsgcnVsZUlkeCsrKSB7XG4gICAgICBydWxlID0gcGFyc2VJbnQocnVsZXNbcnVsZUlkeF0sIDEwKTtcbiAgICAgIGlmIChpc05hTihydWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQllNT05USERBWSB2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGlzIHJ1bGUgZmFsbHMgb3V0c2lkZSBvZiBnaXZlblxuICAgICAgLy8gbW9udGggZGlzY2FyZCBpdC5cbiAgICAgIGlmIChNYXRoLmFicyhydWxlKSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBuZWdhdGl2ZSBjYXNlXG4gICAgICBpZiAocnVsZSA8IDApIHtcbiAgICAgICAgLy8gd2UgYWRkIChub3Qgc3VidHJhY3QgaXQgaXMgYSBuZWdhdGl2ZSBudW1iZXIpXG4gICAgICAgIC8vIG9uZSBmcm9tIHRoZSBydWxlIGJlY2F1c2UgMSA9PT0gbGFzdCBkYXkgb2YgbW9udGhcbiAgICAgICAgcnVsZSA9IGRheXNJbk1vbnRoICsgKHJ1bGUgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAocnVsZSA9PT0gMCkge1xuICAgICAgICAvLyBza2lwIHplcm86IGl0IGlzIGludmFsaWQuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGFkZCB1bmlxdWUgaXRlbXMuLi5cbiAgICAgIGlmIChuZXdSdWxlcy5pbmRleE9mKHJ1bGUpID09PSAtMSkge1xuICAgICAgICBuZXdSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gdW5pcXVlIGFuZCBzb3J0XG4gICAgcmV0dXJuIG5ld1J1bGVzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE5PVEVTOlxuICAgKiBXZSBhcmUgZ2l2ZW4gYSBsaXN0IG9mIGRhdGVzIGluIHRoZSBtb250aCAoQllNT05USERBWSkgKDIzLCBldGMuLilcbiAgICogQWxzbyB3ZSBhcmUgZ2l2ZW4gYSBsaXN0IG9mIGRheXMgKEJZREFZKSAoTU8sIDJTVSwgZXRjLi4pIHdoZW5cbiAgICogYm90aCBjb25kaXRpb25zIG1hdGNoIGEgZ2l2ZW4gZGF0ZSAodGhpcy5sYXN0LmRheSkgaXRlcmF0aW9uIHN0b3BzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBpc0luaXQgICAgIFdoZW4gZ2l2ZW4gdHJ1ZSB3aWxsIG5vdCBpbmNyZW1lbnQgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50IGRheSAodGhpcy5sYXN0KS5cbiAgICovXG4gIF9ieURheUFuZE1vbnRoRGF5KGlzSW5pdCkge1xuICAgIGxldCBieU1vbnRoRGF5OyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICBsZXQgYnlEYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVk7XG5cbiAgICBsZXQgZGF0ZTtcbiAgICBsZXQgZGF0ZUlkeCA9IDA7XG4gICAgbGV0IGRhdGVMZW47IC8vIHNldHVwIGluIGluaXRNb250aFxuICAgIGxldCBkYXlMZW4gPSBieURheS5sZW5ndGg7XG5cbiAgICAvLyB3ZSBhcmUgbm90IHZhbGlkIGJ5IGRlZmF1bHRcbiAgICBsZXQgZGF0YUlzVmFsaWQgPSAwO1xuXG4gICAgbGV0IGRheXNJbk1vbnRoO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAvLyB3ZSBuZWVkIGEgY29weSBvZiB0aGlzLCBiZWNhdXNlIGEgRGF0ZVRpbWUgZ2V0cyBub3JtYWxpemVkXG4gICAgLy8gYXV0b21hdGljYWxseSBpZiB0aGUgZGF5IGlzIG91dCBvZiByYW5nZS4gQXQgc29tZSBwb2ludHMgd2VcbiAgICAvLyBzZXQgdGhlIGxhc3QgZGF5IHRvIDAgdG8gc3RhcnQgY291bnRpbmcuXG4gICAgbGV0IGxhc3REYXkgPSB0aGlzLmxhc3QuZGF5O1xuXG4gICAgZnVuY3Rpb24gaW5pdE1vbnRoKCkge1xuICAgICAgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKFxuICAgICAgICBzZWxmLmxhc3QubW9udGgsIHNlbGYubGFzdC55ZWFyXG4gICAgICApO1xuXG4gICAgICBieU1vbnRoRGF5ID0gc2VsZi5ub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMoXG4gICAgICAgIHNlbGYubGFzdC55ZWFyLFxuICAgICAgICBzZWxmLmxhc3QubW9udGgsXG4gICAgICAgIHNlbGYuYnlfZGF0YS5CWU1PTlRIREFZXG4gICAgICApO1xuXG4gICAgICBkYXRlTGVuID0gYnlNb250aERheS5sZW5ndGg7XG5cbiAgICAgIC8vIEZvciB0aGUgY2FzZSBvZiBtb3JlIHRoYW4gb25lIG9jY3VycmVuY2UgaW4gb25lIG1vbnRoXG4gICAgICAvLyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gc3RhcnQgc2VhcmNoaW5nIGFmdGVyIHRoZSBsYXN0XG4gICAgICAvLyBmb3VuZCBkYXRlIG9yIGF0IHRoZSBsYXN0IEJZTU9OVEhEQVksIHVubGVzcyB3ZSBhcmVcbiAgICAgIC8vIGluaXRpYWxpemluZyB0aGUgaXRlcmF0b3IgYmVjYXVzZSBpbiB0aGlzIGNhc2Ugd2UgaGF2ZVxuICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGxhc3QgZm91bmQgZGF0ZSB0b28uXG4gICAgICB3aGlsZSAoYnlNb250aERheVtkYXRlSWR4XSA8PSBsYXN0RGF5ICYmXG4gICAgICAgICAgICAgIShpc0luaXQgJiYgYnlNb250aERheVtkYXRlSWR4XSA9PSBsYXN0RGF5KSAmJlxuICAgICAgICAgICAgIGRhdGVJZHggPCBkYXRlTGVuIC0gMSkge1xuICAgICAgICBkYXRlSWR4Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgLy8gc2luY2UgdGhlIGRheSBpcyBpbmNyZW1lbnRlZCBhdCB0aGUgc3RhcnRcbiAgICAgIC8vIG9mIHRoZSBsb29wIGJlbG93LCB3ZSBuZWVkIHRvIHN0YXJ0IGF0IDBcbiAgICAgIGxhc3REYXkgPSAwO1xuICAgICAgc2VsZi5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgIGRhdGVJZHggPSAwO1xuICAgICAgaW5pdE1vbnRoKCk7XG4gICAgfVxuXG4gICAgaW5pdE1vbnRoKCk7XG5cbiAgICAvLyBzaG91bGQgY29tZSBhZnRlciBpbml0TW9udGhcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBsYXN0RGF5IC09IDE7XG4gICAgfVxuXG4gICAgLy8gVXNlIGEgY291bnRlciB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIHdpdGggbWFsZm9ybWVkIHJ1bGVzLlxuICAgIC8vIFN0b3AgY2hlY2tpbmcgYWZ0ZXIgNCB5ZWFycyBzbyB3ZSBjb25zaWRlciBhbHNvIGEgbGVhcCB5ZWFyLlxuICAgIGxldCBtb250aHNDb3VudGVyID0gNDg7XG5cbiAgICB3aGlsZSAoIWRhdGFJc1ZhbGlkICYmIG1vbnRoc0NvdW50ZXIpIHtcbiAgICAgIG1vbnRoc0NvdW50ZXItLTtcbiAgICAgIC8vIGluY3JlbWVudCB0aGUgY3VycmVudCBkYXRlLiBUaGlzIGlzIHJlYWxseVxuICAgICAgLy8gaW1wb3J0YW50IG90aGVyd2lzZSB3ZSBtYXkgZmFsbCBpbnRvIHRoZSBpbmZpbml0ZVxuICAgICAgLy8gbG9vcCB0cmFwLiBUaGUgaW5pdGlhbCBkYXRlIHRha2VzIGNhcmUgb2YgdGhlIGNhc2VcbiAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IGRhdGUgaXMgdGhlIGRhdGUgd2UgYXJlIGxvb2tpbmdcbiAgICAgIC8vIGZvci5cbiAgICAgIGRhdGUgPSBsYXN0RGF5ICsgMTtcblxuICAgICAgaWYgKGRhdGUgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgbmV4dCBkYXRlXG4gICAgICBsZXQgbmV4dCA9IGJ5TW9udGhEYXlbZGF0ZUlkeCsrXTtcblxuICAgICAgLy8gdGhpcyBsb2dpYyBpcyBkZXBlbmRlbnQgb24gdGhlIEJZTU9OVEhEQVlTXG4gICAgICAvLyBiZWluZyBpbiBvcmRlciAod2hpY2ggaXMgZG9uZSBieSAjbm9ybWFsaXplQnlNb250aERheVJ1bGVzKVxuICAgICAgaWYgKG5leHQgPj0gZGF0ZSkge1xuICAgICAgICAvLyBpZiB0aGUgbmV4dCBtb250aCBkYXkgaXMgaW4gdGhlIGZ1dHVyZSBqdW1wIHRvIGl0LlxuICAgICAgICBsYXN0RGF5ID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgJ25leHQnIG1vbnRoZGF5IGhhcyBwYXN0XG4gICAgICAgIC8vIHdlIG11c3QgbW92ZSB0byB0aGUgbW9udGguXG4gICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHdlIGNhbiBsb29wIHRocm91Z2ggdGhlIGRheSBydWxlcyB0byBzZWVcbiAgICAgIC8vIGlmIG9uZSBtYXRjaGVzIHRoZSBjdXJyZW50IG1vbnRoIGRhdGUuXG4gICAgICBmb3IgKGxldCBkYXlJZHggPSAwOyBkYXlJZHggPCBkYXlMZW47IGRheUlkeCsrKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhieURheVtkYXlJZHhdKTtcbiAgICAgICAgbGV0IHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICBsZXQgZG93ID0gcGFydHNbMV07XG5cbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3REYXk7XG4gICAgICAgIGlmICh0aGlzLmxhc3QuaXNOdGhXZWVrRGF5KGRvdywgcG9zKSkge1xuICAgICAgICAgIC8vIHdoZW4gd2UgZmluZCB0aGUgdmFsaWQgb25lIHdlIGNhbiBtYXJrXG4gICAgICAgICAgLy8gdGhlIGNvbmRpdGlvbnMgYXMgbWV0IGFuZCBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgICAvLyAoQmVjYXVzZSB3ZSBoYXZlIHRoaXMgY29uZGl0aW9uIGFib3ZlXG4gICAgICAgICAgLy8gIGl0IHdpbGwgYWxzbyBicmVhayB0aGUgcGFyZW50IGxvb3ApLlxuICAgICAgICAgIGRhdGFJc1ZhbGlkID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJdCBpcyBjb21wbGV0ZWx5IHBvc3NpYmxlIHRoYXQgdGhlIGNvbWJpbmF0aW9uXG4gICAgICAvLyBjYW5ub3QgYmUgbWF0Y2hlZCBpbiB0aGUgY3VycmVudCBtb250aC5cbiAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiBwb3NzaWJsZSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIGluIHRoZSBjdXJyZW50IG1vbnRoIHdlIGl0ZXJhdGUgdG8gdGhlIG5leHQgb25lLlxuICAgICAgLy8gc2luY2UgZGF0ZUlkeCBpcyBpbmNyZW1lbnRlZCByaWdodCBhZnRlciBnZXR0aW5nXG4gICAgICAvLyBcIm5leHRcIiwgd2UgZG9uJ3QgbmVlZCBkYXRlTGVuIC0xIGhlcmUuXG4gICAgICBpZiAoIWRhdGFJc1ZhbGlkICYmIGRhdGVJZHggPT09IGRhdGVMZW4pIHtcbiAgICAgICAgbmV4dE1vbnRoKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb250aHNDb3VudGVyIDw9IDApIHtcbiAgICAgIC8vIENoZWNrZWQgNCB5ZWFycyB3aXRob3V0IGZpbmRpbmcgYSBCeWRheSB0aGF0IG1hdGNoZXNcbiAgICAgIC8vIGEgQnltb250aGRheS4gTWF5YmUgdGhlIHJ1bGUgaXMgbm90IGNvcnJlY3QuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIGNvbWJpbmVkIHdpdGggQllNT05USERBWSBwYXJ0c1wiKTtcbiAgICB9XG5cblxuICAgIHJldHVybiBkYXRhSXNWYWxpZDtcbiAgfVxuXG4gIG5leHRfbW9udGgoKSB7XG4gICAgbGV0IGRhdGFfdmFsaWQgPSAxO1xuXG4gICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgZGF0YV92YWxpZCA9IHRoaXMuX2J5RGF5QW5kTW9udGhEYXkoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSkge1xuICAgICAgbGV0IGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgIGxldCBzZXRwb3MgPSAwO1xuICAgICAgbGV0IHNldHBvc190b3RhbCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgbGV0IGxhc3RfZGF5ID0gdGhpcy5sYXN0LmRheTtcbiAgICAgICAgZm9yIChsZXQgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHRoaXMubGFzdCkpIHtcbiAgICAgICAgICAgIHNldHBvc190b3RhbCsrO1xuICAgICAgICAgICAgaWYgKGRheSA8PSBsYXN0X2RheSkge1xuICAgICAgICAgICAgICBzZXRwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3RfZGF5O1xuICAgICAgfVxuXG4gICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgIGxldCBkYXk7XG4gICAgICBmb3IgKGRheSA9IHRoaXMubGFzdC5kYXkgKyAxOyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSsrKSB7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHRoaXMubGFzdCkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSB8fFxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbigrK3NldHBvcykgfHxcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oc2V0cG9zIC0gc2V0cG9zX3RvdGFsIC0gMSkpIHtcblxuICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHwgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oMSkpIHtcbiAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWU1PTlRIREFZKys7XG5cbiAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA+PSB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPSAwO1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPj0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgIGxldCBkYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVt0aGlzLmJ5X2luZGljZXMuQllNT05USERBWV07XG5cbiAgICAgIGlmIChkYXkgPCAwKSB7XG4gICAgICAgIGRheSA9IGRheXNJbk1vbnRoICsgZGF5ICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZWzBdID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgZGF0YV92YWxpZCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gIH1cblxuICBuZXh0X3dlZWtkYXlfYnlfd2VlaygpIHtcbiAgICBsZXQgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBsZXQgdHQgPSBuZXcgVGltZSgpO1xuICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZREFZKys7XG5cbiAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllEQVkgPT0gT2JqZWN0LmtleXModGhpcy5ieV9kYXRhLkJZREFZKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZREFZID0gMDtcbiAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29kZWRfZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW3RoaXMuYnlfaW5kaWNlcy5CWURBWV07XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgIGxldCBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgZG93IC09IHRoaXMucnVsZS53a3N0O1xuXG4gICAgICBpZiAoZG93IDwgMCkge1xuICAgICAgICBkb3cgKz0gNztcbiAgICAgIH1cblxuICAgICAgdHQueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgdHQubW9udGggPSB0aGlzLmxhc3QubW9udGg7XG4gICAgICB0dC5kYXkgPSB0aGlzLmxhc3QuZGF5O1xuXG4gICAgICBsZXQgc3RhcnRPZldlZWsgPSB0dC5zdGFydERveVdlZWsodGhpcy5ydWxlLndrc3QpO1xuXG4gICAgICBpZiAoZG93ICsgc3RhcnRPZldlZWsgPCAxKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RlZCBkYXRlIGlzIGluIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICAgIGlmICghZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgbmV4dCA9IFRpbWUuZnJvbURheU9mWWVhcihzdGFydE9mV2VlayArIGRvdywgdGhpcy5sYXN0LnllYXIpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBub3JtYWxpemF0aW9uIGhvcnJvcnMgYmVsb3cgYXJlIGR1ZSB0b1xuICAgICAgICogdGhlIGZhY3QgdGhhdCB3aGVuIHRoZSB5ZWFyL21vbnRoL2RheSBjaGFuZ2VzXG4gICAgICAgKiBpdCBjYW4gZWZmZWN0IHRoZSBvdGhlciBvcGVyYXRpb25zIHRoYXQgY29tZSBhZnRlci5cbiAgICAgICAqL1xuICAgICAgdGhpcy5sYXN0LnllYXIgPSBuZXh0LnllYXI7XG4gICAgICB0aGlzLmxhc3QubW9udGggPSBuZXh0Lm1vbnRoO1xuICAgICAgdGhpcy5sYXN0LmRheSA9IG5leHQuZGF5O1xuXG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfVxuICB9XG5cbiAgbmV4dF95ZWFyKCkge1xuICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICgrK3RoaXMuZGF5c19pbmRleCA9PSB0aGlzLmRheXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRheXNfaW5kZXggPSAwO1xuICAgICAgZG8ge1xuICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICAgIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZID0gdGhpcy5ub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMoXG4gICAgICAgICAgICB0aGlzLmxhc3QueWVhcixcbiAgICAgICAgICAgIHRoaXMubGFzdC5tb250aCxcbiAgICAgICAgICAgIHRoaXMucnVsZS5wYXJ0cy5CWU1PTlRIREFZXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGFuZF95ZWFyX2RheXModGhpcy5sYXN0LnllYXIpO1xuICAgICAgfSB3aGlsZSAodGhpcy5kYXlzLmxlbmd0aCA9PSAwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIF9uZXh0QnlZZWFyRGF5KCkge1xuICAgIGxldCBkb3kgPSB0aGlzLmRheXNbdGhpcy5kYXlzX2luZGV4XTtcbiAgICBsZXQgeWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICAgIC8vIFRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpIGluZGV4ZXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBnaXZlbiB5ZWFyLiBUaGF0IGlzIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgQllZRUFSREFZIHdoZXJlIG5lZ2F0aXZlIGluZGV4ZXMgYXJlIGFuXG4gICAgICAgIC8vIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHllYXIuXG4gICAgICAgIGRveSArPSAxO1xuICAgICAgICB5ZWFyICs9IDE7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgdGhpcy5sYXN0LmRheSA9IG5leHQuZGF5O1xuICAgIHRoaXMubGFzdC5tb250aCA9IG5leHQubW9udGg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGRvdyAoZWc6ICcxVFUnLCAnLTFNTycpXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheVxuICAgKiBAcmV0dXJuIFtwb3MsIG51bWVyaWNEb3ddIChlZzogWzEsIDNdKSBudW1lcmljRG93IGlzIHJlbGF0aXZlIHRvIGFXZWVrU3RhcnRcbiAgICovXG4gIHJ1bGVEYXlPZldlZWsoZG93LCBhV2Vla1N0YXJ0KSB7XG4gICAgbGV0IG1hdGNoZXMgPSBkb3cubWF0Y2goLyhbKy1dP1swLTldKT8oTU98VFV8V0V8VEh8RlJ8U0F8U1UpLyk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIGxldCBwb3MgPSBwYXJzZUludChtYXRjaGVzWzFdIHx8IDAsIDEwKTtcbiAgICAgIGRvdyA9IFJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkobWF0Y2hlc1syXSwgYVdlZWtTdGFydCk7XG4gICAgICByZXR1cm4gW3BvcywgZG93XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gIH1cblxuICBuZXh0X2dlbmVyaWMoYVJ1bGVUeXBlLCBhSW50ZXJ2YWwsIGFEYXRlQXR0ciwgYUZvbGxvd2luZ0F0dHIsIGFQcmV2aW91c0luY3IpIHtcbiAgICBsZXQgaGFzX2J5X3J1bGUgPSAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgbGV0IHRoaXNfZnJlcSA9ICh0aGlzLnJ1bGUuZnJlcSA9PSBhSW50ZXJ2YWwpO1xuICAgIGxldCBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICBpZiAoYVByZXZpb3VzSW5jciAmJiB0aGlzW2FQcmV2aW91c0luY3JdKCkgPT0gMCkge1xuICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgIH1cblxuICAgIGlmIChoYXNfYnlfcnVsZSkge1xuICAgICAgdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0rKztcbiAgICAgIGxldCBkdGEgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdID09IGR0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPSAwO1xuICAgICAgICBlbmRfb2ZfZGF0YSA9IDE7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSA9IGR0YVt0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXV07XG4gICAgfSBlbHNlIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhRGF0ZUF0dHJdKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgaWYgKGhhc19ieV9ydWxlICYmIGVuZF9vZl9kYXRhICYmIHRoaXNfZnJlcSkge1xuICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFGb2xsb3dpbmdBdHRyXSgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gIH1cblxuICBpbmNyZW1lbnRfbW9udGhkYXkoaW5jKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmM7IGkrKykge1xuICAgICAgbGV0IGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgIHRoaXMubGFzdC5kYXkrKztcblxuICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICB0aGlzLmxhc3QuZGF5IC09IGRheXNJbk1vbnRoO1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluY3JlbWVudF9tb250aCgpIHtcbiAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhcIikpIHtcbiAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWU1PTlRIKys7XG5cbiAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USCA9PSB0aGlzLmJ5X2RhdGEuQllNT05USC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPSAwO1xuICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3QubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFt0aGlzLmJ5X2luZGljZXMuQllNT05USF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIikge1xuICAgICAgICB0aGlzLmxhc3QubW9udGggKz0gdGhpcy5ydWxlLmludGVydmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdC5tb250aC0tO1xuICAgICAgbGV0IHllYXJzID0gdHJ1bmModGhpcy5sYXN0Lm1vbnRoIC8gMTIpO1xuICAgICAgdGhpcy5sYXN0Lm1vbnRoICU9IDEyO1xuICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG5cbiAgICAgIGlmICh5ZWFycyAhPSAwKSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoeWVhcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkgPSB0aGlzLm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyhcbiAgICAgICAgdGhpcy5sYXN0LnllYXIsXG4gICAgICAgIHRoaXMubGFzdC5tb250aCxcbiAgICAgICAgdGhpcy5ydWxlLnBhcnRzLkJZTU9OVEhEQVlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaW5jcmVtZW50X3llYXIoaW5jKSB7XG4gICAgLy8gRG9uJ3QganVtcCBpbnRvIHRoZSBuZXh0IG1vbnRoIGlmIHRoaXMubGFzdCBpcyBGZWIgMjkuXG4gICAgdGhpcy5sYXN0LmRheSA9IDE7XG4gICAgdGhpcy5sYXN0LnllYXIgKz0gaW5jO1xuICB9XG5cbiAgaW5jcmVtZW50X2dlbmVyaWMoaW5jLCBhRGF0ZUF0dHIsIGFGYWN0b3IsIGFOZXh0SW5jcmVtZW50KSB7XG4gICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gKz0gaW5jO1xuICAgIGxldCBuZXh0dW5pdCA9IHRydW5jKHRoaXMubGFzdFthRGF0ZUF0dHJdIC8gYUZhY3Rvcik7XG4gICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gJT0gYUZhY3RvcjtcbiAgICBpZiAobmV4dHVuaXQgIT0gMCkge1xuICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFOZXh0SW5jcmVtZW50XShuZXh0dW5pdCk7XG4gICAgfVxuICB9XG5cbiAgaGFzX2J5X2RhdGEoYVJ1bGVUeXBlKSB7XG4gICAgcmV0dXJuIChhUnVsZVR5cGUgaW4gdGhpcy5ydWxlLnBhcnRzKTtcbiAgfVxuXG4gIGV4cGFuZF95ZWFyX2RheXMoYVllYXIpIHtcbiAgICBsZXQgdCA9IG5ldyBUaW1lKCk7XG4gICAgdGhpcy5kYXlzID0gW107XG5cbiAgICAvLyBXZSBuZWVkIG91ciBvd24gY29weSB3aXRoIGEgZmV3IGtleXMgc2V0XG4gICAgbGV0IHBhcnRzID0ge307XG4gICAgbGV0IHJ1bGVzID0gW1wiQllEQVlcIiwgXCJCWVdFRUtOT1wiLCBcIkJZTU9OVEhEQVlcIiwgXCJCWU1PTlRIXCIsIFwiQllZRUFSREFZXCJdO1xuICAgIGZvciAobGV0IHBhcnQgb2YgcnVsZXMpIHtcbiAgICAgIGlmIChwYXJ0IGluIHRoaXMucnVsZS5wYXJ0cykge1xuICAgICAgICBwYXJ0c1twYXJ0XSA9IHRoaXMucnVsZS5wYXJ0c1twYXJ0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICBsZXQgdmFsaWQgPSAxO1xuICAgICAgbGV0IHZhbGlkV2Vla3MgPSB7fTtcbiAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgdC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKGxldCBtb250aElkeCA9IDA7IG1vbnRoSWR4IDwgdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoOyBtb250aElkeCsrKSB7XG4gICAgICAgIGxldCBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoSWR4XTtcbiAgICAgICAgdC5tb250aCA9IG1vbnRoO1xuICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgIGxldCBmaXJzdF93ZWVrID0gdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgdC5kYXkgPSBUaW1lLmRheXNJbk1vbnRoKG1vbnRoLCBhWWVhcik7XG4gICAgICAgIGxldCBsYXN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICBmb3IgKG1vbnRoSWR4ID0gZmlyc3Rfd2VlazsgbW9udGhJZHggPCBsYXN0X3dlZWs7IG1vbnRoSWR4KyspIHtcbiAgICAgICAgICB2YWxpZFdlZWtzW21vbnRoSWR4XSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgd2Vla0lkeCA9IDA7IHdlZWtJZHggPCB0aGlzLmJ5X2RhdGEuQllXRUVLTk8ubGVuZ3RoICYmIHZhbGlkOyB3ZWVrSWR4KyspIHtcbiAgICAgICAgbGV0IHdlZWtubyA9IHRoaXMuYnlfZGF0YS5CWVdFRUtOT1t3ZWVrSWR4XTtcbiAgICAgICAgaWYgKHdlZWtubyA8IDUyKSB7XG4gICAgICAgICAgdmFsaWQgJj0gdmFsaWRXZWVrc1t3ZWVrSWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgIGRlbGV0ZSBwYXJ0cy5CWU1PTlRIO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBhcnRzLkJZV0VFS05PO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwYXJ0Q291bnQgPSBPYmplY3Qua2V5cyhwYXJ0cykubGVuZ3RoO1xuXG4gICAgaWYgKHBhcnRDb3VudCA9PSAwKSB7XG4gICAgICBsZXQgdDEgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgIHQxLnllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgIHRoaXMuZGF5cy5wdXNoKHQxLmRheU9mWWVhcigpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllNT05USFwiIGluIHBhcnRzKSB7XG4gICAgICBmb3IgKGxldCBtb250aCBvZiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICBsZXQgdDIgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgdDIueWVhciA9IGFZZWFyO1xuICAgICAgICB0Mi5tb250aCA9IG1vbnRoO1xuICAgICAgICB0Mi5pc0RhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRheXMucHVzaCh0Mi5kYXlPZlllYXIoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgZm9yIChsZXQgbW9udGhkYXkgb2YgdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgbGV0IHQzID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGlmIChtb250aGRheSA8IDApIHtcbiAgICAgICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHQzLm1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgbW9udGhkYXkgPSBtb250aGRheSArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0My5kYXkgPSBtb250aGRheTtcbiAgICAgICAgdDMueWVhciA9IGFZZWFyO1xuICAgICAgICB0My5pc0RhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRheXMucHVzaCh0My5kYXlPZlllYXIoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgIFwiQllNT05USFwiIGluIHBhcnRzKSB7XG4gICAgICBmb3IgKGxldCBtb250aCBvZiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKG1vbnRoLCBhWWVhcik7XG4gICAgICAgIGZvciAobGV0IG1vbnRoZGF5IG9mIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZKSB7XG4gICAgICAgICAgaWYgKG1vbnRoZGF5IDwgMCkge1xuICAgICAgICAgICAgbW9udGhkYXkgPSBtb250aGRheSArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC5kYXkgPSBtb250aGRheTtcbiAgICAgICAgICB0Lm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5kYXlzLnB1c2godC5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykgOyBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykgOyBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgIGZvciAobGV0IG1vbnRoIG9mIHRoaXMuYnlfZGF0YS5CWU1PTlRIKSB7XG4gICAgICAgIGxldCBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgobW9udGgsIGFZZWFyKTtcblxuICAgICAgICB0LnllYXIgPSBhWWVhcjtcbiAgICAgICAgdC5tb250aCA9IG1vbnRoO1xuICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICBsZXQgZmlyc3RfZG93ID0gdC5kYXlPZldlZWsoKTtcbiAgICAgICAgbGV0IGRveV9vZmZzZXQgPSB0LmRheU9mWWVhcigpIC0gMTtcblxuICAgICAgICB0LmRheSA9IGRheXNJbk1vbnRoO1xuICAgICAgICBsZXQgbGFzdF9kb3cgPSB0LmRheU9mV2VlaygpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICBsZXQgYnlfbW9udGhfZGF5ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodCkpIHtcbiAgICAgICAgICAgICAgYnlfbW9udGhfZGF5LnB1c2goZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGxldCBzcEluZGV4ID0gMDsgc3BJbmRleCA8IGJ5X21vbnRoX2RheS5sZW5ndGg7IHNwSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNwSW5kZXggKyAxKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNwSW5kZXggLSBieV9tb250aF9kYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgYnlfbW9udGhfZGF5W3NwSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgY29kZWRfZGF5IG9mIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAgICAgbGV0IGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgICAgIGxldCBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgICAgbGV0IGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgICBsZXQgbW9udGhfZGF5O1xuXG4gICAgICAgICAgICBsZXQgZmlyc3RfbWF0Y2hpbmdfZGF5ID0gKChkb3cgKyA3IC0gZmlyc3RfZG93KSAlIDcpICsgMTtcbiAgICAgICAgICAgIGxldCBsYXN0X21hdGNoaW5nX2RheSA9IGRheXNJbk1vbnRoIC0gKChsYXN0X2RvdyArIDcgLSBkb3cpICUgNyk7XG5cbiAgICAgICAgICAgIGlmIChwb3MgPT0gMCkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBkYXkgPSBmaXJzdF9tYXRjaGluZ19kYXk7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5ICs9IDcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgZGF5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgICAgIG1vbnRoX2RheSA9IGZpcnN0X21hdGNoaW5nX2RheSArIChwb3MgLSAxKSAqIDc7XG5cbiAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA8PSBkYXlzSW5Nb250aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBtb250aF9kYXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtb250aF9kYXkgPSBsYXN0X21hdGNoaW5nX2RheSArIChwb3MgKyAxKSAqIDc7XG5cbiAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmV0dXJuIGRhdGVzIGluIG9yZGVyIG9mIG9jY3VycmVuY2UgKDEsMiwzLC4uLikgaW5zdGVhZFxuICAgICAgLy8gb2YgYnkgZ3JvdXBzIG9mIHdlZWtkYXlzICgxLDgsMTUsLi4uLDIsOSwxNiwuLi4pLlxuICAgICAgdGhpcy5kYXlzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pOyAvLyBDb21wYXJhdG9yIGZ1bmN0aW9uIGFsbG93cyB0byBzb3J0IG51bWJlcnMuXG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgIGxldCBleHBhbmRlZERheXMgPSB0aGlzLmV4cGFuZF9ieV9kYXkoYVllYXIpO1xuXG4gICAgICBmb3IgKGxldCBkYXkgb2YgZXhwYW5kZWREYXlzKSB7XG4gICAgICAgIGxldCB0dCA9IFRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDMgJiZcbiAgICAgICAgICAgICAgIFwiQllEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgIFwiQllNT05USFwiIGluIHBhcnRzKSB7XG4gICAgICBsZXQgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgZm9yIChsZXQgZGF5IG9mIGV4cGFuZGVkRGF5cykge1xuICAgICAgICBsZXQgdHQgPSBUaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG5cbiAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRILmluZGV4T2YodHQubW9udGgpID49IDAgJiZcbiAgICAgICAgICAgIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiYgXCJCWURBWVwiIGluIHBhcnRzICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgbGV0IGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgIGZvciAobGV0IGRheSBvZiBleHBhbmRlZERheXMpIHtcbiAgICAgICAgbGV0IHR0ID0gVGltZS5mcm9tRGF5T2ZZZWFyKGRheSwgYVllYXIpO1xuICAgICAgICBsZXQgd2Vla25vID0gdHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWVdFRUtOTy5pbmRleE9mKHdlZWtubykpIHtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgXCJCWURBWVwiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICBcIkJZV0VFS05PXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSA7IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5ieV9kYXRhLkJZWUVBUkRBWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF5cyA9IFtdO1xuICAgIH1cblxuICAgIGxldCBkYXlzSW5ZZWFyID0gVGltZS5pc0xlYXBZZWFyKGFZZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB0aGlzLmRheXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEgPCAwKSBhICs9IGRheXNJblllYXIgKyAxO1xuICAgICAgaWYgKGIgPCAwKSBiICs9IGRheXNJblllYXIgKyAxO1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBleHBhbmRfYnlfZGF5KGFZZWFyKSB7XG5cbiAgICBsZXQgZGF5c19saXN0ID0gW107XG4gICAgbGV0IHRtcCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuXG4gICAgdG1wLnllYXIgPSBhWWVhcjtcbiAgICB0bXAubW9udGggPSAxO1xuICAgIHRtcC5kYXkgPSAxO1xuICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgbGV0IHN0YXJ0X2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcblxuICAgIHRtcC5tb250aCA9IDEyO1xuICAgIHRtcC5kYXkgPSAzMTtcbiAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgIGxldCBlbmRfZG93ID0gdG1wLmRheU9mV2VlaygpO1xuICAgIGxldCBlbmRfeWVhcl9kYXkgPSB0bXAuZGF5T2ZZZWFyKCk7XG5cbiAgICBmb3IgKGxldCBkYXkgb2YgdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoZGF5KTtcbiAgICAgIGxldCBwb3MgPSBwYXJ0c1swXTtcbiAgICAgIGxldCBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgIGxldCB0bXBfc3RhcnRfZG95ID0gKChkb3cgKyA3IC0gc3RhcnRfZG93KSAlIDcpICsgMTtcblxuICAgICAgICBmb3IgKGxldCBkb3kgPSB0bXBfc3RhcnRfZG95OyBkb3kgPD0gZW5kX3llYXJfZGF5OyBkb3kgKz0gNykge1xuICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGRveSk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgIGxldCBmaXJzdDtcbiAgICAgICAgaWYgKGRvdyA+PSBzdGFydF9kb3cpIHtcbiAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBkb3cgLSBzdGFydF9kb3cgKyA4O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF5c19saXN0LnB1c2goZmlyc3QgKyAocG9zIC0gMSkgKiA3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBwb3MgPSAtcG9zO1xuXG4gICAgICAgIGlmIChkb3cgPD0gZW5kX2Rvdykge1xuICAgICAgICAgIGxhc3QgPSBlbmRfeWVhcl9kYXkgLSBlbmRfZG93ICsgZG93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBlbmRfeWVhcl9kYXkgLSBlbmRfZG93ICsgZG93IC0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGRheXNfbGlzdC5wdXNoKGxhc3QgLSAocG9zIC0gMSkgKiA3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRheXNfbGlzdDtcbiAgfVxuXG4gIGlzX2RheV9pbl9ieWRheSh0dCkge1xuICAgIGlmICh0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgIGZvciAobGV0IGRheSBvZiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGRheSk7XG4gICAgICAgIGxldCBwb3MgPSBwYXJ0c1swXTtcbiAgICAgICAgbGV0IGRvdyA9IHBhcnRzWzFdO1xuICAgICAgICBsZXQgdGhpc19kb3cgPSB0dC5kYXlPZldlZWsoKTtcblxuICAgICAgICBpZiAoKHBvcyA9PSAwICYmIGRvdyA9PSB0aGlzX2RvdykgfHxcbiAgICAgICAgICAgICh0dC5udGhXZWVrRGF5KGRvdywgcG9zKSA9PSB0dC5kYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgaW4gQllTRVRQT1MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtZXJpY30gYVBvcyBwb3NpdGlvbiB0byBjaGVjayBmb3IuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZhbHNlIHVubGVzcyBCWVNFVFBPUyBydWxlcyBleGlzdFxuICAgKiAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gcnVsZXMuXG4gICAqL1xuICBjaGVja19zZXRfcG9zaXRpb24oYVBvcykge1xuICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWVNFVFBPUycpKSB7XG4gICAgICBsZXQgaWR4ID0gdGhpcy5ieV9kYXRhLkJZU0VUUE9TLmluZGV4T2YoYVBvcyk7XG4gICAgICAvLyBuZWdhdGl2ZSBudW1iZXJzIGFyZSBub3QgZmFsc2UteVxuICAgICAgcmV0dXJuIGlkeCAhPT0gLTE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNvcnRfYnlkYXlfcnVsZXMoYVJ1bGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2pdLCB0aGlzLnJ1bGUud2tzdClbMV07XG4gICAgICAgIGxldCB0d28gPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2ldLCB0aGlzLnJ1bGUud2tzdClbMV07XG5cbiAgICAgICAgaWYgKG9uZSA+IHR3bykge1xuICAgICAgICAgIGxldCB0bXAgPSBhUnVsZXNbaV07XG4gICAgICAgICAgYVJ1bGVzW2ldID0gYVJ1bGVzW2pdO1xuICAgICAgICAgIGFSdWxlc1tqXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKGFSdWxlVHlwZSwgdikge1xuICAgIGxldCBpbmRleE1hcFZhbHVlID0gUmVjdXJJdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICBsZXQgcnVsZU1hcFZhbHVlID0gUmVjdXJJdGVyYXRvci5fZXhwYW5kTWFwW3RoaXMucnVsZS5mcmVxXVtpbmRleE1hcFZhbHVlXTtcbiAgICBsZXQgcGFzcyA9IGZhbHNlO1xuXG4gICAgaWYgKGFSdWxlVHlwZSBpbiB0aGlzLmJ5X2RhdGEgJiZcbiAgICAgICAgcnVsZU1hcFZhbHVlID09IFJlY3VySXRlcmF0b3IuQ09OVFJBQ1QpIHtcblxuICAgICAgbGV0IHJ1bGVUeXBlID0gdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV07XG5cbiAgICAgIGZvciAobGV0IGJ5ZGF0YSBvZiBydWxlVHlwZSkge1xuICAgICAgICBpZiAoYnlkYXRhID09IHYpIHtcbiAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3QgYSBjb250cmFjdGluZyBieXJ1bGUgb3IgaGFzIG5vIGRhdGEsIHRlc3QgcGFzc2VzXG4gICAgICBwYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3M7XG4gIH1cblxuICBjaGVja19jb250cmFjdGluZ19ydWxlcygpIHtcbiAgICBsZXQgZG93ID0gdGhpcy5sYXN0LmRheU9mV2VlaygpO1xuICAgIGxldCB3ZWVrTm8gPSB0aGlzLmxhc3Qud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgbGV0IGRveSA9IHRoaXMubGFzdC5kYXlPZlllYXIoKTtcblxuICAgIHJldHVybiAodGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZU0VDT05EXCIsIHRoaXMubGFzdC5zZWNvbmQpICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNSU5VVEVcIiwgdGhpcy5sYXN0Lm1pbnV0ZSkgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWUhPVVJcIiwgdGhpcy5sYXN0LmhvdXIpICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllEQVlcIiwgUmVjdXIubnVtZXJpY0RheVRvSWNhbERheShkb3cpKSAmJlxuICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZV0VFS05PXCIsIHdlZWtObykgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIREFZXCIsIHRoaXMubGFzdC5kYXkpICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USFwiLCB0aGlzLmxhc3QubW9udGgpICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllZRUFSREFZXCIsIGRveSkpO1xuICB9XG5cbiAgc2V0dXBfZGVmYXVsdHMoYVJ1bGVUeXBlLCByZXEsIGRlZnRpbWUpIHtcbiAgICBsZXQgaW5kZXhNYXBWYWx1ZSA9IFJlY3VySXRlcmF0b3IuX2luZGV4TWFwW2FSdWxlVHlwZV07XG4gICAgbGV0IHJ1bGVNYXBWYWx1ZSA9IFJlY3VySXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG5cbiAgICBpZiAocnVsZU1hcFZhbHVlICE9IFJlY3VySXRlcmF0b3IuQ09OVFJBQ1QpIHtcbiAgICAgIGlmICghKGFSdWxlVHlwZSBpbiB0aGlzLmJ5X2RhdGEpKSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdID0gW2RlZnRpbWVdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IHJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV1bMF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZ0aW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgaXRlcmF0b3IgaW50byBhIHNlcmlhbGl6ZS1hYmxlIG9iamVjdC4gIFdpbGwgcHJlc2VydmUgY3VycmVudFxuICAgKiBpdGVyYXRpb24gc2VxdWVuY2UgdG8gZW5zdXJlIHRoZSBzZWFtbGVzcyBjb250aW51YXRpb24gb2YgdGhlIHJlY3VycmVuY2VcbiAgICogcnVsZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgcmVzdWx0LmluaXRpYWxpemVkID0gdGhpcy5pbml0aWFsaXplZDtcbiAgICByZXN1bHQucnVsZSA9IHRoaXMucnVsZS50b0pTT04oKTtcbiAgICByZXN1bHQuZHRzdGFydCA9IHRoaXMuZHRzdGFydC50b0pTT04oKTtcbiAgICByZXN1bHQuYnlfZGF0YSA9IHRoaXMuYnlfZGF0YTtcbiAgICByZXN1bHQuZGF5cyA9IHRoaXMuZGF5cztcbiAgICByZXN1bHQubGFzdCA9IHRoaXMubGFzdC50b0pTT04oKTtcbiAgICByZXN1bHQuYnlfaW5kaWNlcyA9IHRoaXMuYnlfaW5kaWNlcztcbiAgICByZXN1bHQub2NjdXJyZW5jZV9udW1iZXIgPSB0aGlzLm9jY3VycmVuY2VfbnVtYmVyO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVycm9yIGluZGljYXRpbmcgdGhhdCBhIHJlY3VycmVuY2UgcnVsZSBpcyBpbnZhbGlkIGFuZCBwcm9kdWNlcyBub1xuICogb2NjdXJyZW5jZXMuXG4gKlxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNsYXNzXG4gKi9cbmNsYXNzIEludmFsaWRSZWN1cnJlbmNlUnVsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlJlY3VycmVuY2UgcnVsZSBoYXMgbm8gdmFsaWQgb2NjdXJyZW5jZXNcIik7XG4gIH1cbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS53ZWVrRGF5fSB3ZWVrRGF5XG4gKiBJbXBvcnRzIHRoZSAnd2Vla0RheScgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5mcmVxdWVuY3lWYWx1ZXN9IGZyZXF1ZW5jeVZhbHVlc1xuICogSW1wb3J0cyB0aGUgJ2ZyZXF1ZW5jeVZhbHVlcycgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuY29uc3QgVkFMSURfREFZX05BTUVTID0gL14oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG5jb25zdCBWQUxJRF9CWURBWV9QQVJUID0gL14oWystXSk/KDVbMC0zXXxbMS00XVswLTldfFsxLTldKT8oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG5jb25zdCBET1dfTUFQID0ge1xuICBTVTogVGltZS5TVU5EQVksXG4gIE1POiBUaW1lLk1PTkRBWSxcbiAgVFU6IFRpbWUuVFVFU0RBWSxcbiAgV0U6IFRpbWUuV0VETkVTREFZLFxuICBUSDogVGltZS5USFVSU0RBWSxcbiAgRlI6IFRpbWUuRlJJREFZLFxuICBTQTogVGltZS5TQVRVUkRBWVxufTtcblxuY29uc3QgUkVWRVJTRV9ET1dfTUFQID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKERPV19NQVApLm1hcChlbnRyeSA9PiBlbnRyeS5yZXZlcnNlKCkpKTtcblxuY29uc3QgQUxMT1dFRF9GUkVRID0gWydTRUNPTkRMWScsICdNSU5VVEVMWScsICdIT1VSTFknLFxuICAgICAgICAgICAgICAgICAgICAgICdEQUlMWScsICdXRUVLTFknLCAnTU9OVEhMWScsICdZRUFSTFknXTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIFwicmVjdXJcIiB2YWx1ZSB0eXBlLCB1c2VkIGZvciBleGFtcGxlIGJ5IFJSVUxFLiBJdCBwcm92aWRlcyBtZXRob2RzIHRvXG4gKiBjYWxjdWxhdGUgb2NjdXJyZW5jZXMgYW1vbmcgb3RoZXJzLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIFJlY3VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUmVjdXJ9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge1JlY3VyfSAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCByZWN1cnJlbmNlIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX3N0cmluZ1RvRGF0YShzdHJpbmcsIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IFJlY3VyKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUmVjdXJ9IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkXG4gICAqIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEBwYXJhbSB7ZnJlcXVlbmN5VmFsdWVzPX0gYURhdGEuZnJlcSAgICAgICAgICAgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5pbnRlcnZhbCAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFEYXRhLndrc3QgICAgICAgICAgICAgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7VGltZT19IGFEYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuY291bnQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5c2Vjb25kICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieW1pbnV0ZSAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlob3VyICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+PX0gYURhdGEuYnlkYXkgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieW1vbnRoZGF5ICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXllYXJkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5d2Vla25vICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltb250aCAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5c2V0cG9zICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRhKGFEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN1cihhRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSByZWN1cnJlbmNlIHN0cmluZyB0byBhIGRhdGEgb2JqZWN0LCBzdWl0YWJsZSBmb3IgdGhlIGZyb21EYXRhXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZtdEljYWwgICBJZiB0cnVlLCB0aGUgc3RyaW5nIGlzIGNvbnNpZGVyZWQgdG8gYmUgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpQ2FsZW5kYXIgc3RyaW5nXG4gICAqIEByZXR1cm4ge1JlY3VyfSAgICAgICAgICAgIFRoZSByZWN1cnJlbmNlIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgX3N0cmluZ1RvRGF0YShzdHJpbmcsIGZtdEljYWwpIHtcbiAgICBsZXQgZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBzcGxpdCBpcyBzbG93ZXIgaW4gRkYgYnV0IGZhc3QgZW5vdWdoLlxuICAgIC8vIHY4IGhvd2V2ZXIgdGhpcyBpcyBmYXN0ZXIgdGhlbiBtYW51YWwgc3BsaXQ/XG4gICAgbGV0IHZhbHVlcyA9IHN0cmluZy5zcGxpdCgnOycpO1xuICAgIGxldCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IHBhcnRzID0gdmFsdWVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICBsZXQgdWNuYW1lID0gcGFydHNbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgIGxldCBsY25hbWUgPSBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbGV0IG5hbWUgPSAoZm10SWNhbCA/IGxjbmFtZSA6IHVjbmFtZSk7XG4gICAgICBsZXQgdmFsdWUgPSBwYXJ0c1sxXTtcblxuICAgICAgaWYgKHVjbmFtZSBpbiBwYXJ0RGVzaWduKSB7XG4gICAgICAgIGxldCBwYXJ0QXJyID0gdmFsdWUuc3BsaXQoJywnKTtcbiAgICAgICAgbGV0IHBhcnRTZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0QXJyKSB7XG4gICAgICAgICAgcGFydFNldC5hZGQocGFydERlc2lnblt1Y25hbWVdKHBhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0QXJyID0gWy4uLnBhcnRTZXRdO1xuXG4gICAgICAgIGRpY3RbbmFtZV0gPSAocGFydEFyci5sZW5ndGggPT0gMSA/IHBhcnRBcnJbMF0gOiBwYXJ0QXJyKTtcbiAgICAgIH0gZWxzZSBpZiAodWNuYW1lIGluIG9wdGlvbkRlc2lnbikge1xuICAgICAgICBvcHRpb25EZXNpZ25bdWNuYW1lXSh2YWx1ZSwgZGljdCwgZm10SWNhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb24ndCBzd2FsbG93IHVua25vd24gdmFsdWVzLiBKdXN0IHNldCB0aGVtIGFzIHRoZXkgYXJlLlxuICAgICAgICBkaWN0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIGljYWwgcmVwcmVzZW50YXRpb24gb2YgYSBkYXkgKFNVLCBNTywgZXRjLi4pXG4gICAqIGludG8gYSBudW1lcmljIHZhbHVlIG9mIHRoYXQgZGF5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBUaGUgaUNhbGVuZGFyIGRheSBuYW1lXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKi9cbiAgc3RhdGljIGljYWxEYXlUb051bWVyaWNEYXkoc3RyaW5nLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbFxuICAgIC8vICAgICB3aXRoIHBvc3NpYmx5IGludmFsaWQgc3RyaW5nIHZhbHVlcy5cbiAgICBsZXQgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IFRpbWUuU1VOREFZO1xuICAgIHJldHVybiAoKERPV19NQVBbc3RyaW5nXSAtIGZpcnN0RG93ICsgNykgJSA3KSArIDE7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIG51bWVyaWMgZGF5IHZhbHVlIGludG8gaXRzIGljYWwgcmVwcmVzZW50YXRpb24gKFNVLCBNTywgZXRjLi4pXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgSUNBTCBkYXkgdmFsdWUsIGUuZyBTVSxNTywuLi5cbiAgICovXG4gIHN0YXRpYyBudW1lcmljRGF5VG9JY2FsRGF5KG51bSwgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWwgd2l0aCBwb3NzaWJseSBpbnZhbGlkIG51bWJlciB2YWx1ZXMuXG4gICAgLy8gICAgIEFsc28sIHRoaXMgYWxsb3dzIGNvbnNpc3RlbnQgbWFwcGluZyBiZXR3ZWVuIGRheSBudW1iZXJzIGFuZCBkYXlcbiAgICAvLyAgICAgbmFtZXMgZm9yIGV4dGVybmFsIHVzZXJzLlxuICAgIGxldCBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgVGltZS5TVU5EQVk7XG4gICAgbGV0IGRvdyA9IChudW0gKyBmaXJzdERvdyAtIFRpbWUuU1VOREFZKTtcbiAgICBpZiAoZG93ID4gNykge1xuICAgICAgZG93IC09IDc7XG4gICAgfVxuICAgIHJldHVybiBSRVZFUlNFX0RPV19NQVBbZG93XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFJlY3VyIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEBwYXJhbSB7ZnJlcXVlbmN5VmFsdWVzPX0gZGF0YS5mcmVxICAgICAgICAgICAgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7VGltZT19IGRhdGEudW50aWwgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZWNvbmQgICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+PX0gZGF0YS5ieWRheSAgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl3ZWVrbm8gICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB0aGlzLnBhcnRzID0ge307XG5cbiAgICBpZiAoZGF0YSAmJiB0eXBlb2YoZGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLmZyb21EYXRhKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgaG9sZGluZyB0aGUgQlktcGFydHMgb2YgdGhlIHJlY3VycmVuY2UgcnVsZVxuICAgKiBAbWVtYmVyb2YgSUNBTC5SZWN1clxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBieVBhcnRzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj49fSBCWVNFQ09ORCAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+PX0gQllNSU5VVEUgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPj19IEJZSE9VUiAgICAgICAgICAgICAgVGhlIGhvdXJzIGZvciB0aGUgQllIT1VSIHBhcnRcbiAgICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPj19IEJZREFZICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+PX0gQllNT05USERBWSAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+PX0gQllZRUFSREFZICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZWUVBUkRBWSBwYXJ0XG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj49fSBCWVdFRUtOTyAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPj19IEJZTU9OVEggICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj49fSBCWVNFVFBPUyAgICAgICAgICAgIFRoZSBwb3NpdGlvbmFscyBmb3IgdGhlIEJZU0VUUE9TIHBhcnRcbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBob2xkaW5nIHRoZSBCWS1wYXJ0cyBvZiB0aGUgcmVjdXJyZW5jZSBydWxlXG4gICAqIEB0eXBlIHtieVBhcnRzfVxuICAgKi9cbiAgcGFydHMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaW50ZXJ2YWwgdmFsdWUgZm9yIHRoZSByZWN1cnJlbmNlIHJ1bGUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBpbnRlcnZhbCA9IDE7XG5cbiAgLyoqXG4gICAqIFRoZSB3ZWVrIHN0YXJ0IGRheVxuICAgKlxuICAgKiBAdHlwZSB7d2Vla0RheX1cbiAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgKi9cbiAgd2tzdCA9IFRpbWUuTU9OREFZO1xuXG4gIC8qKlxuICAgKiBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEB0eXBlIHs/VGltZX1cbiAgICovXG4gIHVudGlsID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIG9jY3VycmVuY2VzXG4gICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgKi9cbiAgY291bnQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZnJlcXVlbmN5IHZhbHVlLlxuICAgKiBAdHlwZSB7ZnJlcXVlbmN5VmFsdWVzfVxuICAgKi9cbiAgZnJlcSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJpY2FscmVjdXJcIlxuICAgKi9cbiAgaWNhbGNsYXNzID0gXCJpY2FscmVjdXJcIjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcInJlY3VyXCJcbiAgICovXG4gIGljYWx0eXBlID0gXCJyZWN1clwiO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaXRlcmF0b3IgZm9yIHRoaXMgcmVjdXJyZW5jZSBydWxlLiBUaGUgcGFzc2VkIHN0YXJ0IGRhdGVcbiAgICogbXVzdCBiZSB0aGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQsIG5vdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlIHRvXG4gICAqIHNlYXJjaCBpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGV0IHJlY3VyID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3JydWxlJyk7XG4gICAqIGxldCBkdHN0YXJ0ID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKTtcbiAgICogbGV0IGl0ZXIgPSByZWN1ci5pdGVyYXRvcihkdHN0YXJ0KTtcbiAgICogZm9yIChsZXQgbmV4dCA9IGl0ZXIubmV4dCgpOyBuZXh0OyBuZXh0ID0gaXRlci5uZXh0KCkpIHtcbiAgICogICBpZiAobmV4dC5jb21wYXJlKHJhbmdlU3RhcnQpIDwgMCkge1xuICAgKiAgICAgY29udGludWU7XG4gICAqICAgfVxuICAgKiAgIGNvbnNvbGUubG9nKG5leHQudG9TdHJpbmcoKSk7XG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lfSBhU3RhcnQgICAgICAgIFRoZSBpdGVtJ3Mgc3RhcnQgZGF0ZVxuICAgKiBAcmV0dXJuIHtSZWN1ckl0ZXJhdG9yfSAgICAgVGhlIHJlY3VycmVuY2UgaXRlcmF0b3JcbiAgICovXG4gIGl0ZXJhdG9yKGFTdGFydCkge1xuICAgIHJldHVybiBuZXcgUmVjdXJJdGVyYXRvcih7XG4gICAgICBydWxlOiB0aGlzLFxuICAgICAgZHRzdGFydDogYVN0YXJ0XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSByZWN1cnJlbmNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7UmVjdXJ9ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUmVjdXIodGhpcy50b0pTT04oKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHJ1bGUgaXMgZmluaXRlLCBpLmUuIGhhcyBhIGNvdW50IG9yIHVudGlsIHBhcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBmaW5pdGVcbiAgICovXG4gIGlzRmluaXRlKCkge1xuICAgIHJldHVybiAhISh0aGlzLmNvdW50IHx8IHRoaXMudW50aWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBydWxlIGhhcyBhIGNvdW50IHBhcnQsIGFuZCBub3QgbGltaXRlZCBieSBhbiB1bnRpbFxuICAgKiBwYXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSwgaWYgdGhlIHJ1bGUgaXMgYnkgY291bnRcbiAgICovXG4gIGlzQnlDb3VudCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5jb3VudCAmJiAhdGhpcy51bnRpbCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCAocGFydCkgdG8gdGhlIHJlY3VycmVuY2UgcnVsZS4gVGhpcyBpcyBub3QgYSBjb21wb25lbnRcbiAgICogaW4gdGhlIHNlbnNlIG9mIHtAbGluayBJQ0FMLkNvbXBvbmVudH0sIGJ1dCBhIHBhcnQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogcnVsZSwgaS5lLiBCWU1PTlRILlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IHBhcnRcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICAgKi9cbiAgYWRkQ29tcG9uZW50KGFUeXBlLCBhVmFsdWUpIHtcbiAgICBsZXQgdWNuYW1lID0gYVR5cGUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAodWNuYW1lIGluIHRoaXMucGFydHMpIHtcbiAgICAgIHRoaXMucGFydHNbdWNuYW1lXS5wdXNoKGFWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFydHNbdWNuYW1lXSA9IFthVmFsdWVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdmFsdWUgZm9yIHRoZSBnaXZlbiBieS1wYXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFWYWx1ZXMgICAgICAgVGhlIGNvbXBvbmVudCB2YWx1ZXNcbiAgICovXG4gIHNldENvbXBvbmVudChhVHlwZSwgYVZhbHVlcykge1xuICAgIHRoaXMucGFydHNbYVR5cGUudG9VcHBlckNhc2UoKV0gPSBhVmFsdWVzLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyAoYSBjb3B5KSBvZiB0aGUgcmVxdWVzdGVkIGNvbXBvbmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgbmFtZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCB2YWx1ZVxuICAgKi9cbiAgZ2V0Q29tcG9uZW50KGFUeXBlKSB7XG4gICAgbGV0IHVjbmFtZSA9IGFUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuICh1Y25hbWUgaW4gdGhpcy5wYXJ0cyA/IHRoaXMucGFydHNbdWNuYW1lXS5zbGljZSgpIDogW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyIHRoZSBnaXZlbiByZWN1cnJlbmNlIGlkLiBTZWUgdGhlXG4gICAqIGd1aWRlIG9uIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIE5PVEU6IEN1cnJlbnRseSwgdGhpcyBtZXRob2QgaXRlcmF0ZXMgYWxsIG9jY3VycmVuY2VzIGZyb20gdGhlIHN0YXJ0XG4gICAqIGRhdGUuIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkIGluIGEgbG9vcCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XG4gICAqIHdvdWxkIGxpa2UgdG8gZ2V0IG1vcmUgdGhhbiBvbmUgb2NjdXJyZW5jZSwgeW91IGNhbiBpdGVyYXRlIHRoZVxuICAgKiBvY2N1cnJlbmNlcyBtYW51YWxseSwgc2VlIHRoZSBleGFtcGxlIG9uIHRoZVxuICAgKiB7QGxpbmsgSUNBTC5SZWN1ciNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWV9IGFTdGFydFRpbWUgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgZXZlbnQgc2VyaWVzXG4gICAqIEBwYXJhbSB7VGltZX0gYVJlY3VycmVuY2VJZCAgICAgVGhlIGRhdGUgb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZVxuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgICAgIFRoZSBuZXh0IG9jY3VycmVuY2UgYWZ0ZXJcbiAgICovXG4gIGdldE5leHRPY2N1cnJlbmNlKGFTdGFydFRpbWUsIGFSZWN1cnJlbmNlSWQpIHtcbiAgICBsZXQgaXRlciA9IHRoaXMuaXRlcmF0b3IoYVN0YXJ0VGltZSk7XG4gICAgbGV0IG5leHQ7XG5cbiAgICBkbyB7XG4gICAgICBuZXh0ID0gaXRlci5uZXh0KCk7XG4gICAgfSB3aGlsZSAobmV4dCAmJiBuZXh0LmNvbXBhcmUoYVJlY3VycmVuY2VJZCkgPD0gMCk7XG5cbiAgICBpZiAobmV4dCAmJiBhUmVjdXJyZW5jZUlkLnpvbmUpIHtcbiAgICAgIG5leHQuem9uZSA9IGFSZWN1cnJlbmNlSWQuem9uZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEBwYXJhbSB7ZnJlcXVlbmN5VmFsdWVzPX0gZGF0YS5mcmVxICAgICAgICAgICAgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7VGltZT19IGRhdGEudW50aWwgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZWNvbmQgICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+PX0gZGF0YS5ieWRheSAgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl3ZWVrbm8gICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cbiAgZnJvbURhdGEoZGF0YSkge1xuICAgIGZvciAobGV0IGtleSBpbiBkYXRhKSB7XG4gICAgICBsZXQgdWNrZXkgPSBrZXkudG9VcHBlckNhc2UoKTtcblxuICAgICAgaWYgKHVja2V5IGluIHBhcnREZXNpZ24pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkge1xuICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gW2RhdGFba2V5XV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnRlcnZhbCAmJiB0eXBlb2YgdGhpcy5pbnRlcnZhbCAhPSBcIm51bWJlclwiKSB7XG4gICAgICBvcHRpb25EZXNpZ24uSU5URVJWQUwodGhpcy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2tzdCAmJiB0eXBlb2YgdGhpcy53a3N0ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMud2tzdCA9IFJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkodGhpcy53a3N0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51bnRpbCAmJiAhKHRoaXMudW50aWwgaW5zdGFuY2VvZiBUaW1lKSkge1xuICAgICAgdGhpcy51bnRpbCA9IFRpbWUuZnJvbVN0cmluZyh0aGlzLnVudGlsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHR5cGUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBsZXQgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXMuZnJlcSA9IHRoaXMuZnJlcTtcblxuICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICByZXMuY291bnQgPSB0aGlzLmNvdW50O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmludGVydmFsID4gMSkge1xuICAgICAgcmVzLmludGVydmFsID0gdGhpcy5pbnRlcnZhbDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBbaywga3BhcnRzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnBhcnRzKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa3BhcnRzKSAmJiBrcGFydHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmVzW2sudG9Mb3dlckNhc2UoKV0gPSBrcGFydHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IGNsb25lKGtwYXJ0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudW50aWwpIHtcbiAgICAgIHJlcy51bnRpbCA9IHRoaXMudW50aWwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKCd3a3N0JyBpbiB0aGlzICYmIHRoaXMud2tzdCAhPT0gVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgIHJlcy53a3N0ID0gUmVjdXIubnVtZXJpY0RheVRvSWNhbERheSh0aGlzLndrc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHJ1bGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIC8vIFRPRE8gcmV0YWluIG9yZGVyXG4gICAgbGV0IHN0ciA9IFwiRlJFUT1cIiArIHRoaXMuZnJlcTtcbiAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgc3RyICs9IFwiO0NPVU5UPVwiICsgdGhpcy5jb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwgPiAxKSB7XG4gICAgICBzdHIgKz0gXCI7SU5URVJWQUw9XCIgKyB0aGlzLmludGVydmFsO1xuICAgIH1cbiAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wYXJ0cykpIHtcbiAgICAgIHN0ciArPSBcIjtcIiArIGsgKyBcIj1cIiArIHY7XG4gICAgfVxuICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICBzdHIgKz0gJztVTlRJTD0nICsgdGhpcy51bnRpbC50b0lDQUxTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKCd3a3N0JyBpbiB0aGlzICYmIHRoaXMud2tzdCAhPT0gVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgIHN0ciArPSAnO1dLU1Q9JyArIFJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU51bWVyaWNWYWx1ZSh0eXBlLCBtaW4sIG1heCwgdmFsdWUpIHtcbiAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuXG4gIGlmICh2YWx1ZVswXSA9PT0gJysnKSB7XG4gICAgcmVzdWx0ID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICByZXN1bHQgPSBzdHJpY3RQYXJzZUludChyZXN1bHQpO1xuXG4gIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8IG1pbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPiAnICsgbWluXG4gICAgKTtcbiAgfVxuXG4gIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPCAnICsgbWluXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IG9wdGlvbkRlc2lnbiA9IHtcbiAgRlJFUTogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAvLyB5ZXMgdGhpcyBpcyBhY3R1YWxseSBlcXVhbCBvciBmYXN0ZXIgdGhlbiByZWdleC5cbiAgICAvLyB1cHNpZGUgaGVyZSBpcyB3ZSBjYW4gZW51bWVyYXRlIHRoZSB2YWxpZCB2YWx1ZXMuXG4gICAgaWYgKEFMTE9XRURfRlJFUS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIGRpY3QuZnJlcSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGZyZXF1ZW5jeSBcIicgKyB2YWx1ZSArICdcIiBleHBlY3RlZDogXCInICtcbiAgICAgICAgQUxMT1dFRF9GUkVRLmpvaW4oJywgJykgKyAnXCInXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICBDT1VOVDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICBkaWN0LmNvdW50ID0gc3RyaWN0UGFyc2VJbnQodmFsdWUpO1xuICB9LFxuXG4gIElOVEVSVkFMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgIGRpY3QuaW50ZXJ2YWwgPSBzdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgaWYgKGRpY3QuaW50ZXJ2YWwgPCAxKSB7XG4gICAgICAvLyAwIG9yIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQsIHNvbWUgZW5naW5lcyBzZWVtIHRvIGdlbmVyYXRlXG4gICAgICAvLyBpdCB0aG91Z2guIEFzc3VtZSAxIGluc3RlYWQuXG4gICAgICBkaWN0LmludGVydmFsID0gMTtcbiAgICB9XG4gIH0sXG5cbiAgVU5USUw6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEwKSB7XG4gICAgICBkaWN0LnVudGlsID0gZGVzaWduJDEuaWNhbGVuZGFyLnZhbHVlWydkYXRlLXRpbWUnXS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QudW50aWwgPSBkZXNpZ24kMS5pY2FsZW5kYXIudmFsdWUuZGF0ZS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghZm10SWNhbCkge1xuICAgICAgZGljdC51bnRpbCA9IFRpbWUuZnJvbVN0cmluZyhkaWN0LnVudGlsKTtcbiAgICB9XG4gIH0sXG5cbiAgV0tTVDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICBpZiAoVkFMSURfREFZX05BTUVTLnRlc3QodmFsdWUpKSB7XG4gICAgICBkaWN0Lndrc3QgPSBSZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFdLU1QgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHBhcnREZXNpZ24gPSB7XG4gIEJZU0VDT05EOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgJ0JZU0VDT05EJywgMCwgNjApLFxuICBCWU1JTlVURTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh1bmRlZmluZWQsICdCWU1JTlVURScsIDAsIDU5KSxcbiAgQllIT1VSOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgJ0JZSE9VUicsIDAsIDIzKSxcbiAgQllEQVk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKFZBTElEX0JZREFZX1BBUlQudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEJZREFZIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiJyk7XG4gICAgfVxuICB9LFxuICBCWU1PTlRIREFZOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgJ0JZTU9OVEhEQVknLCAtMzEsIDMxKSxcbiAgQllZRUFSREFZOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgJ0JZWUVBUkRBWScsIC0zNjYsIDM2NiksXG4gIEJZV0VFS05POiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgJ0JZV0VFS05PJywgLTUzLCA1MyksXG4gIEJZTU9OVEg6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllNT05USCcsIDEsIDEyKSxcbiAgQllTRVRQT1M6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllTRVRQT1MnLCAtMzY2LCAzNjYpXG59O1xuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGxldHMgdHlwZXNjcmlwdCByZXNvbHZlIG91ciBjdXN0b20gdHlwZXMgaW4gdGhlXG4gKiBnZW5lcmF0ZWQgZC50cyBmaWxlcyAoanNkb2MgdHlwZWRlZnMgYXJlIGNvbnZlcnRlZCB0byB0eXBlc2NyaXB0IHR5cGVzKS5cbiAqIElnbm9yZSBwcmV2ZW50cyB0aGUgdHlwZWRlZnMgZnJvbSBiZWluZyBkb2N1bWVudGVkIG1vcmUgdGhhbiBvbmNlLlxuICogQGlnbm9yZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikuakNhbENvbXBvbmVudH0gakNhbENvbXBvbmVudFxuICogSW1wb3J0cyB0aGUgJ29jY3VycmVuY2VEZXRhaWxzJyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJwZXJpb2RcIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb24gYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIFBlcmlvZCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlBlcmlvZH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICAgICAgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eX0gcHJvcCAgICAgICAgIFRoZSBwcm9wZXJ0eSB0aGlzIHBlcmlvZCB3aWxsIGJlIG9uXG4gICAqIEByZXR1cm4ge1BlcmlvZH0gICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwZXJpb2QgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0ciwgcHJvcCkge1xuICAgIGxldCBwYXJ0cyA9IHN0ci5zcGxpdCgnLycpO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW52YWxpZCBzdHJpbmcgdmFsdWU6IFwiJyArIHN0ciArICdcIiBtdXN0IGNvbnRhaW4gYSBcIi9cIiBjaGFyLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICBzdGFydDogVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcocGFydHNbMF0sIHByb3ApXG4gICAgfTtcblxuICAgIGxldCBlbmQgPSBwYXJ0c1sxXTtcblxuICAgIGlmIChEdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGVuZCkpIHtcbiAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tU3RyaW5nKGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuZW5kID0gVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoZW5kLCBwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBlcmlvZChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlBlcmlvZH0gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqIFRoZSBwYXNzZWQgZGF0YSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYm90aCBhbmQgZW5kIGRhdGUgYW5kIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge1RpbWU9fSBhRGF0YS5zdGFydCAgICAgICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge1RpbWU9fSBhRGF0YS5lbmQgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtEdXJhdGlvbj19IGFEYXRhLmR1cmF0aW9uICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICogQHJldHVybiB7UGVyaW9kfSAgICAgICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRhKGFEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBQZXJpb2QoYURhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgcGVyaW9kIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGpDYWwgZGF0YSBhcnJheS4gVGhlIGZpcnN0XG4gICAqIG1lbWJlciBpcyBhbHdheXMgdGhlIHN0YXJ0IGRhdGUgc3RyaW5nLCB0aGUgc2Vjb25kIG1lbWJlciBpcyBlaXRoZXIgYVxuICAgKiBkdXJhdGlvbiBvciBlbmQgZGF0ZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7akNhbENvbXBvbmVudH0gYURhdGEgICAgICAgICAgIFRoZSBqQ2FsIGRhdGEgYXJyYXlcbiAgICogQHBhcmFtIHtQcm9wZXJ0eX0gYVByb3AgICAgICAgICAgICAgICAgVGhlIHByb3BlcnR5IHRoaXMgakNhbCBkYXRhIGlzIG9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYUxlbmllbnQgICAgICAgICAgICAgIElmIHRydWUsIGRhdGEgdmFsdWUgY2FuIGJlIGJvdGggZGF0ZSBhbmQgZGF0ZS10aW1lXG4gICAqIEByZXR1cm4ge1BlcmlvZH0gICAgICAgICAgICAgICAgICAgICAgIFRoZSBwZXJpb2QgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tSlNPTihhRGF0YSwgYVByb3AsIGFMZW5pZW50KSB7XG4gICAgZnVuY3Rpb24gZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgZGF0ZVByb3ApIHtcbiAgICAgIGlmIChhTGVuaWVudCkge1xuICAgICAgICByZXR1cm4gVGltZS5mcm9tU3RyaW5nKGFWYWx1ZSwgZGF0ZVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgZGF0ZVByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChEdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGFEYXRhWzFdKSkge1xuICAgICAgcmV0dXJuIFBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMF0sIGFQcm9wKSxcbiAgICAgICAgZHVyYXRpb246IER1cmF0aW9uLmZyb21TdHJpbmcoYURhdGFbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMF0sIGFQcm9wKSxcbiAgICAgICAgZW5kOiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMV0sIGFQcm9wKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5QZXJpb2QgaW5zdGFuY2UuIFRoZSBwYXNzZWQgZGF0YSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYm90aCBhbmQgZW5kIGRhdGUgYW5kXG4gICAqIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge1RpbWU9fSBhRGF0YS5zdGFydCAgICAgICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge1RpbWU9fSBhRGF0YS5lbmQgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtEdXJhdGlvbj19IGFEYXRhLmR1cmF0aW9uICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFEYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuXG4gICAgaWYgKGFEYXRhICYmICdzdGFydCcgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5zdGFydCAmJiAhKGFEYXRhLnN0YXJ0IGluc3RhbmNlb2YgVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLnN0YXJ0IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0ID0gYURhdGEuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmIGFEYXRhLmVuZCAmJiBhRGF0YS5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWNjZXB0IGJvdGggZW5kIGFuZCBkdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiAnZW5kJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmVuZCAmJiAhKGFEYXRhLmVuZCBpbnN0YW5jZW9mIFRpbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJy5lbmQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLlRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kID0gYURhdGEuZW5kO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiAnZHVyYXRpb24nIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuZHVyYXRpb24gJiYgIShhRGF0YS5kdXJhdGlvbiBpbnN0YW5jZW9mIER1cmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZHVyYXRpb24gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLkR1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmR1cmF0aW9uID0gYURhdGEuZHVyYXRpb247XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogVGhlIHN0YXJ0IG9mIHRoZSBwZXJpb2RcbiAgICogQHR5cGUge1RpbWV9XG4gICAqL1xuICBzdGFydCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgKiBAdHlwZSB7VGltZX1cbiAgICovXG4gIGVuZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAqIEB0eXBlIHtEdXJhdGlvbn1cbiAgICovXG4gIGR1cmF0aW9uID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcImljYWxwZXJpb2RcIlxuICAgKi9cbiAgaWNhbGNsYXNzID0gXCJpY2FscGVyaW9kXCI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJwZXJpb2RcIlxuICAgKi9cbiAgaWNhbHR5cGUgPSBcInBlcmlvZFwiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7UGVyaW9kfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ID8gdGhpcy5zdGFydC5jbG9uZSgpIDogbnVsbCxcbiAgICAgIGVuZDogdGhpcy5lbmQgPyB0aGlzLmVuZC5jbG9uZSgpIDogbnVsbCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uID8gdGhpcy5kdXJhdGlvbi5jbG9uZSgpIDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2QsIGVpdGhlciBkaXJlY3RseSBvciBieSBzdWJ0cmFjdGluZ1xuICAgKiBzdGFydCBmcm9tIGVuZCBkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn0gICAgICBUaGUgY2FsY3VsYXRlZCBkdXJhdGlvblxuICAgKi9cbiAgZ2V0RHVyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmQuc3VidHJhY3REYXRlKHRoaXMuc3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBlbmQgZGF0ZSBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgYWRkaW5nXG4gICAqIGR1cmF0aW9uIHRvIHN0YXJ0IGRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgICAgIFRoZSBjYWxjdWxhdGVkIGVuZCBkYXRlXG4gICAqL1xuICBnZXRFbmQoKSB7XG4gICAgaWYgKHRoaXMuZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSB0aGlzLnN0YXJ0LmNsb25lKCk7XG4gICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG4gICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIFwiL1wiICsgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBqQ2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kIHR5cGUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gW3RoaXMuc3RhcnQudG9TdHJpbmcoKSwgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvU3RyaW5nKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b0lDQUxTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQudG9JQ0FMU3RyaW5nKCkgKyBcIi9cIiArXG4gICAgICAgICAgICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKS50b0lDQUxTdHJpbmcoKTtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGxldHMgdHlwZXNjcmlwdCByZXNvbHZlIG91ciBjdXN0b20gdHlwZXMgaW4gdGhlXG4gKiBnZW5lcmF0ZWQgZC50cyBmaWxlcyAoanNkb2MgdHlwZWRlZnMgYXJlIGNvbnZlcnRlZCB0byB0eXBlc2NyaXB0IHR5cGVzKS5cbiAqIElnbm9yZSBwcmV2ZW50cyB0aGUgdHlwZWRlZnMgZnJvbSBiZWluZyBkb2N1bWVudGVkIG1vcmUgdGhhbiBvbmNlLlxuICogQGlnbm9yZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikuZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAqIEltcG9ydHMgdGhlICdkZXNpZ25TZXQnIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICovXG5cbi8qKiBAbW9kdWxlIElDQUwuZGVzaWduICovXG5cbmNvbnN0IEZST01fSUNBTF9ORVdMSU5FID0gL1xcXFxcXFxcfFxcXFw7fFxcXFwsfFxcXFxbTm5dL2c7XG5jb25zdCBUT19JQ0FMX05FV0xJTkUgPSAvXFxcXHw7fCx8XFxuL2c7XG5jb25zdCBGUk9NX1ZDQVJEX05FV0xJTkUgPSAvXFxcXFxcXFx8XFxcXCx8XFxcXFtObl0vZztcbmNvbnN0IFRPX1ZDQVJEX05FV0xJTkUgPSAvXFxcXHwsfFxcbi9nO1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0VHlwZShmcm9tTmV3bGluZSwgdG9OZXdsaW5lKSB7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgbWF0Y2hlczogLy4qLyxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAgIHJldHVybiByZXBsYWNlTmV3bGluZShhVmFsdWUsIGZyb21OZXdsaW5lLCBzdHJ1Y3R1cmVkRXNjYXBlKTtcbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAgIGxldCByZWdFeCA9IHRvTmV3bGluZTtcbiAgICAgIGlmIChzdHJ1Y3R1cmVkRXNjYXBlKVxuICAgICAgICAgcmVnRXggPSBuZXcgUmVnRXhwKHJlZ0V4LnNvdXJjZSArICd8JyArIHN0cnVjdHVyZWRFc2NhcGUsIHJlZ0V4LmZsYWdzKTtcbiAgICAgIHJldHVybiBhVmFsdWUucmVwbGFjZShyZWdFeCwgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcO1wiO1xuICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFwsXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBkZWZhdWx0IHR5cGVzIHVzZWQgbXVsdGlwbGUgdGltZXNcbmNvbnN0IERFRkFVTFRfVFlQRV9URVhUID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9URVhUX01VTFRJID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIG11bHRpVmFsdWU6IFwiLFwiIH07XG5jb25zdCBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVEID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9JTlRFR0VSID0geyBkZWZhdWx0VHlwZTogXCJpbnRlZ2VyXCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIiwgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdIH07XG5jb25zdCBERUZBVUxUX1RZUEVfREFURVRJTUUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiIH07XG5jb25zdCBERUZBVUxUX1RZUEVfVVJJID0geyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9O1xuY29uc3QgREVGQVVMVF9UWVBFX1VUQ09GRlNFVCA9IHsgZGVmYXVsdFR5cGU6IFwidXRjLW9mZnNldFwiIH07XG5jb25zdCBERUZBVUxUX1RZUEVfUkVDVVIgPSB7IGRlZmF1bHRUeXBlOiBcInJlY3VyXCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtYW5kLW9yLXRpbWVcIiwgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwidGV4dFwiXSB9O1xuXG5mdW5jdGlvbiByZXBsYWNlTmV3bGluZVJlcGxhY2Uoc3RyaW5nKSB7XG4gIHN3aXRjaCAoc3RyaW5nKSB7XG4gICAgY2FzZSBcIlxcXFxcXFxcXCI6XG4gICAgICByZXR1cm4gXCJcXFxcXCI7XG4gICAgY2FzZSBcIlxcXFw7XCI6XG4gICAgICByZXR1cm4gXCI7XCI7XG4gICAgY2FzZSBcIlxcXFwsXCI6XG4gICAgICByZXR1cm4gXCIsXCI7XG4gICAgY2FzZSBcIlxcXFxuXCI6XG4gICAgY2FzZSBcIlxcXFxOXCI6XG4gICAgICByZXR1cm4gXCJcXG5cIjtcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmUodmFsdWUsIG5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgLy8gYXZvaWQgcmVnZXggd2hlbiBwb3NzaWJsZS5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ1xcXFwnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgIG5ld2xpbmUgPSBuZXcgUmVnRXhwKG5ld2xpbmUuc291cmNlICsgJ3xcXFxcXFxcXCcgKyBzdHJ1Y3R1cmVkRXNjYXBlLCBuZXdsaW5lLmZsYWdzKTtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobmV3bGluZSwgcmVwbGFjZU5ld2xpbmVSZXBsYWNlKTtcbn1cblxubGV0IGNvbW1vblByb3BlcnRpZXMgPSB7XG4gIFwiY2F0ZWdvcmllc1wiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgXCJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJ2ZXJzaW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInVpZFwiOiBERUZBVUxUX1RZUEVfVEVYVFxufTtcblxubGV0IGNvbW1vblZhbHVlcyA9IHtcbiAgXCJib29sZWFuXCI6IHtcbiAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXSxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHN3aXRjaCAoYVZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ1RSVUUnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdGQUxTRSc6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vVE9ETzogcGFyc2VyIHdhcm5pbmdcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICBpZiAoYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnVFJVRSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ0ZBTFNFJztcbiAgICB9XG5cbiAgfSxcbiAgZmxvYXQ6IHtcbiAgICBtYXRjaGVzOiAvXlsrLV0/XFxkK1xcLlxcZCskLyxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGxldCBwYXJzZWQgPSBwYXJzZUZsb2F0KGFWYWx1ZSk7XG4gICAgICBpZiAoaXNTdHJpY3RseU5hTihwYXJzZWQpKSB7XG4gICAgICAgIC8vIFRPRE86IHBhcnNlciB3YXJuaW5nXG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhhVmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgaW50ZWdlcjoge1xuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGxldCBwYXJzZWQgPSBwYXJzZUludChhVmFsdWUpO1xuICAgICAgaWYgKGlzU3RyaWN0bHlOYU4ocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGFWYWx1ZSk7XG4gICAgfVxuICB9LFxuICBcInV0Yy1vZmZzZXRcIjoge1xuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDcpIHtcbiAgICAgICAgLy8gbm8gc2Vjb25kc1xuICAgICAgICAvLyAtMDUwMFxuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDMpICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg0LCA2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgLy8gLTA1MDAwMFxuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDMpICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg0LCA2KSArXG4gICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoNywgOSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNikge1xuICAgICAgICAvLyBubyBzZWNvbmRzXG4gICAgICAgIC8vIC0wNTowMFxuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDMpICsgJzonICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgzLCA1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgLy8gLTA1OjAwOjAwXG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgMykgKyAnOicgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDMsIDUpICsgJzonICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg1LCA3KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFV0Y09mZnNldC5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxufTtcblxubGV0IGljYWxQYXJhbXMgPSB7XG4gIC8vIEFsdGhvdWdoIHRoZSBzeW50YXggaXMgRFFVT1RFIHVyaSBEUVVPVEUsIEkgZG9uJ3QgdGhpbmsgd2Ugc2hvdWxkXG4gIC8vIGVuZm9yY2UgYW55dGhpbmcgYXNpZGUgZnJvbSBpdCBiZWluZyBhIHZhbGlkIGNvbnRlbnQgbGluZS5cbiAgLy9cbiAgLy8gQXQgbGVhc3Qgc29tZSBwYXJhbXMgcmVxdWlyZSAtIGlmIG11bHRpIHZhbHVlcyBhcmUgdXNlZCAtIERRVU9URXNcbiAgLy8gZm9yIGVhY2ggb2YgaXRzIHZhbHVlcyAtIGUuZy4gZGVsZWdhdGVkLWZyb209XCJ1cmkxXCIsXCJ1cmkyXCJcbiAgLy8gVG8gaW5kaWNhdGUgdGhpcywgSSBpbnRyb2R1Y2VkIHRoZSBuZXcgay92IHBhaXJcbiAgLy8gbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gIC8vXG4gIC8vIFwiQUxUUkVQXCI6IHsgLi4uIH0sXG5cbiAgLy8gQ04ganVzdCB3YW50cyBhIHBhcmFtLXZhbHVlXG4gIC8vIFwiQ05cIjogeyAuLi4gfVxuXG4gIFwiY3V0eXBlXCI6IHtcbiAgICB2YWx1ZXM6IFtcIklORElWSURVQUxcIiwgXCJHUk9VUFwiLCBcIlJFU09VUkNFXCIsIFwiUk9PTVwiLCBcIlVOS05PV05cIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9LFxuXG4gIFwiZGVsZWdhdGVkLWZyb21cIjoge1xuICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICB9LFxuICBcImRlbGVnYXRlZC10b1wiOiB7XG4gICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gIH0sXG4gIC8vIFwiRElSXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgXCJlbmNvZGluZ1wiOiB7XG4gICAgdmFsdWVzOiBbXCI4QklUXCIsIFwiQkFTRTY0XCJdXG4gIH0sXG4gIC8vIFwiRk1UVFlQRVwiOiB7IC4uLiB9LCAvLyBTZWUgQUxUUkVQXG4gIFwiZmJ0eXBlXCI6IHtcbiAgICB2YWx1ZXM6IFtcIkZSRUVcIiwgXCJCVVNZXCIsIFwiQlVTWS1VTkFWQUlMQUJMRVwiLCBcIkJVU1ktVEVOVEFUSVZFXCJdLFxuICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgfSxcbiAgLy8gXCJMQU5HVUFHRVwiOiB7IC4uLiB9LCAvLyBTZWUgQUxUUkVQXG4gIFwibWVtYmVyXCI6IHtcbiAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgfSxcbiAgXCJwYXJ0c3RhdFwiOiB7XG4gICAgLy8gVE9ETyBUaGVzZSB2YWx1ZXMgYXJlIGFjdHVhbGx5IGRpZmZlcmVudCBwZXItY29tcG9uZW50XG4gICAgdmFsdWVzOiBbXCJORUVEUy1BQ1RJT05cIiwgXCJBQ0NFUFRFRFwiLCBcIkRFQ0xJTkVEXCIsIFwiVEVOVEFUSVZFXCIsXG4gICAgICAgICAgICAgXCJERUxFR0FURURcIiwgXCJDT01QTEVURURcIiwgXCJJTi1QUk9DRVNTXCJdLFxuICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgfSxcbiAgXCJyYW5nZVwiOiB7XG4gICAgdmFsdWVzOiBbXCJUSElTQU5ERlVUVVJFXCJdXG4gIH0sXG4gIFwicmVsYXRlZFwiOiB7XG4gICAgdmFsdWVzOiBbXCJTVEFSVFwiLCBcIkVORFwiXVxuICB9LFxuICBcInJlbHR5cGVcIjoge1xuICAgIHZhbHVlczogW1wiUEFSRU5UXCIsIFwiQ0hJTERcIiwgXCJTSUJMSU5HXCJdLFxuICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgfSxcbiAgXCJyb2xlXCI6IHtcbiAgICB2YWx1ZXM6IFtcIlJFUS1QQVJUSUNJUEFOVFwiLCBcIkNIQUlSXCIsXG4gICAgICAgICAgICAgXCJPUFQtUEFSVElDSVBBTlRcIiwgXCJOT04tUEFSVElDSVBBTlRcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9LFxuICBcInJzdnBcIjoge1xuICAgIHZhbHVlczogW1wiVFJVRVwiLCBcIkZBTFNFXCJdXG4gIH0sXG4gIFwic2VudC1ieVwiOiB7XG4gICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCJcbiAgfSxcbiAgXCJ0emlkXCI6IHtcbiAgICBtYXRjaGVzOiAvXlxcLy9cbiAgfSxcbiAgXCJ2YWx1ZVwiOiB7XG4gICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgdmFsdWVzOiBbXCJiaW5hcnlcIiwgXCJib29sZWFuXCIsIFwiY2FsLWFkZHJlc3NcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsXG4gICAgICAgICAgICAgXCJkdXJhdGlvblwiLCBcImZsb2F0XCIsIFwiaW50ZWdlclwiLCBcInBlcmlvZFwiLCBcInJlY3VyXCIsIFwidGV4dFwiLFxuICAgICAgICAgICAgIFwidGltZVwiLCBcInVyaVwiLCBcInV0Yy1vZmZzZXRcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9XG59O1xuXG4vLyBXaGVuIGFkZGluZyBhIHZhbHVlIGhlcmUsIGJlIHN1cmUgdG8gYWRkIGl0IHRvIHRoZSBwYXJhbWV0ZXIgdHlwZXMhXG5jb25zdCBpY2FsVmFsdWVzID0gZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICB0ZXh0OiBjcmVhdGVUZXh0VHlwZShGUk9NX0lDQUxfTkVXTElORSwgVE9fSUNBTF9ORVdMSU5FKSxcblxuICB1cmk6IHtcbiAgICAvLyBUT0RPXG4gICAgLyogLi4uICovXG4gIH0sXG5cbiAgXCJiaW5hcnlcIjoge1xuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhU3RyaW5nKSB7XG4gICAgICByZXR1cm4gQmluYXJ5LmZyb21TdHJpbmcoYVN0cmluZyk7XG4gICAgfSxcblxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFCaW5hcnkpIHtcbiAgICAgIHJldHVybiBhQmluYXJ5LnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuICBcImNhbC1hZGRyZXNzXCI6IHtcbiAgICAvLyBuZWVkcyB0byBiZSBhbiB1cmlcbiAgfSxcbiAgXCJkYXRlXCI6IHtcbiAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgaWYgKGRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIFRpbWUuZnJvbURhdGVTdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVGltZS5mcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmRlY29yYXRlcyBhIHRpbWUgb2JqZWN0LlxuICAgICAqL1xuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG5cbiAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAvLyBmcm9tOiAyMDEyMDkwMVxuICAgICAgLy8gdG86IDIwMTItMDktMDFcbiAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBhVmFsdWUubGVuZ3RoID49IDE1KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBkYXRlLXRpbWUsIGUuZy4gMjAxMjA5MDFUMTMwMDAwWlxuICAgICAgICByZXR1cm4gaWNhbFZhbHVlc1tcImRhdGUtdGltZVwiXS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5zbGljZSgwLCA0KSArICctJyArXG4gICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoNCwgNikgKyAnLScgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDYsIDgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgLy8gZnJvbTogMjAxMi0wOS0wMVxuICAgICAgLy8gdG86IDIwMTIwOTAxXG4gICAgICBsZXQgbGVuID0gYVZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKGxlbiA9PSAxMCkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDQpICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg1LCA3KSArXG4gICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoOCwgMTApO1xuICAgICAgfSBlbHNlIGlmIChsZW4gPj0gMTkpIHtcbiAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXNbXCJkYXRlLXRpbWVcIl0udG9JQ0FMKGFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL1RPRE86IHNlcmlhbGl6ZSB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgfVxuXG4gICAgfVxuICB9LFxuICBcImRhdGUtdGltZVwiOiB7XG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgLy8gZnJvbTogMjAxMjA5MDFUMTMwMDAwXG4gICAgICAvLyB0bzogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIGFWYWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZGF0ZSwgZS5nLiAyMDEyMDkwMVxuICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYVZhbHVlLnNsaWNlKDAsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg0LCA2KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoNiwgOCkgKyAnVCcgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDksIDExKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoMTEsIDEzKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoMTMsIDE1KTtcblxuICAgICAgICBpZiAoYVZhbHVlWzE1XSAmJiBhVmFsdWVbMTVdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIC8vIGZyb206IDIwMTItMDktMDFUMTM6MDA6MDBcbiAgICAgIC8vIHRvOiAyMDEyMDkwMVQxMzAwMDBcbiAgICAgIGxldCBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICBpZiAobGVuID09IDEwICYmICFkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKGFWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYVZhbHVlLnNsaWNlKDAsIDQpICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg1LCA3KSArXG4gICAgICAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSAoRERUSEgpIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg4LCAxMykgK1xuICAgICAgICAgICAgICAgICAgICAgLy8gTU1cbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgxNCwgMTYpICtcbiAgICAgICAgICAgICAgICAgICAgIC8vIFNTXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoMTcsIDE5KTtcblxuICAgICAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBlcnJvclxuICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgaWYgKGRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIFRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuICBkdXJhdGlvbjoge1xuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgfSxcbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIHBlcmlvZDoge1xuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS5mcm9tSUNBTChwYXJ0c1swXSk7XG5cbiAgICAgIGlmICghRHVyYXRpb24uaXNWYWx1ZVN0cmluZyhwYXJ0c1sxXSkpIHtcbiAgICAgICAgcGFydHNbMV0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS5mcm9tSUNBTChwYXJ0c1sxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgcGFydHMgPSBwYXJ0cy5zbGljZSgpO1xuICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIHBhcnRzWzBdLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwocGFydHNbMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUR1cmF0aW9uLmlzVmFsdWVTdHJpbmcocGFydHNbMV0pKSB7XG4gICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBwYXJ0c1sxXS5sZW5ndGggPT0gMTApIHtcbiAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHBhcnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFydHMuam9pbihcIi9cIik7XG4gICAgfSxcblxuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICByZXR1cm4gUGVyaW9kLmZyb21KU09OKGFWYWx1ZSwgYVByb3AsICFkZXNpZ24uc3RyaWN0KTtcbiAgICB9LFxuXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvSlNPTigpO1xuICAgIH1cbiAgfSxcbiAgcmVjdXI6IHtcbiAgICBmcm9tSUNBTDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gUmVjdXIuX3N0cmluZ1RvRGF0YShzdHJpbmcsIHRydWUpO1xuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgW2ssIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgICAgaWYgKGsgPT0gXCJ1bnRpbFwiKSB7XG4gICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgdmFsID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHZhbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PSBcIndrc3RcIikge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsID0gUmVjdXIubnVtZXJpY0RheVRvSWNhbERheSh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSB2YWwuam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IGsudG9VcHBlckNhc2UoKSArIFwiPVwiICsgdmFsICsgXCI7XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnNsaWNlKDAsIE1hdGgubWF4KDAsIHN0ci5sZW5ndGggLSAxKSk7XG4gICAgfSxcblxuICAgIGRlY29yYXRlOiBmdW5jdGlvbiBkZWNvcmF0ZShhVmFsdWUpIHtcbiAgICAgIHJldHVybiBSZWN1ci5mcm9tRGF0YShhVmFsdWUpO1xuICAgIH0sXG5cbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhUmVjdXIpIHtcbiAgICAgIHJldHVybiBhUmVjdXIudG9KU09OKCk7XG4gICAgfVxuICB9LFxuXG4gIHRpbWU6IHtcbiAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAvLyBmcm9tOiBNTUhIU1MoWik/XG4gICAgICAvLyB0bzogSEg6TU06U1MoWik/XG4gICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgLy8gVE9ETzogcGFyc2VyIGV4Y2VwdGlvbj9cbiAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSEg6Ok1NOjpTU1o/XG4gICAgICBsZXQgcmVzdWx0ID0gYVZhbHVlLnNsaWNlKDAsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoMiwgNCkgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg0LCA2KTtcblxuICAgICAgaWYgKGFWYWx1ZVs2XSA9PT0gJ1onKSB7XG4gICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAvLyBmcm9tOiBISDpNTTpTUyhaKT9cbiAgICAgIC8vIHRvOiBNTUhIU1MoWik/XG4gICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgLy9UT0RPOiBlcnJvclxuICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0gYVZhbHVlLnNsaWNlKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoMywgNSkgK1xuICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg2LCA4KTtcblxuICAgICAgaWYgKGFWYWx1ZVs4XSA9PT0gJ1onKSB7XG4gICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59KTtcblxubGV0IGljYWxQcm9wZXJ0aWVzID0gZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcblxuICBcImFjdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJhdHRhY2hcIjogeyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9LFxuICBcImF0dGVuZGVlXCI6IHsgZGVmYXVsdFR5cGU6IFwiY2FsLWFkZHJlc3NcIiB9LFxuICBcImNhbHNjYWxlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImNsYXNzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImNvbW1lbnRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwiY29tcGxldGVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgXCJjb250YWN0XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImNyZWF0ZWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICBcImRlc2NyaXB0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImR0ZW5kXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICBcImR0c3RhbXBcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICBcImR0c3RhcnRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gIFwiZHVlXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICBcImR1cmF0aW9uXCI6IHsgZGVmYXVsdFR5cGU6IFwiZHVyYXRpb25cIiB9LFxuICBcImV4ZGF0ZVwiOiB7XG4gICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdLFxuICAgIG11bHRpVmFsdWU6ICcsJ1xuICB9LFxuICBcImV4cnVsZVwiOiBERUZBVUxUX1RZUEVfUkVDVVIsXG4gIFwiZnJlZWJ1c3lcIjogeyBkZWZhdWx0VHlwZTogXCJwZXJpb2RcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgXCJnZW9cIjogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gIFwibGFzdC1tb2RpZmllZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gIFwibG9jYXRpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwibWV0aG9kXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcIm9yZ2FuaXplclwiOiB7IGRlZmF1bHRUeXBlOiBcImNhbC1hZGRyZXNzXCIgfSxcbiAgXCJwZXJjZW50LWNvbXBsZXRlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICBcInByaW9yaXR5XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICBcInByb2RpZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJyZWxhdGVkLXRvXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInJlcGVhdFwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgXCJyZGF0ZVwiOiB7XG4gICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwicGVyaW9kXCJdLFxuICAgIG11bHRpVmFsdWU6ICcsJyxcbiAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gJ3BlcmlvZCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgIH1cbiAgfSxcbiAgXCJyZWN1cnJlbmNlLWlkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICBcInJlc291cmNlc1wiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgXCJyZXF1ZXN0LXN0YXR1c1wiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICBcInJydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgXCJzZXF1ZW5jZVwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgXCJzdGF0dXNcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwic3VtbWFyeVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJ0cmFuc3BcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwidHJpZ2dlclwiOiB7IGRlZmF1bHRUeXBlOiBcImR1cmF0aW9uXCIsIGFsbG93ZWRUeXBlczogW1wiZHVyYXRpb25cIiwgXCJkYXRlLXRpbWVcIl0gfSxcbiAgXCJ0em9mZnNldGZyb21cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgXCJ0em9mZnNldHRvXCI6IERFRkFVTFRfVFlQRV9VVENPRkZTRVQsXG4gIFwidHp1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJ0emlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInR6bmFtZVwiOiBERUZBVUxUX1RZUEVfVEVYVFxufSk7XG5cbi8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbmNvbnN0IHZjYXJkVmFsdWVzID0gZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICB0ZXh0OiBjcmVhdGVUZXh0VHlwZShGUk9NX1ZDQVJEX05FV0xJTkUsIFRPX1ZDQVJEX05FV0xJTkUpLFxuICB1cmk6IGNyZWF0ZVRleHRUeXBlKEZST01fVkNBUkRfTkVXTElORSwgVE9fVkNBUkRfTkVXTElORSksXG5cbiAgZGF0ZToge1xuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBWQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGVcIik7XG4gICAgfSxcbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGlmIChhVmFsdWUubGVuZ3RoID09IDgpIHtcbiAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChhVmFsdWVbMF0gPT0gJy0nICYmIGFWYWx1ZS5sZW5ndGggPT0gNikge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDQpICsgJy0nICsgYVZhbHVlLnNsaWNlKDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChhVmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChhVmFsdWVbMF0gPT0gJy0nICYmIGFWYWx1ZS5sZW5ndGggPT0gNykge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDQpICsgYVZhbHVlLnNsaWNlKDUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdGltZToge1xuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBWQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoXCJUXCIgKyBhVmFsdWUsIFwidGltZVwiKTtcbiAgICB9LFxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgbGV0IHNwbGl0em9uZSA9IHZjYXJkVmFsdWVzLnRpbWUuX3NwbGl0Wm9uZShhVmFsdWUsIHRydWUpO1xuICAgICAgbGV0IHpvbmUgPSBzcGxpdHpvbmVbMF0sIHZhbHVlID0gc3BsaXR6b25lWzFdO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKFwiU1BMSVQ6IFwiLHNwbGl0em9uZSk7XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gNikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgyLCA0KSArICc6JyArXG4gICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoNCwgNik7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA0ICYmIHZhbHVlWzBdICE9ICctJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIDIpICsgJzonICsgdmFsdWUuc2xpY2UoMiwgNCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA1KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgMykgKyAnOicgKyB2YWx1ZS5zbGljZSgzLCA1KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDUgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICB6b25lID0gem9uZS5zbGljZSgwLCAzKSArICc6JyArIHpvbmUuc2xpY2UoMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSArIHpvbmU7XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICBsZXQgc3BsaXR6b25lID0gdmNhcmRWYWx1ZXMudGltZS5fc3BsaXRab25lKGFWYWx1ZSk7XG4gICAgICBsZXQgem9uZSA9IHNwbGl0em9uZVswXSwgdmFsdWUgPSBzcGxpdHpvbmVbMV07XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIDIpICtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgzLCA1KSArXG4gICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoNiwgOCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA1ICYmIHZhbHVlWzBdICE9ICctJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIDIpICsgdmFsdWUuc2xpY2UoMywgNSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgMykgKyB2YWx1ZS5zbGljZSg0LCA2KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDYgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICB6b25lID0gem9uZS5zbGljZSgwLCAzKSArIHpvbmUuc2xpY2UoNCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSArIHpvbmU7XG4gICAgfSxcblxuICAgIF9zcGxpdFpvbmU6IGZ1bmN0aW9uKGFWYWx1ZSwgaXNGcm9tSWNhbCkge1xuICAgICAgbGV0IGxhc3RDaGFyID0gYVZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgc2lnbkNoYXIgPSBhVmFsdWUubGVuZ3RoIC0gKGlzRnJvbUljYWwgPyA1IDogNik7XG4gICAgICBsZXQgc2lnbiA9IGFWYWx1ZVtzaWduQ2hhcl07XG4gICAgICBsZXQgem9uZSwgdmFsdWU7XG5cbiAgICAgIGlmIChhVmFsdWVbbGFzdENoYXJdID09ICdaJykge1xuICAgICAgICB6b25lID0gYVZhbHVlW2xhc3RDaGFyXTtcbiAgICAgICAgdmFsdWUgPSBhVmFsdWUuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbGFzdENoYXIpKTtcbiAgICAgIH0gZWxzZSBpZiAoYVZhbHVlLmxlbmd0aCA+IDYgJiYgKHNpZ24gPT0gJy0nIHx8IHNpZ24gPT0gJysnKSkge1xuICAgICAgICB6b25lID0gYVZhbHVlLnNsaWNlKHNpZ25DaGFyKTtcbiAgICAgICAgdmFsdWUgPSBhVmFsdWUuc2xpY2UoMCwgTWF0aC5tYXgoMCwgc2lnbkNoYXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvbmUgPSBcIlwiO1xuICAgICAgICB2YWx1ZSA9IGFWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt6b25lLCB2YWx1ZV07XG4gICAgfVxuICB9LFxuXG4gIFwiZGF0ZS10aW1lXCI6IHtcbiAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlLXRpbWVcIik7XG4gICAgfSxcblxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG5cbiAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gdmNhcmRWYWx1ZXNbJ2RhdGUtYW5kLW9yLXRpbWUnXS5mcm9tSUNBTChhVmFsdWUpO1xuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIHZjYXJkVmFsdWVzWydkYXRlLWFuZC1vci10aW1lJ10udG9JQ0FMKGFWYWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIFwiZGF0ZS1hbmQtb3ItdGltZVwiOiB7XG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIFwiZGF0ZS1hbmQtb3ItdGltZVwiKTtcbiAgICB9LFxuXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgICAgcmV0dXJuIChwYXJ0c1swXSA/IHZjYXJkVmFsdWVzLmRhdGUuZnJvbUlDQUwocGFydHNbMF0pIDogJycpICtcbiAgICAgICAgICAgICAocGFydHNbMV0gPyAnVCcgKyB2Y2FyZFZhbHVlcy50aW1lLmZyb21JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgICAgcmV0dXJuIHZjYXJkVmFsdWVzLmRhdGUudG9JQ0FMKHBhcnRzWzBdKSArXG4gICAgICAgICAgICAgKHBhcnRzWzFdID8gJ1QnICsgdmNhcmRWYWx1ZXMudGltZS50b0lDQUwocGFydHNbMV0pIDogJycpO1xuXG4gICAgfVxuICB9LFxuICB0aW1lc3RhbXA6IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLFxuICBcImxhbmd1YWdlLXRhZ1wiOiB7XG4gICAgbWF0Y2hlczogL15bYS16QS1aMC05LV0rJC8gLy8gQ291bGQgZ28gd2l0aCBhIG1vcmUgc3RyaWN0IHJlZ2V4IGhlcmVcbiAgfSxcbiAgXCJwaG9uZS1udW1iZXJcIjoge1xuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGFWYWx1ZSkuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYyA9PT0gJ1xcXFwnID8gdW5kZWZpbmVkIDogYztcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfSxcbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oYVZhbHVlKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gJywnIHx8IGMgPT09IFwiO1wiID8gJ1xcXFwnICsgYyA6IGM7XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5sZXQgdmNhcmRQYXJhbXMgPSB7XG4gIFwidHlwZVwiOiB7XG4gICAgdmFsdWVUeXBlOiBcInRleHRcIixcbiAgICBtdWx0aVZhbHVlOiBcIixcIlxuICB9LFxuICBcInZhbHVlXCI6IHtcbiAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGUtdGltZVwiLCBcImRhdGUtYW5kLW9yLXRpbWVcIixcbiAgICAgICAgICAgICBcInRpbWVzdGFtcFwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwiZmxvYXRcIiwgXCJ1dGMtb2Zmc2V0XCIsXG4gICAgICAgICAgICAgXCJsYW5ndWFnZS10YWdcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9XG59O1xuXG5sZXQgdmNhcmRQcm9wZXJ0aWVzID0gZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcbiAgXCJhZHJcIjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gIFwiYW5uaXZlcnNhcnlcIjogREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSxcbiAgXCJiZGF5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gIFwiY2FsYWRydXJpXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwiY2FsdXJpXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwiY2xpZW50cGlkbWFwXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gIFwiZW1haWxcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwiZmJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJmblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJnZW5kZXJcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgXCJnZW9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJpbXBwXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwia2V5XCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwia2luZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJsYW5nXCI6IHsgZGVmYXVsdFR5cGU6IFwibGFuZ3VhZ2UtdGFnXCIgfSxcbiAgXCJsb2dvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwibWVtYmVyXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwiblwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgXCJuaWNrbmFtZVwiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgXCJub3RlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcIm9yZ1wiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuICBcInBob3RvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwicmVsYXRlZFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcInJldlwiOiB7IGRlZmF1bHRUeXBlOiBcInRpbWVzdGFtcFwiIH0sXG4gIFwicm9sZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJzb3VuZFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcInNvdXJjZVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcInRlbFwiOiB7IGRlZmF1bHRUeXBlOiBcInVyaVwiLCBhbGxvd2VkVHlwZXM6IFtcInVyaVwiLCBcInRleHRcIl0gfSxcbiAgXCJ0aXRsZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJ0elwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ0ZXh0XCIsIFwidXRjLW9mZnNldFwiLCBcInVyaVwiXSB9LFxuICBcInhtbFwiOiBERUZBVUxUX1RZUEVfVEVYVFxufSk7XG5cbmxldCB2Y2FyZDNWYWx1ZXMgPSBleHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gIGJpbmFyeTogaWNhbFZhbHVlcy5iaW5hcnksXG4gIGRhdGU6IHZjYXJkVmFsdWVzLmRhdGUsXG4gIFwiZGF0ZS10aW1lXCI6IHZjYXJkVmFsdWVzW1wiZGF0ZS10aW1lXCJdLFxuICBcInBob25lLW51bWJlclwiOiB2Y2FyZFZhbHVlc1tcInBob25lLW51bWJlclwiXSxcbiAgdXJpOiBpY2FsVmFsdWVzLnVyaSxcbiAgdGV4dDogaWNhbFZhbHVlcy50ZXh0LFxuICB0aW1lOiBpY2FsVmFsdWVzLnRpbWUsXG4gIHZjYXJkOiBpY2FsVmFsdWVzLnRleHQsXG4gIFwidXRjLW9mZnNldFwiOiB7XG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgNyk7XG4gICAgfSxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgNyk7XG4gICAgfSxcblxuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBVdGNPZmZzZXQuZnJvbVN0cmluZyhhVmFsdWUpO1xuICAgIH0sXG5cbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5sZXQgdmNhcmQzUGFyYW1zID0ge1xuICBcInR5cGVcIjoge1xuICAgIHZhbHVlVHlwZTogXCJ0ZXh0XCIsXG4gICAgbXVsdGlWYWx1ZTogXCIsXCJcbiAgfSxcbiAgXCJ2YWx1ZVwiOiB7XG4gICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgdmFsdWVzOiBbXCJ0ZXh0XCIsIFwidXJpXCIsIFwiZGF0ZVwiLCBcImRhdGUtdGltZVwiLCBcInBob25lLW51bWJlclwiLCBcInRpbWVcIixcbiAgICAgICAgICAgICBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwiZmxvYXRcIiwgXCJ1dGMtb2Zmc2V0XCIsIFwidmNhcmRcIiwgXCJiaW5hcnlcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9XG59O1xuXG5sZXQgdmNhcmQzUHJvcGVydGllcyA9IGV4dGVuZChjb21tb25Qcm9wZXJ0aWVzLCB7XG4gIGZuOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgbjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gIG5pY2tuYW1lOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgcGhvdG86IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG4gIGJkYXk6IHtcbiAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgIH1cbiAgfSxcblxuICBhZHI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICBsYWJlbDogREVGQVVMVF9UWVBFX1RFWFQsXG5cbiAgdGVsOiB7IGRlZmF1bHRUeXBlOiBcInBob25lLW51bWJlclwiIH0sXG4gIGVtYWlsOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgbWFpbGVyOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICB0ejogeyBkZWZhdWx0VHlwZTogXCJ1dGMtb2Zmc2V0XCIsIGFsbG93ZWRUeXBlczogW1widXRjLW9mZnNldFwiLCBcInRleHRcIl0gfSxcbiAgZ2VvOiB7IGRlZmF1bHRUeXBlOiBcImZsb2F0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcblxuICB0aXRsZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gIHJvbGU6IERFRkFVTFRfVFlQRV9URVhULFxuICBsb2dvOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuICBhZ2VudDogeyBkZWZhdWx0VHlwZTogXCJ2Y2FyZFwiLCBhbGxvd2VkVHlwZXM6IFtcInZjYXJkXCIsIFwidGV4dFwiLCBcInVyaVwiXSB9LFxuICBvcmc6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG5cbiAgbm90ZTogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gIHByb2RpZDogREVGQVVMVF9UWVBFX1RFWFQsXG4gIHJldjoge1xuICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgfVxuICB9LFxuICBcInNvcnQtc3RyaW5nXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBzb3VuZDogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcblxuICBjbGFzczogREVGQVVMVF9UWVBFX1RFWFQsXG4gIGtleTogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ0ZXh0XCJdIH1cbn0pO1xuXG4vKipcbiAqIGlDYWxlbmRhciBkZXNpZ24gc2V0XG4gKiBAdHlwZSB7ZGVzaWduU2V0fVxuICovXG5sZXQgaWNhbFNldCA9IHtcbiAgdmFsdWU6IGljYWxWYWx1ZXMsXG4gIHBhcmFtOiBpY2FsUGFyYW1zLFxuICBwcm9wZXJ0eTogaWNhbFByb3BlcnRpZXMsXG4gIHByb3BlcnR5R3JvdXBzOiBmYWxzZVxufTtcblxuLyoqXG4gKiB2Q2FyZCA0LjAgZGVzaWduIHNldFxuICogQHR5cGUge2Rlc2lnblNldH1cbiAqL1xubGV0IHZjYXJkU2V0ID0ge1xuICB2YWx1ZTogdmNhcmRWYWx1ZXMsXG4gIHBhcmFtOiB2Y2FyZFBhcmFtcyxcbiAgcHJvcGVydHk6IHZjYXJkUHJvcGVydGllcyxcbiAgcHJvcGVydHlHcm91cHM6IHRydWVcbn07XG5cbi8qKlxuICogdkNhcmQgMy4wIGRlc2lnbiBzZXRcbiAqIEB0eXBlIHtkZXNpZ25TZXR9XG4gKi9cbmxldCB2Y2FyZDNTZXQgPSB7XG4gIHZhbHVlOiB2Y2FyZDNWYWx1ZXMsXG4gIHBhcmFtOiB2Y2FyZDNQYXJhbXMsXG4gIHByb3BlcnR5OiB2Y2FyZDNQcm9wZXJ0aWVzLFxuICBwcm9wZXJ0eUdyb3VwczogdHJ1ZVxufTtcblxuLyoqXG4gKiBUaGUgZGVzaWduIGRhdGEsIHVzZWQgYnkgdGhlIHBhcnNlciB0byBkZXRlcm1pbmUgdHlwZXMgZm9yIHByb3BlcnRpZXMgYW5kXG4gKiBvdGhlciBtZXRhZGF0YSBuZWVkZWQgdG8gcHJvZHVjZSBjb3JyZWN0IGpDYXJkL2pDYWwgZGF0YS5cbiAqXG4gKiBAYWxpYXMgSUNBTC5kZXNpZ25cbiAqIEBleHBvcnRzIG1vZHVsZTpJQ0FMLmRlc2lnblxuICovXG5jb25zdCBkZXNpZ24gPSB7XG4gIC8qKlxuICAgKiBDYW4gYmUgc2V0IHRvIGZhbHNlIHRvIG1ha2UgdGhlIHBhcnNlciBtb3JlIGxlbmllbnQuXG4gICAqL1xuICBzdHJpY3Q6IHRydWUsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHNldCBmb3IgbmV3IHByb3BlcnRpZXMgYW5kIGNvbXBvbmVudHMgaWYgbm9uZSBpcyBzcGVjaWZpZWQuXG4gICAqIEB0eXBlIHtkZXNpZ25TZXR9XG4gICAqL1xuICBkZWZhdWx0U2V0OiBpY2FsU2V0LFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciB1bmtub3duIHByb3BlcnRpZXNcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGRlZmF1bHRUeXBlOiAndW5rbm93bicsXG5cbiAgLyoqXG4gICAqIEhvbGRzIHRoZSBkZXNpZ24gc2V0IGZvciBrbm93biB0b3AtbGV2ZWwgY29tcG9uZW50c1xuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge2Rlc2lnblNldH0gdmNhcmQgICAgICAgdkNhcmQgVkNBUkRcbiAgICogQHByb3BlcnR5IHtkZXNpZ25TZXR9IHZldmVudCAgICAgIGlDYWxlbmRhciBWRVZFTlRcbiAgICogQHByb3BlcnR5IHtkZXNpZ25TZXR9IHZ0b2RvICAgICAgIGlDYWxlbmRhciBWVE9ET1xuICAgKiBAcHJvcGVydHkge2Rlc2lnblNldH0gdmpvdXJuYWwgICAgaUNhbGVuZGFyIFZKT1VSTkFMXG4gICAqIEBwcm9wZXJ0eSB7ZGVzaWduU2V0fSB2YWxhcm0gICAgICBpQ2FsZW5kYXIgVkFMQVJNXG4gICAqIEBwcm9wZXJ0eSB7ZGVzaWduU2V0fSB2dGltZXpvbmUgICBpQ2FsZW5kYXIgVlRJTUVaT05FXG4gICAqIEBwcm9wZXJ0eSB7ZGVzaWduU2V0fSBkYXlsaWdodCAgICBpQ2FsZW5kYXIgREFZTElHSFRcbiAgICogQHByb3BlcnR5IHtkZXNpZ25TZXR9IHN0YW5kYXJkICAgIGlDYWxlbmRhciBTVEFOREFSRFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgcHJvcGVydHlOYW1lID0gJ2ZuJztcbiAgICogbGV0IGNvbXBvbmVudERlc2lnbiA9IElDQUwuZGVzaWduLmNvbXBvbmVudHMudmNhcmQ7XG4gICAqIGxldCBwcm9wZXJ0eURldGFpbHMgPSBjb21wb25lbnREZXNpZ24ucHJvcGVydHlbcHJvcGVydHlOYW1lXTtcbiAgICogaWYgKHByb3BlcnR5RGV0YWlscy5kZWZhdWx0VHlwZSA9PSAndGV4dCcpIHtcbiAgICogICAvLyBZZXAsIHN1cmUgaXMuLi5cbiAgICogfVxuICAgKi9cbiAgY29tcG9uZW50czoge1xuICAgIHZjYXJkOiB2Y2FyZFNldCxcbiAgICB2Y2FyZDM6IHZjYXJkM1NldCxcbiAgICB2ZXZlbnQ6IGljYWxTZXQsXG4gICAgdnRvZG86IGljYWxTZXQsXG4gICAgdmpvdXJuYWw6IGljYWxTZXQsXG4gICAgdmFsYXJtOiBpY2FsU2V0LFxuICAgIHZ0aW1lem9uZTogaWNhbFNldCxcbiAgICBkYXlsaWdodDogaWNhbFNldCxcbiAgICBzdGFuZGFyZDogaWNhbFNldFxuICB9LFxuXG5cbiAgLyoqXG4gICAqIFRoZSBkZXNpZ24gc2V0IGZvciBpQ2FsZW5kYXIgKHJmYzU1NDUvcmZjNzI2NSkgY29tcG9uZW50cy5cbiAgICogQHR5cGUge2Rlc2lnblNldH1cbiAgICovXG4gIGljYWxlbmRhcjogaWNhbFNldCxcblxuICAvKipcbiAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmM2MzUwL3JmYzcwOTUpIGNvbXBvbmVudHMuXG4gICAqIEB0eXBlIHtkZXNpZ25TZXR9XG4gICAqL1xuICB2Y2FyZDogdmNhcmRTZXQsXG5cbiAgLyoqXG4gICAqIFRoZSBkZXNpZ24gc2V0IGZvciB2Q2FyZCAocmZjMjQyNS9yZmMyNDI2L3JmYzcwOTUpIGNvbXBvbmVudHMuXG4gICAqIEB0eXBlIHtkZXNpZ25TZXR9XG4gICAqL1xuICB2Y2FyZDM6IHZjYXJkM1NldCxcblxuICAvKipcbiAgICogR2V0cyB0aGUgZGVzaWduIHNldCBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50TmFtZSAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtkZXNpZ25TZXR9ICAgICAgVGhlIGRlc2lnbiBzZXQgZm9yIHRoZSBjb21wb25lbnRcbiAgICovXG4gIGdldERlc2lnblNldDogZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgIGxldCBpc0luRGVzaWduID0gY29tcG9uZW50TmFtZSAmJiBjb21wb25lbnROYW1lIGluIGRlc2lnbi5jb21wb25lbnRzO1xuICAgIHJldHVybiBpc0luRGVzaWduID8gZGVzaWduLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0gOiBkZXNpZ24uZGVmYXVsdFNldDtcbiAgfVxufTtcbnZhciBkZXNpZ24kMSA9IGRlc2lnbjtcblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5kZXNpZ25TZXR9IGRlc2lnblNldFxuICogSW1wb3J0cyB0aGUgJ2Rlc2lnblNldCcgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuY29uc3QgTElORV9FTkRJTkcgPSAnXFxyXFxuJztcbmNvbnN0IERFRkFVTFRfVkFMVUVfVFlQRSA9ICd1bmtub3duJztcbmNvbnN0IFJGQzY4NjhfUkVQTEFDRV9NQVAgPSB7ICdcIic6IFwiXidcIiwgXCJcXG5cIjogXCJeblwiLCBcIl5cIjogXCJeXlwiIH07XG5cbi8qKlxuICogQ29udmVydCBhIGZ1bGwgakNhbC9qQ2FyZCBhcnJheSBpbnRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnlcbiAqIEB2YXJpYXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGpDYWwgICAgVGhlIGpDYWwvakNhcmQgZG9jdW1lbnRcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgVGhlIHN0cmluZ2lmaWVkIGlDYWxlbmRhci92Q2FyZCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoakNhbCkge1xuICBpZiAodHlwZW9mIGpDYWxbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgY29tcG9uZW50XG4gICAgakNhbCA9IFtqQ2FsXTtcbiAgfVxuXG4gIGxldCBpID0gMDtcbiAgbGV0IGxlbiA9IGpDYWwubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBzdHJpbmdpZnkuY29tcG9uZW50KGpDYWxbaV0pICsgTElORV9FTkRJTkc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGpDYWwgY29tcG9uZW50IGFycmF5IGludG8gYSBJQ0FMIHN0cmluZy5cbiAqIFJlY3Vyc2l2ZSB3aWxsIHJlc29sdmUgc3ViLWNvbXBvbmVudHMuXG4gKlxuICogRXhhY3QgY29tcG9uZW50L3Byb3BlcnR5IG9yZGVyIGlzIG5vdCBzYXZlZCBhbGxcbiAqIHByb3BlcnRpZXMgd2lsbCBjb21lIGJlZm9yZSBzdWJjb21wb25lbnRzLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5jb21wb25lbnRcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudFxuICogICAgICAgIGpDYWwvakNhcmQgZnJhZ21lbnQgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7ZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIGNvbXBvbmVudFxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZ1xuICovXG5zdHJpbmdpZnkuY29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50LCBkZXNpZ25TZXQpIHtcbiAgbGV0IG5hbWUgPSBjb21wb25lbnRbMF0udG9VcHBlckNhc2UoKTtcbiAgbGV0IHJlc3VsdCA9ICdCRUdJTjonICsgbmFtZSArIExJTkVfRU5ESU5HO1xuXG4gIGxldCBwcm9wcyA9IGNvbXBvbmVudFsxXTtcbiAgbGV0IHByb3BJZHggPSAwO1xuICBsZXQgcHJvcExlbiA9IHByb3BzLmxlbmd0aDtcblxuICBsZXQgZGVzaWduU2V0TmFtZSA9IGNvbXBvbmVudFswXTtcbiAgLy8gcmZjNjM1MCByZXF1aXJlcyB0aGF0IGluIHZDYXJkIDQuMCB0aGUgZmlyc3QgY29tcG9uZW50IGlzIHRoZSBWRVJTSU9OXG4gIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gIGlmIChkZXNpZ25TZXROYW1lID09PSAndmNhcmQnICYmIGNvbXBvbmVudFsxXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgIShjb21wb25lbnRbMV1bMF1bMF0gPT09IFwidmVyc2lvblwiICYmIGNvbXBvbmVudFsxXVswXVszXSA9PT0gXCI0LjBcIikpIHtcbiAgICBkZXNpZ25TZXROYW1lID0gXCJ2Y2FyZDNcIjtcbiAgfVxuICBkZXNpZ25TZXQgPSBkZXNpZ25TZXQgfHwgZGVzaWduJDEuZ2V0RGVzaWduU2V0KGRlc2lnblNldE5hbWUpO1xuXG4gIGZvciAoOyBwcm9wSWR4IDwgcHJvcExlbjsgcHJvcElkeCsrKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5wcm9wZXJ0eShwcm9wc1twcm9wSWR4XSwgZGVzaWduU2V0KSArIExJTkVfRU5ESU5HO1xuICB9XG5cbiAgLy8gSWdub3JlIHN1YmNvbXBvbmVudHMgaWYgbm9uZSBleGlzdCwgZS5nLiBpbiB2Q2FyZC5cbiAgbGV0IGNvbXBzID0gY29tcG9uZW50WzJdIHx8IFtdO1xuICBsZXQgY29tcElkeCA9IDA7XG4gIGxldCBjb21wTGVuID0gY29tcHMubGVuZ3RoO1xuXG4gIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoY29tcHNbY29tcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgfVxuXG4gIHJlc3VsdCArPSAnRU5EOicgKyBuYW1lO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBqQ2FsL2pDYXJkIHByb3BlcnR5IHRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkucHJvcGVydHlcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnR5XG4gKiAgICAgICAgakNhbC9qQ2FyZCBwcm9wZXJ0eSBhcnJheVxuICogQHBhcmFtIHtkZXNpZ25TZXR9IGRlc2lnblNldFxuICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9Gb2xkXG4gKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGxpbmUgaXMgbm90IGZvbGRlZFxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZ1xuICovXG5zdHJpbmdpZnkucHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgZGVzaWduU2V0LCBub0ZvbGQpIHtcbiAgbGV0IG5hbWUgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpO1xuICBsZXQganNOYW1lID0gcHJvcGVydHlbMF07XG4gIGxldCBwYXJhbXMgPSBwcm9wZXJ0eVsxXTtcblxuICBpZiAoIWRlc2lnblNldCkge1xuICAgIGRlc2lnblNldCA9IGRlc2lnbiQxLmRlZmF1bHRTZXQ7XG4gIH1cblxuICBsZXQgZ3JvdXBOYW1lID0gcGFyYW1zLmdyb3VwO1xuICBsZXQgbGluZTtcbiAgaWYgKGRlc2lnblNldC5wcm9wZXJ0eUdyb3VwcyAmJiBncm91cE5hbWUpIHtcbiAgICBsaW5lID0gZ3JvdXBOYW1lLnRvVXBwZXJDYXNlKCkgKyBcIi5cIiArIG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGluZSA9IG5hbWU7XG4gIH1cblxuICBmb3IgKGxldCBbcGFyYW1OYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIGlmIChkZXNpZ25TZXQucHJvcGVydHlHcm91cHMgJiYgcGFyYW1OYW1lID09ICdncm91cCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBwYXJhbURlc2lnbiA9IGRlc2lnblNldC5wYXJhbVtwYXJhbU5hbWVdO1xuICAgIGxldCBtdWx0aVZhbHVlID0gcGFyYW1EZXNpZ24gJiYgcGFyYW1EZXNpZ24ubXVsdGlWYWx1ZTtcbiAgICBpZiAobXVsdGlWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhbCA9IHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlKHZhbCk7XG4gICAgICAgIHZhbCA9IHN0cmluZ2lmeS5wYXJhbVByb3BlcnR5VmFsdWUodmFsLCBwYXJhbURlc2lnbi5tdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGUpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSk7XG4gICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKHZhbHVlLCBtdWx0aVZhbHVlLCBcInVua25vd25cIiwgbnVsbCwgZGVzaWduU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSh2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5wYXJhbVByb3BlcnR5VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIGxpbmUgKz0gJzsnICsgcGFyYW1OYW1lLnRvVXBwZXJDYXNlKCkgKyAnPScgKyB2YWx1ZTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eS5sZW5ndGggPT09IDMpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdmFsdWVzLCB3ZSBtdXN0IGFzc3VtZSBhIGJsYW5rIHZhbHVlXG4gICAgcmV0dXJuIGxpbmUgKyAnOic7XG4gIH1cblxuICBsZXQgdmFsdWVUeXBlID0gcHJvcGVydHlbMl07XG5cbiAgbGV0IHByb3BEZXRhaWxzO1xuICBsZXQgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuICBsZXQgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gIGxldCBpc0RlZmF1bHQgPSBmYWxzZTtcblxuICBpZiAoanNOYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgIHByb3BEZXRhaWxzID0gZGVzaWduU2V0LnByb3BlcnR5W2pzTmFtZV07XG5cbiAgICBpZiAoJ211bHRpVmFsdWUnIGluIHByb3BEZXRhaWxzKSB7XG4gICAgICBtdWx0aVZhbHVlID0gcHJvcERldGFpbHMubXVsdGlWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoKCdzdHJ1Y3R1cmVkVmFsdWUnIGluIHByb3BEZXRhaWxzKSAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5WzNdKSkge1xuICAgICAgc3RydWN0dXJlZFZhbHVlID0gcHJvcERldGFpbHMuc3RydWN0dXJlZFZhbHVlO1xuICAgIH1cblxuICAgIGlmICgnZGVmYXVsdFR5cGUnIGluIHByb3BEZXRhaWxzKSB7XG4gICAgICBpZiAodmFsdWVUeXBlID09PSBwcm9wRGV0YWlscy5kZWZhdWx0VHlwZSkge1xuICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWVUeXBlID09PSBERUZBVUxUX1ZBTFVFX1RZUEUpIHtcbiAgICAgICAgaXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlVHlwZSA9PT0gREVGQVVMVF9WQUxVRV9UWVBFKSB7XG4gICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1c2ggdGhlIFZBTFVFIHByb3BlcnR5IGlmIHR5cGUgaXMgbm90IHRoZSBkZWZhdWx0XG4gIC8vIGZvciB0aGUgY3VycmVudCBwcm9wZXJ0eS5cbiAgaWYgKCFpc0RlZmF1bHQpIHtcbiAgICAvLyB2YWx1ZSB3aWxsIG5ldmVyIGNvbnRhaW4gOy86Lywgc28gd2UgZG9uJ3QgZXNjYXBlIGl0IGhlcmUuXG4gICAgbGluZSArPSAnO1ZBTFVFPScgKyB2YWx1ZVR5cGUudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIGxpbmUgKz0gJzonO1xuXG4gIGlmIChtdWx0aVZhbHVlICYmIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIGxpbmUgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUoXG4gICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG11bHRpVmFsdWUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgKTtcbiAgfSBlbHNlIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgIHByb3BlcnR5LnNsaWNlKDMpLCBtdWx0aVZhbHVlLCB2YWx1ZVR5cGUsIG51bGwsIGRlc2lnblNldCwgZmFsc2VcbiAgICApO1xuICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIGxpbmUgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUoXG4gICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lICs9IHN0cmluZ2lmeS52YWx1ZShwcm9wZXJ0eVszXSwgdmFsdWVUeXBlLCBkZXNpZ25TZXQsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBub0ZvbGQgPyBsaW5lIDogZm9sZGxpbmUobGluZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgZXNjYXBpbmcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgbWF5IGNvbnRhaW46XG4gKlxuICogICAgQ09MT04gKDopLCBTRU1JQ09MT04gKDspLCBvciBDT01NQSAoLClcbiAqXG4gKiBJZiBhbnkgb2YgdGhlIGFib3ZlIGFyZSBwcmVzZW50IHRoZSByZXN1bHQgaXMgd3JhcHBlZFxuICogaW4gZG91YmxlIHF1b3Rlcy5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkucGFyYW1Qcm9wZXJ0eVZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgICBSYXcgcHJvcGVydHkgdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgICAgIElmIHZhbHVlIHNob3VsZCBiZSBlc2NhcGVkIGV2ZW4gd2hlbiB1bm5lY2Vzc2FyeVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgR2l2ZW4gb3IgZXNjYXBlZCB2YWx1ZSB3aGVuIG5lZWRlZFxuICovXG5zdHJpbmdpZnkucGFyYW1Qcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGZvcmNlKSB7XG4gIGlmICghZm9yY2UgJiZcbiAgICAgICh2YWx1ZS5pbmRleE9mKCcsJykgPT09IC0xKSAmJlxuICAgICAgKHZhbHVlLmluZGV4T2YoJzonKSA9PT0gLTEpICYmXG4gICAgICAodmFsdWUuaW5kZXhPZignOycpID09PSAtMSkpIHtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBpY2FsIHZhbHVlcyBpbnRvIGEgc2luZ2xlXG4gKiBzdHJpbmcgYmFzZWQgb24gYSB0eXBlIGFuZCBhIGRlbGltaXRlciB2YWx1ZSAobGlrZSBcIixcIikuXG4gKlxuICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5Lm11bHRpVmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICAgIExpc3Qgb2YgdmFsdWVzIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWxpbSAgICAgIFVzZWQgdG8gam9pbiB0aGUgdmFsdWVzIChcIixcIiwgXCI7XCIsIFwiOlwiKVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgTG93ZWNhc2UgaWNhbCB2YWx1ZSB0eXBlXG4gKiAgICAgICAgKGxpa2UgYm9vbGVhbiwgZGF0ZS10aW1lLCBldGMuLilcbiAqIEBwYXJhbSB7P1N0cmluZ30gaW5uZXJNdWx0aSBJZiBzZXQsIGVhY2ggdmFsdWUgd2lsbCBhZ2FpbiBiZSBwcm9jZXNzZWRcbiAqICAgICAgICBVc2VkIGZvciBzdHJ1Y3R1cmVkIHZhbHVlc1xuICogQHBhcmFtIHtkZXNpZ25TZXR9IGRlc2lnblNldFxuICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nIGZvciB2YWx1ZVxuICovXG5zdHJpbmdpZnkubXVsdGlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZGVsaW0sIHR5cGUsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgbGV0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlubmVyTXVsdGkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNbaV0pKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUodmFsdWVzW2ldLCBpbm5lck11bHRpLCB0eXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkudmFsdWUodmFsdWVzW2ldLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGkgIT09IChsZW4gLSAxKSkge1xuICAgICAgcmVzdWx0ICs9IGRlbGltO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIHNpbmdsZSBpY2FsIHZhbHVlIHJ1bnMgdGhlIGFzc29jaWF0ZWQgXCJ0b0lDQUxcIiBtZXRob2QgZnJvbSB0aGVcbiAqIGRlc2lnbiB2YWx1ZSB0eXBlIGlmIGF2YWlsYWJsZSB0byBjb252ZXJ0IHRoZSB2YWx1ZS5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkudmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWUgICAgICAgQSBmb3JtYXR0ZWQgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICAgICAgICAgICAgTG93ZXJjYXNlIGlDYWxlbmRhci92Q2FyZCB2YWx1ZSB0eXBlXG4gKiAgKGxpa2UgYm9vbGVhbiwgZGF0ZS10aW1lLCBldGMuLilcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIGZvciBzaW5nbGUgdmFsdWVcbiAqL1xuc3RyaW5naWZ5LnZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gIGlmICh0eXBlIGluIGRlc2lnblNldC52YWx1ZSAmJiAndG9JQ0FMJyBpbiBkZXNpZ25TZXQudmFsdWVbdHlwZV0pIHtcbiAgICByZXR1cm4gZGVzaWduU2V0LnZhbHVlW3R5cGVdLnRvSUNBTCh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnN0cmluZ2lmeSBzbyB0aGF0XG4gKiBoYWNrZXJzIGNhbiBkaXNhYmxlIHRoZSByZmM2ODY4IHBhcnNpbmcgaWYgdGhlIHJlYWxseSBuZWVkIHRvLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byB1bmVzY2FwZVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGVzY2FwZWQgdmFsdWVcbiAqL1xuc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbC5yZXBsYWNlKC9bXFxuXlwiXS9nLCBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIFJGQzY4NjhfUkVQTEFDRV9NQVBbeF07XG4gIH0pO1xufTtcblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbmNvbnN0IE5BTUVfSU5ERVgkMSA9IDA7XG5jb25zdCBQUk9QX0lOREVYID0gMTtcbmNvbnN0IFRZUEVfSU5ERVggPSAyO1xuY29uc3QgVkFMVUVfSU5ERVggPSAzO1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5kZXNpZ25TZXR9IGRlc2lnblNldFxuICogSW1wb3J0cyB0aGUgJ2Rlc2lnblNldCcgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5HZW99IEdlb1xuICogSW1wb3J0cyB0aGUgJ0dlbycgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlcyBhIGxheWVyIG9uIHRvcCBvZiB0aGUgcmF3IGpDYWwgb2JqZWN0IGZvciBtYW5pcHVsYXRpbmcgYSBzaW5nbGUgcHJvcGVydHksIHdpdGggaXRzXG4gKiBwYXJhbWV0ZXJzIGFuZCB2YWx1ZS5cbiAqXG4gKiBAbWVtYmVyb2YgSUNBTFxuICovXG5jbGFzcyBQcm9wZXJ0eSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4ge0BsaW5rIElDQUwuUHJvcGVydHl9IGJ5IHBhcnNpbmcgdGhlIHBhc3NlZCBpQ2FsZW5kYXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgVGhlIGlDYWxlbmRhciBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtkZXNpZ25TZXQ9fSBkZXNpZ25TZXQgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7UHJvcGVydHl9ICAgICAgICAgICAgIFRoZSBjcmVhdGVkIGlDYWxlbmRhciBwcm9wZXJ0eVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCBkZXNpZ25TZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KHBhcnNlLnByb3BlcnR5KHN0ciwgZGVzaWduU2V0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlByb3BlcnR5IGluc3RhbmNlLlxuICAgKlxuICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IG11dGF0aW9ucyBkb25lIGluIHRoZSB3cmFwcGVyIGRpcmVjdGx5IG11dGF0ZSB0aGUgakNhbCBvYmplY3QgdXNlZFxuICAgKiB0byBpbml0aWFsaXplLlxuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBuZXcgcHJvcGVydGllcyBieSBwYXNzaW5nIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAoYXMgYSBTdHJpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gakNhbCAgICAgICAgIFJhdyBqQ2FsIHJlcHJlc2VudGF0aW9uIE9SIHRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHtDb21wb25lbnQ9fSBwYXJlbnQgICAgICAgICBQYXJlbnQgY29tcG9uZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihqQ2FsLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblxuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXZSBhcmUgY3JlYXRpbmcgdGhlIHByb3BlcnR5IGJ5IG5hbWUgYW5kIG5lZWQgdG8gZGV0ZWN0IHRoZSB0eXBlXG4gICAgICB0aGlzLmpDYWwgPSBbakNhbCwge30sIGRlc2lnbiQxLmRlZmF1bHRUeXBlXTtcbiAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHRoaXMuZ2V0RGVmYXVsdFR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5qQ2FsID0gakNhbDtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSB0eXBlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5qQ2FsW1RZUEVfSU5ERVhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgcHJvcGVydHksIGluIGxvd2VyY2FzZS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmpDYWxbTkFNRV9JTkRFWCQxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGFyZW50IGNvbXBvbmVudCBmb3IgdGhpcyBwcm9wZXJ0eS5cbiAgICogQHR5cGUge0NvbXBvbmVudH1cbiAgICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuXG4gIHNldCBwYXJlbnQocCkge1xuICAgIC8vIEJlZm9yZSBzZXR0aW5nIHRoZSBwYXJlbnQsIGNoZWNrIGlmIHRoZSBkZXNpZ24gc2V0IGhhcyBjaGFuZ2VkLiBJZiBpdFxuICAgIC8vIGhhcywgd2UgbGF0ZXIgbmVlZCB0byB1cGRhdGUgdGhlIHR5cGUgaWYgaXQgd2FzIHVua25vd24gYmVmb3JlLlxuICAgIGxldCBkZXNpZ25TZXRDaGFuZ2VkID0gIXRoaXMuX3BhcmVudCB8fCAocCAmJiBwLl9kZXNpZ25TZXQgIT0gdGhpcy5fcGFyZW50Ll9kZXNpZ25TZXQpO1xuXG4gICAgdGhpcy5fcGFyZW50ID0gcDtcblxuICAgIGlmICh0aGlzLnR5cGUgPT0gZGVzaWduJDEuZGVmYXVsdFR5cGUgJiYgZGVzaWduU2V0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5qQ2FsW1RZUEVfSU5ERVhdID0gdGhpcy5nZXREZWZhdWx0VHlwZSgpO1xuICAgICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdGhpcyBwcm9wZXJ0eSwgZS5nLiBpY2FsZW5kYXIgdnMgdmNhcmRcbiAgICpcbiAgICogQHR5cGUge2Rlc2lnblNldH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBfZGVzaWduU2V0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Ll9kZXNpZ25TZXQgOiBkZXNpZ24kMS5kZWZhdWx0U2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHR5cGUgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBqQ2FsIHR5cGUgYW5kIGRlc2lnbiBzZXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlVHlwZSgpIHtcbiAgICBsZXQgZGVzaWduU2V0ID0gdGhpcy5fZGVzaWduU2V0O1xuXG4gICAgaWYgKHRoaXMudHlwZSBpbiBkZXNpZ25TZXQudmFsdWUpIHtcbiAgICAgIGlmICgnZGVjb3JhdGUnIGluIGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdKSB7XG4gICAgICAgIHRoaXMuaXNEZWNvcmF0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLmlzTXVsdGlWYWx1ZSA9ICgnbXVsdGlWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICB0aGlzLmlzU3RydWN0dXJlZFZhbHVlID0gKCdzdHJ1Y3R1cmVkVmFsdWUnIGluIGRlc2lnblNldC5wcm9wZXJ0eVt0aGlzLm5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSHlkcmF0ZSBhIHNpbmdsZSB2YWx1ZS4gVGhlIGFjdCBvZiBoeWRyYXRpbmcgbWVhbnMgdHVybmluZyB0aGUgcmF3IGpDYWxcbiAgICogdmFsdWUgaW50byBhIHBvdGVudGlhbGx5IHdyYXBwZWQgb2JqZWN0LCBmb3IgZXhhbXBsZSB7QGxpbmsgSUNBTC5UaW1lfS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIGh5ZHJhdGVcbiAgICogQHJldHVybiB7P09iamVjdH0gICAgICAgICAgICAgVGhlIGRlY29yYXRlZCB2YWx1ZS5cbiAgICovXG4gIF9oeWRyYXRlVmFsdWUoaW5kZXgpIHtcbiAgICBpZiAodGhpcy5fdmFsdWVzICYmIHRoaXMuX3ZhbHVlc1tpbmRleF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIC8vIGZvciB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBubyB2YWx1ZS5cbiAgICBpZiAodGhpcy5qQ2FsLmxlbmd0aCA8PSAoVkFMVUVfSU5ERVggKyBpbmRleCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKFxuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF1cbiAgICAgICkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvcmF0ZSBhIHNpbmdsZSB2YWx1ZSwgcmV0dXJuaW5nIGl0cyB3cmFwcGVkIG9iamVjdC4gVGhpcyBpcyB1c2VkIGJ5XG4gICAqIHRoZSBoeWRyYXRlIGZ1bmN0aW9uIHRvIGFjdHVhbGx5IHdyYXAgdGhlIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgVGhlIHZhbHVlIHRvIGRlY29yYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBUaGUgZGVjb3JhdGVkIHZhbHVlXG4gICAqL1xuICBfZGVjb3JhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0uZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZGVjb3JhdGUgYSBzaW5nbGUgdmFsdWUsIHJldHVybmluZyBpdHMgcmF3IGpDYWwgZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlICAgICAgICAgVGhlIHZhbHVlIHRvIHVuZGVjb3JhdGVcbiAgICogQHJldHVybiB7P30gICAgICAgICAgICAgICAgICAgVGhlIHVuZGVjb3JhdGVkIHZhbHVlXG4gICAqL1xuICBfdW5kZWNvcmF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9kZXNpZ25TZXQudmFsdWVbdGhpcy50eXBlXS51bmRlY29yYXRlKHZhbHVlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2hpbGUgYWxzbyBoeWRyYXRpbmcgaXQuIFRoZSBwYXNzZWRcbiAgICogdmFsdWUgY2FuIGVpdGhlciBiZSBhIGRlY29yYXRlZCBvciB1bmRlY29yYXRlZCB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHs/fSB2YWx1ZSAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgICAgVGhlIGluZGV4IHRvIHNldCBpdCBhdFxuICAgKi9cbiAgX3NldERlY29yYXRlZFZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgJ2ljYWx0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgLy8gZGVjb3JhdGVkIHZhbHVlXG4gICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF0gPSB0aGlzLl91bmRlY29yYXRlKHZhbHVlKTtcbiAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5kZWNvcmF0ZWQgdmFsdWVcbiAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XSA9IHZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHBhcmFtZXRlciBvbiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgbmFtZSAgIFBhcmFtZXRlciBuYW1lIChsb3dlcmNhc2UpXG4gICAqIEByZXR1cm4ge0FycmF5fFN0cmluZ30gICAgICAgIFBhcmFtZXRlciB2YWx1ZVxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyKG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLmpDYWxbUFJPUF9JTkRFWF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZmlyc3QgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgUGFyYW1ldGVyIHZhbHVlXG4gICAqL1xuICBnZXRGaXJzdFBhcmFtZXRlcihuYW1lKSB7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSB0aGlzLmdldFBhcmFtZXRlcihuYW1lKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgIFRoZSBwYXJhbWV0ZXIgbmFtZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsdWUgICAgVGhlIHBhcmFtZXRlciB2YWx1ZVxuICAgKi9cbiAgc2V0UGFyYW1ldGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGxjbmFtZSBpbiB0aGlzLl9kZXNpZ25TZXQucGFyYW0gJiZcbiAgICAgICAgJ211bHRpVmFsdWUnIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbVtsY25hbWVdKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgVGhlIHBhcmFtZXRlciBuYW1lXG4gICAqL1xuICByZW1vdmVQYXJhbWV0ZXIobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb24gdGhpcyBwcm9wZXJ0eSdzIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICovXG4gIGdldERlZmF1bHRUeXBlKCkge1xuICAgIGxldCBuYW1lID0gdGhpcy5qQ2FsW05BTUVfSU5ERVgkMV07XG4gICAgbGV0IGRlc2lnblNldCA9IHRoaXMuX2Rlc2lnblNldDtcblxuICAgIGlmIChuYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgbGV0IGRldGFpbHMgPSBkZXNpZ25TZXQucHJvcGVydHlbbmFtZV07XG4gICAgICBpZiAoJ2RlZmF1bHRUeXBlJyBpbiBkZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiBkZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaWduJDEuZGVmYXVsdFR5cGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0eXBlIG9mIHByb3BlcnR5IGFuZCBjbGVhcnMgb3V0IGFueSBleGlzdGluZyB2YWx1ZXMgb2YgdGhlIGN1cnJlbnRcbiAgICogdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgIE5ldyBpQ0FMIHR5cGUgKHNlZSBkZXNpZ24uKi52YWx1ZXMpXG4gICAqL1xuICByZXNldFR5cGUodHlwZSkge1xuICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgdGhpcy5qQ2FsW1RZUEVfSU5ERVhdID0gdHlwZTtcbiAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHByb3BlcnR5IHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCaW5hcnkgfCBEdXJhdGlvbiB8IFBlcmlvZCB8XG4gICAqIFJlY3VyIHwgVGltZSB8IFV0Y09mZnNldCB8IEdlbyB8IHN0cmluZyB8IG51bGx9ICAgICAgICAgRmlyc3QgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIGdldEZpcnN0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVWYWx1ZSgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB2YWx1ZXMgb24gdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIGNyZWF0ZXMgYW4gYXJyYXkgZHVyaW5nIGVhY2ggY2FsbC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIExpc3Qgb2YgdmFsdWVzXG4gICAqL1xuICBnZXRWYWx1ZXMoKSB7XG4gICAgbGV0IGxlbiA9IHRoaXMuakNhbC5sZW5ndGggLSBWQUxVRV9JTkRFWDtcblxuICAgIGlmIChsZW4gPCAxKSB7XG4gICAgICAvLyBpdCBpcyBwb3NzaWJsZSBmb3IgYSBwcm9wZXJ0eSB0byBoYXZlIG5vIHZhbHVlLlxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB0aGlzLl9oeWRyYXRlVmFsdWUoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB2YWx1ZXMgZnJvbSB0aGlzIHByb3BlcnR5XG4gICAqL1xuICByZW1vdmVBbGxWYWx1ZXMoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlcykge1xuICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuakNhbC5sZW5ndGggPSAzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgcHJvcGVydHkuICBXaWxsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgdmFsdWVzLlxuICAgKiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgZm9yIG11bHRpLXZhbHVlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICBBbiBhcnJheSBvZiB2YWx1ZXNcbiAgICovXG4gIHNldFZhbHVlcyh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNNdWx0aVZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHRoaXMubmFtZSArICc6IGRvZXMgbm90IG5vdCBzdXBwb3J0IG11bGl0VmFsdWUuXFxuJyArXG4gICAgICAgICdvdmVycmlkZSBpc011bHRpVmFsdWUnXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB0aGlzLnJlbW92ZUFsbFZhbHVlcygpO1xuXG4gICAgaWYgKGxlbiA+IDAgJiZcbiAgICAgICAgdHlwZW9mKHZhbHVlc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdpY2FsdHlwZScgaW4gdmFsdWVzWzBdKSB7XG4gICAgICB0aGlzLnJlc2V0VHlwZSh2YWx1ZXNbMF0uaWNhbHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3NldERlY29yYXRlZFZhbHVlKHZhbHVlc1tpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaV0gPSB2YWx1ZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LiBJZiB0aGlzIGlzIGEgbXVsdGktdmFsdWVcbiAgICogcHJvcGVydHksIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlICAgICBOZXcgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmICdpY2FsdHlwZScgaW4gdmFsdWUpIHtcbiAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlLmljYWx0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RlY29yYXRlZCkge1xuICAgICAgdGhpcy5fc2V0RGVjb3JhdGVkVmFsdWUodmFsdWUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVhdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC4gVGhlIHJldHVybmVkIG9iamVjdFxuICAgKiBpcyBhIGxpdmUgakNhbCBvYmplY3QgYW5kIHNob3VsZCBiZSBjbG9uZWQgaWYgbW9kaWZpZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5qQ2FsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSUNBTFN0cmluZygpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5LnByb3BlcnR5KFxuICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXQsIHRydWVcbiAgICApO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5kZXNpZ25TZXR9IGRlc2lnblNldFxuICogSW1wb3J0cyB0aGUgJ2Rlc2lnblNldCcgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5HZW99IEdlb1xuICogSW1wb3J0cyB0aGUgJ0dlbycgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuY29uc3QgTkFNRV9JTkRFWCA9IDA7XG5jb25zdCBQUk9QRVJUWV9JTkRFWCA9IDE7XG5jb25zdCBDT01QT05FTlRfSU5ERVggPSAyO1xuXG4vKipcbiAqIFdyYXBzIGEgakNhbCBjb21wb25lbnQsIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGFkZCwgcmVtb3ZlIGFuZCB1cGRhdGUgc3ViY29tcG9uZW50cyBhbmRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB7QGxpbmsgSUNBTC5Db21wb25lbnR9IGJ5IHBhcnNpbmcgdGhlIHBhc3NlZCBpQ2FsZW5kYXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICBUaGUgaUNhbGVuZGFyIHN0cmluZyB0byBwYXJzZVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnQocGFyc2UuY29tcG9uZW50KHN0cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gakNhbCAgICAgICAgIFJhdyBqQ2FsIGNvbXBvbmVudCBkYXRhIE9SIG5hbWUgb2YgbmV3XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRcbiAgICogQHBhcmFtIHtDb21wb25lbnQ9fSBwYXJlbnQgICAgIFBhcmVudCBjb21wb25lbnQgdG8gYXNzb2NpYXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihqQ2FsLCBwYXJlbnQpIHtcbiAgICBpZiAodHlwZW9mKGpDYWwpID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gakNhbCBzcGVjIChuYW1lLCBwcm9wZXJ0aWVzLCBjb21wb25lbnRzKVxuICAgICAgakNhbCA9IFtqQ2FsLCBbXSwgW11dO1xuICAgIH1cblxuICAgIC8vIG1vc3RseSBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gICAgdGhpcy5qQ2FsID0gakNhbDtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG5cbiAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMubmFtZSA9PT0gJ3ZjYWxlbmRhcicpIHtcbiAgICAgIHRoaXMuX3RpbWV6b25lQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEh5ZHJhdGVkIHByb3BlcnRpZXMgYXJlIGluc2VydGVkIGludG8gdGhlIF9wcm9wZXJ0aWVzIGFycmF5IGF0IHRoZSBzYW1lXG4gICAqIHBvc2l0aW9uIGFzIGluIHRoZSBqQ2FsIGFycmF5LCBzbyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBhcnJheSBjb250YWluc1xuICAgKiB1bmRlZmluZWQgdmFsdWVzIGZvciB1bmh5ZHJkYXRlZCBwcm9wZXJ0aWVzLiBUbyBhdm9pZCBpdGVyYXRpbmcgdGhlXG4gICAqIGFycmF5IHdoZW4gY2hlY2tpbmcgaWYgYWxsIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGh5ZHJhdGVkLCB3ZSBzYXZlIHRoZVxuICAgKiBjb3VudCBoZXJlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBzYW1lIGNvdW50IGFzIGZvciBfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50LCBidXQgZm9yIHN1YmNvbXBvbmVudHNcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcblxuICAvKipcbiAgICogQSBjYWNoZSBvZiBoeWRyYXRlZCB0aW1lIHpvbmUgb2JqZWN0cyB3aGljaCBtYXkgYmUgdXNlZCBieSBjb25zdW1lcnMsIGtleWVkXG4gICAqIGJ5IHRpbWUgem9uZSBJRC5cbiAgICpcbiAgICogQHR5cGUge01hcH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90aW1lem9uZUNhY2hlID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wb25lbnRzID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9wZXJ0aWVzID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyBjb21wb25lbnRcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmpDYWxbTkFNRV9JTkRFWF07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHRoaXMgY29tcG9uZW50LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgKlxuICAgKiBAdHlwZSB7ZGVzaWduU2V0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IF9kZXNpZ25TZXQoKSB7XG4gICAgbGV0IHBhcmVudERlc2lnbiA9IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Ll9kZXNpZ25TZXQ7XG4gICAgcmV0dXJuIHBhcmVudERlc2lnbiB8fCBkZXNpZ24kMS5nZXREZXNpZ25TZXQodGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2h5ZHJhdGVDb21wb25lbnQoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb21wb25lbnRzW2luZGV4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdO1xuICAgIH1cblxuICAgIGxldCBjb21wID0gbmV3IENvbXBvbmVudChcbiAgICAgIHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdW2luZGV4XSxcbiAgICAgIHRoaXNcbiAgICApO1xuXG4gICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCsrO1xuICAgIHJldHVybiAodGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2h5ZHJhdGVQcm9wZXJ0eShpbmRleCkge1xuICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IFtdO1xuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHJvcGVydGllc1tpbmRleF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XTtcbiAgICB9XG5cbiAgICBsZXQgcHJvcCA9IG5ldyBQcm9wZXJ0eShcbiAgICAgIHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF1baW5kZXhdLFxuICAgICAgdGhpc1xuICAgICk7XG5cbiAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQrKztcbiAgICByZXR1cm4gKHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdID0gcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgZmlyc3Qgc3ViIGNvbXBvbmVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIE9wdGlvbmFsIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAqIEByZXR1cm4gez9Db21wb25lbnR9ICAgICBUaGUgZm91bmQgc3ViY29tcG9uZW50XG4gICAqL1xuICBnZXRGaXJzdFN1YmNvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBjb21wcyA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdO1xuICAgICAgbGV0IGxlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoY29tcHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHdlIHJldHVybiBhIHZhbHVlIChzdHJpY3QgbW9kZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgc3ViIGNvbXBvbmVudHMsIG9wdGlvbmFsbHkgZmlsdGVyaW5nIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgIE9wdGlvbmFsIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAqIEByZXR1cm4ge0NvbXBvbmVudFtdfSAgICAgICBUaGUgZm91bmQgc3ViIGNvbXBvbmVudHNcbiAgICovXG4gIGdldEFsbFN1YmNvbXBvbmVudHMobmFtZSkge1xuICAgIGxldCBqQ2FsTGVuID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBsZXQgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IGNvbXBzW2ldW05BTUVfSU5ERVhdKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzIHx8XG4gICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cyB8fCBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gYSBuYW1lZCBwcm9wZXJ0eSBleGlzdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICBUaGUgcHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSwgd2hlbiBwcm9wZXJ0eSBpcyBmb3VuZFxuICAgKi9cbiAgaGFzUHJvcGVydHkobmFtZSkge1xuICAgIGxldCBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgbGV0IGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyAwIGlzIHByb3BlcnR5IG5hbWVcbiAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHByb3BlcnR5LCBvcHRpb25hbGx5IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7P1Byb3BlcnR5fSAgICAgVGhlIGZvdW5kIHByb3BlcnR5XG4gICAqL1xuICBnZXRGaXJzdFByb3BlcnR5KG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgIGxldCBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHByb3BzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZVByb3BlcnR5KDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlyc3QgcHJvcGVydHkncyB2YWx1ZSwgaWYgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgICAgICAgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAqIEByZXR1cm4ge0JpbmFyeSB8IER1cmF0aW9uIHwgUGVyaW9kIHxcbiAgICogUmVjdXIgfCBUaW1lIHwgVXRjT2Zmc2V0IHwgR2VvIHwgc3RyaW5nIHwgbnVsbH0gICAgICAgICBUaGUgZm91bmQgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBnZXRGaXJzdFByb3BlcnR5VmFsdWUobmFtZSkge1xuICAgIGxldCBwcm9wID0gdGhpcy5nZXRGaXJzdFByb3BlcnR5KG5hbWUpO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC5nZXRGaXJzdFZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBwcm9wZXJ0aWVzIGluIHRoZSBjb21wb25lbnQsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHtQcm9wZXJ0eVtdfSAgICBMaXN0IG9mIHByb3BlcnRpZXNcbiAgICovXG4gIGdldEFsbFByb3BlcnRpZXMobmFtZSkge1xuICAgIGxldCBqQ2FsTGVuID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGxldCBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBwcm9wc1tpXVtOQU1FX0lOREVYXSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzIHx8XG4gICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCAhPT0gakNhbExlbikpIHtcbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXMgfHwgW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlLCBpbmRleCkge1xuICAgIGNhY2hlID0gY2FjaGUgfHwgW107XG4gICAgLy8gcmVtb3ZlIGNhY2hlZCB2ZXJzaW9uXG4gICAgaWYgKGNhY2hlW2luZGV4XSkge1xuICAgICAgbGV0IG9iaiA9IGNhY2hlW2luZGV4XTtcbiAgICAgIGlmIChcInBhcmVudFwiIGluIG9iaikge1xuICAgICAgICAgIG9iai5wYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhY2hlLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgakNhbFxuICAgIHRoaXMuakNhbFtqQ2FsSW5kZXhdLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVPYmplY3QoakNhbEluZGV4LCBjYWNoZSwgbmFtZU9yT2JqZWN0KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBvYmplY3RzID0gdGhpcy5qQ2FsW2pDYWxJbmRleF07XG4gICAgbGV0IGxlbiA9IG9iamVjdHMubGVuZ3RoO1xuICAgIGxldCBjYWNoZWQgPSB0aGlzW2NhY2hlXTtcblxuICAgIGlmICh0eXBlb2YobmFtZU9yT2JqZWN0KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWVPck9iamVjdCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYWNoZWQpIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNhY2hlZFtpXSAmJiBjYWNoZWRbaV0gPT09IG5hbWVPck9iamVjdCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlQWxsT2JqZWN0cyhqQ2FsSW5kZXgsIGNhY2hlLCBuYW1lKSB7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXNbY2FjaGVdO1xuXG4gICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBoYXZlIHRvIHJ1biB0aHJvdWdoIGFsbCBjaGlsZHJlbiB0byByZXNldCB0aGVpclxuICAgIC8vIHBhcmVudCBwcm9wZXJ0eS5cbiAgICBsZXQgb2JqZWN0cyA9IHRoaXMuakNhbFtqQ2FsSW5kZXhdO1xuICAgIGxldCBpID0gb2JqZWN0cy5sZW5ndGggLSAxO1xuXG4gICAgLy8gZGVzY2VuZGluZyBzZWFyY2ggcmVxdWlyZWQgYmVjYXVzZSBzcGxpY2VcbiAgICAvLyBpcyB1c2VkIGFuZCB3aWxsIGVmZmVjdCB0aGUgaW5kaWNlcy5cbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICghbmFtZSB8fCBvYmplY3RzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc2luZ2xlIHN1YiBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgICAgICAgIFRoZSBjb21wb25lbnQgdG8gYWRkXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH0gICAgICAgICAgICAgICAgIFRoZSBwYXNzZWQgaW4gY29tcG9uZW50XG4gICAqL1xuICBhZGRTdWJjb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKCF0aGlzLl9jb21wb25lbnRzKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50LnBhcmVudCkge1xuICAgICAgY29tcG9uZW50LnBhcmVudC5yZW1vdmVTdWJjb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBsZXQgaWR4ID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ucHVzaChjb21wb25lbnQuakNhbCk7XG4gICAgdGhpcy5fY29tcG9uZW50c1tpZHggLSAxXSA9IGNvbXBvbmVudDtcbiAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50Kys7XG4gICAgY29tcG9uZW50LnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc2luZ2xlIGNvbXBvbmVudCBieSBuYW1lIG9yIHRoZSBpbnN0YW5jZSBvZiBhIHNwZWNpZmljXG4gICAqIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR8U3RyaW5nfSBuYW1lT3JDb21wICAgIE5hbWUgb2YgY29tcG9uZW50LCBvciBjb21wb25lbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGNvbXAgaXMgcmVtb3ZlZFxuICAgKi9cbiAgcmVtb3ZlU3ViY29tcG9uZW50KG5hbWVPckNvbXApIHtcbiAgICBsZXQgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU9iamVjdChDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWVPckNvbXApO1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50LS07XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNvbXBvbmVudHMgb3IgKGlmIGdpdmVuKSBhbGwgY29tcG9uZW50cyBieSBhIHBhcnRpY3VsYXJcbiAgICogbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICAgICAgTG93ZXJjYXNlIGNvbXBvbmVudCBuYW1lXG4gICAqL1xuICByZW1vdmVBbGxTdWJjb21wb25lbnRzKG5hbWUpIHtcbiAgICBsZXQgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZUFsbE9iamVjdHMoQ09NUE9ORU5UX0lOREVYLCAnX2NvbXBvbmVudHMnLCBuYW1lKTtcbiAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIHtAbGluayBJQ0FMLlByb3BlcnR5fSB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBwcm9wZXJ0eSAgICAgIFRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHJldHVybiB7UHJvcGVydHl9ICAgICAgICAgICAgICBUaGUgcGFzc2VkIGluIHByb3BlcnR5XG4gICAqL1xuICBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmICghKHByb3BlcnR5IGluc3RhbmNlb2YgUHJvcGVydHkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGluc3RhbmNlIG9mIElDQUwuUHJvcGVydHknKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5LnBhcmVudCkge1xuICAgICAgcHJvcGVydHkucGFyZW50LnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICBsZXQgaWR4ID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5wdXNoKHByb3BlcnR5LmpDYWwpO1xuICAgIHRoaXMuX3Byb3BlcnRpZXNbaWR4IC0gMV0gPSBwcm9wZXJ0eTtcbiAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQrKztcbiAgICBwcm9wZXJ0eS5wYXJlbnQgPSB0aGlzO1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBhIHByb3BlcnR5IHdpdGggYSB2YWx1ZSB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBuYW1lICAgICAgICAgUHJvcGVydHkgbmFtZSB0byBhZGRcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gdmFsdWUgICAgICAgIFByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge1Byb3BlcnR5fSAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvcGVydHlcbiAgICovXG4gIGFkZFByb3BlcnR5V2l0aFZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IHByb3AgPSBuZXcgUHJvcGVydHkobmFtZSk7XG4gICAgcHJvcC5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICB0aGlzLmFkZFByb3BlcnR5KHByb3ApO1xuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0aGF0IHdpbGwgdXBkYXRlIG9yIGNyZWF0ZSBhIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBuYW1lXG4gICAqIGFuZCBzZXRzIGl0cyB2YWx1ZS4gSWYgbXVsdGlwbGUgcHJvcGVydGllcyB3aXRoIHRoZSBnaXZlbiBuYW1lIGV4aXN0LFxuICAgKiBvbmx5IHRoZSBmaXJzdCBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBuYW1lICAgICAgICAgUHJvcGVydHkgbmFtZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gdmFsdWUgICAgICAgIFByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge1Byb3BlcnR5fSAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvcGVydHlcbiAgICovXG4gIHVwZGF0ZVByb3BlcnR5V2l0aFZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IHByb3AgPSB0aGlzLmdldEZpcnN0UHJvcGVydHkobmFtZSk7XG5cbiAgICBpZiAocHJvcCkge1xuICAgICAgcHJvcC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AgPSB0aGlzLmFkZFByb3BlcnR5V2l0aFZhbHVlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc2luZ2xlIHByb3BlcnR5IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpY1xuICAgKiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8UHJvcGVydHl9IG5hbWVPclByb3AgICAgIFByb3BlcnR5IG5hbWUgb3IgaW5zdGFuY2UgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRydWUsIHdoZW4gZGVsZXRlZFxuICAgKi9cbiAgcmVtb3ZlUHJvcGVydHkobmFtZU9yUHJvcCkge1xuICAgIGxldCByZW1vdmVkID0gdGhpcy5fcmVtb3ZlT2JqZWN0KFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lT3JQcm9wKTtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50LS07XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LCBvcHRpb25hbGx5XG4gICAqIGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICBUcnVlLCB3aGVuIGRlbGV0ZWRcbiAgICovXG4gIHJlbW92ZUFsbFByb3BlcnRpZXMobmFtZSkge1xuICAgIGxldCByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhQUk9QRVJUWV9JTkRFWCwgJ19wcm9wZXJ0aWVzJywgbmFtZSk7XG4gICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuIFRoZSByZXR1cm5lZCBvYmplY3RcbiAgICogaXMgYSBsaXZlIGpDYWwgb2JqZWN0IGFuZCBzaG91bGQgYmUgY2xvbmVkIGlmIG1vZGlmaWVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuakNhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5LmNvbXBvbmVudChcbiAgICAgIHRoaXMuakNhbCwgdGhpcy5fZGVzaWduU2V0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHRpbWUgem9uZSBkZWZpbml0aW9uIGZyb20gdGhlIGNvbXBvbmVudCB0cmVlLCBpZiBhbnkgaXMgcHJlc2VudC5cbiAgICogSWYgdGhlIHRyZWUgY29udGFpbnMgbm8gdGltZSB6b25lIGRlZmluaXRpb25zIG9yIHRoZSBUWklEIGNhbm5vdCBiZVxuICAgKiBtYXRjaGVkLCByZXR1cm5zIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0emlkICAgICBUaGUgSUQgb2YgdGhlIHRpbWUgem9uZSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJuIHtUaW1lem9uZX0gIFRoZSB0aW1lIHpvbmUgY29ycmVzcG9uZGluZyB0byB0aGUgSUQsIG9yIG51bGxcbiAgICovXG4gIGdldFRpbWVab25lQnlJRCh0emlkKSB7XG4gICAgLy8gVlRJTUVaT05FIGNvbXBvbmVudHMgY2FuIG9ubHkgYXBwZWFyIGFzIGEgY2hpbGQgb2YgdGhlIFZDQUxFTkRBUlxuICAgIC8vIGNvbXBvbmVudDsgd2FsayB0aGUgdHJlZSBpZiB3ZSdyZSBub3QgdGhlIHJvb3QuXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0VGltZVpvbmVCeUlEKHR6aWQpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpbWUgem9uZSBjYWNoZSwgd2UgYXJlIHByb2JhYmx5IHBhcnNpbmcgYW4gaW5jb21wbGV0ZVxuICAgIC8vIGZpbGUgYW5kIHdpbGwgaGF2ZSBubyB0aW1lIHpvbmUgZGVmaW5pdGlvbnMuXG4gICAgaWYgKCF0aGlzLl90aW1lem9uZUNhY2hlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGltZXpvbmVDYWNoZS5oYXModHppZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lem9uZUNhY2hlLmdldCh0emlkKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGltZSB6b25lIGlzIG5vdCBhbHJlYWR5IGNhY2hlZCwgaHlkcmF0ZSBpdCBmcm9tIHRoZVxuICAgIC8vIHN1YmNvbXBvbmVudHMuXG4gICAgY29uc3Qgem9uZXMgPSB0aGlzLmdldEFsbFN1YmNvbXBvbmVudHMoJ3Z0aW1lem9uZScpO1xuICAgIGZvciAoY29uc3Qgem9uZSBvZiB6b25lcykge1xuICAgICAgaWYgKHpvbmUuZ2V0Rmlyc3RQcm9wZXJ0eSgndHppZCcpLmdldEZpcnN0VmFsdWUoKSA9PT0gdHppZCkge1xuICAgICAgICBjb25zdCBoeWRyYXRlZFpvbmUgPSBuZXcgVGltZXpvbmUoe1xuICAgICAgICAgIGNvbXBvbmVudDogem9uZSxcbiAgICAgICAgICB0emlkOiB0emlkLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl90aW1lem9uZUNhY2hlLnNldCh0emlkLCBoeWRyYXRlZFpvbmUpO1xuXG4gICAgICAgIHJldHVybiBoeWRyYXRlZFpvbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgd2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgdGltZSB6b25lIGRlZmluZWQgaW4gYSBmaWxlXG4gICAgLy8gZm9yIGFueSByZWZlcmVuY2VkIFRaSUQsIGJ1dCBkb24ndCBibG93IHVwIGlmIHRoZSBmaWxlIGlzIGludmFsaWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogUHJpbWFyeSBjbGFzcyBmb3IgZXhwYW5kaW5nIHJlY3VycmluZyBydWxlcy4gIENhbiB0YWtlIG11bHRpcGxlIHJydWxlcywgcmRhdGVzLCBleGRhdGUocykgYW5kXG4gKiBpdGVyYXRlIChpbiBvcmRlcikgb3ZlciBlYWNoIG5leHQgb2NjdXJyZW5jZS5cbiAqXG4gKiBPbmNlIGluaXRpYWxpemVkIHRoaXMgY2xhc3MgY2FuIGFsc28gYmUgc2VyaWFsaXplZCBzYXZlZCBhbmQgY29udGludWUgaXRlcmF0aW9uIGZyb20gdGhlIGxhc3RcbiAqIHBvaW50LlxuICpcbiAqIE5PVEU6IGl0IGlzIGludGVuZGVkIHRoYXQgdGhpcyBjbGFzcyBpcyB0byBiZSB1c2VkIHdpdGgge0BsaW5rIElDQUwuRXZlbnR9IHdoaWNoIGhhbmRsZXMgcmVjdXJyZW5jZVxuICogZXhjZXB0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gYXNzdW1pbmcgZXZlbnQgaXMgYSBwYXJzZWQgaWNhbCBjb21wb25lbnRcbiAqIHZhciBldmVudDtcbiAqXG4gKiB2YXIgZXhwYW5kID0gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oe1xuICogICBjb21wb25lbnQ6IGV2ZW50LFxuICogICBkdHN0YXJ0OiBldmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKVxuICogfSk7XG4gKlxuICogLy8gcmVtZW1iZXIgdGhlcmUgYXJlIGluZmluaXRlIHJ1bGVzIHNvIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGxpbWl0IHRoZSBzY29wZSBvZiB0aGUgaXRlcmF0aW9uc1xuICogLy8gdGhlbiByZXN1bWUgbGF0ZXIgb24uXG4gKlxuICogLy8gbmV4dCBpcyBhbHdheXMgYW4gSUNBTC5UaW1lIG9yIG51bGxcbiAqIHZhciBuZXh0O1xuICpcbiAqIHdoaWxlIChzb21lQ29uZGl0aW9uICYmIChuZXh0ID0gZXhwYW5kLm5leHQoKSkpIHtcbiAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggbmV4dFxuICogfVxuICpcbiAqIC8vIHNhdmUgaW5zdGFuY2UgZm9yIGxhdGVyXG4gKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGV4cGFuZCk7XG4gKlxuICogLy8uLi5cbiAqXG4gKiAvLyBOT1RFOiBpZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcyBoYXZlIGNoYW5nZWQgeW91IHdpbGwgbmVlZCB0byByZWJ1aWxkIHRoZSBjbGFzcyBhbmQgc3RhcnRcbiAqIC8vIG92ZXIuIFRoaXMgb25seSB3b3JrcyB3aGVuIHRoZSBjb21wb25lbnQncyByZWN1cnJlbmNlIGluZm8gaXMgdGhlIHNhbWUuXG4gKiB2YXIgZXhwYW5kID0gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oSlNPTi5wYXJzZShqc29uKSk7XG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgUmVjdXJFeHBhbnNpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGJlIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCB2YWx1ZXMuIEl0IGNhbiBhbHNvIGNvbnRhaW5cbiAgICogYWRkaXRpb25hbCBtZW1iZXJzLCBhcyBhIHJlc3VsdCBvZiBzZXJpYWxpemluZyBhIHByZXZpb3VzIGV4cGFuc2lvbiBzdGF0ZSwgYXMgc2hvd24gaW4gdGhlXG4gICAqIGV4YW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBSZWN1cnJlbmNlIGV4cGFuc2lvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7VGltZX0gb3B0aW9ucy5kdHN0YXJ0XG4gICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0NvbXBvbmVudD19IG9wdGlvbnMuY29tcG9uZW50XG4gICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucnVsZURhdGVzID0gW107XG4gICAgdGhpcy5leERhdGVzID0gW107XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZ1bGx5IGNvbXBsZXRlZC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBjb21wbGV0ZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBycnVsZSBpdGVyYXRvcnMuXG4gICAqXG4gICAqIEB0eXBlIHtSZWN1ckl0ZXJhdG9yW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydWxlSXRlcmF0b3JzID0gbnVsbDtcblxuICAvKipcbiAgICogQXJyYXkgb2YgcmRhdGUgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7VGltZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnVsZURhdGVzID0gbnVsbDtcblxuICAvKipcbiAgICogQXJyYXkgb2YgZXhkYXRlIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHR5cGUge1RpbWVbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4RGF0ZXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIHJ1bGVEYXRlcyBhcnJheS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ1bGVEYXRlSW5jID0gMDtcblxuICAvKipcbiAgICogQ3VycmVudCBwb3NpdGlvbiBpbiBleERhdGVzIGFycmF5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleERhdGVJbmMgPSAwO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IG5lZ2F0aXZlIGRhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhEYXRlID0gbnVsbDtcblxuICAvKipcbiAgICogQ3VycmVudCBhZGRpdGlvbmFsIGRhdGUuXG4gICAqXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnVsZURhdGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTdGFydCBkYXRlIG9mIHJlY3VycmluZyBydWxlcy5cbiAgICpcbiAgICogQHR5cGUge1RpbWV9XG4gICAqL1xuICBkdHN0YXJ0ID0gbnVsbDtcblxuICAvKipcbiAgICogTGFzdCBleHBhbmRlZCB0aW1lXG4gICAqXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKi9cbiAgbGFzdCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgZXhwYW5zaW9uIGZyb20gdGhlIGRhdGEgb2JqZWN0LiBUaGUgb3B0aW9uc1xuICAgKiBvYmplY3QgbWF5IGFsc28gY29udGFpbiBhZGRpdGlvbmFsIG1lbWJlcnMsIHNlZSB0aGVcbiAgICoge0BsaW5rIElDQUwuUmVjdXJFeHBhbnNpb24gY29uc3RydWN0b3J9IGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBSZWN1cnJlbmNlIGV4cGFuc2lvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7VGltZX0gb3B0aW9ucy5kdHN0YXJ0XG4gICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0NvbXBvbmVudD19IG9wdGlvbnMuY29tcG9uZW50XG4gICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgKi9cbiAgZnJvbURhdGEob3B0aW9ucykge1xuICAgIGxldCBzdGFydCA9IGZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIFRpbWUpO1xuXG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCcuZHRzdGFydCAoSUNBTC5UaW1lKSBtdXN0IGJlIGdpdmVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHRzdGFydCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNvbXBvbmVudCkge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zLmNvbXBvbmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdCA9IGZvcm1hdENsYXNzVHlwZShvcHRpb25zLmxhc3QsIFRpbWUpIHx8IHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5ydWxlSXRlcmF0b3JzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignLnJ1bGVJdGVyYXRvcnMgb3IgLmNvbXBvbmVudCBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycyA9IG9wdGlvbnMucnVsZUl0ZXJhdG9ycy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0Q2xhc3NUeXBlKGl0ZW0sIFJlY3VySXRlcmF0b3IpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucnVsZURhdGVJbmMgPSBvcHRpb25zLnJ1bGVEYXRlSW5jO1xuICAgICAgdGhpcy5leERhdGVJbmMgPSBvcHRpb25zLmV4RGF0ZUluYztcblxuICAgICAgaWYgKG9wdGlvbnMucnVsZURhdGVzKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGVzID0gb3B0aW9ucy5ydWxlRGF0ZXMubWFwKGl0ZW0gPT4gZm9ybWF0Q2xhc3NUeXBlKGl0ZW0sIFRpbWUpKTtcbiAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzW3RoaXMucnVsZURhdGVJbmNdO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5leERhdGVzKSB7XG4gICAgICAgIHRoaXMuZXhEYXRlcyA9IG9wdGlvbnMuZXhEYXRlcy5tYXAoaXRlbSA9PiBmb3JtYXRDbGFzc1R5cGUoaXRlbSwgVGltZSkpO1xuICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Yob3B0aW9ucy5jb21wbGV0ZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGluIHRoZSBzZXJpZXMuXG4gICAqIEByZXR1cm4ge1RpbWV9XG4gICAqL1xuICBuZXh0KCkge1xuICAgIGxldCBpdGVyO1xuICAgIGxldCBuZXh0O1xuICAgIGxldCBjb21wYXJlO1xuXG4gICAgbGV0IG1heFRyaWVzID0gNTAwO1xuICAgIGxldCBjdXJyZW50VHJ5ID0gMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoY3VycmVudFRyeSsrID4gbWF4VHJpZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdtYXggdHJpZXMgaGF2ZSBvY2N1cnJlZCwgcnVsZSBtYXkgYmUgaW1wb3NzaWJsZSB0byBmdWxmaWxsLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbmV4dCA9IHRoaXMucnVsZURhdGU7XG4gICAgICBpdGVyID0gdGhpcy5fbmV4dFJlY3VycmVuY2VJdGVyKHRoaXMubGFzdCk7XG5cbiAgICAgIC8vIG5vIG1vcmUgbWF0Y2hlc1xuICAgICAgLy8gYmVjYXVzZSB3ZSBpbmNyZW1lbnQgdGhlIHJ1bGUgZGF5IG9yIHJ1bGVcbiAgICAgIC8vIF9hZnRlcl8gd2UgY2hvb3NlIGEgdmFsdWUgdGhpcyBzaG91bGQgYmVcbiAgICAgIC8vIHRoZSBvbmx5IHNwb3Qgd2hlcmUgd2UgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVcbiAgICAgIC8vIGVuZCBvZiBldmVudHMuXG4gICAgICBpZiAoIW5leHQgJiYgIWl0ZXIpIHtcbiAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgaXRlcmF0b3JzIG9yIHJkYXRlc1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG5leHQgcnVsZSBkYXkgb3IgcmVjdXJyZW5jZSBydWxlIGlzIGZpcnN0LlxuICAgICAgaWYgKCFuZXh0IHx8IChpdGVyICYmIG5leHQuY29tcGFyZShpdGVyLmxhc3QpID4gMCkpIHtcbiAgICAgICAgLy8gbXVzdCBiZSBjbG9uZWQsIHJlY3VyIHdpbGwgcmV1c2UgdGhlIHRpbWUgZWxlbWVudC5cbiAgICAgICAgbmV4dCA9IGl0ZXIubGFzdC5jbG9uZSgpO1xuICAgICAgICAvLyBtb3ZlIHRvIG5leHQgc28gd2UgY2FuIGNvbnRpbnVlXG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgcnVsZURhdGUgaXMgc3RpbGwgbmV4dCBpbmNyZW1lbnQgaXQuXG4gICAgICBpZiAodGhpcy5ydWxlRGF0ZSA9PT0gbmV4dCkge1xuICAgICAgICB0aGlzLl9uZXh0UnVsZURheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3QgPSBuZXh0O1xuXG4gICAgICAvLyBjaGVjayB0aGUgbmVnYXRpdmUgcnVsZXNcbiAgICAgIGlmICh0aGlzLmV4RGF0ZSkge1xuICAgICAgICBjb21wYXJlID0gdGhpcy5leERhdGUuY29tcGFyZSh0aGlzLmxhc3QpO1xuXG4gICAgICAgIGlmIChjb21wYXJlIDwgMCkge1xuICAgICAgICAgIHRoaXMuX25leHRFeERheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBleGNsdWRlZCBza2lwIGl0LlxuICAgICAgICBpZiAoY29tcGFyZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX25leHRFeERheSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vWFhYOiBUaGUgc3BlYyBzdGF0ZXMgdGhhdCBhZnRlciB3ZSByZXNvbHZlIHRoZSBmaW5hbFxuICAgICAgLy8gICAgIGxpc3Qgb2YgZGF0ZXMgd2UgZXhlY3V0ZSBleGRhdGUgdGhpcyBzZWVtcyBzb21ld2hhdCBjb3VudGVyXG4gICAgICAvLyAgICAgaW50dWl0aXZlIHRvIHdoYXQgSSBoYXZlIHNlZW4gbW9zdCBzZXJ2ZXJzIGRvIHNvIGZvciBub3dcbiAgICAgIC8vICAgICBJIGV4Y2x1ZGUgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGRhdGUgbm90IHRoZSBvbmUgdGhhdCBtYXlcbiAgICAgIC8vICAgICBoYXZlIGJlZW4gbW9kaWZpZWQgYnkgdGhlIGV4Y2VwdGlvbi5cbiAgICAgIHJldHVybiB0aGlzLmxhc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIG9iamVjdCBpbnRvIGEgc2VyaWFsaXplLWFibGUgZm9ybWF0LiBUaGlzIGZvcm1hdCBjYW4gYmUgcGFzc2VkXG4gICAqIGJhY2sgaW50byB0aGUgZXhwYW5zaW9uIHRvIHJlc3VtZSBpdGVyYXRpb24uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBmdW5jdGlvbiB0b0pTT04oaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0udG9KU09OKCk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVzdWx0LnJ1bGVJdGVyYXRvcnMgPSB0aGlzLnJ1bGVJdGVyYXRvcnMubWFwKHRvSlNPTik7XG5cbiAgICBpZiAodGhpcy5ydWxlRGF0ZXMpIHtcbiAgICAgIHJlc3VsdC5ydWxlRGF0ZXMgPSB0aGlzLnJ1bGVEYXRlcy5tYXAodG9KU09OKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leERhdGVzKSB7XG4gICAgICByZXN1bHQuZXhEYXRlcyA9IHRoaXMuZXhEYXRlcy5tYXAodG9KU09OKTtcbiAgICB9XG5cbiAgICByZXN1bHQucnVsZURhdGVJbmMgPSB0aGlzLnJ1bGVEYXRlSW5jO1xuICAgIHJlc3VsdC5leERhdGVJbmMgPSB0aGlzLmV4RGF0ZUluYztcbiAgICByZXN1bHQubGFzdCA9IHRoaXMubGFzdC50b0pTT04oKTtcbiAgICByZXN1bHQuZHRzdGFydCA9IHRoaXMuZHRzdGFydC50b0pTT04oKTtcbiAgICByZXN1bHQuY29tcGxldGUgPSB0aGlzLmNvbXBsZXRlO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGFsbCBkYXRlcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlbiBjb21wb25lbnQuIFRoZVxuICAgKiBwcm9wZXJ0aWVzIHdpbGwgYmUgZmlsdGVyZWQgYnkgdGhlIHByb3BlcnR5IG5hbWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgICAgICAgICAgICAgVGhlIGNvbXBvbmVudCB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSAgICAgICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm4ge1RpbWVbXX0gICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhY3RlZCBkYXRlcy5cbiAgICovXG4gIF9leHRyYWN0RGF0ZXMoY29tcG9uZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IHByb3BzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMocHJvcGVydHlOYW1lKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwcm9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yIChsZXQgcHJvcCBvZiBwcm9wc1tpXS5nZXRWYWx1ZXMoKSkge1xuICAgICAgICBsZXQgaWR4ID0gYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBwcm9wLFxuICAgICAgICAgIChhLCBiKSA9PiBhLmNvbXBhcmUoYilcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBvcmRlcmVkIGluc2VydFxuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGV4cGFuc2lvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudCAgICBUaGUgY29tcG9uZW50IHRvIGluaXRpYWxpemUgZnJvbS5cbiAgICovXG4gIF9pbml0KGNvbXBvbmVudCkge1xuICAgIHRoaXMucnVsZUl0ZXJhdG9ycyA9IFtdO1xuXG4gICAgdGhpcy5sYXN0ID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG5cbiAgICAvLyB0byBwcm92aWRlIGFwaSBjb25zaXN0ZW5jeSBub24tcmVjdXJyaW5nXG4gICAgLy8gZXZlbnRzIGNhbiBhbHNvIHVzZSB0aGUgaXRlcmF0b3IgdGhvdWdoIGl0IHdpbGxcbiAgICAvLyBvbmx5IHJldHVybiBhIHNpbmdsZSB0aW1lLlxuICAgIGlmICghY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZGF0ZScpICYmXG4gICAgICAgICFjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JydWxlJykgJiZcbiAgICAgICAgIWNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpKSB7XG4gICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5sYXN0LmNsb25lKCk7XG4gICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZGF0ZScpKSB7XG4gICAgICB0aGlzLnJ1bGVEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdyZGF0ZScpO1xuXG4gICAgICAvLyBzcGVjaWFsIGhhY2sgZm9yIGNhc2VzIHdoZXJlIGZpcnN0IHJkYXRlIGlzIHByaW9yXG4gICAgICAvLyB0byB0aGUgc3RhcnQgZGF0ZS4gV2Ugb25seSBjaGVjayBmb3IgdGhlIGZpcnN0IHJkYXRlLlxuICAgICAgLy8gVGhpcyBpcyBtb3N0bHkgZm9yIGdvb2dsZSdzIGNyYXp5IHJlY3VycmluZyBkYXRlIGxvZ2ljXG4gICAgICAvLyAoY29udGFjdHMgYmlydGhkYXlzKS5cbiAgICAgIGlmICgodGhpcy5ydWxlRGF0ZXNbMF0pICYmXG4gICAgICAgICAgKHRoaXMucnVsZURhdGVzWzBdLmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA8IDApKSB7XG5cbiAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IDA7XG4gICAgICAgIHRoaXMubGFzdCA9IHRoaXMucnVsZURhdGVzWzBdLmNsb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMucnVsZURhdGVzLFxuICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAoYSwgYikgPT4gYS5jb21wYXJlKGIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1t0aGlzLnJ1bGVEYXRlSW5jXTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdycnVsZScpKSB7XG4gICAgICBsZXQgcnVsZXMgPSBjb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygncnJ1bGUnKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgICAgIGxldCBydWxlO1xuICAgICAgbGV0IGl0ZXI7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcnVsZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgaXRlciA9IHJ1bGUuaXRlcmF0b3IodGhpcy5kdHN0YXJ0KTtcbiAgICAgICAgdGhpcy5ydWxlSXRlcmF0b3JzLnB1c2goaXRlcik7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugc28gZnV0dXJlXG4gICAgICAgIC8vIGNhbGxzIHRvIG5leHQgcmV0dXJuIHRpbWVzIGJleW9uZCB0aGUgaW5pdGlhbCBpdGVyYXRpb24uXG4gICAgICAgIC8vIFhYWDogSSBmaW5kIHRoaXMgc3VzcGljaW91cyBtaWdodCBiZSBhIGJ1Zz9cbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZXhkYXRlJykpIHtcbiAgICAgIHRoaXMuZXhEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdleGRhdGUnKTtcbiAgICAgIC8vIGlmIHdlIGhhdmUgYSAubGFzdCBkYXkgd2UgaW5jcmVtZW50IHRoZSBpbmRleCB0byBiZXlvbmQgaXQuXG4gICAgICB0aGlzLmV4RGF0ZUluYyA9IGJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5leERhdGVzLFxuICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgIChhLCBiKSA9PiBhLmNvbXBhcmUoYilcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzW3RoaXMuZXhEYXRlSW5jXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0byB0aGUgbmV4dCBleGRhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZXh0RXhEYXkoKSB7XG4gICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbKyt0aGlzLmV4RGF0ZUluY107XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0byB0aGUgbmV4dCBydWxlIGRhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZXh0UnVsZURheSgpIHtcbiAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbKyt0aGlzLnJ1bGVEYXRlSW5jXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuZCByZXR1cm4gdGhlIHJlY3VycmVuY2UgcnVsZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBldmVudCBhbmRcbiAgICogcmV0dXJuIGl0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHs/UmVjdXJJdGVyYXRvcn0gICAgRm91bmQgaXRlcmF0b3IuXG4gICAqL1xuICBfbmV4dFJlY3VycmVuY2VJdGVyKCkge1xuICAgIGxldCBpdGVycyA9IHRoaXMucnVsZUl0ZXJhdG9ycztcblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBpdGVycy5sZW5ndGg7XG4gICAgbGV0IGl0ZXI7XG4gICAgbGV0IGl0ZXJUaW1lO1xuICAgIGxldCBpdGVySWR4ID0gMDtcbiAgICBsZXQgY2hvc2VuSXRlcjtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGl0ZXJhdG9yXG4gICAgZm9yICg7IGl0ZXJJZHggPCBsZW47IGl0ZXJJZHgrKykge1xuICAgICAgaXRlciA9IGl0ZXJzW2l0ZXJJZHhdO1xuICAgICAgaXRlclRpbWUgPSBpdGVyLmxhc3Q7XG5cbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBpcyBjb21wbGV0ZVxuICAgICAgLy8gdGhlbiB3ZSBtdXN0IGV4Y2x1ZGUgaXQgZnJvbVxuICAgICAgLy8gdGhlIHNlYXJjaCBhbmQgcmVtb3ZlIGl0LlxuICAgICAgaWYgKGl0ZXIuY29tcGxldGVkKSB7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBpZiAoaXRlcklkeCAhPT0gMCkge1xuICAgICAgICAgIGl0ZXJJZHgtLTtcbiAgICAgICAgfVxuICAgICAgICBpdGVycy5zcGxpY2UoaXRlcklkeCwgMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIHRoZSBtb3N0IHJlY2VudCBwb3NzaWJsZSBjaG9pY2VcbiAgICAgIGlmICghY2hvc2VuSXRlciB8fCBjaG9zZW5JdGVyLmxhc3QuY29tcGFyZShpdGVyVGltZSkgPiAwKSB7XG4gICAgICAgIC8vIHRoYXQgaXRlcmF0b3IgaXMgc2F2ZWRcbiAgICAgICAgY2hvc2VuSXRlciA9IGl0ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlIGNob3NlbiBpdGVyYXRvciBpcyByZXR1cm5lZCBidXQgbm90IG11dGF0ZWRcbiAgICAvLyB0aGlzIGl0ZXJhdG9yIGNvbnRhaW5zIHRoZSBtb3N0IHJlY2VudCBldmVudC5cbiAgICByZXR1cm4gY2hvc2VuSXRlcjtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGxldHMgdHlwZXNjcmlwdCByZXNvbHZlIG91ciBjdXN0b20gdHlwZXMgaW4gdGhlXG4gKiBnZW5lcmF0ZWQgZC50cyBmaWxlcyAoanNkb2MgdHlwZWRlZnMgYXJlIGNvbnZlcnRlZCB0byB0eXBlc2NyaXB0IHR5cGVzKS5cbiAqIElnbm9yZSBwcmV2ZW50cyB0aGUgdHlwZWRlZnMgZnJvbSBiZWluZyBkb2N1bWVudGVkIG1vcmUgdGhhbiBvbmNlLlxuICogQGlnbm9yZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikuZnJlcXVlbmN5VmFsdWVzfSBmcmVxdWVuY3lWYWx1ZXNcbiAqIEltcG9ydHMgdGhlICdmcmVxdWVuY3lWYWx1ZXMnIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vdHlwZXMuanNcIikub2NjdXJyZW5jZURldGFpbHN9IG9jY3VycmVuY2VEZXRhaWxzXG4gKiBJbXBvcnRzIHRoZSAnb2NjdXJyZW5jZURldGFpbHMnIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICovXG5cbi8qKlxuICogSUNBTC5qcyBpcyBvcmdhbml6ZWQgaW50byBtdWx0aXBsZSBsYXllcnMuIFRoZSBib3R0b20gbGF5ZXIgaXMgYSByYXcgakNhbFxuICogb2JqZWN0LCBmb2xsb3dlZCBieSB0aGUgY29tcG9uZW50L3Byb3BlcnR5IGxheWVyLiBUaGUgaGlnaGVzdCBsZXZlbCBpcyB0aGVcbiAqIGV2ZW50IHJlcHJlc2VudGF0aW9uLCB3aGljaCB0aGlzIGNsYXNzIGlzIHBhcnQgb2YuIFNlZSB0aGVcbiAqIHtAdHV0b3JpYWwgbGF5ZXJzfSBndWlkZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5FdmVudCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnQ9fSBjb21wb25lbnQgICAgICAgICAgICAgIFRoZSBJQ0FMLkNvbXBvbmVudCB0byBiYXNlIHRoaXMgZXZlbnQgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgICAgICAgICAgIE9wdGlvbnMgZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zICBXaGVuIHRydWUsIHdpbGwgdmVyaWZ5IGV4Y2VwdGlvbnMgYXJlIHJlbGF0ZWQgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlaXIgVVVJRFxuICAgKiBAcGFyYW0ge0FycmF5PENvbXBvbmVudHxFdmVudD49fSBvcHRpb25zLmV4Y2VwdGlvbnNcbiAgICogICAgICAgICAgRXhjZXB0aW9ucyB0byB0aGlzIGV2ZW50LCBlaXRoZXIgYXMgY29tcG9uZW50cyBvciBldmVudHMuIElmIG5vdFxuICAgKiAgICAgICAgICAgIHNwZWNpZmllZCBleGNlcHRpb25zIHdpbGwgYXV0b21hdGljYWxseSBiZSBzZXQgaW4gcmVsYXRpb24gb2ZcbiAgICogICAgICAgICAgICBjb21wb25lbnQncyBwYXJlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXBvbmVudCBpbnN0YW5jZW9mIENvbXBvbmVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSBjb21wb25lbnQ7XG4gICAgICBjb21wb25lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoJ3ZldmVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZXhjZXB0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMgPSBbXTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0RXhjZXB0aW9ucykge1xuICAgICAgdGhpcy5zdHJpY3RFeGNlcHRpb25zID0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhjZXB0aW9ucykge1xuICAgICAgb3B0aW9ucy5leGNlcHRpb25zLmZvckVhY2godGhpcy5yZWxhdGVFeGNlcHRpb24sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnQucGFyZW50ICYmICF0aGlzLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5wYXJlbnQuZ2V0QWxsU3ViY29tcG9uZW50cygndmV2ZW50JykuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICAgIHRoaXMucmVsYXRlRXhjZXB0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cblxuICBzdGF0aWMgVEhJU0FOREZVVFVSRSA9ICdUSElTQU5ERlVUVVJFJztcblxuICAvKipcbiAgICogTGlzdCBvZiByZWxhdGVkIGV2ZW50IGV4Y2VwdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudFtdfVxuICAgKi9cbiAgZXhjZXB0aW9ucyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlELlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0cmljdEV4Y2VwdGlvbnMgPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVsYXRlcyBhIGdpdmVuIGV2ZW50IGV4Y2VwdGlvbiB0byB0aGlzIG9iamVjdC4gIElmIHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICogZG9lcyBub3Qgc2hhcmUgdGhlIFVJRCBvZiB0aGlzIGV2ZW50IGl0IGNhbm5vdCBiZSByZWxhdGVkIGFuZCB3aWxsIHRocm93XG4gICAqIGFuIGV4Y2VwdGlvbi5cbiAgICpcbiAgICogSWYgdGhpcyBjb21wb25lbnQgaXMgYW4gZXhjZXB0aW9uIGl0IGNhbm5vdCBoYXZlIG90aGVyIGV4Y2VwdGlvbnNcbiAgICogcmVsYXRlZCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR8RXZlbnR9IG9iaiAgICAgICBDb21wb25lbnQgb3IgZXZlbnRcbiAgICovXG4gIHJlbGF0ZUV4Y2VwdGlvbihvYmopIHtcbiAgICBpZiAodGhpcy5pc1JlY3VycmVuY2VFeGNlcHRpb24oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVsYXRlIGV4Y2VwdGlvbiB0byBleGNlcHRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgb2JqID0gbmV3IEV2ZW50KG9iaik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RyaWN0RXhjZXB0aW9ucyAmJiBvYmoudWlkICE9PSB0aGlzLnVpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gcmVsYXRlIHVucmVsYXRlZCBleGNlcHRpb24nKTtcbiAgICB9XG5cbiAgICBsZXQgaWQgPSBvYmoucmVjdXJyZW5jZUlkLnRvU3RyaW5nKCk7XG5cbiAgICAvLyB3ZSBkb24ndCBzb3J0IG9yIG1hbmFnZSBleGNlcHRpb25zIGRpcmVjdGx5XG4gICAgLy8gaGVyZSB0aGUgcmVjdXJyZW5jZSBleHBhbmRlciBoYW5kbGVzIHRoYXQuXG4gICAgdGhpcy5leGNlcHRpb25zW2lkXSA9IG9iajtcblxuICAgIC8vIGluZGV4IFJBTkdFPVRISVNBTkRGVVRVUkUgZXhjZXB0aW9ucyBzbyB3ZSBjYW5cbiAgICAvLyBsb29rIHRoZW0gdXAgbGF0ZXIgaW4gZ2V0T2NjdXJyZW5jZURldGFpbHMuXG4gICAgaWYgKG9iai5tb2RpZmllc0Z1dHVyZSgpKSB7XG4gICAgICBsZXQgaXRlbSA9IFtcbiAgICAgICAgb2JqLnJlY3VycmVuY2VJZC50b1VuaXhUaW1lKCksIGlkXG4gICAgICBdO1xuXG4gICAgICAvLyB3ZSBrZWVwIHRoZW0gc29ydGVkIHNvIHdlIGNhbiBmaW5kIHRoZSBuZWFyZXN0XG4gICAgICAvLyB2YWx1ZSBsYXRlciBvbi4uLlxuICAgICAgbGV0IGlkeCA9IGJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMsXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGNvbXBhcmVSYW5nZUV4Y2VwdGlvblxuICAgICAgKTtcblxuICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMuc3BsaWNlKGlkeCwgMCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHJlY29yZCBpcyBhbiBleGNlcHRpb24gYW5kIGhhcyB0aGUgUkFOR0U9VEhJU0FOREZVVFVSRVxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gZXhjZXB0aW9uIGlzIHdpdGhpbiByYW5nZVxuICAgKi9cbiAgbW9kaWZpZXNGdXR1cmUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJhbmdlID0gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpLmdldFBhcmFtZXRlcigncmFuZ2UnKTtcbiAgICByZXR1cm4gcmFuZ2UgPT09IEV2ZW50LlRISVNBTkRGVVRVUkU7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIHJhbmdlIGV4Y2VwdGlvbiBuZWFyZXN0IHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWV9IHRpbWUgICB1c3VhbGx5IGFuIG9jY3VycmVuY2UgdGltZSBvZiBhbiBldmVudFxuICAgKiBAcmV0dXJuIHs/RXZlbnR9ICAgICB0aGUgcmVsYXRlZCBldmVudC9leGNlcHRpb24gb3IgbnVsbFxuICAgKi9cbiAgZmluZFJhbmdlRXhjZXB0aW9uKHRpbWUpIHtcbiAgICBpZiAoIXRoaXMucmFuZ2VFeGNlcHRpb25zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHV0YyA9IHRpbWUudG9Vbml4VGltZSgpO1xuICAgIGxldCBpZHggPSBiaW5zZWFyY2hJbnNlcnQoXG4gICAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyxcbiAgICAgIFt1dGNdLFxuICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgKTtcblxuICAgIGlkeCAtPSAxO1xuXG4gICAgLy8gb2NjdXJzIGJlZm9yZVxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgcmFuZ2VJdGVtID0gdGhpcy5yYW5nZUV4Y2VwdGlvbnNbaWR4XTtcblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbiAgICBpZiAodXRjIDwgcmFuZ2VJdGVtWzBdKSB7XG4gICAgICAvLyBzYW5pdHkgY2hlY2sgb25seVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlSXRlbVsxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvY2N1cnJlbmNlIGRldGFpbHMgYmFzZWQgb24gaXRzIHN0YXJ0IHRpbWUuICBJZiB0aGVcbiAgICogb2NjdXJyZW5jZSBoYXMgYW4gZXhjZXB0aW9uIHdpbGwgcmV0dXJuIHRoZSBkZXRhaWxzIGZvciB0aGF0IGV4Y2VwdGlvbi5cbiAgICpcbiAgICogTk9URTogdGhpcyBtZXRob2QgaXMgaW50ZW5kIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb25cbiAgICogICAgICAgd2l0aCB0aGUge0BsaW5rIElDQUwuRXZlbnQjaXRlcmF0b3IgaXRlcmF0b3J9IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lfSBvY2N1cnJlbmNlICAgICAgICAgICAgICAgdGltZSBvY2N1cnJlbmNlXG4gICAqIEByZXR1cm4ge29jY3VycmVuY2VEZXRhaWxzfSAgICAgICAgICAgIEluZm9ybWF0aW9uIGFib3V0IHRoZSBvY2N1cnJlbmNlXG4gICAqL1xuICBnZXRPY2N1cnJlbmNlRGV0YWlscyhvY2N1cnJlbmNlKSB7XG4gICAgbGV0IGlkID0gb2NjdXJyZW5jZS50b1N0cmluZygpO1xuICAgIGxldCB1dGNJZCA9IG9jY3VycmVuY2UuY29udmVydFRvWm9uZShUaW1lem9uZS51dGNUaW1lem9uZSkudG9TdHJpbmcoKTtcbiAgICBsZXQgaXRlbTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgLy9YWFg6IENsb25lP1xuICAgICAgcmVjdXJyZW5jZUlkOiBvY2N1cnJlbmNlXG4gICAgfTtcblxuICAgIGlmIChpZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgIGl0ZW0gPSByZXN1bHQuaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1tpZF07XG4gICAgICByZXN1bHQuc3RhcnREYXRlID0gaXRlbS5zdGFydERhdGU7XG4gICAgICByZXN1bHQuZW5kRGF0ZSA9IGl0ZW0uZW5kRGF0ZTtcbiAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICB9IGVsc2UgaWYgKHV0Y0lkIGluIHRoaXMuZXhjZXB0aW9ucykge1xuICAgICAgaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1t1dGNJZF07XG4gICAgICByZXN1bHQuc3RhcnREYXRlID0gaXRlbS5zdGFydERhdGU7XG4gICAgICByZXN1bHQuZW5kRGF0ZSA9IGl0ZW0uZW5kRGF0ZTtcbiAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmFuZ2UgZXhjZXB0aW9ucyAoUkFOR0U9VEhJU0FOREZVVFVSRSkgaGF2ZSBhXG4gICAgICAvLyBsb3dlciBwcmlvcml0eSB0aGVuIGRpcmVjdCBleGNlcHRpb25zIGJ1dFxuICAgICAgLy8gbXVzdCBiZSBhY2NvdW50ZWQgZm9yIGZpcnN0LiBUaGVpciBpdGVtIGlzXG4gICAgICAvLyBhbHdheXMgdGhlIGZpcnN0IGV4Y2VwdGlvbiB3aXRoIHRoZSByYW5nZSBwcm9wLlxuICAgICAgbGV0IHJhbmdlRXhjZXB0aW9uSWQgPSB0aGlzLmZpbmRSYW5nZUV4Y2VwdGlvbihcbiAgICAgICAgb2NjdXJyZW5jZVxuICAgICAgKTtcbiAgICAgIGxldCBlbmQ7XG5cbiAgICAgIGlmIChyYW5nZUV4Y2VwdGlvbklkKSB7XG4gICAgICAgIGxldCBleGNlcHRpb24gPSB0aGlzLmV4Y2VwdGlvbnNbcmFuZ2VFeGNlcHRpb25JZF07XG5cbiAgICAgICAgLy8gcmFuZ2UgZXhjZXB0aW9uIG11c3QgbW9kaWZ5IHN0YW5kYXJkIHRpbWVcbiAgICAgICAgLy8gYnkgdGhlIGRpZmZlcmVuY2UgKGlmIGFueSkgaW4gc3RhcnQvZW5kIHRpbWVzLlxuICAgICAgICByZXN1bHQuaXRlbSA9IGV4Y2VwdGlvbjtcblxuICAgICAgICBsZXQgc3RhcnREaWZmID0gdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICBpZiAoIXN0YXJ0RGlmZikge1xuICAgICAgICAgIGxldCBvcmlnaW5hbCA9IGV4Y2VwdGlvbi5yZWN1cnJlbmNlSWQuY2xvbmUoKTtcbiAgICAgICAgICBsZXQgbmV3U3RhcnQgPSBleGNlcHRpb24uc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAvLyB6b25lcyBtdXN0IGJlIHNhbWUgb3RoZXJ3aXNlIHN1YnRyYWN0IG1heSBiZSBpbmNvcnJlY3QuXG4gICAgICAgICAgb3JpZ2luYWwuem9uZSA9IG5ld1N0YXJ0LnpvbmU7XG4gICAgICAgICAgc3RhcnREaWZmID0gbmV3U3RhcnQuc3VidHJhY3REYXRlKG9yaWdpbmFsKTtcblxuICAgICAgICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF0gPSBzdGFydERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnQgPSBvY2N1cnJlbmNlLmNsb25lKCk7XG4gICAgICAgIHN0YXJ0LnpvbmUgPSBleGNlcHRpb24uc3RhcnREYXRlLnpvbmU7XG4gICAgICAgIHN0YXJ0LmFkZER1cmF0aW9uKHN0YXJ0RGlmZik7XG5cbiAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgZW5kLmFkZER1cmF0aW9uKGV4Y2VwdGlvbi5kdXJhdGlvbik7XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0RGF0ZSA9IHN0YXJ0O1xuICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHJhbmdlIGV4Y2VwdGlvbiBzdGFuZGFyZCBleHBhbnNpb25cbiAgICAgICAgZW5kID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG5cbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBlbmQ7XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBvY2N1cnJlbmNlO1xuICAgICAgICByZXN1bHQuaXRlbSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSByZWN1ciBleHBhbnNpb24gaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZSAoZGVmYXVsdHNcbiAgICogdG8gc3RhcnREYXRlKS5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lPX0gc3RhcnRUaW1lICAgICBTdGFydGluZyBwb2ludCBmb3IgZXhwYW5zaW9uXG4gICAqIEByZXR1cm4ge1JlY3VyRXhwYW5zaW9ufSAgICBFeHBhbnNpb24gb2JqZWN0XG4gICAqL1xuICBpdGVyYXRvcihzdGFydFRpbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlY3VyRXhwYW5zaW9uKHtcbiAgICAgIGNvbXBvbmVudDogdGhpcy5jb21wb25lbnQsXG4gICAgICBkdHN0YXJ0OiBzdGFydFRpbWUgfHwgdGhpcy5zdGFydERhdGVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSwgaWYgZXZlbnQgaXMgcmVjdXJyaW5nXG4gICAqL1xuICBpc1JlY3VycmluZygpIHtcbiAgICBsZXQgY29tcCA9IHRoaXMuY29tcG9uZW50O1xuICAgIHJldHVybiBjb21wLmhhc1Byb3BlcnR5KCdycnVsZScpIHx8IGNvbXAuaGFzUHJvcGVydHkoJ3JkYXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvbi4gU2VlXG4gICAqIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9IGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlLCBpZiB0aGUgZXZlbnQgZGVzY3JpYmVzIGEgcmVjdXJyZW5jZSBleGNlcHRpb25cbiAgICovXG4gIGlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0eXBlcyBvZiByZWN1cnJlbmNlcyB0aGlzIGV2ZW50IG1heSBoYXZlLlxuICAgKlxuICAgKiBSZXR1cm5lZCBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGtleXM6XG4gICAqXG4gICAqICAgIC0gWUVBUkxZXG4gICAqICAgIC0gTU9OVEhMWVxuICAgKiAgICAtIFdFRUtMWVxuICAgKiAgICAtIERBSUxZXG4gICAqICAgIC0gTUlOVVRFTFlcbiAgICogICAgLSBTRUNPTkRMWVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3QuPGZyZXF1ZW5jeVZhbHVlcywgQm9vbGVhbj59XG4gICAqICAgICAgICAgIE9iamVjdCBvZiByZWN1cnJlbmNlIGZsYWdzXG4gICAqL1xuICBnZXRSZWN1cnJlbmNlVHlwZXMoKSB7XG4gICAgbGV0IHJ1bGVzID0gdGhpcy5jb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygncnJ1bGUnKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgIHJlc3VsdFt2YWx1ZS5mcmVxXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdWlkIG9mIHRoaXMgZXZlbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1aWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgndWlkJyk7XG4gIH1cblxuICBzZXQgdWlkKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0UHJvcCgndWlkJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFydCBkYXRlXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdkdHN0YXJ0Jyk7XG4gIH1cblxuICBzZXQgc3RhcnREYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0VGltZSgnZHRzdGFydCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZW5kIGRhdGUuIFRoaXMgY2FuIGJlIHRoZSByZXN1bHQgZGlyZWN0bHkgZnJvbSB0aGUgcHJvcGVydHksIG9yIHRoZVxuICAgKiBlbmQgZGF0ZSBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZHVyYXRpb24uIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAqIHdpbGwgcmVtb3ZlIGFueSBkdXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBAdHlwZSB7VGltZX1cbiAgICovXG4gIGdldCBlbmREYXRlKCkge1xuICAgIGxldCBlbmREYXRlID0gdGhpcy5fZmlyc3RQcm9wKCdkdGVuZCcpO1xuICAgIGlmICghZW5kRGF0ZSkge1xuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLl9maXJzdFByb3AoJ2R1cmF0aW9uJyk7XG4gICAgICAgIGVuZERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZERhdGUuYWRkRHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGVuZERhdGUuaXNEYXRlKSB7XG4gICAgICAgICAgICBlbmREYXRlLmRheSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmREYXRlO1xuICB9XG5cbiAgc2V0IGVuZERhdGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnJlbW92ZVByb3BlcnR5KCdkdXJhdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRUaW1lKCdkdGVuZCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24uIFRoaXMgY2FuIGJlIHRoZSByZXN1bHQgZGlyZWN0bHkgZnJvbSB0aGUgcHJvcGVydHksIG9yIHRoZVxuICAgKiBkdXJhdGlvbiBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZW5kIGRhdGUuIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAqIHdpbGwgcmVtb3ZlIGFueSBgZHRlbmRgIHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtEdXJhdGlvbn1cbiAgICovXG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBsZXQgZHVyYXRpb24gPSB0aGlzLl9maXJzdFByb3AoJ2R1cmF0aW9uJyk7XG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kRGF0ZS5zdWJ0cmFjdERhdGVUeih0aGlzLnN0YXJ0RGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHNldCBkdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZHRlbmQnKSkge1xuICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R0ZW5kJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0UHJvcCgnZHVyYXRpb24nLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvY2F0aW9uIG9mIHRoZSBldmVudC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdsb2NhdGlvbicpO1xuICB9XG5cbiAgc2V0IGxvY2F0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0UHJvcCgnbG9jYXRpb24nLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGF0dGVuZGVlcyBpbiB0aGUgZXZlbnRcbiAgICogQHR5cGUge1Byb3BlcnR5W119XG4gICAqL1xuICBnZXQgYXR0ZW5kZWVzKCkge1xuICAgIC8vWFhYOiBUaGlzIGlzIHdheSBsYW1lIHdlIHNob3VsZCBoYXZlIGEgYmV0dGVyXG4gICAgLy8gICAgIGRhdGEgc3RydWN0dXJlIGZvciB0aGlzIGxhdGVyLlxuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdhdHRlbmRlZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCBzdW1tYXJ5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgc3VtbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdzdW1tYXJ5Jyk7XG4gIH1cblxuICBzZXQgc3VtbWFyeSh2YWx1ZSkge1xuICAgIHRoaXMuX3NldFByb3AoJ3N1bW1hcnknLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGV2ZW50IGRlc2NyaXB0aW9uLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2Rlc2NyaXB0aW9uJyk7XG4gIH1cblxuICBzZXQgZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9zZXRQcm9wKCdkZXNjcmlwdGlvbicsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgY29sb3IgZnJvbSBbcmZjNzk4Nl0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3OTg2KVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2NvbG9yJyk7XG4gIH1cblxuICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRQcm9wKCdjb2xvcicsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb3JnYW5pemVyIHZhbHVlIGFzIGFuIHVyaS4gSW4gbW9zdCBjYXNlcyB0aGlzIGlzIGEgbWFpbHRvOiB1cmksIGJ1dFxuICAgKiBpdCBjYW4gYWxzbyBiZSBzb21ldGhpbmcgZWxzZSwgbGlrZSB1cm46dXVpZDouLi5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBvcmdhbml6ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnb3JnYW5pemVyJyk7XG4gIH1cblxuICBzZXQgb3JnYW5pemVyKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0UHJvcCgnb3JnYW5pemVyJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzZXF1ZW5jZSB2YWx1ZSBmb3IgdGhpcyBldmVudC4gVXNlZCBmb3Igc2NoZWR1bGluZ1xuICAgKiBzZWUge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc2VxdWVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc2VxdWVuY2UnKTtcbiAgfVxuXG4gIHNldCBzZXF1ZW5jZSh2YWx1ZSkge1xuICAgIHRoaXMuX3NldFByb3AoJ3NlcXVlbmNlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZWN1cnJlbmNlIGlkIGZvciB0aGlzIGV2ZW50LiBTZWUge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKi9cbiAgZ2V0IHJlY3VycmVuY2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdyZWN1cnJlbmNlLWlkJyk7XG4gIH1cblxuICBzZXQgcmVjdXJyZW5jZUlkKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0VGltZSgncmVjdXJyZW5jZS1pZCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQvdXBkYXRlIGEgdGltZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICAgKiBUaGlzIHdpbGwgYWxzbyB1cGRhdGUgdGhlIFRaSUQgb2YgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBUT0RPOiB0aGlzIG1ldGhvZCBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBzd2l0Y2hpbmdcbiAgICogZnJvbSBhIGtub3duIHRpbWV6b25lIHRvIGFuIGltcGxpZWQgdGltZXpvbmUgKG9uZSB3aXRob3V0IFRaSUQpLlxuICAgKiBUaGlzIGRvZXMgX25vdF8gaGFuZGxlIHRoZSBjYXNlIG9mIG1vdmluZyBiZXR3ZWVuIGEga25vd25cbiAgICogIChieSBUaW1lem9uZVNlcnZpY2UpIHRpbWV6b25lIHRvIGFuIHVua25vd24gdGltZXpvbmUuLi5cbiAgICpcbiAgICogV2Ugd2lsbCBub3QgYWRkL3JlbW92ZS91cGRhdGUgdGhlIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzXG4gICAqICBsZWFkaW5nIHRvIGludmFsaWQgSUNBTCBkYXRhLi4uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSAgICAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtUaW1lfSB0aW1lICAgICAgICAgICBUaGUgdGltZSB0byBzZXRcbiAgICovXG4gIF9zZXRUaW1lKHByb3BOYW1lLCB0aW1lKSB7XG4gICAgbGV0IHByb3AgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KHByb3BOYW1lKTtcblxuICAgIGlmICghcHJvcCkge1xuICAgICAgcHJvcCA9IG5ldyBQcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICB0aGlzLmNvbXBvbmVudC5hZGRQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG5cbiAgICAvLyB1dGMgYW5kIGxvY2FsIGRvbid0IGdldCBhIHR6aWRcbiAgICBpZiAoXG4gICAgICB0aW1lLnpvbmUgPT09IFRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgIHRpbWUuem9uZSA9PT0gVGltZXpvbmUudXRjVGltZXpvbmVcbiAgICApIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgdHppZFxuICAgICAgcHJvcC5yZW1vdmVQYXJhbWV0ZXIoJ3R6aWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5zZXRQYXJhbWV0ZXIoJ3R6aWQnLCB0aW1lLnpvbmUudHppZCk7XG4gICAgfVxuXG4gICAgcHJvcC5zZXRWYWx1ZSh0aW1lKTtcbiAgfVxuXG4gIF9zZXRQcm9wKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5jb21wb25lbnQudXBkYXRlUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgX2ZpcnN0UHJvcChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC50b1N0cmluZygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZUV4Y2VwdGlvbihhLCBiKSB7XG4gIGlmIChhWzBdID4gYlswXSkgcmV0dXJuIDE7XG4gIGlmIChiWzBdID4gYVswXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhlIENvbXBvbmVudFBhcnNlciBpcyB1c2VkIHRvIHByb2Nlc3MgYSBTdHJpbmcgb3IgakNhbCBPYmplY3QsXG4gKiBmaXJpbmcgY2FsbGJhY2tzIGZvciB2YXJpb3VzIGZvdW5kIGNvbXBvbmVudHMsIGFzIHdlbGwgYXMgY29tcGxldGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIG9wdGlvbnMgPSB7XG4gKiAgIC8vIHdoZW4gZmFsc2Ugbm8gZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBmb3IgdHlwZVxuICogICBwYXJzZUV2ZW50OiB0cnVlLFxuICogICBwYXJzZVRpbWV6b25lOiB0cnVlXG4gKiB9O1xuICpcbiAqIHZhciBwYXJzZXIgPSBuZXcgSUNBTC5Db21wb25lbnRQYXJzZXIob3B0aW9ucyk7XG4gKlxuICogcGFyc2VyLm9uZXZlbnQoZXZlbnRDb21wb25lbnQpIHtcbiAqICAgLy8uLi5cbiAqIH1cbiAqXG4gKiAvLyBvbnRpbWV6b25lLCBldGMuLi5cbiAqXG4gKiBwYXJzZXIub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICpcbiAqIH07XG4gKlxuICogcGFyc2VyLnByb2Nlc3Moc3RyaW5nT3JDb21wb25lbnQpO1xuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIENvbXBvbmVudFBhcnNlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuQ29tcG9uZW50UGFyc2VyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50IHBhcnNlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZUV2ZW50ICAgICAgICBXaGV0aGVyIGV2ZW50cyBzaG91bGQgYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZVRpbWV6ZW9uZSAgICBXaGV0aGVyIHRpbWV6b25lcyBzaG91bGQgYmUgcGFyc2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucykpIHtcbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHBhcnNlIGV2ZW50c1xuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHBhcnNlRXZlbnQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHBhcnNlIHRpbWV6b25lc1xuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHBhcnNlVGltZXpvbmUgPSB0cnVlO1xuXG5cbiAgLyogU0FYIGxpa2UgZXZlbnRzIGhlcmUgZm9yIHJlZmVyZW5jZSAqL1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHBhcnNpbmcgaXMgY29tcGxldGVcbiAgICogQGNhbGxiYWNrXG4gICAqL1xuICBvbmNvbXBsZXRlID0gLyogYzggaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7fTtcblxuICAvKipcbiAgICogRmlyZWQgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBwYXJzaW5nLlxuICAgKlxuICAgKiBAY2FsbGJhY2tcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIGRldGFpbHMgb2YgZXJyb3JcbiAgICovXG4gIG9uZXJyb3IgPSAvKiBjOCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbihlcnIpIHt9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVlRJTUVaT05FKSBpcyBmb3VuZFxuICAgKlxuICAgKiBAY2FsbGJhY2tcbiAgICogQHBhcmFtIHtUaW1lem9uZX0gY29tcG9uZW50ICAgICBUaW1lem9uZSBvYmplY3RcbiAgICovXG4gIG9udGltZXpvbmUgPSAvKiBjOCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbihjb21wb25lbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVkVWRU5UKSBpcyBmb3VuZC5cbiAgICpcbiAgICogQGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RXZlbnR9IGNvbXBvbmVudCAgICBUb3AgbGV2ZWwgY29tcG9uZW50XG4gICAqL1xuICBvbmV2ZW50ID0gLyogYzggaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oY29tcG9uZW50KSB7fTtcblxuICAvKipcbiAgICogUHJvY2VzcyBhIHN0cmluZyBvciBwYXJzZSBpY2FsIG9iamVjdC4gIFRoaXMgZnVuY3Rpb24gaXRzZWxmIHdpbGwgcmV0dXJuXG4gICAqIG5vdGhpbmcgYnV0IHdpbGwgc3RhcnQgdGhlIHBhcnNpbmcgcHJvY2Vzcy5cbiAgICpcbiAgICogRXZlbnRzIG11c3QgYmUgcmVnaXN0ZXJlZCBwcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudHxTdHJpbmd8T2JqZWN0fSBpY2FsICAgICAgVGhlIGNvbXBvbmVudCB0byBwcm9jZXNzLFxuICAgKiAgICAgICAgZWl0aGVyIGluIGl0cyBmaW5hbCBmb3JtLCBhcyBhIGpDYWwgT2JqZWN0LCBvciBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIHByb2Nlc3MoaWNhbCkge1xuICAgIC8vVE9ETzogdGhpcyBpcyBzeW5jIG5vdyBpbiB0aGUgZnV0dXJlIHdlIHdpbGwgaGF2ZSBhIGluY3JlbWVudGFsIHBhcnNlci5cbiAgICBpZiAodHlwZW9mKGljYWwpID09PSAnc3RyaW5nJykge1xuICAgICAgaWNhbCA9IHBhcnNlKGljYWwpO1xuICAgIH1cblxuICAgIGlmICghKGljYWwgaW5zdGFuY2VvZiBDb21wb25lbnQpKSB7XG4gICAgICBpY2FsID0gbmV3IENvbXBvbmVudChpY2FsKTtcbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50cyA9IGljYWwuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgbGV0IGNvbXBvbmVudDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgIHN3aXRjaCAoY29tcG9uZW50Lm5hbWUpIHtcbiAgICAgICAgY2FzZSAndnRpbWV6b25lJzpcbiAgICAgICAgICBpZiAodGhpcy5wYXJzZVRpbWV6b25lKSB7XG4gICAgICAgICAgICBsZXQgdHppZCA9IGNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICAgICAgICAgIGlmICh0emlkKSB7XG4gICAgICAgICAgICAgIHRoaXMub250aW1lem9uZShuZXcgVGltZXpvbmUoe1xuICAgICAgICAgICAgICAgIHR6aWQ6IHR6aWQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnRcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmV2ZW50JzpcbiAgICAgICAgICBpZiAodGhpcy5wYXJzZUV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9uZXZlbnQobmV3IEV2ZW50KGNvbXBvbmVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1hYWDogaWRlYWxseSB3ZSBzaG91bGQgZG8gYSBcIm5leHRUaWNrXCIgaGVyZVxuICAgIC8vICAgICBzbyBpbiBhbGwgY2FzZXMgdGhpcyBpcyBhY3R1YWxseSBhc3luYy5cbiAgICB0aGlzLm9uY29tcGxldGUoKTtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGUgbWFpbiBJQ0FMIG1vZHVsZS4gUHJvdmlkZXMgYWNjZXNzIHRvIGV2ZXJ5dGhpbmcgZWxzZS5cbiAqXG4gKiBAYWxpYXMgSUNBTFxuICogQG5hbWVzcGFjZSBJQ0FMXG4gKiBAcHJvcGVydHkge0lDQUwuZGVzaWdufSBkZXNpZ25cbiAqIEBwcm9wZXJ0eSB7SUNBTC5oZWxwZXJzfSBoZWxwZXJzXG4gKi9cbnZhciBJQ0FMbW9kdWxlID0ge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGJlZm9yZSBpQ2FsZW5kYXIgbGluZSBmb2xkaW5nIHNob3VsZCBvY2N1clxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCA3NVxuICAgKi9cbiAgZm9sZExlbmd0aDogNzUsXG5cbiAgZGVidWc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBUaGUgY2hhcmFjdGVyKHMpIHRvIGJlIHVzZWQgZm9yIGEgbmV3bGluZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgYnlcbiAgICogcmZjNTU0NS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJcXHJcXG5cIlxuICAgKi9cbiAgbmV3TGluZUNoYXI6ICdcXHJcXG4nLFxuXG4gIEJpbmFyeSxcbiAgQ29tcG9uZW50LFxuICBDb21wb25lbnRQYXJzZXIsXG4gIER1cmF0aW9uLFxuICBFdmVudCxcbiAgUGVyaW9kLFxuICBQcm9wZXJ0eSxcbiAgUmVjdXIsXG4gIFJlY3VyRXhwYW5zaW9uLFxuICBSZWN1ckl0ZXJhdG9yLFxuICBUaW1lLFxuICBUaW1lem9uZSxcbiAgVGltZXpvbmVTZXJ2aWNlLFxuICBVdGNPZmZzZXQsXG4gIFZDYXJkVGltZSxcblxuICBwYXJzZSxcbiAgc3RyaW5naWZ5LFxuXG4gIGRlc2lnbjogZGVzaWduJDEsXG4gIGhlbHBlcnNcbn07XG5cbmV4cG9ydCB7IElDQUxtb2R1bGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIkJpbmFyeSIsImZyb21TdHJpbmciLCJhU3RyaW5nIiwiY29uc3RydWN0b3IiLCJhVmFsdWUiLCJpY2FsdHlwZSIsInZhbHVlIiwiZGVjb2RlVmFsdWUiLCJfYjY0X2RlY29kZSIsInNldEVuY29kZWRWYWx1ZSIsIl9iNjRfZW5jb2RlIiwiZGF0YSIsImI2NCIsIm8xIiwibzIiLCJvMyIsImgxIiwiaDIiLCJoMyIsImg0IiwiYml0cyIsImkiLCJhYyIsImVuYyIsInRtcF9hcnIiLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwibGVuZ3RoIiwiam9pbiIsInIiLCJzbGljZSIsImRlYyIsImluZGV4T2YiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b1N0cmluZyIsIkRVUkFUSU9OX0xFVFRFUlMiLCJEQVRBX1BST1BTX1RPX0NPUFkiLCJEdXJhdGlvbiIsImZyb21TZWNvbmRzIiwiYVNlY29uZHMiLCJpc1ZhbHVlU3RyaW5nIiwic3RyaW5nIiwiYVN0ciIsInBvcyIsImRpY3QiLCJPYmplY3QiLCJjcmVhdGUiLCJjaHVua3MiLCJzZWFyY2giLCJ0eXBlIiwibnVtZXJpYyIsIk1hdGgiLCJtYXgiLCJwYXJzZUR1cmF0aW9uQ2h1bmsiLCJFcnJvciIsImZyb21EYXRhIiwiYURhdGEiLCJ3ZWVrcyIsImRheXMiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwiaXNOZWdhdGl2ZSIsImljYWxjbGFzcyIsIndyYXBwZWRKU09iamVjdCIsImNsb25lIiwidG9TZWNvbmRzIiwic2VjcyIsImFicyIsInRydW5jIiwicHJvcCIsInJlc2V0IiwiY29tcGFyZSIsImFPdGhlciIsInRoaXNTZWNvbmRzIiwib3RoZXJTZWNvbmRzIiwibm9ybWFsaXplIiwic3RyIiwidG9JQ0FMU3RyaW5nIiwibGV0dGVyIiwibnVtYmVyIiwib2JqZWN0IiwibnVtIiwicGFyc2VJbnQiLCJpc1N0cmljdGx5TmFOIiwiVGltZSIsIl9kb3dDYWNoZSIsIl93bkNhY2hlIiwiZGF5c0luTW9udGgiLCJtb250aCIsInllYXIiLCJfZGF5c0luTW9udGgiLCJpc0xlYXBZZWFyIiwiZnJvbURheU9mWWVhciIsImFEYXlPZlllYXIiLCJhWWVhciIsImRveSIsInR0IiwiYXV0b19ub3JtYWxpemUiLCJpc19sZWFwIiwiZGF5c0luWWVhclBhc3NlZE1vbnRoIiwiaXNEYXRlIiwiZGF5IiwiZnJvbVN0cmluZ3YyIiwiZnJvbURhdGVTdHJpbmciLCJzdHJpY3RQYXJzZUludCIsImZyb21EYXRlVGltZVN0cmluZyIsInpvbmUiLCJ6b25lSWQiLCJUaW1lem9uZSIsInV0Y1RpbWV6b25lIiwiZ2V0UGFyYW1ldGVyIiwicGFyZW50IiwibmFtZSIsImxvY2FsVGltZXpvbmUiLCJnZXRUaW1lWm9uZUJ5SUQiLCJ0aW1lRGF0YSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJ0aW1lem9uZSIsImFQcm9wZXJ0eSIsImZyb21KU0RhdGUiLCJhRGF0ZSIsInVzZVVUQyIsImFab25lIiwidCIsIm5vdyIsIkRhdGUiLCJ3ZWVrT25lU3RhcnRzIiwiYVdlZWtTdGFydCIsImRvdyIsImRheU9mV2VlayIsIndrc3QiLCJERUZBVUxUX1dFRUtfU1RBUlQiLCJUSFVSU0RBWSIsImdldERvbWluaWNhbExldHRlciIsInlyIiwiTFRSUyIsImRvbSIsImlzTGVhcCIsImVwb2NoVGltZSIsIl9jbXBfYXR0ciIsImEiLCJiIiwiYXR0ciIsIlNVTkRBWSIsIk1PTkRBWSIsIlRVRVNEQVkiLCJXRURORVNEQVkiLCJGUklEQVkiLCJTQVRVUkRBWSIsIl9jYWNoZWRVbml4VGltZSIsIl9wZW5kaW5nTm9ybWFsaXphdGlvbiIsInRpbWUiLCJfdGltZSIsInJlc2V0VG8iLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJrZXkiLCJlbnRyaWVzIiwiVGltZXpvbmVTZXJ2aWNlIiwiZ2V0IiwiZmlyc3REb3ciLCJkb3dDYWNoZUtleSIsInEiLCJtIiwiWSIsImgiLCJkYXlPZlllYXIiLCJkaXlwbSIsInN0YXJ0T2ZXZWVrIiwicmVzdWx0IiwiZW5kT2ZXZWVrIiwic3RhcnRPZk1vbnRoIiwiZW5kT2ZNb250aCIsInN0YXJ0T2ZZZWFyIiwiZW5kT2ZZZWFyIiwic3RhcnREb3lXZWVrIiwiYUZpcnN0RGF5T2ZXZWVrIiwiZGVsdGEiLCJudGhXZWVrRGF5IiwiYURheU9mV2VlayIsImFQb3MiLCJ3ZWVrZGF5Iiwic3RhcnQiLCJvdGhlckRheSIsInN0YXJ0RG93Iiwib2Zmc2V0IiwiZW5kRG93IiwiaXNOdGhXZWVrRGF5Iiwid2Vla051bWJlciIsInduQ2FjaGVLZXkiLCJ3ZWVrMSIsImR0IiwiaXNveWVhciIsImRheXNCZXR3ZWVuIiwic3VidHJhY3REYXRlIiwiYW5zd2VyIiwiYWRkRHVyYXRpb24iLCJhRHVyYXRpb24iLCJtdWx0IiwidW5peFRpbWUiLCJ0b1VuaXhUaW1lIiwidXRjT2Zmc2V0Iiwib3RoZXIiLCJzdWJ0cmFjdERhdGVUeiIsImNvbXBhcmVEYXRlT25seVR6IiwidHoiLCJjb252ZXJ0VG9ab25lIiwicmMiLCJjb3B5Iiwiem9uZV9lcXVhbHMiLCJ0emlkIiwiY29udmVydF90aW1lIiwiZGVzaWduJDEiLCJpY2FsZW5kYXIiLCJ0b0lDQUwiLCJkYXRlIiwicGFkMiIsInRvSlNEYXRlIiwiX25vcm1hbGl6ZSIsImFkanVzdCIsImFFeHRyYURheXMiLCJhRXh0cmFIb3VycyIsImFFeHRyYU1pbnV0ZXMiLCJhRXh0cmFTZWNvbmRzIiwiYVRpbWUiLCJtaW51dGVzT3ZlcmZsb3ciLCJob3Vyc092ZXJmbG93IiwiZGF5c092ZXJmbG93IiwieWVhcnNPdmVyZmxvdyIsImZyb21Vbml4VGltZSIsIm1zIiwiVVRDIiwidG9KU09OIiwibGVuIiwic2V0dXBOb3JtYWxpemVBdHRyaWJ1dGVzIiwiZGVmaW5lQXR0ciIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0VGltZUF0dHIiLCJzZXQiLCJzZXRUaW1lQXR0ciIsInZhbCIsIkNIQVIiLCJWQUxVRV9ERUxJTUlURVIiLCJQQVJBTV9ERUxJTUlURVIiLCJQQVJBTV9OQU1FX0RFTElNSVRFUiIsIkRFRkFVTFRfVkFMVUVfVFlQRSQxIiwiREVGQVVMVF9QQVJBTV9UWVBFIiwiUkZDNjg2OF9SRVBMQUNFX01BUCQxIiwicGFyc2UiLCJpbnB1dCIsInN0YXRlIiwicm9vdCIsImNvbXBvbmVudCIsInN0YWNrIiwiX2VhY2hMaW5lIiwiZXJyIiwibGluZSIsIl9oYW5kbGVDb250ZW50TGluZSIsIlBhcnNlckVycm9yIiwicHJvcGVydHkiLCJkZXNpZ25TZXQiLCJkZWZhdWx0U2V0IiwidmFsdWVQb3MiLCJwYXJhbVBvcyIsImxhc3RQYXJhbUluZGV4IiwibGFzdFZhbHVlUG9zIiwicGFyYW1zIiwicGFyc2VkUGFyYW1zIiwidG9Mb3dlckNhc2UiLCJfcGFyc2VQYXJhbWV0ZXJzIiwibmV3Q29tcG9uZW50IiwicHVzaCIsImdldERlc2lnblNldCIsInBvcCIsInZhbHVlVHlwZSIsIm11bHRpVmFsdWUiLCJzdHJ1Y3R1cmVkVmFsdWUiLCJwcm9wZXJ0eURldGFpbHMiLCJzcGxpdE5hbWUiLCJ1bmdyb3VwZWROYW1lIiwicHJvcGVydHlHcm91cHMiLCJzcGxpdCIsImdyb3VwIiwiZGV0ZWN0VHlwZSIsImRlZmF1bHRUeXBlIiwiX3BhcnNlTXVsdGlWYWx1ZSIsIl9wYXJzZVZhbHVlIiwiZnJvbUlDQUwiLCJsYXN0UGFyYW0iLCJkZWxpbSIsImxjbmFtZSIsIm12ZGVsaW0iLCJwYXJhbSIsIm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSIsIl9yZmM2ODY4RXNjYXBlIiwibmV4dENoYXIiLCJleHRlbmRlZFZhbHVlIiwicHJvcFZhbHVlUG9zIiwibmV4dFBvcyIsImxlbmd0aF9iZWZvcmUiLCJkZWxpbWl0ZXIiLCJBcnJheSIsImlzQXJyYXkiLCJyZXBsYWNlIiwieCIsImJ1ZmZlciIsImlubmVyTXVsdGkiLCJsYXN0UG9zIiwidW5lc2NhcGVkSW5kZXhPZiIsImNhbGxiYWNrIiwiZmlyc3RDaGFyIiwibmV3bGluZU9mZnNldCIsInRyaW0iLCJPUFRJT05TIiwiX2NvbXBhcmVfY2hhbmdlX2ZuIiwiZnJvbV96b25lIiwidG9fem9uZSIsImFkanVzdF9jaGFuZ2UiLCJjaGFuZ2UiLCJjYWxsIiwiX21pbmltdW1FeHBhbnNpb25ZZWFyIiwiRVhUUkFfQ09WRVJBR0UiLCJsb2NhdGlvbiIsInR6bmFtZXMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImV4cGFuZGVkVW50aWxZZWFyIiwiY2hhbmdlcyIsIkNvbXBvbmVudCIsImpDYWwiLCJnZXRGaXJzdFByb3BlcnR5VmFsdWUiLCJfZW5zdXJlQ292ZXJhZ2UiLCJ0dF9jaGFuZ2UiLCJjaGFuZ2VfbnVtIiwiX2ZpbmROZWFyYnlDaGFuZ2UiLCJjaGFuZ2VfbnVtX3RvX3VzZSIsInN0ZXAiLCJwcmV2VXRjT2Zmc2V0IiwiY21wIiwiem9uZV9jaGFuZ2UiLCJ1dGNPZmZzZXRfY2hhbmdlIiwidG1wX2NoYW5nZSIsInByZXZfem9uZV9jaGFuZ2UiLCJ3YW50X2RheWxpZ2h0IiwiaXNfZGF5bGlnaHQiLCJpZHgiLCJiaW5zZWFyY2hJbnNlcnQiLCJ0b2RheSIsImNoYW5nZXNFbmRZZWFyIiwic3ViY29tcHMiLCJnZXRBbGxTdWJjb21wb25lbnRzIiwiY29tcExlbiIsImNvbXBJZHgiLCJfZXhwYW5kQ29tcG9uZW50Iiwic29ydCIsImFDb21wb25lbnQiLCJoYXNQcm9wZXJ0eSIsImR0c3RhcnQiLCJnZXRGaXJzdFByb3BlcnR5IiwiZ2V0Rmlyc3RWYWx1ZSIsImNvbnZlcnRfdHpvZmZzZXQiLCJmYWN0b3IiLCJpbml0X2NoYW5nZXMiLCJjaGFuZ2ViYXNlIiwicHJvcHMiLCJnZXRBbGxQcm9wZXJ0aWVzIiwicmRhdGUiLCJycnVsZSIsInVudGlsIiwiaXRlcmF0b3IiLCJvY2MiLCJuZXh0Iiwiem9uZXMiLCJjb3VudCIsImtleXMiLCJ1dGMiLCJaIiwiR01UIiwiX2hhcmRfcmVzZXQiLCJoYXMiLCJyZWdpc3RlciIsIlR5cGVFcnJvciIsInJlbW92ZSIsInVwZGF0ZVRpbWV6b25lcyIsInZjYWwiLCJhbGxzdWJzIiwicHJvcGVydGllcyIsInZ0aW1lem9uZXMiLCJyZXFUemlkIiwiY29uY2F0IiwiY29tcCIsInJlbW92ZVN1YmNvbXBvbmVudCIsImFkZFN1YmNvbXBvbmVudCIsImlzTmFOIiwiZm9ybWF0Q2xhc3NUeXBlIiwidW5kZWZpbmVkIiwibGlzdCIsInNlZWtWYWwiLCJjbXBmdW5jIiwibG93IiwiaGlnaCIsIm1pZCIsImNtcHZhbCIsImZsb29yIiwiYVNyYyIsImFEZWVwIiwiZ2V0VGltZSIsImFyciIsIm9iaiIsImZvbGRsaW5lIiwiYUxpbmUiLCJsaW5lX2xlbmd0aCIsImNwIiwiY29kZVBvaW50QXQiLCJJQ0FMbW9kdWxlIiwiZm9sZExlbmd0aCIsIm5ld0xpbmVDaGFyIiwiY2VpbCIsImV4dGVuZCIsInNvdXJjZSIsInRhcmdldCIsImRlc2NyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaGVscGVycyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIlV0Y09mZnNldCIsIm9wdGlvbnMiLCJpbnN0YW5jZSIsIlZDYXJkVGltZSIsImZyb21EYXRlQW5kT3JUaW1lU3RyaW5nIiwiYUljYWxUeXBlIiwicGFydCIsInYiLCJzIiwiZSIsInBhcnRzIiwidG16Iiwic3BsaXR6b25lIiwidmNhcmQiLCJfc3BsaXRab25lIiwidG0iLCJkdGxlbiIsInRtbGVuIiwiaGFzRGFzaERhdGUiLCJoYXNEYXNoVGltZSIsIm8iLCJhcHBseSIsImFyZ3VtZW50cyIsInkiLCJkIiwibW0iLCJoYXNZZWFyIiwiaGFzTW9udGgiLCJoYXNEYXkiLCJoYXNIb3VyIiwiaGFzTWludXRlIiwiaGFzU2Vjb25kIiwiZGF0ZXBhcnQiLCJ0aW1lcGFydCIsIlJlY3VySXRlcmF0b3IiLCJfaW5kZXhNYXAiLCJfZXhwYW5kTWFwIiwiVU5LTk9XTiIsIkNPTlRSQUNUIiwiRVhQQU5EIiwiSUxMRUdBTCIsImNvbXBsZXRlZCIsInJ1bGUiLCJsYXN0Iiwib2NjdXJyZW5jZV9udW1iZXIiLCJieV9pbmRpY2VzIiwiaW5pdGlhbGl6ZWQiLCJieV9kYXRhIiwiZGF5c19pbmRleCIsIlJlY3VyIiwiaW5pdCIsIkludmFsaWRSZWN1cnJlbmNlUnVsZUVycm9yIiwic29ydF9ieWRheV9ydWxlcyIsIkJZREFZIiwiZnJlcSIsInNldHVwX2RlZmF1bHRzIiwicnVsZURheU9mV2VlayIsIndrZHkiLCJkYXlOYW1lIiwibnVtZXJpY0RheVRvSWNhbERheSIsInVudGlsWWVhciIsImV4cGFuZF95ZWFyX2RheXMiLCJpbmNyZW1lbnRfeWVhciIsImludGVydmFsIiwiX25leHRCeVllYXJEYXkiLCJoYXNfYnlfZGF0YSIsInRlbXBMYXN0IiwiaW5pdExhc3QiLCJieWRvdyIsImRheU9mTW9udGgiLCJpbmNyZW1lbnRfbW9udGgiLCJfYnlEYXlBbmRNb250aERheSIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMiLCJCWU1PTlRIREFZIiwiZmlsdGVyIiwibmV4dF9tb250aCIsImFnYWluIiwiYmVmb3JlIiwidmFsaWQiLCJuZXh0X3NlY29uZCIsIm5leHRfbWludXRlIiwibmV4dF9ob3VyIiwibmV4dF9kYXkiLCJuZXh0X3dlZWsiLCJuZXh0X3llYXIiLCJjaGVja19jb250cmFjdGluZ19ydWxlcyIsIm5leHRfZ2VuZXJpYyIsImluY3JlbWVudF9zZWNvbmQiLCJpbmMiLCJpbmNyZW1lbnRfZ2VuZXJpYyIsImluY3JlbWVudF9taW51dGUiLCJpbmNyZW1lbnRfaG91ciIsInRoaXNfZnJlcSIsImluY3JlbWVudF9tb250aGRheSIsImVuZF9vZl9kYXRhIiwibmV4dF93ZWVrZGF5X2J5X3dlZWsiLCJCWVdFRUtOTyIsIndlZWtfbm8iLCJydWxlcyIsIm5ld1J1bGVzIiwicnVsZUlkeCIsImlzSW5pdCIsImJ5TW9udGhEYXkiLCJieURheSIsImRhdGVJZHgiLCJkYXRlTGVuIiwiZGF5TGVuIiwiZGF0YUlzVmFsaWQiLCJzZWxmIiwibGFzdERheSIsImluaXRNb250aCIsIm5leHRNb250aCIsIm1vbnRoc0NvdW50ZXIiLCJkYXlJZHgiLCJkYXRhX3ZhbGlkIiwic2V0cG9zIiwic2V0cG9zX3RvdGFsIiwibGFzdF9kYXkiLCJpc19kYXlfaW5fYnlkYXkiLCJjaGVja19zZXRfcG9zaXRpb24iLCJjb2RlZF9kYXkiLCJtYXRjaGVzIiwibWF0Y2giLCJpY2FsRGF5VG9OdW1lcmljRGF5IiwiYVJ1bGVUeXBlIiwiYUludGVydmFsIiwiYURhdGVBdHRyIiwiYUZvbGxvd2luZ0F0dHIiLCJhUHJldmlvdXNJbmNyIiwiaGFzX2J5X3J1bGUiLCJkdGEiLCJCWU1PTlRIIiwieWVhcnMiLCJhRmFjdG9yIiwiYU5leHRJbmNyZW1lbnQiLCJuZXh0dW5pdCIsInZhbGlkV2Vla3MiLCJtb250aElkeCIsImZpcnN0X3dlZWsiLCJsYXN0X3dlZWsiLCJ3ZWVrSWR4Iiwid2Vla25vIiwicGFydENvdW50IiwidDEiLCJ0MiIsIm1vbnRoZGF5IiwidDMiLCJleHBhbmRfYnlfZGF5IiwiZmlyc3RfZG93IiwiZG95X29mZnNldCIsImxhc3RfZG93IiwiYnlfbW9udGhfZGF5Iiwic3BJbmRleCIsImJ5ZGF5UGFydHMiLCJtb250aF9kYXkiLCJmaXJzdF9tYXRjaGluZ19kYXkiLCJsYXN0X21hdGNoaW5nX2RheSIsImV4cGFuZGVkRGF5cyIsIkJZWUVBUkRBWSIsImRheXNJblllYXIiLCJkYXlzX2xpc3QiLCJ0bXAiLCJzdGFydF9kb3ciLCJlbmRfZG93IiwiZW5kX3llYXJfZGF5IiwidG1wX3N0YXJ0X2RveSIsImZpcnN0IiwidGhpc19kb3ciLCJCWVNFVFBPUyIsImFSdWxlcyIsImoiLCJvbmUiLCJ0d28iLCJjaGVja19jb250cmFjdF9yZXN0cmljdGlvbiIsImluZGV4TWFwVmFsdWUiLCJydWxlTWFwVmFsdWUiLCJwYXNzIiwicnVsZVR5cGUiLCJieWRhdGEiLCJ3ZWVrTm8iLCJyZXEiLCJkZWZ0aW1lIiwiVkFMSURfREFZX05BTUVTIiwiVkFMSURfQllEQVlfUEFSVCIsIkRPV19NQVAiLCJTVSIsIk1PIiwiVFUiLCJXRSIsIlRIIiwiRlIiLCJTQSIsIlJFVkVSU0VfRE9XX01BUCIsImZyb21FbnRyaWVzIiwibWFwIiwiZW50cnkiLCJyZXZlcnNlIiwiQUxMT1dFRF9GUkVRIiwiX3N0cmluZ1RvRGF0YSIsImZtdEljYWwiLCJ2YWx1ZXMiLCJ1Y25hbWUiLCJ0b1VwcGVyQ2FzZSIsInBhcnREZXNpZ24iLCJwYXJ0QXJyIiwicGFydFNldCIsIlNldCIsImFkZCIsIm9wdGlvbkRlc2lnbiIsImFTdGFydCIsImlzRmluaXRlIiwiaXNCeUNvdW50IiwiYWRkQ29tcG9uZW50IiwiYVR5cGUiLCJzZXRDb21wb25lbnQiLCJhVmFsdWVzIiwiZ2V0Q29tcG9uZW50IiwiZ2V0TmV4dE9jY3VycmVuY2UiLCJhU3RhcnRUaW1lIiwiYVJlY3VycmVuY2VJZCIsIml0ZXIiLCJ1Y2tleSIsIklOVEVSVkFMIiwicmVzIiwiayIsImtwYXJ0cyIsInBhcnNlTnVtZXJpY1ZhbHVlIiwibWluIiwiRlJFUSIsIkNPVU5UIiwiVU5USUwiLCJXS1NUIiwidGVzdCIsIkJZU0VDT05EIiwiYmluZCIsIkJZTUlOVVRFIiwiQllIT1VSIiwiUGVyaW9kIiwiZW5kIiwiZHVyYXRpb24iLCJmcm9tSlNPTiIsImFQcm9wIiwiYUxlbmllbnQiLCJmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmciLCJkYXRlUHJvcCIsImdldER1cmF0aW9uIiwiZ2V0RW5kIiwiRlJPTV9JQ0FMX05FV0xJTkUiLCJUT19JQ0FMX05FV0xJTkUiLCJGUk9NX1ZDQVJEX05FV0xJTkUiLCJUT19WQ0FSRF9ORVdMSU5FIiwiY3JlYXRlVGV4dFR5cGUiLCJmcm9tTmV3bGluZSIsInRvTmV3bGluZSIsInN0cnVjdHVyZWRFc2NhcGUiLCJyZXBsYWNlTmV3bGluZSIsInJlZ0V4IiwiUmVnRXhwIiwiZmxhZ3MiLCJERUZBVUxUX1RZUEVfVEVYVCIsIkRFRkFVTFRfVFlQRV9URVhUX01VTFRJIiwiREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCIsIkRFRkFVTFRfVFlQRV9JTlRFR0VSIiwiREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUiLCJhbGxvd2VkVHlwZXMiLCJERUZBVUxUX1RZUEVfREFURVRJTUUiLCJERUZBVUxUX1RZUEVfVVJJIiwiREVGQVVMVF9UWVBFX1VUQ09GRlNFVCIsIkRFRkFVTFRfVFlQRV9SRUNVUiIsIkRFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUiLCJyZXBsYWNlTmV3bGluZVJlcGxhY2UiLCJuZXdsaW5lIiwiY29tbW9uUHJvcGVydGllcyIsImNvbW1vblZhbHVlcyIsImZsb2F0IiwicGFyc2VkIiwicGFyc2VGbG9hdCIsImludGVnZXIiLCJkZWNvcmF0ZSIsInVuZGVjb3JhdGUiLCJpY2FsUGFyYW1zIiwiYWxsb3dYTmFtZSIsImFsbG93SWFuYVRva2VuIiwiaWNhbFZhbHVlcyIsInRleHQiLCJ1cmkiLCJhQmluYXJ5IiwiZGVzaWduIiwic3RyaWN0IiwicGVyaW9kIiwicmVjdXIiLCJhUmVjdXIiLCJpY2FsUHJvcGVydGllcyIsInZjYXJkVmFsdWVzIiwiaXNGcm9tSWNhbCIsImxhc3RDaGFyIiwic2lnbkNoYXIiLCJzaWduIiwidGltZXN0YW1wIiwiZnJvbSIsImMiLCJ2Y2FyZFBhcmFtcyIsInZjYXJkUHJvcGVydGllcyIsInZjYXJkM1ZhbHVlcyIsImJpbmFyeSIsInZjYXJkM1BhcmFtcyIsInZjYXJkM1Byb3BlcnRpZXMiLCJmbiIsIm4iLCJuaWNrbmFtZSIsInBob3RvIiwiYmRheSIsImFkciIsImxhYmVsIiwidGVsIiwiZW1haWwiLCJtYWlsZXIiLCJnZW8iLCJ0aXRsZSIsInJvbGUiLCJsb2dvIiwiYWdlbnQiLCJvcmciLCJub3RlIiwicHJvZGlkIiwicmV2Iiwic291bmQiLCJjbGFzcyIsImljYWxTZXQiLCJ2Y2FyZFNldCIsInZjYXJkM1NldCIsImNvbXBvbmVudHMiLCJ2Y2FyZDMiLCJ2ZXZlbnQiLCJ2dG9kbyIsInZqb3VybmFsIiwidmFsYXJtIiwidnRpbWV6b25lIiwiZGF5bGlnaHQiLCJzdGFuZGFyZCIsImNvbXBvbmVudE5hbWUiLCJpc0luRGVzaWduIiwiTElORV9FTkRJTkciLCJERUZBVUxUX1ZBTFVFX1RZUEUiLCJSRkM2ODY4X1JFUExBQ0VfTUFQIiwic3RyaW5naWZ5IiwicHJvcElkeCIsInByb3BMZW4iLCJkZXNpZ25TZXROYW1lIiwiY29tcHMiLCJub0ZvbGQiLCJqc05hbWUiLCJncm91cE5hbWUiLCJwYXJhbU5hbWUiLCJwYXJhbURlc2lnbiIsIl9yZmM2ODY4VW5lc2NhcGUiLCJwYXJhbVByb3BlcnR5VmFsdWUiLCJwcm9wRGV0YWlscyIsImlzRGVmYXVsdCIsImZvcmNlIiwiTkFNRV9JTkRFWCQxIiwiUFJPUF9JTkRFWCIsIlRZUEVfSU5ERVgiLCJWQUxVRV9JTkRFWCIsIlByb3BlcnR5IiwiX3BhcmVudCIsImdldERlZmF1bHRUeXBlIiwiX3VwZGF0ZVR5cGUiLCJwIiwiZGVzaWduU2V0Q2hhbmdlZCIsIl9kZXNpZ25TZXQiLCJpc0RlY29yYXRlZCIsImlzTXVsdGlWYWx1ZSIsImlzU3RydWN0dXJlZFZhbHVlIiwiX2h5ZHJhdGVWYWx1ZSIsImluZGV4IiwiX3ZhbHVlcyIsIl9kZWNvcmF0ZSIsIl91bmRlY29yYXRlIiwiX3NldERlY29yYXRlZFZhbHVlIiwiZ2V0Rmlyc3RQYXJhbWV0ZXIiLCJwYXJhbWV0ZXJzIiwic2V0UGFyYW1ldGVyIiwicmVtb3ZlUGFyYW1ldGVyIiwiZGV0YWlscyIsInJlc2V0VHlwZSIsInJlbW92ZUFsbFZhbHVlcyIsImdldFZhbHVlcyIsInNldFZhbHVlcyIsInNldFZhbHVlIiwiTkFNRV9JTkRFWCIsIlBST1BFUlRZX0lOREVYIiwiQ09NUE9ORU5UX0lOREVYIiwiX2h5ZHJhdGVkUHJvcGVydHlDb3VudCIsIl9oeWRyYXRlZENvbXBvbmVudENvdW50IiwiX3RpbWV6b25lQ2FjaGUiLCJfY29tcG9uZW50cyIsIl9wcm9wZXJ0aWVzIiwiTWFwIiwicGFyZW50RGVzaWduIiwiX2h5ZHJhdGVDb21wb25lbnQiLCJfaHlkcmF0ZVByb3BlcnR5IiwiZ2V0Rmlyc3RTdWJjb21wb25lbnQiLCJqQ2FsTGVuIiwiX3JlbW92ZU9iamVjdEJ5SW5kZXgiLCJqQ2FsSW5kZXgiLCJjYWNoZSIsInNwbGljZSIsIl9yZW1vdmVPYmplY3QiLCJuYW1lT3JPYmplY3QiLCJvYmplY3RzIiwiY2FjaGVkIiwiX3JlbW92ZUFsbE9iamVjdHMiLCJuYW1lT3JDb21wIiwicmVtb3ZlZCIsInJlbW92ZUFsbFN1YmNvbXBvbmVudHMiLCJhZGRQcm9wZXJ0eSIsInJlbW92ZVByb3BlcnR5IiwiYWRkUHJvcGVydHlXaXRoVmFsdWUiLCJ1cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZSIsIm5hbWVPclByb3AiLCJyZW1vdmVBbGxQcm9wZXJ0aWVzIiwiaHlkcmF0ZWRab25lIiwiUmVjdXJFeHBhbnNpb24iLCJjb21wbGV0ZSIsInJ1bGVJdGVyYXRvcnMiLCJydWxlRGF0ZXMiLCJleERhdGVzIiwicnVsZURhdGVJbmMiLCJleERhdGVJbmMiLCJleERhdGUiLCJydWxlRGF0ZSIsIl9pbml0IiwiaXRlbSIsIm1heFRyaWVzIiwiY3VycmVudFRyeSIsIl9uZXh0UmVjdXJyZW5jZUl0ZXIiLCJfbmV4dFJ1bGVEYXkiLCJfbmV4dEV4RGF5IiwiX2V4dHJhY3REYXRlcyIsInByb3BlcnR5TmFtZSIsIml0ZXJzIiwiaXRlclRpbWUiLCJpdGVySWR4IiwiY2hvc2VuSXRlciIsIkV2ZW50IiwiZXhjZXB0aW9ucyIsInN0cmljdEV4Y2VwdGlvbnMiLCJfcmFuZ2VFeGNlcHRpb25DYWNoZSIsInJhbmdlRXhjZXB0aW9ucyIsImZvckVhY2giLCJyZWxhdGVFeGNlcHRpb24iLCJpc1JlY3VycmVuY2VFeGNlcHRpb24iLCJldmVudCIsIlRISVNBTkRGVVRVUkUiLCJ1aWQiLCJpZCIsInJlY3VycmVuY2VJZCIsIm1vZGlmaWVzRnV0dXJlIiwiY29tcGFyZVJhbmdlRXhjZXB0aW9uIiwicmFuZ2UiLCJmaW5kUmFuZ2VFeGNlcHRpb24iLCJyYW5nZUl0ZW0iLCJnZXRPY2N1cnJlbmNlRGV0YWlscyIsIm9jY3VycmVuY2UiLCJ1dGNJZCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJyYW5nZUV4Y2VwdGlvbklkIiwiZXhjZXB0aW9uIiwic3RhcnREaWZmIiwib3JpZ2luYWwiLCJuZXdTdGFydCIsInN0YXJ0VGltZSIsImlzUmVjdXJyaW5nIiwiZ2V0UmVjdXJyZW5jZVR5cGVzIiwiX2ZpcnN0UHJvcCIsIl9zZXRQcm9wIiwiX3NldFRpbWUiLCJhdHRlbmRlZXMiLCJzdW1tYXJ5IiwiZGVzY3JpcHRpb24iLCJjb2xvciIsIm9yZ2FuaXplciIsInNlcXVlbmNlIiwicHJvcE5hbWUiLCJDb21wb25lbnRQYXJzZXIiLCJwYXJzZUV2ZW50IiwicGFyc2VUaW1lem9uZSIsIm9uY29tcGxldGUiLCJvbmVycm9yIiwib250aW1lem9uZSIsIm9uZXZlbnQiLCJwcm9jZXNzIiwiaWNhbCIsImRlYnVnIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ical.js/dist/ical.js\n");

/***/ })

};
;