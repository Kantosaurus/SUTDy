"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/welcome/page",{

/***/ "(app-pages-browser)/./app/welcome/page.tsx":
/*!******************************!*\
  !*** ./app/welcome/page.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ WelcomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var ical_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ical.js */ \"(app-pages-browser)/./node_modules/ical.js/dist/ical.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst DAYS_OF_WEEK = [\n    \"Sun\",\n    \"Mon\",\n    \"Tue\",\n    \"Wed\",\n    \"Thu\",\n    \"Fri\",\n    \"Sat\"\n];\nconst MONTHS = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n];\nfunction WelcomePage() {\n    _s();\n    const [showWelcome, setShowWelcome] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showCalendar, setShowCalendar] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useSearchParams)();\n    const username = searchParams === null || searchParams === void 0 ? void 0 : searchParams.get(\"username\");\n    const isFirstLogin = (searchParams === null || searchParams === void 0 ? void 0 : searchParams.get(\"firstLogin\")) === \"true\";\n    // Calendar state\n    const [currentDate, setCurrentDate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Date());\n    const [selectedDate, setSelectedDate] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [showEventDetails, setShowEventDetails] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Welcome page mounted\");\n        console.log(\"Search params:\", Object.fromEntries((searchParams === null || searchParams === void 0 ? void 0 : searchParams.entries()) || []));\n        console.log(\"Username from params:\", username);\n        if (!username) {\n            console.log(\"No username found, redirecting to login\");\n            router.push(\"/login\");\n            return;\n        }\n        // Hide welcome message after 3 seconds\n        const timer = setTimeout(()=>{\n            console.log(\"Hiding welcome message\");\n            setShowWelcome(false);\n            // Show calendar after welcome message disappears\n            setTimeout(()=>{\n                console.log(\"Showing calendar\");\n                setShowCalendar(true);\n            }, 500);\n        }, 3000);\n        return ()=>clearTimeout(timer);\n    }, [\n        username,\n        router,\n        searchParams\n    ]);\n    const handleFileUpload = async (e)=>{\n        var _e_target_files;\n        const file = (_e_target_files = e.target.files) === null || _e_target_files === void 0 ? void 0 : _e_target_files[0];\n        if (!file) return;\n        try {\n            const text = await file.text();\n            const jcalData = ical_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].parse(text);\n            const comp = new ical_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Component(jcalData);\n            const vevents = comp.getAllSubcomponents(\"vevent\");\n            const newEvents = vevents.map((vevent)=>{\n                const event = new ical_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Event(vevent);\n                return {\n                    id: event.uid,\n                    title: event.summary,\n                    start: event.startDate.toJSDate(),\n                    end: event.endDate.toJSDate(),\n                    description: event.description\n                };\n            });\n            setEvents((prevEvents)=>[\n                    ...prevEvents,\n                    ...newEvents\n                ]);\n            alert(\"Successfully imported \".concat(newEvents.length, \" events!\"));\n        } catch (error) {\n            console.error(\"Error parsing .ics file:\", error);\n            alert(\"Error importing calendar file. Please make sure it's a valid .ics file.\");\n        }\n    };\n    const getEventsForDate = (date)=>{\n        return events.filter((event)=>{\n            const eventDate = new Date(event.start);\n            return eventDate.getDate() === date.getDate() && eventDate.getMonth() === date.getMonth() && eventDate.getFullYear() === date.getFullYear();\n        });\n    };\n    const getDaysInMonth = (date)=>{\n        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n    };\n    const getFirstDayOfMonth = (date)=>{\n        return new Date(date.getFullYear(), date.getMonth(), 1).getDay();\n    };\n    const handlePreviousMonth = ()=>{\n        setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1));\n    };\n    const handleNextMonth = ()=>{\n        setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1));\n    };\n    const generateCalendarDays = ()=>{\n        const daysInMonth = getDaysInMonth(currentDate);\n        const firstDayOfMonth = getFirstDayOfMonth(currentDate);\n        const days = [];\n        // Add empty cells for days before the first day of the month\n        for(let i = 0; i < firstDayOfMonth; i++){\n            days.push(null);\n        }\n        // Add the days of the month\n        for(let day = 1; day <= daysInMonth; day++){\n            days.push(new Date(currentDate.getFullYear(), currentDate.getMonth(), day));\n        }\n        return days;\n    };\n    const isToday = (date)=>{\n        const today = new Date();\n        return date.getDate() === today.getDate() && date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();\n    };\n    const isSelected = (date)=>{\n        return selectedDate && date.getDate() === selectedDate.getDate() && date.getMonth() === selectedDate.getMonth() && date.getFullYear() === selectedDate.getFullYear();\n    };\n    if (!username) {\n        console.log(\"Rendering null - no username\");\n        return null;\n    }\n    console.log(\"Rendering welcome page with username:\", username);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 flex items-center justify-center p-4\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative w-full max-w-4xl\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute -top-20 -left-20 w-72 h-72 bg-purple-300 rounded-full mix-blend-multiply filter blur-xl opacity-30 animate-blob\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                    lineNumber: 157,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute -bottom-20 -right-20 w-72 h-72 bg-blue-300 rounded-full mix-blend-multiply filter blur-xl opacity-30 animate-blob animation-delay-2000\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                    lineNumber: 158,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_4__.AnimatePresence, {\n                    mode: \"wait\",\n                    children: [\n                        showWelcome && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_5__.motion.div, {\n                            initial: {\n                                opacity: 0,\n                                y: 20\n                            },\n                            animate: {\n                                opacity: 1,\n                                y: 0\n                            },\n                            exit: {\n                                opacity: 0,\n                                y: -20\n                            },\n                            transition: {\n                                duration: 0.5\n                            },\n                            className: \"backdrop-blur-lg bg-white/70 p-8 rounded-2xl shadow-xl border border-white/20 relative text-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                    className: \"text-4xl font-light text-gray-900 mb-4\",\n                                    children: [\n                                        isFirstLogin ? \"Hello\" : \"Welcome Back\",\n                                        \", \",\n                                        username,\n                                        \"!\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                    lineNumber: 170,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-gray-500 text-lg\",\n                                    children: isFirstLogin ? \"We're excited to have you here!\" : \"Great to see you again!\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                    lineNumber: 173,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, \"welcome\", true, {\n                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                            lineNumber: 162,\n                            columnNumber: 13\n                        }, this),\n                        showCalendar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_5__.motion.div, {\n                            initial: {\n                                opacity: 0,\n                                scale: 0.9\n                            },\n                            animate: {\n                                opacity: 1,\n                                scale: 1\n                            },\n                            transition: {\n                                duration: 0.5\n                            },\n                            className: \"backdrop-blur-lg bg-white/70 p-8 rounded-2xl shadow-xl border border-white/20 relative\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center justify-between mb-8\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    className: \"text-2xl font-light text-gray-900\",\n                                                    children: \"Your Study Calendar\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                    lineNumber: 189,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"mt-2\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                        className: \"inline-flex items-center px-4 py-2 bg-black text-white rounded-lg hover:bg-gray-800 transition-colors cursor-pointer\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                                className: \"w-5 h-5 mr-2\",\n                                                                fill: \"none\",\n                                                                stroke: \"currentColor\",\n                                                                viewBox: \"0 0 24 24\",\n                                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                                    strokeLinecap: \"round\",\n                                                                    strokeLinejoin: \"round\",\n                                                                    strokeWidth: 1.5,\n                                                                    d: \"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12\"\n                                                                }, void 0, false, {\n                                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                                    lineNumber: 193,\n                                                                    columnNumber: 25\n                                                                }, this)\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                                lineNumber: 192,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            \"Import Calendar\",\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"file\",\n                                                                accept: \".ics\",\n                                                                onChange: handleFileUpload,\n                                                                className: \"hidden\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                                lineNumber: 196,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                        lineNumber: 191,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                    lineNumber: 190,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                            lineNumber: 188,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex items-center space-x-4\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: handlePreviousMonth,\n                                                    className: \"p-2 hover:bg-gray-100 rounded-lg transition-colors\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                        className: \"w-5 h-5\",\n                                                        fill: \"none\",\n                                                        stroke: \"currentColor\",\n                                                        viewBox: \"0 0 24 24\",\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                            strokeLinecap: \"round\",\n                                                            strokeLinejoin: \"round\",\n                                                            strokeWidth: 1.5,\n                                                            d: \"M15 19l-7-7 7-7\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 211,\n                                                            columnNumber: 23\n                                                        }, this)\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                        lineNumber: 210,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                    lineNumber: 206,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"text-lg font-medium text-gray-900\",\n                                                    children: [\n                                                        MONTHS[currentDate.getMonth()],\n                                                        \" \",\n                                                        currentDate.getFullYear()\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                    lineNumber: 214,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: handleNextMonth,\n                                                    className: \"p-2 hover:bg-gray-100 rounded-lg transition-colors\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                        className: \"w-5 h-5\",\n                                                        fill: \"none\",\n                                                        stroke: \"currentColor\",\n                                                        viewBox: \"0 0 24 24\",\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                            strokeLinecap: \"round\",\n                                                            strokeLinejoin: \"round\",\n                                                            strokeWidth: 1.5,\n                                                            d: \"M9 5l7 7-7 7\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 222,\n                                                            columnNumber: 23\n                                                        }, this)\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                        lineNumber: 221,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                    lineNumber: 217,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                            lineNumber: 205,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                    lineNumber: 187,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"grid grid-cols-7 gap-2\",\n                                    children: [\n                                        DAYS_OF_WEEK.map((day)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"text-sm font-medium text-gray-500 text-center py-2\",\n                                                children: day\n                                            }, day, false, {\n                                                fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                lineNumber: 231,\n                                                columnNumber: 19\n                                            }, this)),\n                                        generateCalendarDays().map((date, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"aspect-square p-2 \".concat(date ? \"cursor-pointer hover:bg-gray-50\" : \"\", \" rounded-lg transition-colors relative\"),\n                                                onClick: ()=>date && setSelectedDate(date),\n                                                children: date && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"w-full h-full flex items-center justify-center text-sm \".concat(isToday(date) ? \"bg-black text-white rounded-lg\" : isSelected(date) ? \"bg-gray-100 font-medium\" : \"\"),\n                                                            children: date.getDate()\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 250,\n                                                            columnNumber: 25\n                                                        }, this),\n                                                        getEventsForDate(date).length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"absolute bottom-1 left-1/2 transform -translate-x-1/2\",\n                                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"w-1 h-1 bg-blue-500 rounded-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                                lineNumber: 263,\n                                                                columnNumber: 29\n                                                            }, this)\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 262,\n                                                            columnNumber: 27\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true)\n                                            }, index, false, {\n                                                fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                lineNumber: 241,\n                                                columnNumber: 19\n                                            }, this))\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                    lineNumber: 228,\n                                    columnNumber: 15\n                                }, this),\n                                selectedDate && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"mt-6 p-4 bg-gray-50 rounded-lg\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"text-lg font-medium text-gray-900 mb-2\",\n                                            children: selectedDate.toLocaleDateString(\"en-US\", {\n                                                weekday: \"long\",\n                                                year: \"numeric\",\n                                                month: \"long\",\n                                                day: \"numeric\"\n                                            })\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                            lineNumber: 274,\n                                            columnNumber: 19\n                                        }, this),\n                                        getEventsForDate(selectedDate).length > 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"space-y-3\",\n                                            children: getEventsForDate(selectedDate).map((event)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"p-3 bg-white rounded-lg shadow-sm\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                            className: \"font-medium text-gray-900\",\n                                                            children: event.title\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 286,\n                                                            columnNumber: 27\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                            className: \"text-sm text-gray-500\",\n                                                            children: [\n                                                                event.start.toLocaleTimeString(),\n                                                                \" - \",\n                                                                event.end.toLocaleTimeString()\n                                                            ]\n                                                        }, void 0, true, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 287,\n                                                            columnNumber: 27\n                                                        }, this),\n                                                        event.description && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                            className: \"text-sm text-gray-600 mt-1\",\n                                                            children: event.description\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                            lineNumber: 291,\n                                                            columnNumber: 29\n                                                        }, this)\n                                                    ]\n                                                }, event.id, true, {\n                                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                                    lineNumber: 285,\n                                                    columnNumber: 25\n                                                }, this))\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                            lineNumber: 283,\n                                            columnNumber: 21\n                                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-gray-500\",\n                                            children: \"No events scheduled for this day\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                            lineNumber: 297,\n                                            columnNumber: 21\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                                    lineNumber: 273,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, \"calendar\", true, {\n                            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                            lineNumber: 180,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n                    lineNumber: 160,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n            lineNumber: 155,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\wooai\\\\OneDrive\\\\Documents\\\\GitHub\\\\SUTDy\\\\app\\\\welcome\\\\page.tsx\",\n        lineNumber: 154,\n        columnNumber: 5\n    }, this);\n}\n_s(WelcomePage, \"8kX8iULUkivppFT5Hl8vV+O6kt4=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useSearchParams\n    ];\n});\n_c = WelcomePage;\nvar _c;\n$RefreshReg$(_c, \"WelcomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC93ZWxjb21lL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDSztBQUNLO0FBQ2xDO0FBRTNCLE1BQU1RLGVBQWU7SUFBQztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFNO0FBQ3RFLE1BQU1DLFNBQVM7SUFDYjtJQUFXO0lBQVk7SUFBUztJQUFTO0lBQU87SUFDaEQ7SUFBUTtJQUFVO0lBQWE7SUFBVztJQUFZO0NBQ3ZEO0FBVWMsU0FBU0M7O0lBQ3RCLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHViwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNXLGNBQWNDLGdCQUFnQixHQUFHWiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNYSxTQUFTViwwREFBU0E7SUFDeEIsTUFBTVcsZUFBZVYsZ0VBQWVBO0lBQ3BDLE1BQU1XLFdBQVdELHlCQUFBQSxtQ0FBQUEsYUFBY0UsR0FBRyxDQUFDO0lBQ25DLE1BQU1DLGVBQWVILENBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY0UsR0FBRyxDQUFDLG1CQUFrQjtJQUV6RCxpQkFBaUI7SUFDakIsTUFBTSxDQUFDRSxhQUFhQyxlQUFlLEdBQUduQiwrQ0FBUUEsQ0FBQyxJQUFJb0I7SUFDbkQsTUFBTSxDQUFDQyxjQUFjQyxnQkFBZ0IsR0FBR3RCLCtDQUFRQSxDQUFjO0lBQzlELE1BQU0sQ0FBQ3VCLFFBQVFDLFVBQVUsR0FBR3hCLCtDQUFRQSxDQUFrQixFQUFFO0lBQ3hELE1BQU0sQ0FBQ3lCLGtCQUFrQkMsb0JBQW9CLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUV6REQsZ0RBQVNBLENBQUM7UUFDUjRCLFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUMsa0JBQWtCQyxPQUFPQyxXQUFXLENBQUNoQixDQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWNpQixPQUFPLE9BQU0sRUFBRTtRQUM5RUosUUFBUUMsR0FBRyxDQUFDLHlCQUF5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NENBQ1A7Ozs7Ozt3Q0FFRGpCLGlCQUFpQjlDLGNBQWM0QyxNQUFNLEdBQUcsa0JBQ3ZDLDhEQUFDeUI7NENBQUlELFdBQVU7c0RBQ1p0QixpQkFBaUI5QyxjQUFjNEIsR0FBRyxDQUFDLENBQUNFLHNCQUNuQyw4REFBQ3VDO29EQUFtQkQsV0FBVTs7c0VBQzVCLDhEQUFDcUM7NERBQUdyQyxXQUFVO3NFQUE2QnRDLE1BQU1JLEtBQUs7Ozs7OztzRUFDdEQsOERBQUM2Qzs0REFBRVgsV0FBVTs7Z0VBQ1Z0QyxNQUFNTSxLQUFLLENBQUNzRSxrQkFBa0I7Z0VBQUc7Z0VBQUk1RSxNQUFNUyxHQUFHLENBQUNtRSxrQkFBa0I7Ozs7Ozs7d0RBRW5FNUUsTUFBTVcsV0FBVyxrQkFDaEIsOERBQUNzQzs0REFBRVgsV0FBVTtzRUFBOEJ0QyxNQUFNVyxXQUFXOzs7Ozs7O21EQU50RFgsTUFBTUUsRUFBRTs7Ozs7Ozs7O2lFQVl0Qiw4REFBQytDOzRDQUFFWCxXQUFVO3NEQUFnQjs7Ozs7Ozs7Ozs7OzsyQkFwSC9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEhsQjtHQTdSd0JqRjs7UUFHUEwsc0RBQVNBO1FBQ0hDLDREQUFlQTs7O0tBSmRJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC93ZWxjb21lL3BhZ2UudHN4PzZiYzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XHJcbmltcG9ydCB7IHVzZVJvdXRlciwgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuaW1wb3J0IElDQUwgZnJvbSAnaWNhbC5qcyc7XHJcblxyXG5jb25zdCBEQVlTX09GX1dFRUsgPSBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddO1xyXG5jb25zdCBNT05USFMgPSBbXHJcbiAgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLFxyXG4gICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcclxuXTtcclxuXHJcbmludGVyZmFjZSBDYWxlbmRhckV2ZW50IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgc3RhcnQ6IERhdGU7XHJcbiAgZW5kOiBEYXRlO1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXZWxjb21lUGFnZSgpIHtcclxuICBjb25zdCBbc2hvd1dlbGNvbWUsIHNldFNob3dXZWxjb21lXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IFtzaG93Q2FsZW5kYXIsIHNldFNob3dDYWxlbmRhcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XHJcbiAgY29uc3QgdXNlcm5hbWUgPSBzZWFyY2hQYXJhbXM/LmdldCgndXNlcm5hbWUnKTtcclxuICBjb25zdCBpc0ZpcnN0TG9naW4gPSBzZWFyY2hQYXJhbXM/LmdldCgnZmlyc3RMb2dpbicpID09PSAndHJ1ZSc7XHJcblxyXG4gIC8vIENhbGVuZGFyIHN0YXRlXHJcbiAgY29uc3QgW2N1cnJlbnREYXRlLCBzZXRDdXJyZW50RGF0ZV0gPSB1c2VTdGF0ZShuZXcgRGF0ZSgpKTtcclxuICBjb25zdCBbc2VsZWN0ZWREYXRlLCBzZXRTZWxlY3RlZERhdGVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtldmVudHMsIHNldEV2ZW50c10gPSB1c2VTdGF0ZTxDYWxlbmRhckV2ZW50W10+KFtdKTtcclxuICBjb25zdCBbc2hvd0V2ZW50RGV0YWlscywgc2V0U2hvd0V2ZW50RGV0YWlsc10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnV2VsY29tZSBwYWdlIG1vdW50ZWQnKTtcclxuICAgIGNvbnNvbGUubG9nKCdTZWFyY2ggcGFyYW1zOicsIE9iamVjdC5mcm9tRW50cmllcyhzZWFyY2hQYXJhbXM/LmVudHJpZXMoKSB8fCBbXSkpO1xyXG4gICAgY29uc29sZS5sb2coJ1VzZXJuYW1lIGZyb20gcGFyYW1zOicsIHVzZXJuYW1lKTtcclxuICAgIFxyXG4gICAgaWYgKCF1c2VybmFtZSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gdXNlcm5hbWUgZm91bmQsIHJlZGlyZWN0aW5nIHRvIGxvZ2luJyk7XHJcbiAgICAgIHJvdXRlci5wdXNoKCcvbG9naW4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZGUgd2VsY29tZSBtZXNzYWdlIGFmdGVyIDMgc2Vjb25kc1xyXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ0hpZGluZyB3ZWxjb21lIG1lc3NhZ2UnKTtcclxuICAgICAgc2V0U2hvd1dlbGNvbWUoZmFsc2UpO1xyXG4gICAgICAvLyBTaG93IGNhbGVuZGFyIGFmdGVyIHdlbGNvbWUgbWVzc2FnZSBkaXNhcHBlYXJzXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTaG93aW5nIGNhbGVuZGFyJyk7XHJcbiAgICAgICAgc2V0U2hvd0NhbGVuZGFyKHRydWUpO1xyXG4gICAgICB9LCA1MDApO1xyXG4gICAgfSwgMzAwMCk7XHJcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICB9LCBbdXNlcm5hbWUsIHJvdXRlciwgc2VhcmNoUGFyYW1zXSk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZUZpbGVVcGxvYWQgPSBhc3luYyAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlcz8uWzBdO1xyXG4gICAgaWYgKCFmaWxlKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZpbGUudGV4dCgpO1xyXG4gICAgICBjb25zdCBqY2FsRGF0YSA9IElDQUwucGFyc2UodGV4dCk7XHJcbiAgICAgIGNvbnN0IGNvbXAgPSBuZXcgSUNBTC5Db21wb25lbnQoamNhbERhdGEpO1xyXG4gICAgICBjb25zdCB2ZXZlbnRzID0gY29tcC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKTtcclxuXHJcbiAgICAgIGNvbnN0IG5ld0V2ZW50czogQ2FsZW5kYXJFdmVudFtdID0gdmV2ZW50cy5tYXAoKHZldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IElDQUwuRXZlbnQodmV2ZW50KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6IGV2ZW50LnVpZCxcclxuICAgICAgICAgIHRpdGxlOiBldmVudC5zdW1tYXJ5LFxyXG4gICAgICAgICAgc3RhcnQ6IGV2ZW50LnN0YXJ0RGF0ZS50b0pTRGF0ZSgpLFxyXG4gICAgICAgICAgZW5kOiBldmVudC5lbmREYXRlLnRvSlNEYXRlKCksXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZXZlbnQuZGVzY3JpcHRpb25cclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNldEV2ZW50cygocHJldkV2ZW50cykgPT4gWy4uLnByZXZFdmVudHMsIC4uLm5ld0V2ZW50c10pO1xyXG4gICAgICBhbGVydChgU3VjY2Vzc2Z1bGx5IGltcG9ydGVkICR7bmV3RXZlbnRzLmxlbmd0aH0gZXZlbnRzIWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyAuaWNzIGZpbGU6JywgZXJyb3IpO1xyXG4gICAgICBhbGVydCgnRXJyb3IgaW1wb3J0aW5nIGNhbGVuZGFyIGZpbGUuIFBsZWFzZSBtYWtlIHN1cmUgaXRcXCdzIGEgdmFsaWQgLmljcyBmaWxlLicpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEV2ZW50c0ZvckRhdGUgPSAoZGF0ZTogRGF0ZSkgPT4ge1xyXG4gICAgcmV0dXJuIGV2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICBjb25zdCBldmVudERhdGUgPSBuZXcgRGF0ZShldmVudC5zdGFydCk7XHJcbiAgICAgIHJldHVybiBldmVudERhdGUuZ2V0RGF0ZSgpID09PSBkYXRlLmdldERhdGUoKSAmJlxyXG4gICAgICAgICAgICAgZXZlbnREYXRlLmdldE1vbnRoKCkgPT09IGRhdGUuZ2V0TW9udGgoKSAmJlxyXG4gICAgICAgICAgICAgZXZlbnREYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldERheXNJbk1vbnRoID0gKGRhdGU6IERhdGUpID0+IHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRGaXJzdERheU9mTW9udGggPSAoZGF0ZTogRGF0ZSkgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKS5nZXREYXkoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVQcmV2aW91c01vbnRoID0gKCkgPT4ge1xyXG4gICAgc2V0Q3VycmVudERhdGUobmV3IERhdGUoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSwgY3VycmVudERhdGUuZ2V0TW9udGgoKSAtIDEpKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVOZXh0TW9udGggPSAoKSA9PiB7XHJcbiAgICBzZXRDdXJyZW50RGF0ZShuZXcgRGF0ZShjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpLCBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMSkpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdlbmVyYXRlQ2FsZW5kYXJEYXlzID0gKCkgPT4ge1xyXG4gICAgY29uc3QgZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aChjdXJyZW50RGF0ZSk7XHJcbiAgICBjb25zdCBmaXJzdERheU9mTW9udGggPSBnZXRGaXJzdERheU9mTW9udGgoY3VycmVudERhdGUpO1xyXG4gICAgY29uc3QgZGF5cyA9IFtdO1xyXG5cclxuICAgIC8vIEFkZCBlbXB0eSBjZWxscyBmb3IgZGF5cyBiZWZvcmUgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGhcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3REYXlPZk1vbnRoOyBpKyspIHtcclxuICAgICAgZGF5cy5wdXNoKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgZGF5cyBvZiB0aGUgbW9udGhcclxuICAgIGZvciAobGV0IGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcclxuICAgICAgZGF5cy5wdXNoKG5ldyBEYXRlKGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCksIGN1cnJlbnREYXRlLmdldE1vbnRoKCksIGRheSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXlzO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGlzVG9kYXkgPSAoZGF0ZTogRGF0ZSkgPT4ge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpID09PSB0b2RheS5nZXREYXRlKCkgJiZcclxuICAgICAgICAgICBkYXRlLmdldE1vbnRoKCkgPT09IHRvZGF5LmdldE1vbnRoKCkgJiZcclxuICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHRvZGF5LmdldEZ1bGxZZWFyKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaXNTZWxlY3RlZCA9IChkYXRlOiBEYXRlKSA9PiB7XHJcbiAgICByZXR1cm4gc2VsZWN0ZWREYXRlICYmXHJcbiAgICAgICAgICAgZGF0ZS5nZXREYXRlKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXREYXRlKCkgJiZcclxuICAgICAgICAgICBkYXRlLmdldE1vbnRoKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpICYmXHJcbiAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcclxuICB9O1xyXG5cclxuICBpZiAoIXVzZXJuYW1lKSB7XHJcbiAgICBjb25zb2xlLmxvZygnUmVuZGVyaW5nIG51bGwgLSBubyB1c2VybmFtZScpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZygnUmVuZGVyaW5nIHdlbGNvbWUgcGFnZSB3aXRoIHVzZXJuYW1lOicsIHVzZXJuYW1lKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxtYWluIGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBiZy1ncmFkaWVudC10by1iciBmcm9tLWJsdWUtNTAgdmlhLXdoaXRlIHRvLXB1cnBsZS01MCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBwLTRcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgbWF4LXctNHhsXCI+XHJcbiAgICAgICAgey8qIEdsYXNzbW9ycGhpYyBiYWNrZ3JvdW5kIGVmZmVjdHMgKi99XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSAtdG9wLTIwIC1sZWZ0LTIwIHctNzIgaC03MiBiZy1wdXJwbGUtMzAwIHJvdW5kZWQtZnVsbCBtaXgtYmxlbmQtbXVsdGlwbHkgZmlsdGVyIGJsdXIteGwgb3BhY2l0eS0zMCBhbmltYXRlLWJsb2JcIj48L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIC1ib3R0b20tMjAgLXJpZ2h0LTIwIHctNzIgaC03MiBiZy1ibHVlLTMwMCByb3VuZGVkLWZ1bGwgbWl4LWJsZW5kLW11bHRpcGx5IGZpbHRlciBibHVyLXhsIG9wYWNpdHktMzAgYW5pbWF0ZS1ibG9iIGFuaW1hdGlvbi1kZWxheS0yMDAwXCI+PC9kaXY+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPEFuaW1hdGVQcmVzZW5jZSBtb2RlPVwid2FpdFwiPlxyXG4gICAgICAgICAge3Nob3dXZWxjb21lICYmIChcclxuICAgICAgICAgICAgPG1vdGlvbi5kaXZcclxuICAgICAgICAgICAgICBrZXk9XCJ3ZWxjb21lXCJcclxuICAgICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHk6IDIwIH19XHJcbiAgICAgICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxLCB5OiAwIH19XHJcbiAgICAgICAgICAgICAgZXhpdD17eyBvcGFjaXR5OiAwLCB5OiAtMjAgfX1cclxuICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjUgfX1cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiYWNrZHJvcC1ibHVyLWxnIGJnLXdoaXRlLzcwIHAtOCByb3VuZGVkLTJ4bCBzaGFkb3cteGwgYm9yZGVyIGJvcmRlci13aGl0ZS8yMCByZWxhdGl2ZSB0ZXh0LWNlbnRlclwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC00eGwgZm9udC1saWdodCB0ZXh0LWdyYXktOTAwIG1iLTRcIj5cclxuICAgICAgICAgICAgICAgIHtpc0ZpcnN0TG9naW4gPyAnSGVsbG8nIDogJ1dlbGNvbWUgQmFjayd9LCB7dXNlcm5hbWV9IVxyXG4gICAgICAgICAgICAgIDwvaDE+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMCB0ZXh0LWxnXCI+XHJcbiAgICAgICAgICAgICAgICB7aXNGaXJzdExvZ2luID8gJ1dlXFwncmUgZXhjaXRlZCB0byBoYXZlIHlvdSBoZXJlIScgOiAnR3JlYXQgdG8gc2VlIHlvdSBhZ2FpbiEnfVxyXG4gICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgPC9tb3Rpb24uZGl2PlxyXG4gICAgICAgICAgKX1cclxuXHJcbiAgICAgICAgICB7c2hvd0NhbGVuZGFyICYmIChcclxuICAgICAgICAgICAgPG1vdGlvbi5kaXZcclxuICAgICAgICAgICAgICBrZXk9XCJjYWxlbmRhclwiXHJcbiAgICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCBzY2FsZTogMC45IH19XHJcbiAgICAgICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxLCBzY2FsZTogMSB9fVxyXG4gICAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuNSB9fVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJhY2tkcm9wLWJsdXItbGcgYmctd2hpdGUvNzAgcC04IHJvdW5kZWQtMnhsIHNoYWRvdy14bCBib3JkZXIgYm9yZGVyLXdoaXRlLzIwIHJlbGF0aXZlXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIG1iLThcIj5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWxpZ2h0IHRleHQtZ3JheS05MDBcIj5Zb3VyIFN0dWR5IENhbGVuZGFyPC9oMj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBweC00IHB5LTIgYmctYmxhY2sgdGV4dC13aGl0ZSByb3VuZGVkLWxnIGhvdmVyOmJnLWdyYXktODAwIHRyYW5zaXRpb24tY29sb3JzIGN1cnNvci1wb2ludGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cInctNSBoLTUgbXItMlwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9ezEuNX0gZD1cIk00IDE2djFhMyAzIDAgMDAzIDNoMTBhMyAzIDAgMDAzLTN2LTFtLTQtOGwtNC00bTAgMEw4IDhtNC00djEyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgSW1wb3J0IENhbGVuZGFyXHJcbiAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ9XCIuaWNzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUZpbGVVcGxvYWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImhpZGRlblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtNFwiPlxyXG4gICAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUHJldmlvdXNNb250aH1cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgaG92ZXI6YmctZ3JheS0xMDAgcm91bmRlZC1sZyB0cmFuc2l0aW9uLWNvbG9yc1wiXHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cInctNSBoLTVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD17MS41fSBkPVwiTTE1IDE5bC03LTcgNy03XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtNT05USFNbY3VycmVudERhdGUuZ2V0TW9udGgoKV19IHtjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpfVxyXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVOZXh0TW9udGh9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGhvdmVyOmJnLWdyYXktMTAwIHJvdW5kZWQtbGcgdHJhbnNpdGlvbi1jb2xvcnNcIlxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJ3LTUgaC01XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9ezEuNX0gZD1cIk05IDVsNyA3LTcgN1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtNyBnYXAtMlwiPlxyXG4gICAgICAgICAgICAgICAgey8qIERheSBoZWFkZXJzICovfVxyXG4gICAgICAgICAgICAgICAge0RBWVNfT0ZfV0VFSy5tYXAoKGRheSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAga2V5PXtkYXl9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIHRleHQtY2VudGVyIHB5LTJcIlxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2RheX1cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApKX1cclxuXHJcbiAgICAgICAgICAgICAgICB7LyogQ2FsZW5kYXIgZGF5cyAqL31cclxuICAgICAgICAgICAgICAgIHtnZW5lcmF0ZUNhbGVuZGFyRGF5cygpLm1hcCgoZGF0ZSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgYXNwZWN0LXNxdWFyZSBwLTIgJHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPyAnY3Vyc29yLXBvaW50ZXIgaG92ZXI6YmctZ3JheS01MCcgOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0gcm91bmRlZC1sZyB0cmFuc2l0aW9uLWNvbG9ycyByZWxhdGl2ZWB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZGF0ZSAmJiBzZXRTZWxlY3RlZERhdGUoZGF0ZSl9XHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7ZGF0ZSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdy1mdWxsIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LXNtICR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RvZGF5KGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2JnLWJsYWNrIHRleHQtd2hpdGUgcm91bmRlZC1sZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc1NlbGVjdGVkKGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2JnLWdyYXktMTAwIGZvbnQtbWVkaXVtJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGF0ZS5nZXREYXRlKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7Z2V0RXZlbnRzRm9yRGF0ZShkYXRlKS5sZW5ndGggPiAwICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGJvdHRvbS0xIGxlZnQtMS8yIHRyYW5zZm9ybSAtdHJhbnNsYXRlLXgtMS8yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMSBoLTEgYmctYmx1ZS01MDAgcm91bmRlZC1mdWxsXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICB7c2VsZWN0ZWREYXRlICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNiBwLTQgYmctZ3JheS01MCByb3VuZGVkLWxnXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtbWVkaXVtIHRleHQtZ3JheS05MDAgbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHdlZWtkYXk6ICdsb25nJyxcclxuICAgICAgICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcclxuICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiAnbG9uZycsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXk6ICdudW1lcmljJyxcclxuICAgICAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgICAgPC9oMz5cclxuICAgICAgICAgICAgICAgICAge2dldEV2ZW50c0ZvckRhdGUoc2VsZWN0ZWREYXRlKS5sZW5ndGggPiAwID8gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0zXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7Z2V0RXZlbnRzRm9yRGF0ZShzZWxlY3RlZERhdGUpLm1hcCgoZXZlbnQpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e2V2ZW50LmlkfSBjbGFzc05hbWU9XCJwLTMgYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3ctc21cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMFwiPntldmVudC50aXRsZX08L2g0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTUwMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2V2ZW50LnN0YXJ0LnRvTG9jYWxlVGltZVN0cmluZygpfSAtIHtldmVudC5lbmQudG9Mb2NhbGVUaW1lU3RyaW5nKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtldmVudC5kZXNjcmlwdGlvbiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDAgbXQtMVwiPntldmVudC5kZXNjcmlwdGlvbn08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gZXZlbnRzIHNjaGVkdWxlZCBmb3IgdGhpcyBkYXk8L3A+XHJcbiAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICA8L21vdGlvbi5kaXY+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvQW5pbWF0ZVByZXNlbmNlPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvbWFpbj5cclxuICApO1xyXG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwibW90aW9uIiwiQW5pbWF0ZVByZXNlbmNlIiwidXNlUm91dGVyIiwidXNlU2VhcmNoUGFyYW1zIiwiSUNBTCIsIkRBWVNfT0ZfV0VFSyIsIk1PTlRIUyIsIldlbGNvbWVQYWdlIiwic2hvd1dlbGNvbWUiLCJzZXRTaG93V2VsY29tZSIsInNob3dDYWxlbmRhciIsInNldFNob3dDYWxlbmRhciIsInJvdXRlciIsInNlYXJjaFBhcmFtcyIsInVzZXJuYW1lIiwiZ2V0IiwiaXNGaXJzdExvZ2luIiwiY3VycmVudERhdGUiLCJzZXRDdXJyZW50RGF0ZSIsIkRhdGUiLCJzZWxlY3RlZERhdGUiLCJzZXRTZWxlY3RlZERhdGUiLCJldmVudHMiLCJzZXRFdmVudHMiLCJzaG93RXZlbnREZXRhaWxzIiwic2V0U2hvd0V2ZW50RGV0YWlscyIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJwdXNoIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlRmlsZVVwbG9hZCIsImUiLCJmaWxlIiwidGFyZ2V0IiwiZmlsZXMiLCJ0ZXh0IiwiamNhbERhdGEiLCJwYXJzZSIsImNvbXAiLCJDb21wb25lbnQiLCJ2ZXZlbnRzIiwiZ2V0QWxsU3ViY29tcG9uZW50cyIsIm5ld0V2ZW50cyIsIm1hcCIsInZldmVudCIsImV2ZW50IiwiRXZlbnQiLCJpZCIsInVpZCIsInRpdGxlIiwic3VtbWFyeSIsInN0YXJ0Iiwic3RhcnREYXRlIiwidG9KU0RhdGUiLCJlbmQiLCJlbmREYXRlIiwiZGVzY3JpcHRpb24iLCJwcmV2RXZlbnRzIiwiYWxlcnQiLCJsZW5ndGgiLCJlcnJvciIsImdldEV2ZW50c0ZvckRhdGUiLCJkYXRlIiwiZmlsdGVyIiwiZXZlbnREYXRlIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwiZ2V0RnVsbFllYXIiLCJnZXREYXlzSW5Nb250aCIsImdldEZpcnN0RGF5T2ZNb250aCIsImdldERheSIsImhhbmRsZVByZXZpb3VzTW9udGgiLCJoYW5kbGVOZXh0TW9udGgiLCJnZW5lcmF0ZUNhbGVuZGFyRGF5cyIsImRheXNJbk1vbnRoIiwiZmlyc3REYXlPZk1vbnRoIiwiZGF5cyIsImkiLCJkYXkiLCJpc1RvZGF5IiwidG9kYXkiLCJpc1NlbGVjdGVkIiwibWFpbiIsImNsYXNzTmFtZSIsImRpdiIsIm1vZGUiLCJpbml0aWFsIiwib3BhY2l0eSIsInkiLCJhbmltYXRlIiwiZXhpdCIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImgxIiwicCIsInNjYWxlIiwiaDIiLCJsYWJlbCIsInN2ZyIsImZpbGwiLCJzdHJva2UiLCJ2aWV3Qm94IiwicGF0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCIsImlucHV0IiwidHlwZSIsImFjY2VwdCIsIm9uQ2hhbmdlIiwiYnV0dG9uIiwib25DbGljayIsInNwYW4iLCJpbmRleCIsImgzIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwid2Vla2RheSIsInllYXIiLCJtb250aCIsImg0IiwidG9Mb2NhbGVUaW1lU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/welcome/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_apply_descriptor_get; },\n/* harmony export */   _class_apply_descriptor_get: function() { return /* binding */ _class_apply_descriptor_get; }\n/* harmony export */ });\nfunction _class_apply_descriptor_get(receiver, descriptor) {\n    if (descriptor.get) return descriptor.get.call(receiver);\n    return descriptor.value;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX2dldC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLDRCQUE0QkMsUUFBUSxFQUFFQyxVQUFVO0lBQzVELElBQUlBLFdBQVdDLEdBQUcsRUFBRSxPQUFPRCxXQUFXQyxHQUFHLENBQUNDLElBQUksQ0FBQ0g7SUFFL0MsT0FBT0MsV0FBV0csS0FBSztBQUMzQjtBQUM0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9nZXQuanM/NTFlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0KHJlY2VpdmVyLCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbn1cbmV4cG9ydCB7IF9jbGFzc19hcHBseV9kZXNjcmlwdG9yX2dldCBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0IiwicmVjZWl2ZXIiLCJkZXNjcmlwdG9yIiwiZ2V0IiwiY2FsbCIsInZhbHVlIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_apply_descriptor_set; },\n/* harmony export */   _class_apply_descriptor_set: function() { return /* binding */ _class_apply_descriptor_set; }\n/* harmony export */ });\nfunction _class_apply_descriptor_set(receiver, descriptor, value) {\n    if (descriptor.set) descriptor.set.call(receiver, value);\n    else {\n        if (!descriptor.writable) {\n            // This should only throw in strict mode, but class bodies are\n            // always strict and private fields can only be used inside\n            // class bodies.\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        descriptor.value = value;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLFNBQVNBLDRCQUE0QkMsUUFBUSxFQUFFQyxVQUFVLEVBQUVDLEtBQUs7SUFDbkUsSUFBSUQsV0FBV0UsR0FBRyxFQUFFRixXQUFXRSxHQUFHLENBQUNDLElBQUksQ0FBQ0osVUFBVUU7U0FDN0M7UUFDRCxJQUFJLENBQUNELFdBQVdJLFFBQVEsRUFBRTtZQUN0Qiw4REFBOEQ7WUFDOUQsMkRBQTJEO1lBQzNELGdCQUFnQjtZQUNoQixNQUFNLElBQUlDLFVBQVU7UUFDeEI7UUFDQUwsV0FBV0MsS0FBSyxHQUFHQTtJQUN2QjtBQUNKO0FBQzRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19hcHBseV9kZXNjcmlwdG9yX3NldC5qcz84MmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQocmVjZWl2ZXIsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSBkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSB0aHJvdyBpbiBzdHJpY3QgbW9kZSwgYnV0IGNsYXNzIGJvZGllcyBhcmVcbiAgICAgICAgICAgIC8vIGFsd2F5cyBzdHJpY3QgYW5kIHByaXZhdGUgZmllbGRzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlXG4gICAgICAgICAgICAvLyBjbGFzcyBib2RpZXMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCByZWFkIG9ubHkgcHJpdmF0ZSBmaWVsZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IHsgX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3Jfc2V0IGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQiLCJyZWNlaXZlciIsImRlc2NyaXB0b3IiLCJ2YWx1ZSIsInNldCIsImNhbGwiLCJ3cml0YWJsZSIsIlR5cGVFcnJvciIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_check_private_static_access.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_check_private_static_access; },\n/* harmony export */   _class_check_private_static_access: function() { return /* binding */ _class_check_private_static_access; }\n/* harmony export */ });\nfunction _class_check_private_static_access(receiver, classConstructor) {\n    if (receiver !== classConstructor) throw new TypeError(\"Private static access of wrong provenance\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19hY2Nlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQ0FBbUNDLFFBQVEsRUFBRUMsZ0JBQWdCO0lBQ3pFLElBQUlELGFBQWFDLGtCQUFrQixNQUFNLElBQUlDLFVBQVU7QUFDM0Q7QUFDbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2Vzcy5qcz8wNTMzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzKHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yKSB7XG4gICAgaWYgKHJlY2VpdmVyICE9PSBjbGFzc0NvbnN0cnVjdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBzdGF0aWMgYWNjZXNzIG9mIHdyb25nIHByb3ZlbmFuY2VcIik7XG59XG5leHBvcnQgeyBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzIGFzIF8gfTtcbiJdLCJuYW1lcyI6WyJfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzIiwicmVjZWl2ZXIiLCJjbGFzc0NvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_field_descriptor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_check_private_static_field_descriptor.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_check_private_static_field_descriptor; },\n/* harmony export */   _class_check_private_static_field_descriptor: function() { return /* binding */ _class_check_private_static_field_descriptor; }\n/* harmony export */ });\nfunction _class_check_private_static_field_descriptor(descriptor, action) {\n    if (descriptor === undefined) {\n        throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\");\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19maWVsZF9kZXNjcmlwdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sU0FBU0EsNkNBQTZDQyxVQUFVLEVBQUVDLE1BQU07SUFDM0UsSUFBSUQsZUFBZUUsV0FBVztRQUMxQixNQUFNLElBQUlDLFVBQVUsa0JBQWtCRixTQUFTO0lBQ25EO0FBQ0o7QUFDNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2ZpZWxkX2Rlc2NyaXB0b3IuanM/YWM1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2ZpZWxkX2Rlc2NyaXB0b3IoZGVzY3JpcHRvciwgYWN0aW9uKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIFwiICsgYWN0aW9uICsgXCIgcHJpdmF0ZSBzdGF0aWMgZmllbGQgYmVmb3JlIGl0cyBkZWNsYXJhdGlvblwiKTtcbiAgICB9XG59XG5leHBvcnQgeyBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfZmllbGRfZGVzY3JpcHRvciBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2ZpZWxkX2Rlc2NyaXB0b3IiLCJkZXNjcmlwdG9yIiwiYWN0aW9uIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_field_descriptor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_field_spec_get.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_static_private_field_spec_get.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_static_private_field_spec_get; },\n/* harmony export */   _class_static_private_field_spec_get: function() { return /* binding */ _class_static_private_field_spec_get; }\n/* harmony export */ });\n/* harmony import */ var _class_apply_descriptor_get_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_class_apply_descriptor_get.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js\");\n/* harmony import */ var _class_check_private_static_access_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_class_check_private_static_access.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js\");\n/* harmony import */ var _class_check_private_static_field_descriptor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_class_check_private_static_field_descriptor.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_field_descriptor.js\");\n\n\n\nfunction _class_static_private_field_spec_get(receiver, classConstructor, descriptor) {\n    (0,_class_check_private_static_access_js__WEBPACK_IMPORTED_MODULE_0__._class_check_private_static_access)(receiver, classConstructor);\n    (0,_class_check_private_static_field_descriptor_js__WEBPACK_IMPORTED_MODULE_1__._class_check_private_static_field_descriptor)(descriptor, \"get\");\n    return (0,_class_apply_descriptor_get_js__WEBPACK_IMPORTED_MODULE_2__._class_apply_descriptor_get)(receiver, descriptor);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19zdGF0aWNfcHJpdmF0ZV9maWVsZF9zcGVjX2dldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUNjO0FBQ29CO0FBRTFHLFNBQVNHLHFDQUFxQ0MsUUFBUSxFQUFFQyxnQkFBZ0IsRUFBRUMsVUFBVTtJQUN2RkwseUdBQWtDQSxDQUFDRyxVQUFVQztJQUM3Q0gsNkhBQTRDQSxDQUFDSSxZQUFZO0lBRXpELE9BQU9OLDJGQUEyQkEsQ0FBQ0ksVUFBVUU7QUFDakQ7QUFDcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzd2MvaGVscGVycy9lc20vX2NsYXNzX3N0YXRpY19wcml2YXRlX2ZpZWxkX3NwZWNfZ2V0LmpzPzg0ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0IH0gZnJvbSBcIi4vX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0LmpzXCI7XG5pbXBvcnQgeyBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzIH0gZnJvbSBcIi4vX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2Vzcy5qc1wiO1xuaW1wb3J0IHsgX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2ZpZWxkX2Rlc2NyaXB0b3IgfSBmcm9tIFwiLi9fY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfZmllbGRfZGVzY3JpcHRvci5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gX2NsYXNzX3N0YXRpY19wcml2YXRlX2ZpZWxkX3NwZWNfZ2V0KHJlY2VpdmVyLCBjbGFzc0NvbnN0cnVjdG9yLCBkZXNjcmlwdG9yKSB7XG4gICAgX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2VzcyhyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3Rvcik7XG4gICAgX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2ZpZWxkX2Rlc2NyaXB0b3IoZGVzY3JpcHRvciwgXCJnZXRcIik7XG5cbiAgICByZXR1cm4gX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0KHJlY2VpdmVyLCBkZXNjcmlwdG9yKTtcbn1cbmV4cG9ydCB7IF9jbGFzc19zdGF0aWNfcHJpdmF0ZV9maWVsZF9zcGVjX2dldCBhcyBfIH07XG4iXSwibmFtZXMiOlsiX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3JfZ2V0IiwiX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2VzcyIsIl9jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19maWVsZF9kZXNjcmlwdG9yIiwiX2NsYXNzX3N0YXRpY19wcml2YXRlX2ZpZWxkX3NwZWNfZ2V0IiwicmVjZWl2ZXIiLCJjbGFzc0NvbnN0cnVjdG9yIiwiZGVzY3JpcHRvciIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_field_spec_get.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_field_spec_set.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@swc/helpers/esm/_class_static_private_field_spec_set.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: function() { return /* binding */ _class_static_private_field_spec_set; },\n/* harmony export */   _class_static_private_field_spec_set: function() { return /* binding */ _class_static_private_field_spec_set; }\n/* harmony export */ });\n/* harmony import */ var _class_apply_descriptor_set_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_class_apply_descriptor_set.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js\");\n/* harmony import */ var _class_check_private_static_access_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_class_check_private_static_access.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_access.js\");\n/* harmony import */ var _class_check_private_static_field_descriptor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_class_check_private_static_field_descriptor.js */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_check_private_static_field_descriptor.js\");\n\n\n\nfunction _class_static_private_field_spec_set(receiver, classConstructor, descriptor, value) {\n    (0,_class_check_private_static_access_js__WEBPACK_IMPORTED_MODULE_0__._class_check_private_static_access)(receiver, classConstructor);\n    (0,_class_check_private_static_field_descriptor_js__WEBPACK_IMPORTED_MODULE_1__._class_check_private_static_field_descriptor)(descriptor, \"set\");\n    (0,_class_apply_descriptor_set_js__WEBPACK_IMPORTED_MODULE_2__._class_apply_descriptor_set)(receiver, descriptor, value);\n    return value;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3djL2hlbHBlcnMvZXNtL19jbGFzc19zdGF0aWNfcHJpdmF0ZV9maWVsZF9zcGVjX3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUNjO0FBQ29CO0FBRTFHLFNBQVNHLHFDQUFxQ0MsUUFBUSxFQUFFQyxnQkFBZ0IsRUFBRUMsVUFBVSxFQUFFQyxLQUFLO0lBQzlGTix5R0FBa0NBLENBQUNHLFVBQVVDO0lBQzdDSCw2SEFBNENBLENBQUNJLFlBQVk7SUFDekROLDJGQUEyQkEsQ0FBQ0ksVUFBVUUsWUFBWUM7SUFFbEQsT0FBT0E7QUFDWDtBQUNxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN3Yy9oZWxwZXJzL2VzbS9fY2xhc3Nfc3RhdGljX3ByaXZhdGVfZmllbGRfc3BlY19zZXQuanM/MmYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQgfSBmcm9tIFwiLi9fY2xhc3NfYXBwbHlfZGVzY3JpcHRvcl9zZXQuanNcIjtcbmltcG9ydCB7IF9jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19hY2Nlc3MgfSBmcm9tIFwiLi9fY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfYWNjZXNzLmpzXCI7XG5pbXBvcnQgeyBfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfZmllbGRfZGVzY3JpcHRvciB9IGZyb20gXCIuL19jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19maWVsZF9kZXNjcmlwdG9yLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBfY2xhc3Nfc3RhdGljX3ByaXZhdGVfZmllbGRfc3BlY19zZXQocmVjZWl2ZXIsIGNsYXNzQ29uc3RydWN0b3IsIGRlc2NyaXB0b3IsIHZhbHVlKSB7XG4gICAgX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2FjY2VzcyhyZWNlaXZlciwgY2xhc3NDb25zdHJ1Y3Rvcik7XG4gICAgX2NsYXNzX2NoZWNrX3ByaXZhdGVfc3RhdGljX2ZpZWxkX2Rlc2NyaXB0b3IoZGVzY3JpcHRvciwgXCJzZXRcIik7XG4gICAgX2NsYXNzX2FwcGx5X2Rlc2NyaXB0b3Jfc2V0KHJlY2VpdmVyLCBkZXNjcmlwdG9yLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgeyBfY2xhc3Nfc3RhdGljX3ByaXZhdGVfZmllbGRfc3BlY19zZXQgYXMgXyB9O1xuIl0sIm5hbWVzIjpbIl9jbGFzc19hcHBseV9kZXNjcmlwdG9yX3NldCIsIl9jbGFzc19jaGVja19wcml2YXRlX3N0YXRpY19hY2Nlc3MiLCJfY2xhc3NfY2hlY2tfcHJpdmF0ZV9zdGF0aWNfZmllbGRfZGVzY3JpcHRvciIsIl9jbGFzc19zdGF0aWNfcHJpdmF0ZV9maWVsZF9zcGVjX3NldCIsInJlY2VpdmVyIiwiY2xhc3NDb25zdHJ1Y3RvciIsImRlc2NyaXB0b3IiLCJ2YWx1ZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_field_spec_set.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ical.js/dist/ical.js":
/*!*******************************************!*\
  !*** ./node_modules/ical.js/dist/ical.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ICALmodule; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_class_static_private_field_spec_get */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_field_spec_get.js\");\n/* harmony import */ var _swc_helpers_class_static_private_field_spec_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_class_static_private_field_spec_set */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_static_private_field_spec_set.js\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Represents the BINARY value type, which contains extra methods for encoding and decoding.\n *\n * @memberof ICAL\n */ \n\nclass Binary {\n    /**\n   * Creates a binary value from the given string.\n   *\n   * @param {String} aString        The binary value string\n   * @return {Binary}               The binary value instance\n   */ static fromString(aString) {\n        return new Binary(aString);\n    }\n    /**\n   * Base64 decode the current value\n   *\n   * @return {String}         The base64-decoded value\n   */ decodeValue() {\n        return this._b64_decode(this.value);\n    }\n    /**\n   * Encodes the passed parameter with base64 and sets the internal\n   * value to the result.\n   *\n   * @param {String} aValue      The raw binary value to encode\n   */ setEncodedValue(aValue) {\n        this.value = this._b64_encode(aValue);\n    }\n    _b64_encode(data) {\n        // http://kevin.vanzonneveld.net\n        // +   original by: Tyler Akins (http://rumkin.com)\n        // +   improved by: Bayron Guevara\n        // +   improved by: Thunder.m\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +   bugfixed by: Pellentesque Malesuada\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +   improved by: Rafa Kukawski (http://kukawski.pl)\n        // *     example 1: base64_encode('Kevin van Zonneveld');\n        // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n        // mozilla has this native\n        // - but breaks in 2.0.0.12!\n        //if (typeof this.window['atob'] == 'function') {\n        //    return atob(data);\n        //}\n        let b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = \"\", tmp_arr = [];\n        if (!data) {\n            return data;\n        }\n        do {\n            o1 = data.charCodeAt(i++);\n            o2 = data.charCodeAt(i++);\n            o3 = data.charCodeAt(i++);\n            bits = o1 << 16 | o2 << 8 | o3;\n            h1 = bits >> 18 & 0x3f;\n            h2 = bits >> 12 & 0x3f;\n            h3 = bits >> 6 & 0x3f;\n            h4 = bits & 0x3f;\n            // use hexets to index into b64, and append result to encoded string\n            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n        }while (i < data.length);\n        enc = tmp_arr.join(\"\");\n        let r = data.length % 3;\n        return (r ? enc.slice(0, r - 3) : enc) + \"===\".slice(r || 3);\n    }\n    _b64_decode(data) {\n        // http://kevin.vanzonneveld.net\n        // +   original by: Tyler Akins (http://rumkin.com)\n        // +   improved by: Thunder.m\n        // +      input by: Aman Gupta\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +   bugfixed by: Onno Marsman\n        // +   bugfixed by: Pellentesque Malesuada\n        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // +      input by: Brett Zamir (http://brett-zamir.me)\n        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n        // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n        // *     returns 1: 'Kevin van Zonneveld'\n        // mozilla has this native\n        // - but breaks in 2.0.0.12!\n        //if (typeof this.window['btoa'] == 'function') {\n        //    return btoa(data);\n        //}\n        let b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = \"\", tmp_arr = [];\n        if (!data) {\n            return data;\n        }\n        data += \"\";\n        do {\n            h1 = b64.indexOf(data.charAt(i++));\n            h2 = b64.indexOf(data.charAt(i++));\n            h3 = b64.indexOf(data.charAt(i++));\n            h4 = b64.indexOf(data.charAt(i++));\n            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n            o1 = bits >> 16 & 0xff;\n            o2 = bits >> 8 & 0xff;\n            o3 = bits & 0xff;\n            if (h3 == 64) {\n                tmp_arr[ac++] = String.fromCharCode(o1);\n            } else if (h4 == 64) {\n                tmp_arr[ac++] = String.fromCharCode(o1, o2);\n            } else {\n                tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n            }\n        }while (i < data.length);\n        dec = tmp_arr.join(\"\");\n        return dec;\n    }\n    /**\n   * The string representation of this value\n   * @return {String}\n   */ toString() {\n        return this.value;\n    }\n    /**\n   * Creates a new ICAL.Binary instance\n   *\n   * @param {String} aValue     The binary data for this value\n   */ constructor(aValue){\n        /**\n   * The type name, to be used in the jCal object.\n   * @default \"binary\"\n   * @constant\n   */ this.icaltype = \"binary\";\n        this.value = aValue;\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ const DURATION_LETTERS = /([PDWHMTS]{1,1})/;\nconst DATA_PROPS_TO_COPY = [\n    \"weeks\",\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"isNegative\"\n];\n/**\n * This class represents the \"duration\" value type, with various calculation\n * and manipulation methods.\n *\n * @memberof ICAL\n */ class Duration {\n    /**\n   * Returns a new ICAL.Duration instance from the passed seconds value.\n   *\n   * @param {Number} aSeconds       The seconds to create the instance from\n   * @return {Duration}             The newly created duration instance\n   */ static fromSeconds(aSeconds) {\n        return new Duration().fromSeconds(aSeconds);\n    }\n    /**\n   * Checks if the given string is an iCalendar duration value.\n   *\n   * @param {String} value      The raw ical value\n   * @return {Boolean}          True, if the given value is of the\n   *                              duration ical type\n   */ static isValueString(string) {\n        return string[0] === \"P\" || string[1] === \"P\";\n    }\n    /**\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\n   *\n   * @param {String} aStr       The string to parse\n   * @return {Duration}         The created duration instance\n   */ static fromString(aStr) {\n        let pos = 0;\n        let dict = Object.create(null);\n        let chunks = 0;\n        while((pos = aStr.search(DURATION_LETTERS)) !== -1){\n            let type = aStr[pos];\n            let numeric = aStr.slice(0, Math.max(0, pos));\n            aStr = aStr.slice(pos + 1);\n            chunks += parseDurationChunk(type, numeric, dict);\n        }\n        if (chunks < 2) {\n            // There must be at least a chunk with \"P\" and some unit chunk\n            throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n        }\n        return new Duration(dict);\n    }\n    /**\n   * Creates a new ICAL.Duration instance from the given data object.\n   *\n   * @param {Object} aData                An object with members of the duration\n   * @param {Number=} aData.weeks         Duration in weeks\n   * @param {Number=} aData.days          Duration in days\n   * @param {Number=} aData.hours         Duration in hours\n   * @param {Number=} aData.minutes       Duration in minutes\n   * @param {Number=} aData.seconds       Duration in seconds\n   * @param {Boolean=} aData.isNegative   If true, the duration is negative\n   * @return {Duration}                   The createad duration instance\n   */ static fromData(aData) {\n        return new Duration(aData);\n    }\n    /**\n   * Returns a clone of the duration object.\n   *\n   * @return {Duration}      The cloned object\n   */ clone() {\n        return Duration.fromData(this);\n    }\n    /**\n   * The duration value expressed as a number of seconds.\n   *\n   * @return {Number}             The duration value in seconds\n   */ toSeconds() {\n        let seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n        return this.isNegative ? -seconds : seconds;\n    }\n    /**\n   * Reads the passed seconds value into this duration object. Afterwards,\n   * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\n   * accordingly.\n   *\n   * @param {Number} aSeconds     The duration value in seconds\n   * @return {Duration}           Returns this instance\n   */ fromSeconds(aSeconds) {\n        let secs = Math.abs(aSeconds);\n        this.isNegative = aSeconds < 0;\n        this.days = trunc(secs / 86400);\n        // If we have a flat number of weeks, use them.\n        if (this.days % 7 == 0) {\n            this.weeks = this.days / 7;\n            this.days = 0;\n        } else {\n            this.weeks = 0;\n        }\n        secs -= (this.days + 7 * this.weeks) * 86400;\n        this.hours = trunc(secs / 3600);\n        secs -= this.hours * 3600;\n        this.minutes = trunc(secs / 60);\n        secs -= this.minutes * 60;\n        this.seconds = secs;\n        return this;\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} aData                An object with members of the duration\n   * @param {Number=} aData.weeks         Duration in weeks\n   * @param {Number=} aData.days          Duration in days\n   * @param {Number=} aData.hours         Duration in hours\n   * @param {Number=} aData.minutes       Duration in minutes\n   * @param {Number=} aData.seconds       Duration in seconds\n   * @param {Boolean=} aData.isNegative   If true, the duration is negative\n   */ fromData(aData) {\n        for (let prop of DATA_PROPS_TO_COPY){\n            if (aData && prop in aData) {\n                this[prop] = aData[prop];\n            } else {\n                this[prop] = 0;\n            }\n        }\n    }\n    /**\n   * Resets the duration instance to the default values, i.e. PT0S\n   */ reset() {\n        this.isNegative = false;\n        this.weeks = 0;\n        this.days = 0;\n        this.hours = 0;\n        this.minutes = 0;\n        this.seconds = 0;\n    }\n    /**\n   * Compares the duration instance with another one.\n   *\n   * @param {Duration} aOther             The instance to compare with\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compare(aOther) {\n        let thisSeconds = this.toSeconds();\n        let otherSeconds = aOther.toSeconds();\n        return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    }\n    /**\n   * Normalizes the duration instance. For example, a duration with a value\n   * of 61 seconds will be normalized to 1 minute and 1 second.\n   */ normalize() {\n        this.fromSeconds(this.toSeconds());\n    }\n    /**\n   * The string representation of this duration.\n   * @return {String}\n   */ toString() {\n        if (this.toSeconds() == 0) {\n            return \"PT0S\";\n        } else {\n            let str = \"\";\n            if (this.isNegative) str += \"-\";\n            str += \"P\";\n            if (this.weeks) str += this.weeks + \"W\";\n            if (this.days) str += this.days + \"D\";\n            if (this.hours || this.minutes || this.seconds) {\n                str += \"T\";\n                if (this.hours) str += this.hours + \"H\";\n                if (this.minutes) str += this.minutes + \"M\";\n                if (this.seconds) str += this.seconds + \"S\";\n            }\n            return str;\n        }\n    }\n    /**\n   * The iCalendar string representation of this duration.\n   * @return {String}\n   */ toICALString() {\n        return this.toString();\n    }\n    /**\n   * Creates a new ICAL.Duration instance.\n   *\n   * @param {Object} data                 An object with members of the duration\n   * @param {Number=} data.weeks          Duration in weeks\n   * @param {Number=} data.days           Duration in days\n   * @param {Number=} data.hours          Duration in hours\n   * @param {Number=} data.minutes        Duration in minutes\n   * @param {Number=} data.seconds        Duration in seconds\n   * @param {Boolean=} data.isNegative    If true, the duration is negative\n   */ constructor(data){\n        /**\n   * The weeks in this duration\n   * @type {Number}\n   * @default 0\n   */ this.weeks = 0;\n        /**\n   * The days in this duration\n   * @type {Number}\n   * @default 0\n   */ this.days = 0;\n        /**\n   * The days in this duration\n   * @type {Number}\n   * @default 0\n   */ this.hours = 0;\n        /**\n   * The minutes in this duration\n   * @type {Number}\n   * @default 0\n   */ this.minutes = 0;\n        /**\n   * The seconds in this duration\n   * @type {Number}\n   * @default 0\n   */ this.seconds = 0;\n        /**\n   * The seconds in this duration\n   * @type {Boolean}\n   * @default false\n   */ this.isNegative = false;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icalduration\"\n   */ this.icalclass = \"icalduration\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"duration\"\n   */ this.icaltype = \"duration\";\n        this.wrappedJSObject = this;\n        this.fromData(data);\n    }\n}\n/**\n * Internal helper function to handle a chunk of a duration.\n *\n * @private\n * @param {String} letter type of duration chunk\n * @param {String} number numeric value or -/+\n * @param {Object} dict target to assign values to\n */ function parseDurationChunk(letter, number, object) {\n    let type;\n    switch(letter){\n        case \"P\":\n            if (number && number === \"-\") {\n                object.isNegative = true;\n            } else {\n                object.isNegative = false;\n            }\n            break;\n        case \"D\":\n            type = \"days\";\n            break;\n        case \"W\":\n            type = \"weeks\";\n            break;\n        case \"H\":\n            type = \"hours\";\n            break;\n        case \"M\":\n            type = \"minutes\";\n            break;\n        case \"S\":\n            type = \"seconds\";\n            break;\n        default:\n            // Not a valid chunk\n            return 0;\n    }\n    if (type) {\n        if (!number && number !== 0) {\n            throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n        }\n        let num = parseInt(number, 10);\n        if (isStrictlyNaN(num)) {\n            throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n        }\n        object[type] = num;\n    }\n    return 1;\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").weekDay} weekDay\n * Imports the 'weekDay' type from the \"types.js\" module\n */ /**\n * @classdesc\n * iCalendar Time representation (similar to JS Date object).  Fully\n * independent of system (OS) timezone / time.  Unlike JS Date, the month\n * January is 1, not zero.\n *\n * @example\n * var time = new ICAL.Time({\n *   year: 2012,\n *   month: 10,\n *   day: 11\n *   minute: 0,\n *   second: 0,\n *   isDate: false\n * });\n *\n *\n * @memberof ICAL\n*/ class Time {\n    /**\n   * Returns the days in the given month\n   *\n   * @param {Number} month      The month to check\n   * @param {Number} year       The year to check\n   * @return {Number}           The number of days in the month\n   */ static daysInMonth(month, year) {\n        let _daysInMonth = [\n            0,\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        let days = 30;\n        if (month < 1 || month > 12) return days;\n        days = _daysInMonth[month];\n        if (month == 2) {\n            days += Time.isLeapYear(year);\n        }\n        return days;\n    }\n    /**\n   * Checks if the year is a leap year\n   *\n   * @param {Number} year       The year to check\n   * @return {Boolean}          True, if the year is a leap year\n   */ static isLeapYear(year) {\n        if (year <= 1752) {\n            return year % 4 == 0;\n        } else {\n            return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n        }\n    }\n    /**\n   * Create a new ICAL.Time from the day of year and year. The date is returned\n   * in floating timezone.\n   *\n   * @param {Number} aDayOfYear     The day of year\n   * @param {Number} aYear          The year to create the instance in\n   * @return {Time}                 The created instance with the calculated date\n   */ static fromDayOfYear(aDayOfYear, aYear) {\n        let year = aYear;\n        let doy = aDayOfYear;\n        let tt = new Time();\n        tt.auto_normalize = false;\n        let is_leap = Time.isLeapYear(year) ? 1 : 0;\n        if (doy < 1) {\n            year--;\n            is_leap = Time.isLeapYear(year) ? 1 : 0;\n            doy += Time.daysInYearPassedMonth[is_leap][12];\n            return Time.fromDayOfYear(doy, year);\n        } else if (doy > Time.daysInYearPassedMonth[is_leap][12]) {\n            is_leap = Time.isLeapYear(year) ? 1 : 0;\n            doy -= Time.daysInYearPassedMonth[is_leap][12];\n            year++;\n            return Time.fromDayOfYear(doy, year);\n        }\n        tt.year = year;\n        tt.isDate = true;\n        for(let month = 11; month >= 0; month--){\n            if (doy > Time.daysInYearPassedMonth[is_leap][month]) {\n                tt.month = month + 1;\n                tt.day = doy - Time.daysInYearPassedMonth[is_leap][month];\n                break;\n            }\n        }\n        tt.auto_normalize = true;\n        return tt;\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\n   * @param {String} str        The string to create from\n   * @return {Time}             The date/time instance\n   */ static fromStringv2(str) {\n        return new Time({\n            year: parseInt(str.slice(0, 4), 10),\n            month: parseInt(str.slice(5, 7), 10),\n            day: parseInt(str.slice(8, 10), 10),\n            isDate: true\n        });\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\n   *\n   * @param {String} aValue     The string to create from\n   * @return {Time}             The date/time instance\n   */ static fromDateString(aValue) {\n        // Dates should have no timezone.\n        // Google likes to sometimes specify Z on dates\n        // we specifically ignore that to avoid issues.\n        // YYYY-MM-DD\n        // 2012-10-10\n        return new Time({\n            year: strictParseInt(aValue.slice(0, 4)),\n            month: strictParseInt(aValue.slice(5, 7)),\n            day: strictParseInt(aValue.slice(8, 10)),\n            isDate: true\n        });\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date-time string, e.g\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\n   * from the property's TZID parameter.\n   *\n   * @param {String} aValue         The string to create from\n   * @param {Property=} prop        The property the date belongs to\n   * @return {Time}                 The date/time instance\n   */ static fromDateTimeString(aValue, prop) {\n        if (aValue.length < 19) {\n            throw new Error('invalid date-time value: \"' + aValue + '\"');\n        }\n        let zone;\n        let zoneId;\n        if (aValue[19] && aValue[19] === \"Z\") {\n            zone = Timezone.utcTimezone;\n        } else if (prop) {\n            zoneId = prop.getParameter(\"tzid\");\n            if (prop.parent) {\n                if (prop.parent.name === \"standard\" || prop.parent.name === \"daylight\") {\n                    // Per RFC 5545 3.8.2.4 and 3.8.2.2, start/end date-times within\n                    // these components MUST be specified in local time.\n                    zone = Timezone.localTimezone;\n                } else if (zoneId) {\n                    // If the desired time zone is defined within the component tree,\n                    // fetch its definition and prefer that.\n                    zone = prop.parent.getTimeZoneByID(zoneId);\n                }\n            }\n        }\n        const timeData = {\n            year: strictParseInt(aValue.slice(0, 4)),\n            month: strictParseInt(aValue.slice(5, 7)),\n            day: strictParseInt(aValue.slice(8, 10)),\n            hour: strictParseInt(aValue.slice(11, 13)),\n            minute: strictParseInt(aValue.slice(14, 16)),\n            second: strictParseInt(aValue.slice(17, 19))\n        };\n        // Although RFC 5545 requires that all TZIDs used within a file have a\n        // corresponding time zone definition, we may not be parsing the full file\n        // or we may be dealing with a non-compliant file; in either case, we can\n        // check our own time zone service for the TZID in a last-ditch effort.\n        if (zoneId && !zone) {\n            timeData.timezone = zoneId;\n        }\n        // 2012-10-10T10:10:10(Z)?\n        return new Time(timeData, zone);\n    }\n    /**\n   * Returns a new ICAL.Time instance from a date or date-time string,\n   *\n   * @param {String} aValue         The string to create from\n   * @param {Property=} prop        The property the date belongs to\n   * @return {Time}                 The date/time instance\n   */ static fromString(aValue, aProperty) {\n        if (aValue.length > 10) {\n            return Time.fromDateTimeString(aValue, aProperty);\n        } else {\n            return Time.fromDateString(aValue);\n        }\n    }\n    /**\n   * Creates a new ICAL.Time instance from the given Javascript Date.\n   *\n   * @param {?Date} aDate             The Javascript Date to read, or null to reset\n   * @param {Boolean} [useUTC=false]  If true, the UTC values of the date will be used\n   */ static fromJSDate(aDate, useUTC) {\n        let tt = new Time();\n        return tt.fromJSDate(aDate, useUTC);\n    }\n    /**\n   * Creates a new ICAL.Time instance from the current moment.\n   * The instance is floating - has no timezone relation.\n   * To create an instance considering the time zone, call\n   * ICAL.Time.fromJSDate(new Date(), true)\n   * @return {Time}\n   */ static now() {\n        return Time.fromJSDate(new Date(), false);\n    }\n    /**\n   * Returns the date on which ISO week number 1 starts.\n   *\n   * @see Time#weekNumber\n   * @param {Number} aYear                  The year to search in\n   * @param {weekDay=} aWeekStart           The week start weekday, used for calculation.\n   * @return {Time}                         The date on which week number 1 starts\n   */ static weekOneStarts(aYear, aWeekStart) {\n        let t = Time.fromData({\n            year: aYear,\n            month: 1,\n            day: 1,\n            isDate: true\n        });\n        let dow = t.dayOfWeek();\n        let wkst = aWeekStart || Time.DEFAULT_WEEK_START;\n        if (dow > Time.THURSDAY) {\n            t.day += 7;\n        }\n        if (wkst > Time.THURSDAY) {\n            t.day -= 7;\n        }\n        t.day -= dow - wkst;\n        return t;\n    }\n    /**\n   * Get the dominical letter for the given year. Letters range from A - G for\n   * common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */ static getDominicalLetter(yr) {\n        let LTRS = \"GFEDCBA\";\n        let dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n        let isLeap = Time.isLeapYear(yr);\n        if (isLeap) {\n            return LTRS[(dom + 6) % 7] + LTRS[dom];\n        } else {\n            return LTRS[dom];\n        }\n    }\n    /**\n   * January 1st, 1970 as an ICAL.Time.\n   * @type {Time}\n   * @constant\n   * @instance\n   */ static get epochTime() {\n        if (!(0,_swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__._)(this, Time, _epochTime)) {\n            (0,_swc_helpers_class_static_private_field_spec_set__WEBPACK_IMPORTED_MODULE_1__._)(this, Time, _epochTime, Time.fromData({\n                year: 1970,\n                month: 1,\n                day: 1,\n                hour: 0,\n                minute: 0,\n                second: 0,\n                isDate: false,\n                timezone: \"Z\"\n            }));\n        }\n        return (0,_swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__._)(this, Time, _epochTime);\n    }\n    static _cmp_attr(a, b, attr) {\n        if (a[attr] > b[attr]) return 1;\n        if (a[attr] < b[attr]) return -1;\n        return 0;\n    }\n    /**\n   * The type name, to be used in the jCal object. This value may change and\n   * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\n   * @type {String}\n   * @default \"date-time\"\n   */ get icaltype() {\n        return this.isDate ? \"date\" : \"date-time\";\n    }\n    /**\n   * Returns a clone of the time object.\n   *\n   * @return {Time}              The cloned object\n   */ clone() {\n        return new Time(this._time, this.zone);\n    }\n    /**\n   * Reset the time instance to epoch time\n   */ reset() {\n        this.fromData(Time.epochTime);\n        this.zone = Timezone.utcTimezone;\n    }\n    /**\n   * Reset the time instance to the given date/time values.\n   *\n   * @param {Number} year             The year to set\n   * @param {Number} month            The month to set\n   * @param {Number} day              The day to set\n   * @param {Number} hour             The hour to set\n   * @param {Number} minute           The minute to set\n   * @param {Number} second           The second to set\n   * @param {Timezone} timezone       The timezone to set\n   */ resetTo(year, month, day, hour, minute, second, timezone) {\n        this.fromData({\n            year: year,\n            month: month,\n            day: day,\n            hour: hour,\n            minute: minute,\n            second: second,\n            zone: timezone\n        });\n    }\n    /**\n   * Set up the current instance from the Javascript date value.\n   *\n   * @param {?Date} aDate             The Javascript Date to read, or null to reset\n   * @param {Boolean} [useUTC=false]  If true, the UTC values of the date will be used\n   */ fromJSDate(aDate, useUTC) {\n        if (!aDate) {\n            this.reset();\n        } else {\n            if (useUTC) {\n                this.zone = Timezone.utcTimezone;\n                this.year = aDate.getUTCFullYear();\n                this.month = aDate.getUTCMonth() + 1;\n                this.day = aDate.getUTCDate();\n                this.hour = aDate.getUTCHours();\n                this.minute = aDate.getUTCMinutes();\n                this.second = aDate.getUTCSeconds();\n            } else {\n                this.zone = Timezone.localTimezone;\n                this.year = aDate.getFullYear();\n                this.month = aDate.getMonth() + 1;\n                this.day = aDate.getDate();\n                this.hour = aDate.getHours();\n                this.minute = aDate.getMinutes();\n                this.second = aDate.getSeconds();\n            }\n        }\n        this._cachedUnixTime = null;\n        return this;\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {Timezone=} aZone         Timezone this position occurs in\n   */ fromData(aData, aZone) {\n        if (aData) {\n            for (let [key, value] of Object.entries(aData)){\n                // ical type cannot be set\n                if (key === \"icaltype\") continue;\n                this[key] = value;\n            }\n        }\n        if (aZone) {\n            this.zone = aZone;\n        }\n        if (aData && !(\"isDate\" in aData)) {\n            this.isDate = !(\"hour\" in aData);\n        } else if (aData && \"isDate\" in aData) {\n            this.isDate = aData.isDate;\n        }\n        if (aData && \"timezone\" in aData) {\n            let zone = TimezoneService.get(aData.timezone);\n            this.zone = zone || Timezone.localTimezone;\n        }\n        if (aData && \"zone\" in aData) {\n            this.zone = aData.zone;\n        }\n        if (!this.zone) {\n            this.zone = Timezone.localTimezone;\n        }\n        this._cachedUnixTime = null;\n        return this;\n    }\n    /**\n   * Calculate the day of week.\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {weekDay}\n   */ dayOfWeek(aWeekStart) {\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n        if (dowCacheKey in Time._dowCache) {\n            return Time._dowCache[dowCacheKey];\n        }\n        // Using Zeller's algorithm\n        let q = this.day;\n        let m = this.month + (this.month < 3 ? 12 : 0);\n        let Y = this.year - (this.month < 3 ? 1 : 0);\n        let h = q + Y + trunc((m + 1) * 26 / 10) + trunc(Y / 4);\n        {\n            h += trunc(Y / 100) * 6 + trunc(Y / 400);\n        }\n        // Normalize to 1 = wkst\n        h = (h + 7 - firstDow) % 7 + 1;\n        Time._dowCache[dowCacheKey] = h;\n        return h;\n    }\n    /**\n   * Calculate the day of year.\n   * @return {Number}\n   */ dayOfYear() {\n        let is_leap = Time.isLeapYear(this.year) ? 1 : 0;\n        let diypm = Time.daysInYearPassedMonth;\n        return diypm[is_leap][this.month - 1] + this.day;\n    }\n    /**\n   * Returns a copy of the current date/time, rewound to the start of the\n   * week. The resulting ICAL.Time instance is of icaltype date, even if this\n   * is a date-time.\n   *\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Time}      The start of the week (cloned)\n   */ startOfWeek(aWeekStart) {\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let result = this.clone();\n        result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, shifted to the end of the week.\n   * The resulting ICAL.Time instance is of icaltype date, even if this is a\n   * date-time.\n   *\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Time}      The end of the week (cloned)\n   */ endOfWeek(aWeekStart) {\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let result = this.clone();\n        result.day += (7 - this.dayOfWeek() + firstDow - Time.SUNDAY) % 7;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, rewound to the start of the\n   * month. The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The start of the month (cloned)\n   */ startOfMonth() {\n        let result = this.clone();\n        result.day = 1;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, shifted to the end of the\n   * month.  The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The end of the month (cloned)\n   */ endOfMonth() {\n        let result = this.clone();\n        result.day = Time.daysInMonth(result.month, result.year);\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, rewound to the start of the\n   * year. The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The start of the year (cloned)\n   */ startOfYear() {\n        let result = this.clone();\n        result.day = 1;\n        result.month = 1;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * Returns a copy of the current date/time, shifted to the end of the\n   * year.  The resulting ICAL.Time instance is of icaltype date, even if\n   * this is a date-time.\n   *\n   * @return {Time}      The end of the year (cloned)\n   */ endOfYear() {\n        let result = this.clone();\n        result.day = 31;\n        result.month = 12;\n        result.isDate = true;\n        result.hour = 0;\n        result.minute = 0;\n        result.second = 0;\n        return result;\n    }\n    /**\n   * First calculates the start of the week, then returns the day of year for\n   * this date. If the day falls into the previous year, the day is zero or negative.\n   *\n   * @param {weekDay=} aFirstDayOfWeek\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}     The calculated day of year\n   */ startDoyWeek(aFirstDayOfWeek) {\n        let firstDow = aFirstDayOfWeek || Time.SUNDAY;\n        let delta = this.dayOfWeek() - firstDow;\n        if (delta < 0) delta += 7;\n        return this.dayOfYear() - delta;\n    }\n    /**\n   * Get the dominical letter for the current year. Letters range from A - G\n   * for common years, and AG to GF for leap years.\n   *\n   * @param {Number} yr           The year to retrieve the letter for\n   * @return {String}             The dominical letter.\n   */ getDominicalLetter() {\n        return Time.getDominicalLetter(this.year);\n    }\n    /**\n   * Finds the nthWeekDay relative to the current month (not day).  The\n   * returned value is a day relative the month that this month belongs to so\n   * 1 would indicate the first of the month and 40 would indicate a day in\n   * the following month.\n   *\n   * @param {Number} aDayOfWeek   Day of the week see the day name constants\n   * @param {Number} aPos         Nth occurrence of a given week day values\n   *        of 1 and 0 both indicate the first weekday of that type. aPos may\n   *        be either positive or negative\n   *\n   * @return {Number} numeric value indicating a day relative\n   *                   to the current month of this time object\n   */ nthWeekDay(aDayOfWeek, aPos) {\n        let daysInMonth = Time.daysInMonth(this.month, this.year);\n        let weekday;\n        let pos = aPos;\n        let start = 0;\n        let otherDay = this.clone();\n        if (pos >= 0) {\n            otherDay.day = 1;\n            // because 0 means no position has been given\n            // 1 and 0 indicate the same day.\n            if (pos != 0) {\n                // remove the extra numeric value\n                pos--;\n            }\n            // set current start offset to current day.\n            start = otherDay.day;\n            // find the current day of week\n            let startDow = otherDay.dayOfWeek();\n            // calculate the difference between current\n            // day of the week and desired day of the week\n            let offset = aDayOfWeek - startDow;\n            // if the offset goes into the past\n            // week we add 7 so it goes into the next\n            // week. We only want to go forward in time here.\n            if (offset < 0) // this is really important otherwise we would\n            // end up with dates from in the past.\n            offset += 7;\n            // add offset to start so start is the same\n            // day of the week as the desired day of week.\n            start += offset;\n            // because we are going to add (and multiply)\n            // the numeric value of the day we subtract it\n            // from the start position so not to add it twice.\n            start -= aDayOfWeek;\n            // set week day\n            weekday = aDayOfWeek;\n        } else {\n            // then we set it to the last day in the current month\n            otherDay.day = daysInMonth;\n            // find the ends weekday\n            let endDow = otherDay.dayOfWeek();\n            pos++;\n            weekday = endDow - aDayOfWeek;\n            if (weekday < 0) {\n                weekday += 7;\n            }\n            weekday = daysInMonth - weekday;\n        }\n        weekday += pos * 7;\n        return start + weekday;\n    }\n    /**\n   * Checks if current time is the nth weekday, relative to the current\n   * month.  Will always return false when rule resolves outside of current\n   * month.\n   *\n   * @param {weekDay} aDayOfWeek                 Day of week to check\n   * @param {Number} aPos                        Relative position\n   * @return {Boolean}                           True, if it is the nth weekday\n   */ isNthWeekDay(aDayOfWeek, aPos) {\n        let dow = this.dayOfWeek();\n        if (aPos === 0 && dow === aDayOfWeek) {\n            return true;\n        }\n        // get pos\n        let day = this.nthWeekDay(aDayOfWeek, aPos);\n        if (day === this.day) {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Calculates the ISO 8601 week number. The first week of a year is the\n   * week that contains the first Thursday. The year can have 53 weeks, if\n   * January 1st is a Friday.\n   *\n   * Note there are regions where the first week of the year is the one that\n   * starts on January 1st, which may offset the week number. Also, if a\n   * different week start is specified, this will also affect the week\n   * number.\n   *\n   * @see Time.weekOneStarts\n   * @param {weekDay} aWeekStart                  The weekday the week starts with\n   * @return {Number}                             The ISO week number\n   */ weekNumber(aWeekStart) {\n        let wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n        if (wnCacheKey in Time._wnCache) {\n            return Time._wnCache[wnCacheKey];\n        }\n        // This function courtesty of Julian Bucknall, published under the MIT license\n        // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n        // plus some fixes to be able to use different week starts.\n        let week1;\n        let dt = this.clone();\n        dt.isDate = true;\n        let isoyear = this.year;\n        if (dt.month == 12 && dt.day > 25) {\n            week1 = Time.weekOneStarts(isoyear + 1, aWeekStart);\n            if (dt.compare(week1) < 0) {\n                week1 = Time.weekOneStarts(isoyear, aWeekStart);\n            } else {\n                isoyear++;\n            }\n        } else {\n            week1 = Time.weekOneStarts(isoyear, aWeekStart);\n            if (dt.compare(week1) < 0) {\n                week1 = Time.weekOneStarts(--isoyear, aWeekStart);\n            }\n        }\n        let daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n        let answer = trunc(daysBetween / 7) + 1;\n        Time._wnCache[wnCacheKey] = answer;\n        return answer;\n    }\n    /**\n   * Adds the duration to the current time. The instance is modified in\n   * place.\n   *\n   * @param {Duration} aDuration         The duration to add\n   */ addDuration(aDuration) {\n        let mult = aDuration.isNegative ? -1 : 1;\n        // because of the duration optimizations it is much\n        // more efficient to grab all the values up front\n        // then set them directly (which will avoid a normalization call).\n        // So we don't actually normalize until we need it.\n        let second = this.second;\n        let minute = this.minute;\n        let hour = this.hour;\n        let day = this.day;\n        second += mult * aDuration.seconds;\n        minute += mult * aDuration.minutes;\n        hour += mult * aDuration.hours;\n        day += mult * aDuration.days;\n        day += mult * 7 * aDuration.weeks;\n        this.second = second;\n        this.minute = minute;\n        this.hour = hour;\n        this.day = day;\n        this._cachedUnixTime = null;\n    }\n    /**\n   * Subtract the date details (_excluding_ timezone).  Useful for finding\n   * the relative difference between two time objects excluding their\n   * timezone differences.\n   *\n   * @param {Time} aDate     The date to subtract\n   * @return {Duration}      The difference as a duration\n   */ subtractDate(aDate) {\n        let unixTime = this.toUnixTime() + this.utcOffset();\n        let other = aDate.toUnixTime() + aDate.utcOffset();\n        return Duration.fromSeconds(unixTime - other);\n    }\n    /**\n   * Subtract the date details, taking timezones into account.\n   *\n   * @param {Time} aDate  The date to subtract\n   * @return {Duration}   The difference in duration\n   */ subtractDateTz(aDate) {\n        let unixTime = this.toUnixTime();\n        let other = aDate.toUnixTime();\n        return Duration.fromSeconds(unixTime - other);\n    }\n    /**\n   * Compares the ICAL.Time instance with another one.\n   *\n   * @param {Duration} aOther        The instance to compare with\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compare(other) {\n        let a = this.toUnixTime();\n        let b = other.toUnixTime();\n        if (a > b) return 1;\n        if (b > a) return -1;\n        return 0;\n    }\n    /**\n   * Compares only the date part of this instance with another one.\n   *\n   * @param {Duration} other              The instance to compare with\n   * @param {Timezone} tz                 The timezone to compare in\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compareDateOnlyTz(other, tz) {\n        let a = this.convertToZone(tz);\n        let b = other.convertToZone(tz);\n        let rc = 0;\n        if ((rc = Time._cmp_attr(a, b, \"year\")) != 0) return rc;\n        if ((rc = Time._cmp_attr(a, b, \"month\")) != 0) return rc;\n        if ((rc = Time._cmp_attr(a, b, \"day\")) != 0) return rc;\n        return rc;\n    }\n    /**\n   * Convert the instance into another timezone. The returned ICAL.Time\n   * instance is always a copy.\n   *\n   * @param {Timezone} zone      The zone to convert to\n   * @return {Time}              The copy, converted to the zone\n   */ convertToZone(zone) {\n        let copy = this.clone();\n        let zone_equals = this.zone.tzid == zone.tzid;\n        if (!this.isDate && !zone_equals) {\n            Timezone.convert_time(copy, this.zone, zone);\n        }\n        copy.zone = zone;\n        return copy;\n    }\n    /**\n   * Calculates the UTC offset of the current date/time in the timezone it is\n   * in.\n   *\n   * @return {Number}     UTC offset in seconds\n   */ utcOffset() {\n        if (this.zone == Timezone.localTimezone || this.zone == Timezone.utcTimezone) {\n            return 0;\n        } else {\n            return this.zone.utcOffset(this);\n        }\n    }\n    /**\n   * Returns an RFC 5545 compliant ical representation of this object.\n   *\n   * @return {String} ical date/date-time\n   */ toICALString() {\n        let string = this.toString();\n        if (string.length > 10) {\n            return design$1.icalendar.value[\"date-time\"].toICAL(string);\n        } else {\n            return design$1.icalendar.value.date.toICAL(string);\n        }\n    }\n    /**\n   * The string representation of this date/time, in jCal form\n   * (including : and - separators).\n   * @return {String}\n   */ toString() {\n        let result = this.year + \"-\" + pad2(this.month) + \"-\" + pad2(this.day);\n        if (!this.isDate) {\n            result += \"T\" + pad2(this.hour) + \":\" + pad2(this.minute) + \":\" + pad2(this.second);\n            if (this.zone === Timezone.utcTimezone) {\n                result += \"Z\";\n            }\n        }\n        return result;\n    }\n    /**\n   * Converts the current instance to a Javascript date\n   * @return {Date}\n   */ toJSDate() {\n        if (this.zone == Timezone.localTimezone) {\n            if (this.isDate) {\n                return new Date(this.year, this.month - 1, this.day);\n            } else {\n                return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n            }\n        } else {\n            return new Date(this.toUnixTime() * 1000);\n        }\n    }\n    _normalize() {\n        if (this._time.isDate) {\n            this._time.hour = 0;\n            this._time.minute = 0;\n            this._time.second = 0;\n        }\n        this.adjust(0, 0, 0, 0);\n        return this;\n    }\n    /**\n   * Adjust the date/time by the given offset\n   *\n   * @param {Number} aExtraDays       The extra amount of days\n   * @param {Number} aExtraHours      The extra amount of hours\n   * @param {Number} aExtraMinutes    The extra amount of minutes\n   * @param {Number} aExtraSeconds    The extra amount of seconds\n   * @param {Number=} aTime           The time to adjust, defaults to the\n   *                                    current instance.\n   */ adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n        let minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;\n        let second, minute, hour, day;\n        let daysInMonth;\n        let time = aTime || this._time;\n        if (!time.isDate) {\n            second = time.second + aExtraSeconds;\n            time.second = second % 60;\n            minutesOverflow = trunc(second / 60);\n            if (time.second < 0) {\n                time.second += 60;\n                minutesOverflow--;\n            }\n            minute = time.minute + aExtraMinutes + minutesOverflow;\n            time.minute = minute % 60;\n            hoursOverflow = trunc(minute / 60);\n            if (time.minute < 0) {\n                time.minute += 60;\n                hoursOverflow--;\n            }\n            hour = time.hour + aExtraHours + hoursOverflow;\n            time.hour = hour % 24;\n            daysOverflow = trunc(hour / 24);\n            if (time.hour < 0) {\n                time.hour += 24;\n                daysOverflow--;\n            }\n        }\n        // Adjust month and year first, because we need to know what month the day\n        // is in before adjusting it.\n        if (time.month > 12) {\n            yearsOverflow = trunc((time.month - 1) / 12);\n        } else if (time.month < 1) {\n            yearsOverflow = trunc(time.month / 12) - 1;\n        }\n        time.year += yearsOverflow;\n        time.month -= 12 * yearsOverflow;\n        // Now take care of the days (and adjust month if needed)\n        day = time.day + aExtraDays + daysOverflow;\n        if (day > 0) {\n            for(;;){\n                daysInMonth = Time.daysInMonth(time.month, time.year);\n                if (day <= daysInMonth) {\n                    break;\n                }\n                time.month++;\n                if (time.month > 12) {\n                    time.year++;\n                    time.month = 1;\n                }\n                day -= daysInMonth;\n            }\n        } else {\n            while(day <= 0){\n                if (time.month == 1) {\n                    time.year--;\n                    time.month = 12;\n                } else {\n                    time.month--;\n                }\n                day += Time.daysInMonth(time.month, time.year);\n            }\n        }\n        time.day = day;\n        this._cachedUnixTime = null;\n        return this;\n    }\n    /**\n   * Sets up the current instance from unix time, the number of seconds since\n   * January 1st, 1970.\n   *\n   * @param {Number} seconds      The seconds to set up with\n   */ fromUnixTime(seconds) {\n        this.zone = Timezone.utcTimezone;\n        // We could use `fromJSDate` here, but this is about twice as fast.\n        // We could also clone `epochTime` and use `adjust` for a more\n        // ical.js-centric approach, but this is about 100 times as fast.\n        let date = new Date(seconds * 1000);\n        this.year = date.getUTCFullYear();\n        this.month = date.getUTCMonth() + 1;\n        this.day = date.getUTCDate();\n        if (this._time.isDate) {\n            this.hour = 0;\n            this.minute = 0;\n            this.second = 0;\n        } else {\n            this.hour = date.getUTCHours();\n            this.minute = date.getUTCMinutes();\n            this.second = date.getUTCSeconds();\n        }\n        this._cachedUnixTime = null;\n    }\n    /**\n   * Converts the current instance to seconds since January 1st 1970.\n   *\n   * @return {Number}         Seconds since 1970\n   */ toUnixTime() {\n        if (this._cachedUnixTime !== null) {\n            return this._cachedUnixTime;\n        }\n        let offset = this.utcOffset();\n        // we use the offset trick to ensure\n        // that we are getting the actual UTC time\n        let ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset);\n        // seconds\n        this._cachedUnixTime = ms / 1000;\n        return this._cachedUnixTime;\n    }\n    /**\n   * Converts time to into Object which can be serialized then re-created\n   * using the constructor.\n   *\n   * @example\n   * // toJSON will automatically be called\n   * var json = JSON.stringify(mytime);\n   *\n   * var deserialized = JSON.parse(json);\n   *\n   * var time = new ICAL.Time(deserialized);\n   *\n   * @return {Object}\n   */ toJSON() {\n        let copy = [\n            \"year\",\n            \"month\",\n            \"day\",\n            \"hour\",\n            \"minute\",\n            \"second\",\n            \"isDate\"\n        ];\n        let result = Object.create(null);\n        let i = 0;\n        let len = copy.length;\n        let prop;\n        for(; i < len; i++){\n            prop = copy[i];\n            result[prop] = this[prop];\n        }\n        if (this.zone) {\n            result.timezone = this.zone.tzid;\n        }\n        return result;\n    }\n    /**\n   * Creates a new ICAL.Time instance.\n   *\n   * @param {Object} data           Time initialization\n   * @param {Number=} data.year     The year for this date\n   * @param {Number=} data.month    The month for this date\n   * @param {Number=} data.day      The day for this date\n   * @param {Number=} data.hour     The hour for this date\n   * @param {Number=} data.minute   The minute for this date\n   * @param {Number=} data.second   The second for this date\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\n   *                                  opposed to a date-time)\n   * @param {Timezone} zone         timezone this position occurs in\n   */ constructor(data, zone){\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icaltime\"\n   */ this.icalclass = \"icaltime\";\n        this._cachedUnixTime = null;\n        /**\n   * The timezone for this time.\n   * @type {Timezone}\n   */ this.zone = null;\n        /**\n   * Internal uses to indicate that a change has been made and the next read\n   * operation must attempt to normalize the value (for example changing the\n   * day to 33).\n   *\n   * @type {Boolean}\n   * @private\n   */ this._pendingNormalization = false;\n        this.wrappedJSObject = this;\n        let time = this._time = Object.create(null);\n        /* time defaults */ time.year = 0;\n        time.month = 1;\n        time.day = 1;\n        time.hour = 0;\n        time.minute = 0;\n        time.second = 0;\n        time.isDate = false;\n        this.fromData(data, zone);\n    }\n}\nTime._dowCache = {};\nTime._wnCache = {};\n/**\n   * Creates a new ICAL.Time instance from the the passed data object.\n   *\n   * @param {Object} aData            Time initialization\n   * @param {Number=} aData.year      The year for this date\n   * @param {Number=} aData.month     The month for this date\n   * @param {Number=} aData.day       The day for this date\n   * @param {Number=} aData.hour      The hour for this date\n   * @param {Number=} aData.minute    The minute for this date\n   * @param {Number=} aData.second    The second for this date\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\n   *                                    (as opposed to a date-time)\n   * @param {Timezone=} aZone         Timezone this position occurs in\n   */ Time.fromData = function fromData(aData, aZone) {\n    let t = new Time();\n    return t.fromData(aData, aZone);\n};\nvar _epochTime = {\n    writable: true,\n    value: null\n};\n/**\n   * The days that have passed in the year after a given month. The array has\n   * two members, one being an array of passed days for non-leap years, the\n   * other analog for leap years.\n   * @example\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\n   * @type {Array.<Array.<Number>>}\n   */ Time.daysInYearPassedMonth = [\n    [\n        0,\n        31,\n        59,\n        90,\n        120,\n        151,\n        181,\n        212,\n        243,\n        273,\n        304,\n        334,\n        365\n    ],\n    [\n        0,\n        31,\n        60,\n        91,\n        121,\n        152,\n        182,\n        213,\n        244,\n        274,\n        305,\n        335,\n        366\n    ]\n];\nTime.SUNDAY = 1;\nTime.MONDAY = 2;\nTime.TUESDAY = 3;\nTime.WEDNESDAY = 4;\nTime.THURSDAY = 5;\nTime.FRIDAY = 6;\nTime.SATURDAY = 7;\n/**\n   * The default weekday for the WKST part.\n   * @constant\n   * @default ICAL.Time.MONDAY\n   */ Time.DEFAULT_WEEK_START = 2 // MONDAY\n;\n(function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n        Object.defineProperty(Time.prototype, attr, {\n            get: function getTimeAttr() {\n                if (this._pendingNormalization) {\n                    this._normalize();\n                    this._pendingNormalization = false;\n                }\n                return this._time[attr];\n            },\n            set: function setTimeAttr(val) {\n                // Check if isDate will be set and if was not set to normalize date.\n                // This avoids losing days when seconds, minutes and hours are zeroed\n                // what normalize will do when time is a date.\n                if (attr === \"isDate\" && val && !this._time.isDate) {\n                    this.adjust(0, 0, 0, 0);\n                }\n                this._cachedUnixTime = null;\n                this._pendingNormalization = true;\n                this._time[attr] = val;\n            }\n        });\n    }\n    defineAttr(\"year\");\n    defineAttr(\"month\");\n    defineAttr(\"day\");\n    defineAttr(\"hour\");\n    defineAttr(\"minute\");\n    defineAttr(\"second\");\n    defineAttr(\"isDate\");\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").parserState} parserState\n * Imports the 'parserState' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n */ const CHAR = /[^ \\t]/;\nconst VALUE_DELIMITER = \":\";\nconst PARAM_DELIMITER = \";\";\nconst PARAM_NAME_DELIMITER = \"=\";\nconst DEFAULT_VALUE_TYPE$1 = \"unknown\";\nconst DEFAULT_PARAM_TYPE = \"text\";\nconst RFC6868_REPLACE_MAP$1 = {\n    \"^'\": '\"',\n    \"^n\": \"\\n\",\n    \"^^\": \"^\"\n};\n/**\n * Parses iCalendar or vCard data into a raw jCal object. Consult\n * documentation on the {@tutorial layers|layers of parsing} for more\n * details.\n *\n * @function ICAL.parse\n * @memberof ICAL\n * @variation function\n * @todo Fix the API to be more clear on the return type\n * @param {String} input      The string data to parse\n * @return {Object|Object[]}  A single jCal object, or an array thereof\n */ function parse(input) {\n    let state = {};\n    let root = state.component = [];\n    state.stack = [\n        root\n    ];\n    parse._eachLine(input, function(err, line) {\n        parse._handleContentLine(line, state);\n    });\n    // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n    if (state.stack.length > 1) {\n        throw new ParserError(\"invalid ical body. component began but did not end\");\n    }\n    state = null;\n    return root.length == 1 ? root[0] : root;\n}\n/**\n * Parse an iCalendar property value into the jCal for a single property\n *\n * @function ICAL.parse.property\n * @param {String} str\n *   The iCalendar property string to parse\n * @param {designSet=} designSet\n *   The design data to use for this property\n * @return {Object}\n *   The jCal Object containing the property\n */ parse.property = function(str, designSet) {\n    let state = {\n        component: [\n            [],\n            []\n        ],\n        designSet: designSet || design$1.defaultSet\n    };\n    parse._handleContentLine(str, state);\n    return state.component[1][0];\n};\n/**\n * Convenience method to parse a component. You can use ICAL.parse() directly\n * instead.\n *\n * @function ICAL.parse.component\n * @see ICAL.parse(function)\n * @param {String} str    The iCalendar component string to parse\n * @return {Object}       The jCal Object containing the component\n */ parse.component = function(str) {\n    return parse(str);\n};\n/**\n * An error that occurred during parsing.\n *\n * @param {String} message        The error message\n * @memberof ICAL.parse\n * @extends {Error}\n */ class ParserError extends Error {\n    constructor(...args){\n        super(...args);\n        this.name = this.constructor.name;\n    }\n}\n// classes & constants\nparse.ParserError = ParserError;\n/**\n * Handles a single line of iCalendar/vCard, updating the state.\n *\n * @private\n * @function ICAL.parse._handleContentLine\n * @param {String} line          The content line to process\n * @param {parserState} state    The current state of the line parsing\n */ parse._handleContentLine = function(line, state) {\n    // break up the parts of the line\n    let valuePos = line.indexOf(VALUE_DELIMITER);\n    let paramPos = line.indexOf(PARAM_DELIMITER);\n    let lastParamIndex;\n    let lastValuePos;\n    // name of property or begin/end\n    let name;\n    let value;\n    // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n    let params = {};\n    /**\n   * Different property cases\n   *\n   *\n   * 1. RRULE:FREQ=foo\n   *    // FREQ= is not a param but the value\n   *\n   * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\n   *    // ROLE= is a param because : has not happened yet\n   */ // when the parameter delimiter is after the\n    // value delimiter then it is not a parameter.\n    if (paramPos !== -1 && valuePos !== -1) {\n        // when the parameter delimiter is after the\n        // value delimiter then it is not a parameter.\n        if (paramPos > valuePos) {\n            paramPos = -1;\n        }\n    }\n    let parsedParams;\n    if (paramPos !== -1) {\n        name = line.slice(0, Math.max(0, paramPos)).toLowerCase();\n        parsedParams = parse._parseParameters(line.slice(Math.max(0, paramPos)), 0, state.designSet);\n        if (parsedParams[2] == -1) {\n            throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n        }\n        params = parsedParams[0];\n        lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n        if ((lastValuePos = line.slice(Math.max(0, lastParamIndex)).indexOf(VALUE_DELIMITER)) !== -1) {\n            value = line.slice(Math.max(0, lastParamIndex + lastValuePos + 1));\n        } else {\n            throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n        }\n    } else if (valuePos !== -1) {\n        // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n        name = line.slice(0, Math.max(0, valuePos)).toLowerCase();\n        value = line.slice(Math.max(0, valuePos + 1));\n        if (name === \"begin\") {\n            let newComponent = [\n                value.toLowerCase(),\n                [],\n                []\n            ];\n            if (state.stack.length === 1) {\n                state.component.push(newComponent);\n            } else {\n                state.component[2].push(newComponent);\n            }\n            state.stack.push(state.component);\n            state.component = newComponent;\n            if (!state.designSet) {\n                state.designSet = design$1.getDesignSet(state.component[0]);\n            }\n            return;\n        } else if (name === \"end\") {\n            state.component = state.stack.pop();\n            return;\n        }\n    // If it is not begin/end, then this is a property with an empty value,\n    // which should be considered valid.\n    } else {\n        /**\n     * Invalid line.\n     * The rational to throw an error is we will\n     * never be certain that the rest of the file\n     * is sane and it is unlikely that we can serialize\n     * the result correctly either.\n     */ throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n    }\n    let valueType;\n    let multiValue = false;\n    let structuredValue = false;\n    let propertyDetails;\n    let splitName;\n    let ungroupedName;\n    // fetch the ungrouped part of the name\n    if (state.designSet.propertyGroups && name.indexOf(\".\") !== -1) {\n        splitName = name.split(\".\");\n        params.group = splitName[0];\n        ungroupedName = splitName[1];\n    } else {\n        ungroupedName = name;\n    }\n    if (ungroupedName in state.designSet.property) {\n        propertyDetails = state.designSet.property[ungroupedName];\n        if (\"multiValue\" in propertyDetails) {\n            multiValue = propertyDetails.multiValue;\n        }\n        if (\"structuredValue\" in propertyDetails) {\n            structuredValue = propertyDetails.structuredValue;\n        }\n        if (value && \"detectType\" in propertyDetails) {\n            valueType = propertyDetails.detectType(value);\n        }\n    }\n    // attempt to determine value\n    if (!valueType) {\n        if (!(\"value\" in params)) {\n            if (propertyDetails) {\n                valueType = propertyDetails.defaultType;\n            } else {\n                valueType = DEFAULT_VALUE_TYPE$1;\n            }\n        } else {\n            // possible to avoid this?\n            valueType = params.value.toLowerCase();\n        }\n    }\n    delete params.value;\n    /**\n   * Note on `var result` juggling:\n   *\n   * I observed that building the array in pieces has adverse\n   * effects on performance, so where possible we inline the creation.\n   * It is a little ugly but resulted in ~2000 additional ops/sec.\n   */ let result;\n    if (multiValue && structuredValue) {\n        value = parse._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n        result = [\n            ungroupedName,\n            params,\n            valueType,\n            value\n        ];\n    } else if (multiValue) {\n        result = [\n            ungroupedName,\n            params,\n            valueType\n        ];\n        parse._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n        value = parse._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n        result = [\n            ungroupedName,\n            params,\n            valueType,\n            value\n        ];\n    } else {\n        value = parse._parseValue(value, valueType, state.designSet, false);\n        result = [\n            ungroupedName,\n            params,\n            valueType,\n            value\n        ];\n    }\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (state.component[0] === \"vcard\" && state.component[1].length === 0 && !(name === \"version\" && value === \"4.0\")) {\n        state.designSet = design$1.getDesignSet(\"vcard3\");\n    }\n    state.component[1].push(result);\n};\n/**\n * Parse a value from the raw value into the jCard/jCal value.\n *\n * @private\n * @function ICAL.parse._parseValue\n * @param {String} value          Original value\n * @param {String} type           Type of value\n * @param {Object} designSet      The design data to use for this value\n * @return {Object} varies on type\n */ parse._parseValue = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && \"fromICAL\" in designSet.value[type]) {\n        return designSet.value[type].fromICAL(value, structuredValue);\n    }\n    return value;\n};\n/**\n * Parse parameters from a string to object.\n *\n * @function ICAL.parse._parseParameters\n * @private\n * @param {String} line           A single unfolded line\n * @param {Number} start         Position to start looking for properties\n * @param {Object} designSet      The design data to use for this property\n * @return {Object} key/value pairs\n */ parse._parseParameters = function(line, start, designSet) {\n    let lastParam = start;\n    let pos = 0;\n    let delim = PARAM_NAME_DELIMITER;\n    let result = {};\n    let name, lcname;\n    let value, valuePos = -1;\n    let type, multiValue, mvdelim;\n    // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n    while(pos !== false && (pos = line.indexOf(delim, pos + 1)) !== -1){\n        name = line.slice(lastParam + 1, pos);\n        if (name.length == 0) {\n            throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n        }\n        lcname = name.toLowerCase();\n        mvdelim = false;\n        multiValue = false;\n        if (lcname in designSet.param && designSet.param[lcname].valueType) {\n            type = designSet.param[lcname].valueType;\n        } else {\n            type = DEFAULT_PARAM_TYPE;\n        }\n        if (lcname in designSet.param) {\n            multiValue = designSet.param[lcname].multiValue;\n            if (designSet.param[lcname].multiValueSeparateDQuote) {\n                mvdelim = parse._rfc6868Escape('\"' + multiValue + '\"');\n            }\n        }\n        let nextChar = line[pos + 1];\n        if (nextChar === '\"') {\n            valuePos = pos + 2;\n            pos = line.indexOf('\"', valuePos);\n            if (multiValue && pos != -1) {\n                let extendedValue = true;\n                while(extendedValue){\n                    if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n                        pos = line.indexOf('\"', pos + 3);\n                    } else {\n                        extendedValue = false;\n                    }\n                }\n            }\n            if (pos === -1) {\n                throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n            }\n            value = line.slice(valuePos, pos);\n            lastParam = line.indexOf(PARAM_DELIMITER, pos);\n            let propValuePos = line.indexOf(VALUE_DELIMITER, pos);\n            // if either no next parameter or delimeter in property value, let's stop here\n            if (lastParam === -1 || propValuePos !== -1 && lastParam > propValuePos) {\n                pos = false;\n            }\n        } else {\n            valuePos = pos + 1;\n            // move to next \";\"\n            let nextPos = line.indexOf(PARAM_DELIMITER, valuePos);\n            let propValuePos = line.indexOf(VALUE_DELIMITER, valuePos);\n            if (propValuePos !== -1 && nextPos > propValuePos) {\n                // this is a delimiter in the property value, let's stop here\n                nextPos = propValuePos;\n                pos = false;\n            } else if (nextPos === -1) {\n                // no \";\"\n                if (propValuePos === -1) {\n                    nextPos = line.length;\n                } else {\n                    nextPos = propValuePos;\n                }\n                pos = false;\n            } else {\n                lastParam = nextPos;\n                pos = nextPos;\n            }\n            value = line.slice(valuePos, nextPos);\n        }\n        const length_before = value.length;\n        value = parse._rfc6868Escape(value);\n        valuePos += length_before - value.length;\n        if (multiValue) {\n            let delimiter = mvdelim || multiValue;\n            value = parse._parseMultiValue(value, delimiter, type, [], null, designSet);\n        } else {\n            value = parse._parseValue(value, type, designSet);\n        }\n        if (multiValue && lcname in result) {\n            if (Array.isArray(result[lcname])) {\n                result[lcname].push(value);\n            } else {\n                result[lcname] = [\n                    result[lcname],\n                    value\n                ];\n            }\n        } else {\n            result[lcname] = value;\n        }\n    }\n    return [\n        result,\n        value,\n        valuePos\n    ];\n};\n/**\n * Internal helper for rfc6868. Exposing this on ICAL.parse so that\n * hackers can disable the rfc6868 parsing if the really need to.\n *\n * @function ICAL.parse._rfc6868Escape\n * @param {String} val        The value to escape\n * @return {String}           The escaped value\n */ parse._rfc6868Escape = function(val) {\n    return val.replace(/\\^['n^]/g, function(x) {\n        return RFC6868_REPLACE_MAP$1[x];\n    });\n};\n/**\n * Parse a multi value string. This function is used either for parsing\n * actual multi-value property's values, or for handling parameter values. It\n * can be used for both multi-value properties and structured value properties.\n *\n * @private\n * @function ICAL.parse._parseMultiValue\n * @param {String} buffer           The buffer containing the full value\n * @param {String} delim            The multi-value delimiter\n * @param {String} type             The value type to be parsed\n * @param {Array.<?>} result        The array to append results to, varies on value type\n * @param {String} innerMulti       The inner delimiter to split each value with\n * @param {designSet} designSet     The design data for this value\n * @return {?|Array.<?>}            Either an array of results, or the first result\n */ parse._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    let pos = 0;\n    let lastPos = 0;\n    let value;\n    if (delim.length === 0) {\n        return buffer;\n    }\n    // split each piece\n    while((pos = unescapedIndexOf(buffer, delim, lastPos)) !== -1){\n        value = buffer.slice(lastPos, pos);\n        if (innerMulti) {\n            value = parse._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n        } else {\n            value = parse._parseValue(value, type, designSet, structuredValue);\n        }\n        result.push(value);\n        lastPos = pos + delim.length;\n    }\n    // on the last piece take the rest of string\n    value = buffer.slice(lastPos);\n    if (innerMulti) {\n        value = parse._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n        value = parse._parseValue(value, type, designSet, structuredValue);\n    }\n    result.push(value);\n    return result.length == 1 ? result[0] : result;\n};\n/**\n * Process a complete buffer of iCalendar/vCard data line by line, correctly\n * unfolding content. Each line will be processed with the given callback\n *\n * @private\n * @function ICAL.parse._eachLine\n * @param {String} buffer                         The buffer to process\n * @param {function(?String, String)} callback    The callback for each line\n */ parse._eachLine = function(buffer, callback) {\n    let len = buffer.length;\n    let lastPos = buffer.search(CHAR);\n    let pos = lastPos;\n    let line;\n    let firstChar;\n    let newlineOffset;\n    do {\n        pos = buffer.indexOf(\"\\n\", lastPos) + 1;\n        if (pos > 1 && buffer[pos - 2] === \"\\r\") {\n            newlineOffset = 2;\n        } else {\n            newlineOffset = 1;\n        }\n        if (pos === 0) {\n            pos = len;\n            newlineOffset = 0;\n        }\n        firstChar = buffer[lastPos];\n        if (firstChar === \" \" || firstChar === \"\t\") {\n            // add to line\n            line += buffer.slice(lastPos + 1, pos - newlineOffset);\n        } else {\n            if (line) callback(null, line);\n            // push line\n            line = buffer.slice(lastPos, pos - newlineOffset);\n        }\n        lastPos = pos;\n    }while (pos !== len);\n    // extra ending line\n    line = line.trim();\n    if (line.length) callback(null, line);\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ const OPTIONS = [\n    \"tzid\",\n    \"location\",\n    \"tznames\",\n    \"latitude\",\n    \"longitude\"\n];\n/**\n * Timezone representation.\n *\n * @example\n * var vcalendar;\n * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\n * var tzid = timezoneComp.getFirstPropertyValue('tzid');\n *\n * var timezone = new ICAL.Timezone({\n *   component: timezoneComp,\n *   tzid\n * });\n *\n * @memberof ICAL\n */ class Timezone {\n    static _compare_change_fn(a, b) {\n        if (a.year < b.year) return -1;\n        else if (a.year > b.year) return 1;\n        if (a.month < b.month) return -1;\n        else if (a.month > b.month) return 1;\n        if (a.day < b.day) return -1;\n        else if (a.day > b.day) return 1;\n        if (a.hour < b.hour) return -1;\n        else if (a.hour > b.hour) return 1;\n        if (a.minute < b.minute) return -1;\n        else if (a.minute > b.minute) return 1;\n        if (a.second < b.second) return -1;\n        else if (a.second > b.second) return 1;\n        return 0;\n    }\n    /**\n   * Convert the date/time from one zone to the next.\n   *\n   * @param {Time} tt                  The time to convert\n   * @param {Timezone} from_zone       The source zone to convert from\n   * @param {Timezone} to_zone         The target zone to convert to\n   * @return {Time}                    The converted date/time object\n   */ static convert_time(tt, from_zone, to_zone) {\n        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == Timezone.localTimezone || to_zone == Timezone.localTimezone) {\n            tt.zone = to_zone;\n            return tt;\n        }\n        let utcOffset = from_zone.utcOffset(tt);\n        tt.adjust(0, 0, 0, -utcOffset);\n        utcOffset = to_zone.utcOffset(tt);\n        tt.adjust(0, 0, 0, utcOffset);\n        return null;\n    }\n    /**\n   * Creates a new ICAL.Timezone instance from the passed data object.\n   *\n   * @param {Component|Object} aData options for class\n   * @param {String|Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */ static fromData(aData) {\n        let tt = new Timezone();\n        return tt.fromData(aData);\n    }\n    static get utcTimezone() {\n        if (!(0,_swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__._)(this, Timezone, _utcTimezone)) {\n            (0,_swc_helpers_class_static_private_field_spec_set__WEBPACK_IMPORTED_MODULE_1__._)(this, Timezone, _utcTimezone, Timezone.fromData({\n                tzid: \"UTC\"\n            }));\n        }\n        return (0,_swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__._)(this, Timezone, _utcTimezone);\n    }\n    static get localTimezone() {\n        if (!(0,_swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__._)(this, Timezone, _localTimezone)) {\n            (0,_swc_helpers_class_static_private_field_spec_set__WEBPACK_IMPORTED_MODULE_1__._)(this, Timezone, _localTimezone, Timezone.fromData({\n                tzid: \"floating\"\n            }));\n        }\n        return (0,_swc_helpers_class_static_private_field_spec_get__WEBPACK_IMPORTED_MODULE_0__._)(this, Timezone, _localTimezone);\n    }\n    /**\n   * Adjust a timezone change object.\n   * @private\n   * @param {Object} change     The timezone change object\n   * @param {Number} days       The extra amount of days\n   * @param {Number} hours      The extra amount of hours\n   * @param {Number} minutes    The extra amount of minutes\n   * @param {Number} seconds    The extra amount of seconds\n   */ static adjust_change(change, days, hours, minutes, seconds) {\n        return Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Component|Object} aData options for class\n   * @param {String|Component} aData.component\n   *        If aData is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} aData.tzid      The timezone identifier\n   * @param {String} aData.location  The timezone locationw\n   * @param {String} aData.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} aData.latitude  The latitude of the timezone\n   * @param {Number} aData.longitude The longitude of the timezone\n   */ fromData(aData) {\n        this.expandedUntilYear = 0;\n        this.changes = [];\n        if (aData instanceof Component) {\n            // Either a component is passed directly\n            this.component = aData;\n        } else {\n            // Otherwise the component may be in the data object\n            if (aData && \"component\" in aData) {\n                if (typeof aData.component == \"string\") {\n                    // If a string was passed, parse it as a component\n                    let jCal = parse(aData.component);\n                    this.component = new Component(jCal);\n                } else if (aData.component instanceof Component) {\n                    // If it was a component already, then just set it\n                    this.component = aData.component;\n                } else {\n                    // Otherwise just null out the component\n                    this.component = null;\n                }\n            }\n            // Copy remaining passed properties\n            for (let prop of OPTIONS){\n                if (aData && prop in aData) {\n                    this[prop] = aData[prop];\n                }\n            }\n        }\n        // If we have a component but no TZID, attempt to get it from the\n        // component's properties.\n        if (this.component instanceof Component && !this.tzid) {\n            this.tzid = this.component.getFirstPropertyValue(\"tzid\");\n        }\n        return this;\n    }\n    /**\n   * Finds the utcOffset the given time would occur in this timezone.\n   *\n   * @param {Time} tt         The time to check for\n   * @return {Number}         utc offset in seconds\n   */ utcOffset(tt) {\n        if (this == Timezone.utcTimezone || this == Timezone.localTimezone) {\n            return 0;\n        }\n        this._ensureCoverage(tt.year);\n        if (!this.changes.length) {\n            return 0;\n        }\n        let tt_change = {\n            year: tt.year,\n            month: tt.month,\n            day: tt.day,\n            hour: tt.hour,\n            minute: tt.minute,\n            second: tt.second\n        };\n        let change_num = this._findNearbyChange(tt_change);\n        let change_num_to_use = -1;\n        let step = 1;\n        // TODO: replace with bin search?\n        for(;;){\n            let change = clone(this.changes[change_num], true);\n            if (change.utcOffset < change.prevUtcOffset) {\n                Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n            } else {\n                Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n            }\n            let cmp = Timezone._compare_change_fn(tt_change, change);\n            if (cmp >= 0) {\n                change_num_to_use = change_num;\n            } else {\n                step = -1;\n            }\n            if (step == -1 && change_num_to_use != -1) {\n                break;\n            }\n            change_num += step;\n            if (change_num < 0) {\n                return 0;\n            }\n            if (change_num >= this.changes.length) {\n                break;\n            }\n        }\n        let zone_change = this.changes[change_num_to_use];\n        let utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n        if (utcOffset_change < 0 && change_num_to_use > 0) {\n            let tmp_change = clone(zone_change, true);\n            Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n            if (Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n                let prev_zone_change = this.changes[change_num_to_use - 1];\n                let want_daylight = false; // TODO\n                if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n                    zone_change = prev_zone_change;\n                }\n            }\n        }\n        // TODO return is_daylight?\n        return zone_change.utcOffset;\n    }\n    _findNearbyChange(change) {\n        // find the closest match\n        let idx = binsearchInsert(this.changes, change, Timezone._compare_change_fn);\n        if (idx >= this.changes.length) {\n            return this.changes.length - 1;\n        }\n        return idx;\n    }\n    _ensureCoverage(aYear) {\n        if (Timezone._minimumExpansionYear == -1) {\n            let today = Time.now();\n            Timezone._minimumExpansionYear = today.year;\n        }\n        let changesEndYear = aYear;\n        if (changesEndYear < Timezone._minimumExpansionYear) {\n            changesEndYear = Timezone._minimumExpansionYear;\n        }\n        changesEndYear += Timezone.EXTRA_COVERAGE;\n        if (!this.changes.length || this.expandedUntilYear < aYear) {\n            let subcomps = this.component.getAllSubcomponents();\n            let compLen = subcomps.length;\n            let compIdx = 0;\n            for(; compIdx < compLen; compIdx++){\n                this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n            }\n            this.changes.sort(Timezone._compare_change_fn);\n            this.expandedUntilYear = changesEndYear;\n        }\n    }\n    _expandComponent(aComponent, aYear, changes) {\n        if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n            return null;\n        }\n        let dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n        let change;\n        function convert_tzoffset(offset) {\n            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n        }\n        function init_changes() {\n            let changebase = {};\n            changebase.is_daylight = aComponent.name == \"daylight\";\n            changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n            changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n            return changebase;\n        }\n        if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n            change = init_changes();\n            change.year = dtstart.year;\n            change.month = dtstart.month;\n            change.day = dtstart.day;\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n            Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            changes.push(change);\n        } else {\n            let props = aComponent.getAllProperties(\"rdate\");\n            for (let rdate of props){\n                let time = rdate.getFirstValue();\n                change = init_changes();\n                change.year = time.year;\n                change.month = time.month;\n                change.day = time.day;\n                if (time.isDate) {\n                    change.hour = dtstart.hour;\n                    change.minute = dtstart.minute;\n                    change.second = dtstart.second;\n                    if (dtstart.zone != Timezone.utcTimezone) {\n                        Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                    }\n                } else {\n                    change.hour = time.hour;\n                    change.minute = time.minute;\n                    change.second = time.second;\n                    if (time.zone != Timezone.utcTimezone) {\n                        Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                    }\n                }\n                changes.push(change);\n            }\n            let rrule = aComponent.getFirstProperty(\"rrule\");\n            if (rrule) {\n                rrule = rrule.getFirstValue();\n                change = init_changes();\n                if (rrule.until && rrule.until.zone == Timezone.utcTimezone) {\n                    rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n                    rrule.until.zone = Timezone.localTimezone;\n                }\n                let iterator = rrule.iterator(dtstart);\n                let occ;\n                while(occ = iterator.next()){\n                    change = init_changes();\n                    if (occ.year > aYear || !occ) {\n                        break;\n                    }\n                    change.year = occ.year;\n                    change.month = occ.month;\n                    change.day = occ.day;\n                    change.hour = occ.hour;\n                    change.minute = occ.minute;\n                    change.second = occ.second;\n                    change.isDate = occ.isDate;\n                    Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n                    changes.push(change);\n                }\n            }\n        }\n        return changes;\n    }\n    /**\n   * The string representation of this timezone.\n   * @return {String}\n   */ toString() {\n        return this.tznames ? this.tznames : this.tzid;\n    }\n    /**\n   * Creates a new ICAL.Timezone instance, by passing in a tzid and component.\n   *\n   * @param {Component|Object} data options for class\n   * @param {String|Component} data.component\n   *        If data is a simple object, then this member can be set to either a\n   *        string containing the component data, or an already parsed\n   *        ICAL.Component\n   * @param {String} data.tzid      The timezone identifier\n   * @param {String} data.location  The timezone locationw\n   * @param {String} data.tznames   An alternative string representation of the\n   *                                  timezone\n   * @param {Number} data.latitude  The latitude of the timezone\n   * @param {Number} data.longitude The longitude of the timezone\n   */ constructor(data){\n        /**\n   * Timezone identifier\n   * @type {String}\n   */ this.tzid = \"\";\n        /**\n   * Timezone location\n   * @type {String}\n   */ this.location = \"\";\n        /**\n   * Alternative timezone name, for the string representation\n   * @type {String}\n   */ this.tznames = \"\";\n        /**\n   * The primary latitude for the timezone.\n   * @type {Number}\n   */ this.latitude = 0.0;\n        /**\n   * The primary longitude for the timezone.\n   * @type {Number}\n   */ this.longitude = 0.0;\n        /**\n   * The vtimezone component for this timezone.\n   * @type {Component}\n   */ this.component = null;\n        /**\n   * The year this timezone has been expanded to. All timezone transition\n   * dates until this year are known and can be used for calculation\n   *\n   * @private\n   * @type {Number}\n   */ this.expandedUntilYear = 0;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icaltimezone\"\n   */ this.icalclass = \"icaltimezone\";\n        this.wrappedJSObject = this;\n        this.fromData(data);\n    }\n}\n/**\n   * The instance describing the UTC timezone\n   * @type {Timezone}\n   * @constant\n   * @instance\n   */ var _utcTimezone = {\n    writable: true,\n    value: null\n};\n/**\n   * The instance describing the local timezone\n   * @type {Timezone}\n   * @constant\n   * @instance\n   */ var _localTimezone = {\n    writable: true,\n    value: null\n};\nTimezone._minimumExpansionYear = -1;\nTimezone.EXTRA_COVERAGE = 5;\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ let zones = null;\n/**\n * @classdesc\n * Singleton class to contain timezones.  Right now it is all manual registry in\n * the future we may use this class to download timezone information or handle\n * loading pre-expanded timezones.\n *\n * @exports module:ICAL.TimezoneService\n * @memberof ICAL\n */ const TimezoneService = {\n    get count () {\n        if (zones === null) {\n            return 0;\n        }\n        return Object.keys(zones).length;\n    },\n    reset: function() {\n        zones = Object.create(null);\n        let utc = Timezone.utcTimezone;\n        zones.Z = utc;\n        zones.UTC = utc;\n        zones.GMT = utc;\n    },\n    _hard_reset: function() {\n        zones = null;\n    },\n    /**\n   * Checks if timezone id has been registered.\n   *\n   * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n   * @return {Boolean}        False, when not present\n   */ has: function(tzid) {\n        if (zones === null) {\n            return false;\n        }\n        return !!zones[tzid];\n    },\n    /**\n   * Returns a timezone by its tzid if present.\n   *\n   * @param {String} tzid               Timezone identifier (e.g. America/Los_Angeles)\n   * @return {Timezone | undefined}     The timezone, or undefined if not found\n   */ get: function(tzid) {\n        if (zones === null) {\n            this.reset();\n        }\n        return zones[tzid];\n    },\n    /**\n   * Registers a timezone object or component.\n   *\n   * @param {Component|Timezone} timezone\n   *        The initialized zone or vtimezone.\n   *\n   * @param {String=} name\n   *        The name of the timezone. Defaults to the component's TZID if not\n   *        passed.\n   */ register: function(timezone, name) {\n        if (zones === null) {\n            this.reset();\n        }\n        // This avoids a breaking change by the change of argument order\n        // TODO remove in v3\n        if (typeof timezone === \"string\" && name instanceof Timezone) {\n            [timezone, name] = [\n                name,\n                timezone\n            ];\n        }\n        if (!name) {\n            if (timezone instanceof Timezone) {\n                name = timezone.tzid;\n            } else {\n                if (timezone.name === \"vtimezone\") {\n                    timezone = new Timezone(timezone);\n                    name = timezone.tzid;\n                }\n            }\n        }\n        if (!name) {\n            throw new TypeError(\"Neither a timezone nor a name was passed\");\n        }\n        if (timezone instanceof Timezone) {\n            zones[name] = timezone;\n        } else {\n            throw new TypeError(\"timezone must be ICAL.Timezone or ICAL.Component\");\n        }\n    },\n    /**\n   * Removes a timezone by its tzid from the list.\n   *\n   * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\n   * @return {?Timezone}      The removed timezone, or null if not registered\n   */ remove: function(tzid) {\n        if (zones === null) {\n            return null;\n        }\n        return delete zones[tzid];\n    }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Helper functions used in various places within ical.js\n * @module ICAL.helpers\n */ /**\n * Compiles a list of all referenced TZIDs in all subcomponents and\n * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\n * are referenced by a component, but a VTIMEZONE does not exist,\n * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\n *\n * @param {Component} vcal     The top-level VCALENDAR component.\n * @return {Component}         The ICAL.Component that was passed in.\n */ function updateTimezones(vcal) {\n    let allsubs, properties, vtimezones, reqTzid, i;\n    if (!vcal || vcal.name !== \"vcalendar\") {\n        //not a top-level vcalendar component\n        return vcal;\n    }\n    //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n    for(i = 0; i < allsubs.length; i++){\n        if (allsubs[i].name === \"vtimezone\") {\n            let tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n            vtimezones[tzid] = allsubs[i];\n        } else {\n            properties = properties.concat(allsubs[i].getAllProperties());\n        }\n    }\n    //create an object with one entry for each required tz\n    reqTzid = {};\n    for(i = 0; i < properties.length; i++){\n        let tzid = properties[i].getParameter(\"tzid\");\n        if (tzid) {\n            reqTzid[tzid] = true;\n        }\n    }\n    //delete any vtimezones that are not on the reqTzid list.\n    for (let [tzid, comp] of Object.entries(vtimezones)){\n        if (!reqTzid[tzid]) {\n            vcal.removeSubcomponent(comp);\n        }\n    }\n    //create any missing, but registered timezones\n    for (let tzid of Object.keys(reqTzid)){\n        if (!vtimezones[tzid] && TimezoneService.has(tzid)) {\n            vcal.addSubcomponent(TimezoneService.get(tzid).component);\n        }\n    }\n    return vcal;\n}\n/**\n * Checks if the given type is of the number type and also NaN.\n *\n * @param {Number} number     The number to check\n * @return {Boolean}          True, if the number is strictly NaN\n */ function isStrictlyNaN(number) {\n    return typeof number === \"number\" && isNaN(number);\n}\n/**\n * Parses a string value that is expected to be an integer, when the valid is\n * not an integer throws a decoration error.\n *\n * @param {String} string     Raw string input\n * @return {Number}           Parsed integer\n */ function strictParseInt(string) {\n    let result = parseInt(string, 10);\n    if (isStrictlyNaN(result)) {\n        throw new Error('Could not extract integer from \"' + string + '\"');\n    }\n    return result;\n}\n/**\n * Creates or returns a class instance of a given type with the initialization\n * data if the data is not already an instance of the given type.\n *\n * @example\n * var time = new ICAL.Time(...);\n * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\n *\n * (result instanceof ICAL.Time)\n * // => true\n *\n * result = ICAL.helpers.formatClassType({}, ICAL.Time);\n * (result isntanceof ICAL.Time)\n * // => true\n *\n *\n * @param {Object} data       object initialization data\n * @param {Object} type       object type (like ICAL.Time)\n * @return {?}                An instance of the found type.\n */ function formatClassType(data, type) {\n    if (typeof data === \"undefined\") {\n        return undefined;\n    }\n    if (data instanceof type) {\n        return data;\n    }\n    return new type(data);\n}\n/**\n * Identical to indexOf but will only match values when they are not preceded\n * by a backslash character.\n *\n * @param {String} buffer         String to search\n * @param {String} search         Value to look for\n * @param {Number} pos            Start position\n * @return {Number}               The position, or -1 if not found\n */ function unescapedIndexOf(buffer, search, pos) {\n    while((pos = buffer.indexOf(search, pos)) !== -1){\n        if (pos > 0 && buffer[pos - 1] === \"\\\\\") {\n            pos += 1;\n        } else {\n            return pos;\n        }\n    }\n    return -1;\n}\n/**\n * Find the index for insertion using binary search.\n *\n * @param {Array} list            The list to search\n * @param {?} seekVal             The value to insert\n * @param {function(?,?)} cmpfunc The comparison func, that can\n *                                  compare two seekVals\n * @return {Number}               The insert position\n */ function binsearchInsert(list, seekVal, cmpfunc) {\n    if (!list.length) return 0;\n    let low = 0, high = list.length - 1, mid, cmpval;\n    while(low <= high){\n        mid = low + Math.floor((high - low) / 2);\n        cmpval = cmpfunc(seekVal, list[mid]);\n        if (cmpval < 0) high = mid - 1;\n        else if (cmpval > 0) low = mid + 1;\n        else break;\n    }\n    if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0) return mid + 1;\n    else return mid;\n}\n/**\n * Clone the passed object or primitive. By default a shallow clone will be\n * executed.\n *\n * @param {*} aSrc            The thing to clone\n * @param {Boolean=} aDeep    If true, a deep clone will be performed\n * @return {*}                The copy of the thing\n */ function clone(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n        return aSrc;\n    } else if (aSrc instanceof Date) {\n        return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n        return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n        let arr = [];\n        for(let i = 0; i < aSrc.length; i++){\n            arr.push(aDeep ? clone(aSrc[i], true) : aSrc[i]);\n        }\n        return arr;\n    } else {\n        let obj = {};\n        for (let [name, value] of Object.entries(aSrc)){\n            if (aDeep) {\n                obj[name] = clone(value, true);\n            } else {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n}\n/**\n * Performs iCalendar line folding. A line ending character is inserted and\n * the next line begins with a whitespace.\n *\n * @example\n * SUMMARY:This line will be fold\n *  ed right in the middle of a word.\n *\n * @param {String} aLine      The line to fold\n * @return {String}           The folded line\n */ function foldline(aLine) {\n    let result = \"\";\n    let line = aLine || \"\", pos = 0, line_length = 0;\n    //pos counts position in line for the UTF-16 presentation\n    //line_length counts the bytes for the UTF-8 presentation\n    while(line.length){\n        let cp = line.codePointAt(pos);\n        if (cp < 128) ++line_length;\n        else if (cp < 2048) line_length += 2; //needs 2 UTF-8 bytes\n        else if (cp < 65536) line_length += 3;\n        else line_length += 4; //cp is less than 1114112\n        if (line_length < ICALmodule.foldLength + 1) pos += cp > 65535 ? 2 : 1;\n        else {\n            result += ICALmodule.newLineChar + \" \" + line.slice(0, Math.max(0, pos));\n            line = line.slice(Math.max(0, pos));\n            pos = line_length = 0;\n        }\n    }\n    return result.slice(ICALmodule.newLineChar.length + 1);\n}\n/**\n * Pads the given string or number with zeros so it will have at least two\n * characters.\n *\n * @param {String|Number} data    The string or number to pad\n * @return {String}               The number padded as a string\n */ function pad2(data) {\n    if (typeof data !== \"string\") {\n        // handle fractions.\n        if (typeof data === \"number\") {\n            data = parseInt(data);\n        }\n        data = String(data);\n    }\n    let len = data.length;\n    switch(len){\n        case 0:\n            return \"00\";\n        case 1:\n            return \"0\" + data;\n        default:\n            return data;\n    }\n}\n/**\n * Truncates the given number, correctly handling negative numbers.\n *\n * @param {Number} number     The number to truncate\n * @return {Number}           The truncated number\n */ function trunc(number) {\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n}\n/**\n * Poor-man's cross-browser object extension. Doesn't support all the\n * features, but enough for our usage. Note that the target's properties are\n * not overwritten with the source properties.\n *\n * @example\n * var child = ICAL.helpers.extend(parent, {\n *   \"bar\": 123\n * });\n *\n * @param {Object} source     The object to extend\n * @param {Object} target     The object to extend with\n * @return {Object}           Returns the target.\n */ function extend(source, target) {\n    for(let key in source){\n        let descr = Object.getOwnPropertyDescriptor(source, key);\n        if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n            Object.defineProperty(target, key, descr);\n        }\n    }\n    return target;\n}\nvar helpers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    updateTimezones: updateTimezones,\n    isStrictlyNaN: isStrictlyNaN,\n    strictParseInt: strictParseInt,\n    formatClassType: formatClassType,\n    unescapedIndexOf: unescapedIndexOf,\n    binsearchInsert: binsearchInsert,\n    clone: clone,\n    foldline: foldline,\n    pad2: pad2,\n    trunc: trunc,\n    extend: extend\n});\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This class represents the \"utc-offset\" value type, with various calculation and manipulation\n * methods.\n *\n * @memberof ICAL\n */ class UtcOffset {\n    /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\n   *\n   * @param {String} aString    The string to parse\n   * @return {Duration}         The created utc-offset instance\n   */ static fromString(aString) {\n        // -05:00\n        let options = {};\n        //TODO: support seconds per rfc5545 ?\n        options.factor = aString[0] === \"+\" ? 1 : -1;\n        options.hours = strictParseInt(aString.slice(1, 3));\n        options.minutes = strictParseInt(aString.slice(4, 6));\n        return new UtcOffset(options);\n    }\n    /**\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\n   * value.\n   *\n   * @param {Number} aSeconds       The number of seconds to convert\n   */ static fromSeconds(aSeconds) {\n        let instance = new UtcOffset();\n        instance.fromSeconds(aSeconds);\n        return instance;\n    }\n    /**\n   * Returns a clone of the utc offset object.\n   *\n   * @return {UtcOffset}     The cloned object\n   */ clone() {\n        return UtcOffset.fromSeconds(this.toSeconds());\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */ fromData(aData) {\n        if (aData) {\n            for (let [key, value] of Object.entries(aData)){\n                this[key] = value;\n            }\n        }\n        this._normalize();\n    }\n    /**\n   * Sets up the current instance from the given seconds value. The seconds\n   * value is truncated to the minute. Offsets are wrapped when the world\n   * ends, the hour after UTC+14:00 is UTC-12:00.\n   *\n   * @param {Number} aSeconds         The seconds to convert into an offset\n   */ fromSeconds(aSeconds) {\n        let secs = Math.abs(aSeconds);\n        this.factor = aSeconds < 0 ? -1 : 1;\n        this.hours = trunc(secs / 3600);\n        secs -= this.hours * 3600;\n        this.minutes = trunc(secs / 60);\n        return this;\n    }\n    /**\n   * Convert the current offset to a value in seconds\n   *\n   * @return {Number}                 The offset in seconds\n   */ toSeconds() {\n        return this.factor * (60 * this.minutes + 3600 * this.hours);\n    }\n    /**\n   * Compare this utc offset with another one.\n   *\n   * @param {UtcOffset} other             The other offset to compare with\n   * @return {Number}                     -1, 0 or 1 for less/equal/greater\n   */ compare(other) {\n        let a = this.toSeconds();\n        let b = other.toSeconds();\n        return (a > b) - (b > a);\n    }\n    _normalize() {\n        // Range: 97200 seconds (with 1 hour inbetween)\n        let secs = this.toSeconds();\n        let factor = this.factor;\n        while(secs < -43200){\n            secs += 97200;\n        }\n        while(secs > 50400){\n            secs -= 97200;\n        }\n        this.fromSeconds(secs);\n        // Avoid changing the factor when on zero seconds\n        if (secs == 0) {\n            this.factor = factor;\n        }\n    }\n    /**\n   * The iCalendar string representation of this utc-offset.\n   * @return {String}\n   */ toICALString() {\n        return design$1.icalendar.value[\"utc-offset\"].toICAL(this.toString());\n    }\n    /**\n   * The string representation of this utc-offset.\n   * @return {String}\n   */ toString() {\n        return (this.factor == 1 ? \"+\" : \"-\") + pad2(this.hours) + \":\" + pad2(this.minutes);\n    }\n    /**\n   * Creates a new ICAL.UtcOffset instance.\n   *\n   * @param {Object} aData          An object with members of the utc offset\n   * @param {Number=} aData.hours   The hours for the utc offset\n   * @param {Number=} aData.minutes The minutes in the utc offset\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\n   */ constructor(aData){\n        /**\n   * The hours in the utc-offset\n   * @type {Number}\n   */ this.hours = 0;\n        /**\n   * The minutes in the utc-offset\n   * @type {Number}\n   */ this.minutes = 0;\n        /**\n   * The sign of the utc offset, 1 for positive offset, -1 for negative\n   * offsets.\n   * @type {Number}\n   */ this.factor = 1;\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"utc-offset\"\n   */ this.icaltype = \"utc-offset\";\n        this.fromData(aData);\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Describes a vCard time, which has slight differences to the ICAL.Time.\n * Properties can be null if not specified, for example for dates with\n * reduced accuracy or truncation.\n *\n * Note that currently not all methods are correctly re-implemented for\n * VCardTime. For example, comparison will have undefined results when some\n * members are null.\n *\n * Also, normalization is not yet implemented for this class!\n *\n * @memberof ICAL\n * @extends {ICAL.Time}\n */ class VCardTime extends Time {\n    /**\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\n   *\n   * @param {String} aValue     The string to create from\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\n   * @return {VCardTime}        The date/time instance\n   */ static fromDateAndOrTimeString(aValue, aIcalType) {\n        function part(v, s, e) {\n            return v ? strictParseInt(v.slice(s, s + e)) : null;\n        }\n        let parts = aValue.split(\"T\");\n        let dt = parts[0], tmz = parts[1];\n        let splitzone = tmz ? design$1.vcard.value.time._splitZone(tmz) : [];\n        let zone = splitzone[0], tm = splitzone[1];\n        let dtlen = dt ? dt.length : 0;\n        let tmlen = tm ? tm.length : 0;\n        let hasDashDate = dt && dt[0] == \"-\" && dt[1] == \"-\";\n        let hasDashTime = tm && tm[0] == \"-\";\n        let o = {\n            year: hasDashDate ? null : part(dt, 0, 4),\n            month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n            day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n            hour: hasDashTime ? null : part(tm, 0, 2),\n            minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n            second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n        };\n        if (zone == \"Z\") {\n            zone = Timezone.utcTimezone;\n        } else if (zone && zone[3] == \":\") {\n            zone = UtcOffset.fromString(zone);\n        } else {\n            zone = null;\n        }\n        return new VCardTime(o, zone, aIcalType);\n    }\n    /**\n   * Returns a clone of the vcard date/time object.\n   *\n   * @return {VCardTime}     The cloned object\n   */ clone() {\n        return new VCardTime(this._time, this.zone, this.icaltype);\n    }\n    _normalize() {\n        return this;\n    }\n    /**\n   * @inheritdoc\n   */ utcOffset() {\n        if (this.zone instanceof UtcOffset) {\n            return this.zone.toSeconds();\n        } else {\n            return Time.prototype.utcOffset.apply(this, arguments);\n        }\n    }\n    /**\n   * Returns an RFC 6350 compliant representation of this object.\n   *\n   * @return {String}         vcard date/time string\n   */ toICALString() {\n        return design$1.vcard.value[this.icaltype].toICAL(this.toString());\n    }\n    /**\n   * The string representation of this date/time, in jCard form\n   * (including : and - separators).\n   * @return {String}\n   */ toString() {\n        let y = this.year, m = this.month, d = this.day;\n        let h = this.hour, mm = this.minute, s = this.second;\n        let hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\n        let hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\n        let datepart = (hasYear ? pad2(y) + (hasMonth || hasDay ? \"-\" : \"\") : hasMonth || hasDay ? \"--\" : \"\") + (hasMonth ? pad2(m) : \"\") + (hasDay ? \"-\" + pad2(d) : \"\");\n        let timepart = (hasHour ? pad2(h) : \"-\") + (hasHour && hasMinute ? \":\" : \"\") + (hasMinute ? pad2(mm) : \"\") + (!hasHour && !hasMinute ? \"-\" : \"\") + (hasMinute && hasSecond ? \":\" : \"\") + (hasSecond ? pad2(s) : \"\");\n        let zone;\n        if (this.zone === Timezone.utcTimezone) {\n            zone = \"Z\";\n        } else if (this.zone instanceof UtcOffset) {\n            zone = this.zone.toString();\n        } else if (this.zone === Timezone.localTimezone) {\n            zone = \"\";\n        } else if (this.zone instanceof Timezone) {\n            let offset = UtcOffset.fromSeconds(this.zone.utcOffset(this));\n            zone = offset.toString();\n        } else {\n            zone = \"\";\n        }\n        switch(this.icaltype){\n            case \"time\":\n                return timepart + zone;\n            case \"date-and-or-time\":\n            case \"date-time\":\n                return datepart + (timepart == \"--\" ? \"\" : \"T\" + timepart + zone);\n            case \"date\":\n                return datepart;\n        }\n        return null;\n    }\n    /**\n   * Creates a new ICAL.VCardTime instance.\n   *\n   * @param {Object} data                           The data for the time instance\n   * @param {Number=} data.year                     The year for this date\n   * @param {Number=} data.month                    The month for this date\n   * @param {Number=} data.day                      The day for this date\n   * @param {Number=} data.hour                     The hour for this date\n   * @param {Number=} data.minute                   The minute for this date\n   * @param {Number=} data.second                   The second for this date\n   * @param {Timezone|UtcOffset} zone               The timezone to use\n   * @param {String} icaltype                       The type for this date/time object\n   */ constructor(data, zone, icaltype){\n        super(data, zone);\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"vcardtime\"\n   */ this.icalclass = \"vcardtime\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @type {String}\n   * @default \"date-and-or-time\"\n   */ this.icaltype = \"date-and-or-time\";\n        this.icaltype = icaltype || \"date-and-or-time\";\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").weekDay} weekDay\n * Imports the 'weekDay' type from the \"types.js\" module\n */ /**\n * An iterator for a single recurrence rule. This class usually doesn't have to be instanciated\n * directly, the convenience method {@link ICAL.Recur#iterator} can be used.\n *\n * @memberof ICAL\n */ class RecurIterator {\n    /**\n   * Initialize the recurrence iterator from the passed data object. This\n   * method is usually not called directly, you can initialize the iterator\n   * through the constructor.\n   *\n   * @param {Object} options                The iterator options\n   * @param {Recur} options.rule            The rule to iterate.\n   * @param {Time} options.dtstart          The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */ fromData(options) {\n        this.rule = formatClassType(options.rule, Recur);\n        if (!this.rule) {\n            throw new Error(\"iterator requires a (ICAL.Recur) rule\");\n        }\n        this.dtstart = formatClassType(options.dtstart, Time);\n        if (!this.dtstart) {\n            throw new Error(\"iterator requires a (ICAL.Time) dtstart\");\n        }\n        if (options.by_data) {\n            this.by_data = options.by_data;\n        } else {\n            this.by_data = clone(this.rule.parts, true);\n        }\n        if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n        this.days = options.days || [];\n        if (options.last) {\n            this.last = formatClassType(options.last, Time);\n        }\n        this.by_indices = options.by_indices;\n        if (!this.by_indices) {\n            this.by_indices = {\n                \"BYSECOND\": 0,\n                \"BYMINUTE\": 0,\n                \"BYHOUR\": 0,\n                \"BYDAY\": 0,\n                \"BYMONTH\": 0,\n                \"BYWEEKNO\": 0,\n                \"BYMONTHDAY\": 0\n            };\n        }\n        this.initialized = options.initialized || false;\n        if (!this.initialized) {\n            try {\n                this.init();\n            } catch (e) {\n                if (e instanceof InvalidRecurrenceRuleError) {\n                    // Init may error if there are no possible recurrence instances from\n                    // the rule, but we don't want to bubble this error up. Instead, we\n                    // create an empty iterator.\n                    this.completed = true;\n                } else {\n                    // Propagate other errors to consumers.\n                    throw e;\n                }\n            }\n        }\n    }\n    /**\n   * Initialize the iterator\n   * @private\n   */ init() {\n        this.initialized = true;\n        this.last = this.dtstart.clone();\n        let parts = this.by_data;\n        if (\"BYDAY\" in parts) {\n            // libical does this earlier when the rule is loaded, but we postpone to\n            // now so we can preserve the original order.\n            this.sort_byday_rules(parts.BYDAY);\n        }\n        // If the BYYEARDAY appares, no other date rule part may appear\n        if (\"BYYEARDAY\" in parts) {\n            if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n                throw new Error(\"Invalid BYYEARDAY rule\");\n            }\n        }\n        // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n        if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n            throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n        }\n        // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n        // BYWEEKNO may appear.\n        if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n            throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n        }\n        // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n        // BYYEARDAY may appear.\n        if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n            throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n        }\n        // BYYEARDAY may only appear in YEARLY rules\n        if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n            throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n        }\n        this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n        this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n        this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n        this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n        this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n        if (this.rule.freq == \"WEEKLY\") {\n            if (\"BYDAY\" in parts) {\n                let [, dow] = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n                let wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n                if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n                    // Initial time is after first day of BYDAY data\n                    this.last.day += wkdy;\n                }\n            } else {\n                let dayName = Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n                parts.BYDAY = [\n                    dayName\n                ];\n            }\n        }\n        if (this.rule.freq == \"YEARLY\") {\n            // Some yearly recurrence rules may be specific enough to not actually\n            // occur on a yearly basis, e.g. the 29th day of February or the fifth\n            // Monday of a given month. The standard isn't clear on the intended\n            // behavior in these cases, but `libical` at least will iterate until it\n            // finds a matching year.\n            // CAREFUL: Some rules may specify an occurrence that can never happen,\n            // e.g. the first Monday of April so long as it falls on the 15th\n            // through the 21st. Detecting these is non-trivial, so ensure that we\n            // stop iterating at some point.\n            const untilYear = this.rule.until ? this.rule.until.year : 20000;\n            while(this.last.year <= untilYear){\n                this.expand_year_days(this.last.year);\n                if (this.days.length > 0) {\n                    break;\n                }\n                this.increment_year(this.rule.interval);\n            }\n            if (this.days.length == 0) {\n                throw new InvalidRecurrenceRuleError();\n            }\n            this._nextByYearDay();\n        }\n        if (this.rule.freq == \"MONTHLY\") {\n            if (this.has_by_data(\"BYDAY\")) {\n                let tempLast = null;\n                let initLast = this.last.clone();\n                let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n                // Check every weekday in BYDAY with relative dow and pos.\n                for (let bydow of this.by_data.BYDAY){\n                    this.last = initLast.clone();\n                    let [pos, dow] = this.ruleDayOfWeek(bydow);\n                    let dayOfMonth = this.last.nthWeekDay(dow, pos);\n                    // If |pos| >= 6, the byday is invalid for a monthly rule.\n                    if (pos >= 6 || pos <= -6) {\n                        throw new Error(\"Malformed values in BYDAY part\");\n                    }\n                    // If a Byday with pos=+/-5 is not in the current month it\n                    // must be searched in the next months.\n                    if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n                        // Skip if we have already found a \"last\" in this month.\n                        if (tempLast && tempLast.month == initLast.month) {\n                            continue;\n                        }\n                        while(dayOfMonth > daysInMonth || dayOfMonth <= 0){\n                            this.increment_month();\n                            daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n                            dayOfMonth = this.last.nthWeekDay(dow, pos);\n                        }\n                    }\n                    this.last.day = dayOfMonth;\n                    if (!tempLast || this.last.compare(tempLast) < 0) {\n                        tempLast = this.last.clone();\n                    }\n                }\n                this.last = tempLast.clone();\n                //XXX: This feels like a hack, but we need to initialize\n                //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n                //     this case. It accepts a special flag which will avoid incrementing\n                //     the initial value without the flag days that match the start time\n                //     would be missed.\n                if (this.has_by_data(\"BYMONTHDAY\")) {\n                    this._byDayAndMonthDay(true);\n                }\n                if (this.last.day > daysInMonth || this.last.day == 0) {\n                    throw new Error(\"Malformed values in BYDAY part\");\n                }\n            } else if (this.has_by_data(\"BYMONTHDAY\")) {\n                // Change the day value so that normalisation won't change the month.\n                this.last.day = 1;\n                // Get a sorted list of days in the starting month that match the rule.\n                let normalized = this.normalizeByMonthDayRules(this.last.year, this.last.month, this.rule.parts.BYMONTHDAY).filter((d)=>d >= this.last.day);\n                if (normalized.length) {\n                    // There's at least one valid day, use it.\n                    this.last.day = normalized[0];\n                    this.by_data.BYMONTHDAY = normalized;\n                } else {\n                    // There's no occurrence in this month, find the next valid month.\n                    // The longest possible sequence of skipped months is February-April-June,\n                    // so we might need to call next_month up to three times.\n                    if (!this.next_month() && !this.next_month() && !this.next_month()) {\n                        throw new Error(\"No possible occurrences\");\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Retrieve the next occurrence from the iterator.\n   * @return {Time}\n   */ next() {\n        let again = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        let before = this.last ? this.last.clone() : null;\n        if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n            this.completed = true;\n        }\n        if (this.completed) {\n            return null;\n        }\n        if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n            // First of all, give the instance that was initialized\n            this.occurrence_number++;\n            return this.last;\n        }\n        let valid;\n        do {\n            valid = 1;\n            switch(this.rule.freq){\n                case \"SECONDLY\":\n                    this.next_second();\n                    break;\n                case \"MINUTELY\":\n                    this.next_minute();\n                    break;\n                case \"HOURLY\":\n                    this.next_hour();\n                    break;\n                case \"DAILY\":\n                    this.next_day();\n                    break;\n                case \"WEEKLY\":\n                    this.next_week();\n                    break;\n                case \"MONTHLY\":\n                    valid = this.next_month();\n                    break;\n                case \"YEARLY\":\n                    this.next_year();\n                    break;\n                default:\n                    return null;\n            }\n        }while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);\n        if (this.last.compare(before) == 0) {\n            if (again) {\n                throw new Error(\"Same occurrence found twice, protecting you from death by recursion\");\n            }\n            this.next(true);\n        }\n        if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n            this.completed = true;\n            return null;\n        } else {\n            this.occurrence_number++;\n            return this.last;\n        }\n    }\n    next_second() {\n        return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    }\n    increment_second(inc) {\n        return this.increment_generic(inc, \"second\", 60, \"minute\");\n    }\n    next_minute() {\n        return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n    }\n    increment_minute(inc) {\n        return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    }\n    next_hour() {\n        return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n    }\n    increment_hour(inc) {\n        this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    }\n    next_day() {\n        let this_freq = this.rule.freq == \"DAILY\";\n        if (this.next_hour() == 0) {\n            return 0;\n        }\n        if (this_freq) {\n            this.increment_monthday(this.rule.interval);\n        } else {\n            this.increment_monthday(1);\n        }\n        return 0;\n    }\n    next_week() {\n        let end_of_data = 0;\n        if (this.next_weekday_by_week() == 0) {\n            return end_of_data;\n        }\n        if (this.has_by_data(\"BYWEEKNO\")) {\n            this.by_indices.BYWEEKNO++;\n            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n                this.by_indices.BYWEEKNO = 0;\n                end_of_data = 1;\n            }\n            // HACK should be first month of the year\n            this.last.month = 1;\n            this.last.day = 1;\n            let week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n            this.last.day += 7 * week_no;\n            if (end_of_data) {\n                this.increment_year(1);\n            }\n        } else {\n            // Jump to the next week\n            this.increment_monthday(7 * this.rule.interval);\n        }\n        return end_of_data;\n    }\n    /**\n   * Normalize each by day rule for a given year/month.\n   * Takes into account ordering and negative rules\n   *\n   * @private\n   * @param {Number} year         Current year.\n   * @param {Number} month        Current month.\n   * @param {Array}  rules        Array of rules.\n   *\n   * @return {Array} sorted and normalized rules.\n   *                 Negative rules will be expanded to their\n   *                 correct positive values for easier processing.\n   */ normalizeByMonthDayRules(year, month, rules) {\n        let daysInMonth = Time.daysInMonth(month, year);\n        // XXX: This is probably bad for performance to allocate\n        //      a new array for each month we scan, if possible\n        //      we should try to optimize this...\n        let newRules = [];\n        let ruleIdx = 0;\n        let len = rules.length;\n        let rule;\n        for(; ruleIdx < len; ruleIdx++){\n            rule = parseInt(rules[ruleIdx], 10);\n            if (isNaN(rule)) {\n                throw new Error(\"Invalid BYMONTHDAY value\");\n            }\n            // if this rule falls outside of given\n            // month discard it.\n            if (Math.abs(rule) > daysInMonth) {\n                continue;\n            }\n            // negative case\n            if (rule < 0) {\n                // we add (not subtract it is a negative number)\n                // one from the rule because 1 === last day of month\n                rule = daysInMonth + (rule + 1);\n            } else if (rule === 0) {\n                continue;\n            }\n            // only add unique items...\n            if (newRules.indexOf(rule) === -1) {\n                newRules.push(rule);\n            }\n        }\n        // unique and sort\n        return newRules.sort(function(a, b) {\n            return a - b;\n        });\n    }\n    /**\n   * NOTES:\n   * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\n   * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\n   * both conditions match a given date (this.last.day) iteration stops.\n   *\n   * @private\n   * @param {Boolean=} isInit     When given true will not increment the\n   *                                current day (this.last).\n   */ _byDayAndMonthDay(isInit) {\n        let byMonthDay; // setup in initMonth\n        let byDay = this.by_data.BYDAY;\n        let date;\n        let dateIdx = 0;\n        let dateLen; // setup in initMonth\n        let dayLen = byDay.length;\n        // we are not valid by default\n        let dataIsValid = 0;\n        let daysInMonth;\n        let self = this;\n        // we need a copy of this, because a DateTime gets normalized\n        // automatically if the day is out of range. At some points we\n        // set the last day to 0 to start counting.\n        let lastDay = this.last.day;\n        function initMonth() {\n            daysInMonth = Time.daysInMonth(self.last.month, self.last.year);\n            byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n            dateLen = byMonthDay.length;\n            // For the case of more than one occurrence in one month\n            // we have to be sure to start searching after the last\n            // found date or at the last BYMONTHDAY, unless we are\n            // initializing the iterator because in this case we have\n            // to consider the last found date too.\n            while(byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1){\n                dateIdx++;\n            }\n        }\n        function nextMonth() {\n            // since the day is incremented at the start\n            // of the loop below, we need to start at 0\n            lastDay = 0;\n            self.increment_month();\n            dateIdx = 0;\n            initMonth();\n        }\n        initMonth();\n        // should come after initMonth\n        if (isInit) {\n            lastDay -= 1;\n        }\n        // Use a counter to avoid an infinite loop with malformed rules.\n        // Stop checking after 4 years so we consider also a leap year.\n        let monthsCounter = 48;\n        while(!dataIsValid && monthsCounter){\n            monthsCounter--;\n            // increment the current date. This is really\n            // important otherwise we may fall into the infinite\n            // loop trap. The initial date takes care of the case\n            // where the current date is the date we are looking\n            // for.\n            date = lastDay + 1;\n            if (date > daysInMonth) {\n                nextMonth();\n                continue;\n            }\n            // find next date\n            let next = byMonthDay[dateIdx++];\n            // this logic is dependent on the BYMONTHDAYS\n            // being in order (which is done by #normalizeByMonthDayRules)\n            if (next >= date) {\n                // if the next month day is in the future jump to it.\n                lastDay = next;\n            } else {\n                // in this case the 'next' monthday has past\n                // we must move to the month.\n                nextMonth();\n                continue;\n            }\n            // Now we can loop through the day rules to see\n            // if one matches the current month date.\n            for(let dayIdx = 0; dayIdx < dayLen; dayIdx++){\n                let parts = this.ruleDayOfWeek(byDay[dayIdx]);\n                let pos = parts[0];\n                let dow = parts[1];\n                this.last.day = lastDay;\n                if (this.last.isNthWeekDay(dow, pos)) {\n                    // when we find the valid one we can mark\n                    // the conditions as met and break the loop.\n                    // (Because we have this condition above\n                    //  it will also break the parent loop).\n                    dataIsValid = 1;\n                    break;\n                }\n            }\n            // It is completely possible that the combination\n            // cannot be matched in the current month.\n            // When we reach the end of possible combinations\n            // in the current month we iterate to the next one.\n            // since dateIdx is incremented right after getting\n            // \"next\", we don't need dateLen -1 here.\n            if (!dataIsValid && dateIdx === dateLen) {\n                nextMonth();\n                continue;\n            }\n        }\n        if (monthsCounter <= 0) {\n            // Checked 4 years without finding a Byday that matches\n            // a Bymonthday. Maybe the rule is not correct.\n            throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n        }\n        return dataIsValid;\n    }\n    next_month() {\n        let data_valid = 1;\n        if (this.next_hour() == 0) {\n            return data_valid;\n        }\n        if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n            data_valid = this._byDayAndMonthDay();\n        } else if (this.has_by_data(\"BYDAY\")) {\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            let setpos = 0;\n            let setpos_total = 0;\n            if (this.has_by_data(\"BYSETPOS\")) {\n                let last_day = this.last.day;\n                for(let day = 1; day <= daysInMonth; day++){\n                    this.last.day = day;\n                    if (this.is_day_in_byday(this.last)) {\n                        setpos_total++;\n                        if (day <= last_day) {\n                            setpos++;\n                        }\n                    }\n                }\n                this.last.day = last_day;\n            }\n            data_valid = 0;\n            let day;\n            for(day = this.last.day + 1; day <= daysInMonth; day++){\n                this.last.day = day;\n                if (this.is_day_in_byday(this.last)) {\n                    if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n                        data_valid = 1;\n                        break;\n                    }\n                }\n            }\n            if (day > daysInMonth) {\n                this.last.day = 1;\n                this.increment_month();\n                if (this.is_day_in_byday(this.last)) {\n                    if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n                        data_valid = 1;\n                    }\n                } else {\n                    data_valid = 0;\n                }\n            }\n        } else if (this.has_by_data(\"BYMONTHDAY\")) {\n            this.by_indices.BYMONTHDAY++;\n            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n                this.by_indices.BYMONTHDAY = 0;\n                this.increment_month();\n                if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n                    return 0;\n                }\n            }\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            let day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n            if (day < 0) {\n                day = daysInMonth + day + 1;\n            }\n            if (day > daysInMonth) {\n                this.last.day = 1;\n                data_valid = this.is_day_in_byday(this.last);\n            } else {\n                this.last.day = day;\n            }\n        } else {\n            this.increment_month();\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n                data_valid = 0;\n            } else {\n                this.last.day = this.by_data.BYMONTHDAY[0];\n            }\n        }\n        return data_valid;\n    }\n    next_weekday_by_week() {\n        let end_of_data = 0;\n        if (this.next_hour() == 0) {\n            return end_of_data;\n        }\n        if (!this.has_by_data(\"BYDAY\")) {\n            return 1;\n        }\n        for(;;){\n            let tt = new Time();\n            this.by_indices.BYDAY++;\n            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n                this.by_indices.BYDAY = 0;\n                end_of_data = 1;\n            }\n            let coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n            let parts = this.ruleDayOfWeek(coded_day);\n            let dow = parts[1];\n            dow -= this.rule.wkst;\n            if (dow < 0) {\n                dow += 7;\n            }\n            tt.year = this.last.year;\n            tt.month = this.last.month;\n            tt.day = this.last.day;\n            let startOfWeek = tt.startDoyWeek(this.rule.wkst);\n            if (dow + startOfWeek < 1) {\n                // The selected date is in the previous year\n                if (!end_of_data) {\n                    continue;\n                }\n            }\n            let next = Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n            /**\n       * The normalization horrors below are due to\n       * the fact that when the year/month/day changes\n       * it can effect the other operations that come after.\n       */ this.last.year = next.year;\n            this.last.month = next.month;\n            this.last.day = next.day;\n            return end_of_data;\n        }\n    }\n    next_year() {\n        if (this.next_hour() == 0) {\n            return 0;\n        }\n        if (++this.days_index == this.days.length) {\n            this.days_index = 0;\n            do {\n                this.increment_year(this.rule.interval);\n                if (this.has_by_data(\"BYMONTHDAY\")) {\n                    this.by_data.BYMONTHDAY = this.normalizeByMonthDayRules(this.last.year, this.last.month, this.rule.parts.BYMONTHDAY);\n                }\n                this.expand_year_days(this.last.year);\n            }while (this.days.length == 0);\n        }\n        this._nextByYearDay();\n        return 1;\n    }\n    _nextByYearDay() {\n        let doy = this.days[this.days_index];\n        let year = this.last.year;\n        if (doy < 1) {\n            // Time.fromDayOfYear(doy, year) indexes relative to the\n            // start of the given year. That is different from the\n            // semantics of BYYEARDAY where negative indexes are an\n            // offset from the end of the given year.\n            doy += 1;\n            year += 1;\n        }\n        let next = Time.fromDayOfYear(doy, year);\n        this.last.day = next.day;\n        this.last.month = next.month;\n    }\n    /**\n   * @param dow (eg: '1TU', '-1MO')\n   * @param {weekDay=} aWeekStart The week start weekday\n   * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\n   */ ruleDayOfWeek(dow, aWeekStart) {\n        let matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n        if (matches) {\n            let pos = parseInt(matches[1] || 0, 10);\n            dow = Recur.icalDayToNumericDay(matches[2], aWeekStart);\n            return [\n                pos,\n                dow\n            ];\n        } else {\n            return [\n                0,\n                0\n            ];\n        }\n    }\n    next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n        let has_by_rule = aRuleType in this.by_data;\n        let this_freq = this.rule.freq == aInterval;\n        let end_of_data = 0;\n        if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n            return end_of_data;\n        }\n        if (has_by_rule) {\n            this.by_indices[aRuleType]++;\n            let dta = this.by_data[aRuleType];\n            if (this.by_indices[aRuleType] == dta.length) {\n                this.by_indices[aRuleType] = 0;\n                end_of_data = 1;\n            }\n            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n        } else if (this_freq) {\n            this[\"increment_\" + aDateAttr](this.rule.interval);\n        }\n        if (has_by_rule && end_of_data && this_freq) {\n            this[\"increment_\" + aFollowingAttr](1);\n        }\n        return end_of_data;\n    }\n    increment_monthday(inc) {\n        for(let i = 0; i < inc; i++){\n            let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);\n            this.last.day++;\n            if (this.last.day > daysInMonth) {\n                this.last.day -= daysInMonth;\n                this.increment_month();\n            }\n        }\n    }\n    increment_month() {\n        this.last.day = 1;\n        if (this.has_by_data(\"BYMONTH\")) {\n            this.by_indices.BYMONTH++;\n            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n                this.by_indices.BYMONTH = 0;\n                this.increment_year(1);\n            }\n            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n        } else {\n            if (this.rule.freq == \"MONTHLY\") {\n                this.last.month += this.rule.interval;\n            } else {\n                this.last.month++;\n            }\n            this.last.month--;\n            let years = trunc(this.last.month / 12);\n            this.last.month %= 12;\n            this.last.month++;\n            if (years != 0) {\n                this.increment_year(years);\n            }\n        }\n        if (this.has_by_data(\"BYMONTHDAY\")) {\n            this.by_data.BYMONTHDAY = this.normalizeByMonthDayRules(this.last.year, this.last.month, this.rule.parts.BYMONTHDAY);\n        }\n    }\n    increment_year(inc) {\n        // Don't jump into the next month if this.last is Feb 29.\n        this.last.day = 1;\n        this.last.year += inc;\n    }\n    increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n        this.last[aDateAttr] += inc;\n        let nextunit = trunc(this.last[aDateAttr] / aFactor);\n        this.last[aDateAttr] %= aFactor;\n        if (nextunit != 0) {\n            this[\"increment_\" + aNextIncrement](nextunit);\n        }\n    }\n    has_by_data(aRuleType) {\n        return aRuleType in this.rule.parts;\n    }\n    expand_year_days(aYear) {\n        let t = new Time();\n        this.days = [];\n        // We need our own copy with a few keys set\n        let parts = {};\n        let rules = [\n            \"BYDAY\",\n            \"BYWEEKNO\",\n            \"BYMONTHDAY\",\n            \"BYMONTH\",\n            \"BYYEARDAY\"\n        ];\n        for (let part of rules){\n            if (part in this.rule.parts) {\n                parts[part] = this.rule.parts[part];\n            }\n        }\n        if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n            let valid = 1;\n            let validWeeks = {};\n            t.year = aYear;\n            t.isDate = true;\n            for(let monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++){\n                let month = this.by_data.BYMONTH[monthIdx];\n                t.month = month;\n                t.day = 1;\n                let first_week = t.weekNumber(this.rule.wkst);\n                t.day = Time.daysInMonth(month, aYear);\n                let last_week = t.weekNumber(this.rule.wkst);\n                for(monthIdx = first_week; monthIdx < last_week; monthIdx++){\n                    validWeeks[monthIdx] = 1;\n                }\n            }\n            for(let weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++){\n                let weekno = this.by_data.BYWEEKNO[weekIdx];\n                if (weekno < 52) {\n                    valid &= validWeeks[weekIdx];\n                } else {\n                    valid = 0;\n                }\n            }\n            if (valid) {\n                delete parts.BYMONTH;\n            } else {\n                delete parts.BYWEEKNO;\n            }\n        }\n        let partCount = Object.keys(parts).length;\n        if (partCount == 0) {\n            let t1 = this.dtstart.clone();\n            t1.year = this.last.year;\n            this.days.push(t1.dayOfYear());\n        } else if (partCount == 1 && \"BYMONTH\" in parts) {\n            for (let month of this.by_data.BYMONTH){\n                let t2 = this.dtstart.clone();\n                t2.year = aYear;\n                t2.month = month;\n                t2.isDate = true;\n                this.days.push(t2.dayOfYear());\n            }\n        } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n            for (let monthday of this.by_data.BYMONTHDAY){\n                let t3 = this.dtstart.clone();\n                if (monthday < 0) {\n                    let daysInMonth = Time.daysInMonth(t3.month, aYear);\n                    monthday = monthday + daysInMonth + 1;\n                }\n                t3.day = monthday;\n                t3.year = aYear;\n                t3.isDate = true;\n                this.days.push(t3.dayOfYear());\n            }\n        } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n            for (let month of this.by_data.BYMONTH){\n                let daysInMonth = Time.daysInMonth(month, aYear);\n                for (let monthday of this.by_data.BYMONTHDAY){\n                    if (monthday < 0) {\n                        monthday = monthday + daysInMonth + 1;\n                    }\n                    t.day = monthday;\n                    t.month = month;\n                    t.year = aYear;\n                    t.isDate = true;\n                    this.days.push(t.dayOfYear());\n                }\n            }\n        } else if (partCount == 1 && \"BYWEEKNO\" in parts) ;\n        else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) ;\n        else if (partCount == 1 && \"BYDAY\" in parts) {\n            this.days = this.days.concat(this.expand_by_day(aYear));\n        } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n            for (let month of this.by_data.BYMONTH){\n                let daysInMonth = Time.daysInMonth(month, aYear);\n                t.year = aYear;\n                t.month = month;\n                t.day = 1;\n                t.isDate = true;\n                let first_dow = t.dayOfWeek();\n                let doy_offset = t.dayOfYear() - 1;\n                t.day = daysInMonth;\n                let last_dow = t.dayOfWeek();\n                if (this.has_by_data(\"BYSETPOS\")) {\n                    let by_month_day = [];\n                    for(let day = 1; day <= daysInMonth; day++){\n                        t.day = day;\n                        if (this.is_day_in_byday(t)) {\n                            by_month_day.push(day);\n                        }\n                    }\n                    for(let spIndex = 0; spIndex < by_month_day.length; spIndex++){\n                        if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                            this.days.push(doy_offset + by_month_day[spIndex]);\n                        }\n                    }\n                } else {\n                    for (let coded_day of this.by_data.BYDAY){\n                        let bydayParts = this.ruleDayOfWeek(coded_day);\n                        let pos = bydayParts[0];\n                        let dow = bydayParts[1];\n                        let month_day;\n                        let first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n                        let last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n                        if (pos == 0) {\n                            for(let day = first_matching_day; day <= daysInMonth; day += 7){\n                                this.days.push(doy_offset + day);\n                            }\n                        } else if (pos > 0) {\n                            month_day = first_matching_day + (pos - 1) * 7;\n                            if (month_day <= daysInMonth) {\n                                this.days.push(doy_offset + month_day);\n                            }\n                        } else {\n                            month_day = last_matching_day + (pos + 1) * 7;\n                            if (month_day > 0) {\n                                this.days.push(doy_offset + month_day);\n                            }\n                        }\n                    }\n                }\n            }\n            // Return dates in order of occurrence (1,2,3,...) instead\n            // of by groups of weekdays (1,8,15,...,2,9,16,...).\n            this.days.sort(function(a, b) {\n                return a - b;\n            }); // Comparator function allows to sort numbers.\n        } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n            let expandedDays = this.expand_by_day(aYear);\n            for (let day of expandedDays){\n                let tt = Time.fromDayOfYear(day, aYear);\n                if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n                    this.days.push(day);\n                }\n            }\n        } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n            let expandedDays = this.expand_by_day(aYear);\n            for (let day of expandedDays){\n                let tt = Time.fromDayOfYear(day, aYear);\n                if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n                    this.days.push(day);\n                }\n            }\n        } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n            let expandedDays = this.expand_by_day(aYear);\n            for (let day of expandedDays){\n                let tt = Time.fromDayOfYear(day, aYear);\n                let weekno = tt.weekNumber(this.rule.wkst);\n                if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n                    this.days.push(day);\n                }\n            }\n        } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) ;\n        else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n            this.days = this.days.concat(this.by_data.BYYEARDAY);\n        } else {\n            this.days = [];\n        }\n        let daysInYear = Time.isLeapYear(aYear) ? 366 : 365;\n        this.days.sort((a, b)=>{\n            if (a < 0) a += daysInYear + 1;\n            if (b < 0) b += daysInYear + 1;\n            return a - b;\n        });\n        return 0;\n    }\n    expand_by_day(aYear) {\n        let days_list = [];\n        let tmp = this.last.clone();\n        tmp.year = aYear;\n        tmp.month = 1;\n        tmp.day = 1;\n        tmp.isDate = true;\n        let start_dow = tmp.dayOfWeek();\n        tmp.month = 12;\n        tmp.day = 31;\n        tmp.isDate = true;\n        let end_dow = tmp.dayOfWeek();\n        let end_year_day = tmp.dayOfYear();\n        for (let day of this.by_data.BYDAY){\n            let parts = this.ruleDayOfWeek(day);\n            let pos = parts[0];\n            let dow = parts[1];\n            if (pos == 0) {\n                let tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n                for(let doy = tmp_start_doy; doy <= end_year_day; doy += 7){\n                    days_list.push(doy);\n                }\n            } else if (pos > 0) {\n                let first;\n                if (dow >= start_dow) {\n                    first = dow - start_dow + 1;\n                } else {\n                    first = dow - start_dow + 8;\n                }\n                days_list.push(first + (pos - 1) * 7);\n            } else {\n                let last;\n                pos = -pos;\n                if (dow <= end_dow) {\n                    last = end_year_day - end_dow + dow;\n                } else {\n                    last = end_year_day - end_dow + dow - 7;\n                }\n                days_list.push(last - (pos - 1) * 7);\n            }\n        }\n        return days_list;\n    }\n    is_day_in_byday(tt) {\n        if (this.by_data.BYDAY) {\n            for (let day of this.by_data.BYDAY){\n                let parts = this.ruleDayOfWeek(day);\n                let pos = parts[0];\n                let dow = parts[1];\n                let this_dow = tt.dayOfWeek();\n                if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    /**\n   * Checks if given value is in BYSETPOS.\n   *\n   * @private\n   * @param {Numeric} aPos position to check for.\n   * @return {Boolean} false unless BYSETPOS rules exist\n   *                   and the given value is present in rules.\n   */ check_set_position(aPos) {\n        if (this.has_by_data(\"BYSETPOS\")) {\n            let idx = this.by_data.BYSETPOS.indexOf(aPos);\n            // negative numbers are not false-y\n            return idx !== -1;\n        }\n        return false;\n    }\n    sort_byday_rules(aRules) {\n        for(let i = 0; i < aRules.length; i++){\n            for(let j = 0; j < i; j++){\n                let one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n                let two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n                if (one > two) {\n                    let tmp = aRules[i];\n                    aRules[i] = aRules[j];\n                    aRules[j] = tmp;\n                }\n            }\n        }\n    }\n    check_contract_restriction(aRuleType, v) {\n        let indexMapValue = RecurIterator._indexMap[aRuleType];\n        let ruleMapValue = RecurIterator._expandMap[this.rule.freq][indexMapValue];\n        let pass = false;\n        if (aRuleType in this.by_data && ruleMapValue == RecurIterator.CONTRACT) {\n            let ruleType = this.by_data[aRuleType];\n            for (let bydata of ruleType){\n                if (bydata == v) {\n                    pass = true;\n                    break;\n                }\n            }\n        } else {\n            // Not a contracting byrule or has no data, test passes\n            pass = true;\n        }\n        return pass;\n    }\n    check_contracting_rules() {\n        let dow = this.last.dayOfWeek();\n        let weekNo = this.last.weekNumber(this.rule.wkst);\n        let doy = this.last.dayOfYear();\n        return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n    }\n    setup_defaults(aRuleType, req, deftime) {\n        let indexMapValue = RecurIterator._indexMap[aRuleType];\n        let ruleMapValue = RecurIterator._expandMap[this.rule.freq][indexMapValue];\n        if (ruleMapValue != RecurIterator.CONTRACT) {\n            if (!(aRuleType in this.by_data)) {\n                this.by_data[aRuleType] = [\n                    deftime\n                ];\n            }\n            if (this.rule.freq != req) {\n                return this.by_data[aRuleType][0];\n            }\n        }\n        return deftime;\n    }\n    /**\n   * Convert iterator into a serialize-able object.  Will preserve current\n   * iteration sequence to ensure the seamless continuation of the recurrence\n   * rule.\n   * @return {Object}\n   */ toJSON() {\n        let result = Object.create(null);\n        result.initialized = this.initialized;\n        result.rule = this.rule.toJSON();\n        result.dtstart = this.dtstart.toJSON();\n        result.by_data = this.by_data;\n        result.days = this.days;\n        result.last = this.last.toJSON();\n        result.by_indices = this.by_indices;\n        result.occurrence_number = this.occurrence_number;\n        return result;\n    }\n    /**\n   * Creates a new ICAL.RecurIterator instance. The options object may contain additional members\n   * when resuming iteration from a previous run.\n   *\n   * @param {Object} options                The iterator options\n   * @param {Recur} options.rule            The rule to iterate.\n   * @param {Time} options.dtstart          The start date of the event.\n   * @param {Boolean=} options.initialized  When true, assume that options are\n   *        from a previously constructed iterator. Initialization will not be\n   *        repeated.\n   */ constructor(options){\n        /**\n   * True when iteration is finished.\n   * @type {Boolean}\n   */ this.completed = false;\n        /**\n   * The rule that is being iterated\n   * @type {Recur}\n   */ this.rule = null;\n        /**\n   * The start date of the event being iterated.\n   * @type {Time}\n   */ this.dtstart = null;\n        /**\n   * The last occurrence that was returned from the\n   * {@link RecurIterator#next} method.\n   * @type {Time}\n   */ this.last = null;\n        /**\n   * The sequence number from the occurrence\n   * @type {Number}\n   */ this.occurrence_number = 0;\n        /**\n   * The indices used for the {@link ICAL.RecurIterator#by_data} object.\n   * @type {Object}\n   * @private\n   */ this.by_indices = null;\n        /**\n   * If true, the iterator has already been initialized\n   * @type {Boolean}\n   * @private\n   */ this.initialized = false;\n        /**\n   * The initializd by-data.\n   * @type {Object}\n   * @private\n   */ this.by_data = null;\n        /**\n   * The expanded yeardays\n   * @type {Array}\n   * @private\n   */ this.days = null;\n        /**\n   * The index in the {@link ICAL.RecurIterator#days} array.\n   * @type {Number}\n   * @private\n   */ this.days_index = 0;\n        this.fromData(options);\n    }\n}\nRecurIterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n};\nRecurIterator._expandMap = {\n    \"SECONDLY\": [\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1\n    ],\n    \"MINUTELY\": [\n        2,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1\n    ],\n    \"HOURLY\": [\n        2,\n        2,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1\n    ],\n    \"DAILY\": [\n        2,\n        2,\n        2,\n        1,\n        1,\n        1,\n        1,\n        1\n    ],\n    \"WEEKLY\": [\n        2,\n        2,\n        2,\n        2,\n        3,\n        3,\n        1,\n        1\n    ],\n    \"MONTHLY\": [\n        2,\n        2,\n        2,\n        2,\n        2,\n        3,\n        3,\n        1\n    ],\n    \"YEARLY\": [\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2\n    ]\n};\nRecurIterator.UNKNOWN = 0;\nRecurIterator.CONTRACT = 1;\nRecurIterator.EXPAND = 2;\nRecurIterator.ILLEGAL = 3;\n/**\n * An error indicating that a recurrence rule is invalid and produces no\n * occurrences.\n *\n * @extends {Error}\n * @class\n */ class InvalidRecurrenceRuleError extends Error {\n    constructor(){\n        super(\"Recurrence rule has no valid occurrences\");\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").weekDay} weekDay\n * Imports the 'weekDay' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").frequencyValues} frequencyValues\n * Imports the 'frequencyValues' type from the \"types.js\" module\n */ const VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\nconst VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\nconst DOW_MAP = {\n    SU: Time.SUNDAY,\n    MO: Time.MONDAY,\n    TU: Time.TUESDAY,\n    WE: Time.WEDNESDAY,\n    TH: Time.THURSDAY,\n    FR: Time.FRIDAY,\n    SA: Time.SATURDAY\n};\nconst REVERSE_DOW_MAP = Object.fromEntries(_c1 = Object.entries(DOW_MAP).map(_c = (entry)=>entry.reverse()));\n_c2 = REVERSE_DOW_MAP;\nconst ALLOWED_FREQ = [\n    \"SECONDLY\",\n    \"MINUTELY\",\n    \"HOURLY\",\n    \"DAILY\",\n    \"WEEKLY\",\n    \"MONTHLY\",\n    \"YEARLY\"\n];\n/**\n * This class represents the \"recur\" value type, used for example by RRULE. It provides methods to\n * calculate occurrences among others.\n *\n * @memberof ICAL\n */ class Recur {\n    /**\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\n   *\n   * @param {String} string         The string to parse\n   * @return {Recur}                The created recurrence instance\n   */ static fromString(string) {\n        let data = this._stringToData(string, false);\n        return new Recur(data);\n    }\n    /**\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\n   * data object.\n   *\n   * @param {Object} aData                              An object with members of the recurrence\n   * @param {frequencyValues=} aData.freq               The frequency value\n   * @param {Number=} aData.interval                    The INTERVAL value\n   * @param {weekDay=} aData.wkst                       The week start value\n   * @param {Time=} aData.until                         The end of the recurrence set\n   * @param {Number=} aData.count                       The number of occurrences\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\n   * @param {Array.<String>=} aData.byday               The BYDAY values\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\n   */ static fromData(aData) {\n        return new Recur(aData);\n    }\n    /**\n   * Converts a recurrence string to a data object, suitable for the fromData\n   * method.\n   *\n   * @private\n   * @param {String} string     The string to parse\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\n   *                              iCalendar string\n   * @return {Recur}            The recurrence instance\n   */ static _stringToData(string, fmtIcal) {\n        let dict = Object.create(null);\n        // split is slower in FF but fast enough.\n        // v8 however this is faster then manual split?\n        let values = string.split(\";\");\n        let len = values.length;\n        for(let i = 0; i < len; i++){\n            let parts = values[i].split(\"=\");\n            let ucname = parts[0].toUpperCase();\n            let lcname = parts[0].toLowerCase();\n            let name = fmtIcal ? lcname : ucname;\n            let value = parts[1];\n            if (ucname in partDesign) {\n                let partArr = value.split(\",\");\n                let partSet = new Set();\n                for (let part of partArr){\n                    partSet.add(partDesign[ucname](part));\n                }\n                partArr = [\n                    ...partSet\n                ];\n                dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n            } else if (ucname in optionDesign) {\n                optionDesign[ucname](value, dict, fmtIcal);\n            } else {\n                // Don't swallow unknown values. Just set them as they are.\n                dict[lcname] = value;\n            }\n        }\n        return dict;\n    }\n    /**\n   * Convert an ical representation of a day (SU, MO, etc..)\n   * into a numeric value of that day.\n   *\n   * @param {String} string     The iCalendar day name\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {Number}           Numeric value of given day\n   */ static icalDayToNumericDay(string, aWeekStart) {\n        //XXX: this is here so we can deal\n        //     with possibly invalid string values.\n        let firstDow = aWeekStart || Time.SUNDAY;\n        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n    }\n    /**\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\n   *\n   * @param {Number} num        Numeric value of given day\n   * @param {weekDay=} aWeekStart\n   *        The week start weekday, defaults to SUNDAY\n   * @return {String}           The ICAL day value, e.g SU,MO,...\n   */ static numericDayToIcalDay(num, aWeekStart) {\n        //XXX: this is here so we can deal with possibly invalid number values.\n        //     Also, this allows consistent mapping between day numbers and day\n        //     names for external users.\n        let firstDow = aWeekStart || Time.SUNDAY;\n        let dow = num + firstDow - Time.SUNDAY;\n        if (dow > 7) {\n            dow -= 7;\n        }\n        return REVERSE_DOW_MAP[dow];\n    }\n    /**\n   * Create a new iterator for this recurrence rule. The passed start date\n   * must be the start date of the event, not the start of the range to\n   * search in.\n   *\n   * @example\n   * let recur = comp.getFirstPropertyValue('rrule');\n   * let dtstart = comp.getFirstPropertyValue('dtstart');\n   * let iter = recur.iterator(dtstart);\n   * for (let next = iter.next(); next; next = iter.next()) {\n   *   if (next.compare(rangeStart) < 0) {\n   *     continue;\n   *   }\n   *   console.log(next.toString());\n   * }\n   *\n   * @param {Time} aStart        The item's start date\n   * @return {RecurIterator}     The recurrence iterator\n   */ iterator(aStart) {\n        return new RecurIterator({\n            rule: this,\n            dtstart: aStart\n        });\n    }\n    /**\n   * Returns a clone of the recurrence object.\n   *\n   * @return {Recur}      The cloned object\n   */ clone() {\n        return new Recur(this.toJSON());\n    }\n    /**\n   * Checks if the current rule is finite, i.e. has a count or until part.\n   *\n   * @return {Boolean}        True, if the rule is finite\n   */ isFinite() {\n        return !!(this.count || this.until);\n    }\n    /**\n   * Checks if the current rule has a count part, and not limited by an until\n   * part.\n   *\n   * @return {Boolean}        True, if the rule is by count\n   */ isByCount() {\n        return !!(this.count && !this.until);\n    }\n    /**\n   * Adds a component (part) to the recurrence rule. This is not a component\n   * in the sense of {@link ICAL.Component}, but a part of the recurrence\n   * rule, i.e. BYMONTH.\n   *\n   * @param {String} aType            The name of the component part\n   * @param {Array|String} aValue     The component value\n   */ addComponent(aType, aValue) {\n        let ucname = aType.toUpperCase();\n        if (ucname in this.parts) {\n            this.parts[ucname].push(aValue);\n        } else {\n            this.parts[ucname] = [\n                aValue\n            ];\n        }\n    }\n    /**\n   * Sets the component value for the given by-part.\n   *\n   * @param {String} aType        The component part name\n   * @param {Array} aValues       The component values\n   */ setComponent(aType, aValues) {\n        this.parts[aType.toUpperCase()] = aValues.slice();\n    }\n    /**\n   * Gets (a copy) of the requested component value.\n   *\n   * @param {String} aType        The component part name\n   * @return {Array}              The component part value\n   */ getComponent(aType) {\n        let ucname = aType.toUpperCase();\n        return ucname in this.parts ? this.parts[ucname].slice() : [];\n    }\n    /**\n   * Retrieves the next occurrence after the given recurrence id. See the\n   * guide on {@tutorial terminology} for more details.\n   *\n   * NOTE: Currently, this method iterates all occurrences from the start\n   * date. It should not be called in a loop for performance reasons. If you\n   * would like to get more than one occurrence, you can iterate the\n   * occurrences manually, see the example on the\n   * {@link ICAL.Recur#iterator iterator} method.\n   *\n   * @param {Time} aStartTime        The start of the event series\n   * @param {Time} aRecurrenceId     The date of the last occurrence\n   * @return {Time}                  The next occurrence after\n   */ getNextOccurrence(aStartTime, aRecurrenceId) {\n        let iter = this.iterator(aStartTime);\n        let next;\n        do {\n            next = iter.next();\n        }while (next && next.compare(aRecurrenceId) <= 0);\n        if (next && aRecurrenceId.zone) {\n            next.zone = aRecurrenceId.zone;\n        }\n        return next;\n    }\n    /**\n   * Sets up the current instance using members from the passed data object.\n   *\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {frequencyValues=} data.freq                The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {weekDay=} data.wkst                        The week start value\n   * @param {Time=} data.until                          The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */ fromData(data) {\n        for(let key in data){\n            let uckey = key.toUpperCase();\n            if (uckey in partDesign) {\n                if (Array.isArray(data[key])) {\n                    this.parts[uckey] = data[key];\n                } else {\n                    this.parts[uckey] = [\n                        data[key]\n                    ];\n                }\n            } else {\n                this[key] = data[key];\n            }\n        }\n        if (this.interval && typeof this.interval != \"number\") {\n            optionDesign.INTERVAL(this.interval, this);\n        }\n        if (this.wkst && typeof this.wkst != \"number\") {\n            this.wkst = Recur.icalDayToNumericDay(this.wkst);\n        }\n        if (this.until && !(this.until instanceof Time)) {\n            this.until = Time.fromString(this.until);\n        }\n    }\n    /**\n   * The jCal representation of this recurrence type.\n   * @return {Object}\n   */ toJSON() {\n        let res = Object.create(null);\n        res.freq = this.freq;\n        if (this.count) {\n            res.count = this.count;\n        }\n        if (this.interval > 1) {\n            res.interval = this.interval;\n        }\n        for (let [k, kparts] of Object.entries(this.parts)){\n            if (Array.isArray(kparts) && kparts.length == 1) {\n                res[k.toLowerCase()] = kparts[0];\n            } else {\n                res[k.toLowerCase()] = clone(kparts);\n            }\n        }\n        if (this.until) {\n            res.until = this.until.toString();\n        }\n        if (\"wkst\" in this && this.wkst !== Time.DEFAULT_WEEK_START) {\n            res.wkst = Recur.numericDayToIcalDay(this.wkst);\n        }\n        return res;\n    }\n    /**\n   * The string representation of this recurrence rule.\n   * @return {String}\n   */ toString() {\n        // TODO retain order\n        let str = \"FREQ=\" + this.freq;\n        if (this.count) {\n            str += \";COUNT=\" + this.count;\n        }\n        if (this.interval > 1) {\n            str += \";INTERVAL=\" + this.interval;\n        }\n        for (let [k, v] of Object.entries(this.parts)){\n            str += \";\" + k + \"=\" + v;\n        }\n        if (this.until) {\n            str += \";UNTIL=\" + this.until.toICALString();\n        }\n        if (\"wkst\" in this && this.wkst !== Time.DEFAULT_WEEK_START) {\n            str += \";WKST=\" + Recur.numericDayToIcalDay(this.wkst);\n        }\n        return str;\n    }\n    /**\n   * Create a new instance of the Recur class.\n   *\n   * @param {Object} data                               An object with members of the recurrence\n   * @param {frequencyValues=} data.freq                The frequency value\n   * @param {Number=} data.interval                     The INTERVAL value\n   * @param {weekDay=} data.wkst                        The week start value\n   * @param {Time=} data.until                          The end of the recurrence set\n   * @param {Number=} data.count                        The number of occurrences\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\n   * @param {Array.<String>=} data.byday                The BYDAY values\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\n   */ constructor(data){\n        /**\n   * An object holding the BY-parts of the recurrence rule\n   * @memberof ICAL.Recur\n   * @typedef {Object} byParts\n   * @property {Array.<Number>=} BYSECOND            The seconds for the BYSECOND part\n   * @property {Array.<Number>=} BYMINUTE            The minutes for the BYMINUTE part\n   * @property {Array.<Number>=} BYHOUR              The hours for the BYHOUR part\n   * @property {Array.<String>=} BYDAY               The BYDAY values\n   * @property {Array.<Number>=} BYMONTHDAY          The days for the BYMONTHDAY part\n   * @property {Array.<Number>=} BYYEARDAY           The days for the BYYEARDAY part\n   * @property {Array.<Number>=} BYWEEKNO            The weeks for the BYWEEKNO part\n   * @property {Array.<Number>=} BYMONTH             The month for the BYMONTH part\n   * @property {Array.<Number>=} BYSETPOS            The positionals for the BYSETPOS part\n   */ /**\n   * An object holding the BY-parts of the recurrence rule\n   * @type {byParts}\n   */ this.parts = null;\n        /**\n   * The interval value for the recurrence rule.\n   * @type {Number}\n   */ this.interval = 1;\n        /**\n   * The week start day\n   *\n   * @type {weekDay}\n   * @default ICAL.Time.MONDAY\n   */ this.wkst = Time.MONDAY;\n        /**\n   * The end of the recurrence\n   * @type {?Time}\n   */ this.until = null;\n        /**\n   * The maximum number of occurrences\n   * @type {?Number}\n   */ this.count = null;\n        /**\n   * The frequency value.\n   * @type {frequencyValues}\n   */ this.freq = null;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icalrecur\"\n   */ this.icalclass = \"icalrecur\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"recur\"\n   */ this.icaltype = \"recur\";\n        this.wrappedJSObject = this;\n        this.parts = {};\n        if (data && typeof data === \"object\") {\n            this.fromData(data);\n        }\n    }\n}\nfunction parseNumericValue(type, min, max, value) {\n    let result = value;\n    if (value[0] === \"+\") {\n        result = value.slice(1);\n    }\n    result = strictParseInt(result);\n    if (min !== undefined && value < min) {\n        throw new Error(type + ': invalid value \"' + value + '\" must be > ' + min);\n    }\n    if (max !== undefined && value > max) {\n        throw new Error(type + ': invalid value \"' + value + '\" must be < ' + min);\n    }\n    return result;\n}\nconst optionDesign = {\n    FREQ: function(value, dict, fmtIcal) {\n        // yes this is actually equal or faster then regex.\n        // upside here is we can enumerate the valid values.\n        if (ALLOWED_FREQ.indexOf(value) !== -1) {\n            dict.freq = value;\n        } else {\n            throw new Error('invalid frequency \"' + value + '\" expected: \"' + ALLOWED_FREQ.join(\", \") + '\"');\n        }\n    },\n    COUNT: function(value, dict, fmtIcal) {\n        dict.count = strictParseInt(value);\n    },\n    INTERVAL: function(value, dict, fmtIcal) {\n        dict.interval = strictParseInt(value);\n        if (dict.interval < 1) {\n            // 0 or negative values are not allowed, some engines seem to generate\n            // it though. Assume 1 instead.\n            dict.interval = 1;\n        }\n    },\n    UNTIL: function(value, dict, fmtIcal) {\n        if (value.length > 10) {\n            dict.until = design$1.icalendar.value[\"date-time\"].fromICAL(value);\n        } else {\n            dict.until = design$1.icalendar.value.date.fromICAL(value);\n        }\n        if (!fmtIcal) {\n            dict.until = Time.fromString(dict.until);\n        }\n    },\n    WKST: function(value, dict, fmtIcal) {\n        if (VALID_DAY_NAMES.test(value)) {\n            dict.wkst = Recur.icalDayToNumericDay(value);\n        } else {\n            throw new Error('invalid WKST value \"' + value + '\"');\n        }\n    }\n};\nconst partDesign = {\n    BYSECOND: parseNumericValue.bind(undefined, \"BYSECOND\", 0, 60),\n    BYMINUTE: parseNumericValue.bind(undefined, \"BYMINUTE\", 0, 59),\n    BYHOUR: parseNumericValue.bind(undefined, \"BYHOUR\", 0, 23),\n    BYDAY: function(value) {\n        if (VALID_BYDAY_PART.test(value)) {\n            return value;\n        } else {\n            throw new Error('invalid BYDAY value \"' + value + '\"');\n        }\n    },\n    BYMONTHDAY: parseNumericValue.bind(undefined, \"BYMONTHDAY\", -31, 31),\n    BYYEARDAY: parseNumericValue.bind(undefined, \"BYYEARDAY\", -366, 366),\n    BYWEEKNO: parseNumericValue.bind(undefined, \"BYWEEKNO\", -53, 53),\n    BYMONTH: parseNumericValue.bind(undefined, \"BYMONTH\", 1, 12),\n    BYSETPOS: parseNumericValue.bind(undefined, \"BYSETPOS\", -366, 366)\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").jCalComponent} jCalComponent\n * Imports the 'occurrenceDetails' type from the \"types.js\" module\n */ /**\n * This class represents the \"period\" value type, with various calculation and manipulation methods.\n *\n * @memberof ICAL\n */ class Period {\n    /**\n   * Creates a new {@link ICAL.Period} instance from the passed string.\n   *\n   * @param {String} str            The string to parse\n   * @param {Property} prop         The property this period will be on\n   * @return {Period}               The created period instance\n   */ static fromString(str, prop) {\n        let parts = str.split(\"/\");\n        if (parts.length !== 2) {\n            throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n        }\n        let options = {\n            start: Time.fromDateTimeString(parts[0], prop)\n        };\n        let end = parts[1];\n        if (Duration.isValueString(end)) {\n            options.duration = Duration.fromString(end);\n        } else {\n            options.end = Time.fromDateTimeString(end, prop);\n        }\n        return new Period(options);\n    }\n    /**\n   * Creates a new {@link ICAL.Period} instance from the given data object.\n   * The passed data object cannot contain both and end date and a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {Time=} aData.start             The start of the period\n   * @param {Time=} aData.end               The end of the period\n   * @param {Duration=} aData.duration      The duration of the period\n   * @return {Period}                       The period instance\n   */ static fromData(aData) {\n        return new Period(aData);\n    }\n    /**\n   * Returns a new period instance from the given jCal data array. The first\n   * member is always the start date string, the second member is either a\n   * duration or end date string.\n   *\n   * @param {jCalComponent} aData           The jCal data array\n   * @param {Property} aProp                The property this jCal data is on\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\n   * @return {Period}                       The period instance\n   */ static fromJSON(aData, aProp, aLenient) {\n        function fromDateOrDateTimeString(aValue, dateProp) {\n            if (aLenient) {\n                return Time.fromString(aValue, dateProp);\n            } else {\n                return Time.fromDateTimeString(aValue, dateProp);\n            }\n        }\n        if (Duration.isValueString(aData[1])) {\n            return Period.fromData({\n                start: fromDateOrDateTimeString(aData[0], aProp),\n                duration: Duration.fromString(aData[1])\n            });\n        } else {\n            return Period.fromData({\n                start: fromDateOrDateTimeString(aData[0], aProp),\n                end: fromDateOrDateTimeString(aData[1], aProp)\n            });\n        }\n    }\n    /**\n   * Returns a clone of the duration object.\n   *\n   * @return {Period}      The cloned object\n   */ clone() {\n        return Period.fromData({\n            start: this.start ? this.start.clone() : null,\n            end: this.end ? this.end.clone() : null,\n            duration: this.duration ? this.duration.clone() : null\n        });\n    }\n    /**\n   * Calculates the duration of the period, either directly or by subtracting\n   * start from end date.\n   *\n   * @return {Duration}      The calculated duration\n   */ getDuration() {\n        if (this.duration) {\n            return this.duration;\n        } else {\n            return this.end.subtractDate(this.start);\n        }\n    }\n    /**\n   * Calculates the end date of the period, either directly or by adding\n   * duration to start date.\n   *\n   * @return {Time}          The calculated end date\n   */ getEnd() {\n        if (this.end) {\n            return this.end;\n        } else {\n            let end = this.start.clone();\n            end.addDuration(this.duration);\n            return end;\n        }\n    }\n    /**\n   * The string representation of this period.\n   * @return {String}\n   */ toString() {\n        return this.start + \"/\" + (this.end || this.duration);\n    }\n    /**\n   * The jCal representation of this period type.\n   * @return {Object}\n   */ toJSON() {\n        return [\n            this.start.toString(),\n            (this.end || this.duration).toString()\n        ];\n    }\n    /**\n   * The iCalendar string representation of this period.\n   * @return {String}\n   */ toICALString() {\n        return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n    }\n    /**\n   * Creates a new ICAL.Period instance. The passed data object cannot contain both and end date and\n   * a duration.\n   *\n   * @param {Object} aData                  An object with members of the period\n   * @param {Time=} aData.start             The start of the period\n   * @param {Time=} aData.end               The end of the period\n   * @param {Duration=} aData.duration      The duration of the period\n   */ constructor(aData){\n        /**\n   * The start of the period\n   * @type {Time}\n   */ this.start = null;\n        /**\n   * The end of the period\n   * @type {Time}\n   */ this.end = null;\n        /**\n   * The duration of the period\n   * @type {Duration}\n   */ this.duration = null;\n        /**\n   * The class identifier.\n   * @constant\n   * @type {String}\n   * @default \"icalperiod\"\n   */ this.icalclass = \"icalperiod\";\n        /**\n   * The type name, to be used in the jCal object.\n   * @constant\n   * @type {String}\n   * @default \"period\"\n   */ this.icaltype = \"period\";\n        this.wrappedJSObject = this;\n        if (aData && \"start\" in aData) {\n            if (aData.start && !(aData.start instanceof Time)) {\n                throw new TypeError(\".start must be an instance of ICAL.Time\");\n            }\n            this.start = aData.start;\n        }\n        if (aData && aData.end && aData.duration) {\n            throw new Error(\"cannot accept both end and duration\");\n        }\n        if (aData && \"end\" in aData) {\n            if (aData.end && !(aData.end instanceof Time)) {\n                throw new TypeError(\".end must be an instance of ICAL.Time\");\n            }\n            this.end = aData.end;\n        }\n        if (aData && \"duration\" in aData) {\n            if (aData.duration && !(aData.duration instanceof Duration)) {\n                throw new TypeError(\".duration must be an instance of ICAL.Duration\");\n            }\n            this.duration = aData.duration;\n        }\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n */ /** @module ICAL.design */ const FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\nconst TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\nconst FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\nconst TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\nfunction createTextType(fromNewline, toNewline) {\n    let result = {\n        matches: /.*/,\n        fromICAL: function(aValue, structuredEscape) {\n            return replaceNewline(aValue, fromNewline, structuredEscape);\n        },\n        toICAL: function(aValue, structuredEscape) {\n            let regEx = toNewline;\n            if (structuredEscape) regEx = new RegExp(regEx.source + \"|\" + structuredEscape, regEx.flags);\n            return aValue.replace(regEx, function(str) {\n                switch(str){\n                    case \"\\\\\":\n                        return \"\\\\\\\\\";\n                    case \";\":\n                        return \"\\\\;\";\n                    case \",\":\n                        return \"\\\\,\";\n                    case \"\\n\":\n                        return \"\\\\n\";\n                    /* c8 ignore next 2 */ default:\n                        return str;\n                }\n            });\n        }\n    };\n    return result;\n}\n// default types used multiple times\nconst DEFAULT_TYPE_TEXT = {\n    defaultType: \"text\"\n};\nconst DEFAULT_TYPE_TEXT_MULTI = {\n    defaultType: \"text\",\n    multiValue: \",\"\n};\nconst DEFAULT_TYPE_TEXT_STRUCTURED = {\n    defaultType: \"text\",\n    structuredValue: \";\"\n};\nconst DEFAULT_TYPE_INTEGER = {\n    defaultType: \"integer\"\n};\nconst DEFAULT_TYPE_DATETIME_DATE = {\n    defaultType: \"date-time\",\n    allowedTypes: [\n        \"date-time\",\n        \"date\"\n    ]\n};\nconst DEFAULT_TYPE_DATETIME = {\n    defaultType: \"date-time\"\n};\nconst DEFAULT_TYPE_URI = {\n    defaultType: \"uri\"\n};\nconst DEFAULT_TYPE_UTCOFFSET = {\n    defaultType: \"utc-offset\"\n};\nconst DEFAULT_TYPE_RECUR = {\n    defaultType: \"recur\"\n};\nconst DEFAULT_TYPE_DATE_ANDOR_TIME = {\n    defaultType: \"date-and-or-time\",\n    allowedTypes: [\n        \"date-time\",\n        \"date\",\n        \"text\"\n    ]\n};\nfunction replaceNewlineReplace(string) {\n    switch(string){\n        case \"\\\\\\\\\":\n            return \"\\\\\";\n        case \"\\\\;\":\n            return \";\";\n        case \"\\\\,\":\n            return \",\";\n        case \"\\\\n\":\n        case \"\\\\N\":\n            return \"\\n\";\n        /* c8 ignore next 2 */ default:\n            return string;\n    }\n}\nfunction replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf(\"\\\\\") === -1) {\n        return value;\n    }\n    if (structuredEscape) newline = new RegExp(newline.source + \"|\\\\\\\\\" + structuredEscape, newline.flags);\n    return value.replace(newline, replaceNewlineReplace);\n}\nlet commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n};\nlet commonValues = {\n    \"boolean\": {\n        values: [\n            \"TRUE\",\n            \"FALSE\"\n        ],\n        fromICAL: function(aValue) {\n            switch(aValue){\n                case \"TRUE\":\n                    return true;\n                case \"FALSE\":\n                    return false;\n                default:\n                    //TODO: parser warning\n                    return false;\n            }\n        },\n        toICAL: function(aValue) {\n            if (aValue) {\n                return \"TRUE\";\n            }\n            return \"FALSE\";\n        }\n    },\n    float: {\n        matches: /^[+-]?\\d+\\.\\d+$/,\n        fromICAL: function(aValue) {\n            let parsed = parseFloat(aValue);\n            if (isStrictlyNaN(parsed)) {\n                // TODO: parser warning\n                return 0.0;\n            }\n            return parsed;\n        },\n        toICAL: function(aValue) {\n            return String(aValue);\n        }\n    },\n    integer: {\n        fromICAL: function(aValue) {\n            let parsed = parseInt(aValue);\n            if (isStrictlyNaN(parsed)) {\n                return 0;\n            }\n            return parsed;\n        },\n        toICAL: function(aValue) {\n            return String(aValue);\n        }\n    },\n    \"utc-offset\": {\n        toICAL: function(aValue) {\n            if (aValue.length < 7) {\n                // no seconds\n                // -0500\n                return aValue.slice(0, 3) + aValue.slice(4, 6);\n            } else {\n                // seconds\n                // -050000\n                return aValue.slice(0, 3) + aValue.slice(4, 6) + aValue.slice(7, 9);\n            }\n        },\n        fromICAL: function(aValue) {\n            if (aValue.length < 6) {\n                // no seconds\n                // -05:00\n                return aValue.slice(0, 3) + \":\" + aValue.slice(3, 5);\n            } else {\n                // seconds\n                // -05:00:00\n                return aValue.slice(0, 3) + \":\" + aValue.slice(3, 5) + \":\" + aValue.slice(5, 7);\n            }\n        },\n        decorate: function(aValue) {\n            return UtcOffset.fromString(aValue);\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    }\n};\nlet icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enforce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n    // CN just wants a param-value\n    // \"CN\": { ... }\n    \"cutype\": {\n        values: [\n            \"INDIVIDUAL\",\n            \"GROUP\",\n            \"RESOURCE\",\n            \"ROOM\",\n            \"UNKNOWN\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"delegated-from\": {\n        valueType: \"cal-address\",\n        multiValue: \",\",\n        multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n        valueType: \"cal-address\",\n        multiValue: \",\",\n        multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n        values: [\n            \"8BIT\",\n            \"BASE64\"\n        ]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n        values: [\n            \"FREE\",\n            \"BUSY\",\n            \"BUSY-UNAVAILABLE\",\n            \"BUSY-TENTATIVE\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n        valueType: \"cal-address\",\n        multiValue: \",\",\n        multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n        // TODO These values are actually different per-component\n        values: [\n            \"NEEDS-ACTION\",\n            \"ACCEPTED\",\n            \"DECLINED\",\n            \"TENTATIVE\",\n            \"DELEGATED\",\n            \"COMPLETED\",\n            \"IN-PROCESS\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"range\": {\n        values: [\n            \"THISANDFUTURE\"\n        ]\n    },\n    \"related\": {\n        values: [\n            \"START\",\n            \"END\"\n        ]\n    },\n    \"reltype\": {\n        values: [\n            \"PARENT\",\n            \"CHILD\",\n            \"SIBLING\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"role\": {\n        values: [\n            \"REQ-PARTICIPANT\",\n            \"CHAIR\",\n            \"OPT-PARTICIPANT\",\n            \"NON-PARTICIPANT\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    },\n    \"rsvp\": {\n        values: [\n            \"TRUE\",\n            \"FALSE\"\n        ]\n    },\n    \"sent-by\": {\n        valueType: \"cal-address\"\n    },\n    \"tzid\": {\n        matches: /^\\//\n    },\n    \"value\": {\n        // since the value here is a 'type' lowercase is used.\n        values: [\n            \"binary\",\n            \"boolean\",\n            \"cal-address\",\n            \"date\",\n            \"date-time\",\n            \"duration\",\n            \"float\",\n            \"integer\",\n            \"period\",\n            \"recur\",\n            \"text\",\n            \"time\",\n            \"uri\",\n            \"utc-offset\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    }\n};\n// When adding a value here, be sure to add it to the parameter types!\nconst icalValues = extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n    uri: {\n    },\n    \"binary\": {\n        decorate: function(aString) {\n            return Binary.fromString(aString);\n        },\n        undecorate: function(aBinary) {\n            return aBinary.toString();\n        }\n    },\n    \"cal-address\": {\n    },\n    \"date\": {\n        decorate: function(aValue, aProp) {\n            if (design.strict) {\n                return Time.fromDateString(aValue, aProp);\n            } else {\n                return Time.fromString(aValue, aProp);\n            }\n        },\n        /**\n     * undecorates a time object.\n     */ undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            // from: 20120901\n            // to: 2012-09-01\n            if (!design.strict && aValue.length >= 15) {\n                // This is probably a date-time, e.g. 20120901T130000Z\n                return icalValues[\"date-time\"].fromICAL(aValue);\n            } else {\n                return aValue.slice(0, 4) + \"-\" + aValue.slice(4, 6) + \"-\" + aValue.slice(6, 8);\n            }\n        },\n        toICAL: function(aValue) {\n            // from: 2012-09-01\n            // to: 20120901\n            let len = aValue.length;\n            if (len == 10) {\n                return aValue.slice(0, 4) + aValue.slice(5, 7) + aValue.slice(8, 10);\n            } else if (len >= 19) {\n                return icalValues[\"date-time\"].toICAL(aValue);\n            } else {\n                //TODO: serialize warning?\n                return aValue;\n            }\n        }\n    },\n    \"date-time\": {\n        fromICAL: function(aValue) {\n            // from: 20120901T130000\n            // to: 2012-09-01T13:00:00\n            if (!design.strict && aValue.length == 8) {\n                // This is probably a date, e.g. 20120901\n                return icalValues.date.fromICAL(aValue);\n            } else {\n                let result = aValue.slice(0, 4) + \"-\" + aValue.slice(4, 6) + \"-\" + aValue.slice(6, 8) + \"T\" + aValue.slice(9, 11) + \":\" + aValue.slice(11, 13) + \":\" + aValue.slice(13, 15);\n                if (aValue[15] && aValue[15] === \"Z\") {\n                    result += \"Z\";\n                }\n                return result;\n            }\n        },\n        toICAL: function(aValue) {\n            // from: 2012-09-01T13:00:00\n            // to: 20120901T130000\n            let len = aValue.length;\n            if (len == 10 && !design.strict) {\n                return icalValues.date.toICAL(aValue);\n            } else if (len >= 19) {\n                let result = aValue.slice(0, 4) + aValue.slice(5, 7) + // grab the (DDTHH) segment\n                aValue.slice(8, 13) + // MM\n                aValue.slice(14, 16) + // SS\n                aValue.slice(17, 19);\n                if (aValue[19] && aValue[19] === \"Z\") {\n                    result += \"Z\";\n                }\n                return result;\n            } else {\n                // TODO: error\n                return aValue;\n            }\n        },\n        decorate: function(aValue, aProp) {\n            if (design.strict) {\n                return Time.fromDateTimeString(aValue, aProp);\n            } else {\n                return Time.fromString(aValue, aProp);\n            }\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    },\n    duration: {\n        decorate: function(aValue) {\n            return Duration.fromString(aValue);\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    },\n    period: {\n        fromICAL: function(string) {\n            let parts = string.split(\"/\");\n            parts[0] = icalValues[\"date-time\"].fromICAL(parts[0]);\n            if (!Duration.isValueString(parts[1])) {\n                parts[1] = icalValues[\"date-time\"].fromICAL(parts[1]);\n            }\n            return parts;\n        },\n        toICAL: function(parts) {\n            parts = parts.slice();\n            if (!design.strict && parts[0].length == 10) {\n                parts[0] = icalValues.date.toICAL(parts[0]);\n            } else {\n                parts[0] = icalValues[\"date-time\"].toICAL(parts[0]);\n            }\n            if (!Duration.isValueString(parts[1])) {\n                if (!design.strict && parts[1].length == 10) {\n                    parts[1] = icalValues.date.toICAL(parts[1]);\n                } else {\n                    parts[1] = icalValues[\"date-time\"].toICAL(parts[1]);\n                }\n            }\n            return parts.join(\"/\");\n        },\n        decorate: function(aValue, aProp) {\n            return Period.fromJSON(aValue, aProp, !design.strict);\n        },\n        undecorate: function(aValue) {\n            return aValue.toJSON();\n        }\n    },\n    recur: {\n        fromICAL: function(string) {\n            return Recur._stringToData(string, true);\n        },\n        toICAL: function(data) {\n            let str = \"\";\n            for (let [k, val] of Object.entries(data)){\n                if (k == \"until\") {\n                    if (val.length > 10) {\n                        val = icalValues[\"date-time\"].toICAL(val);\n                    } else {\n                        val = icalValues.date.toICAL(val);\n                    }\n                } else if (k == \"wkst\") {\n                    if (typeof val === \"number\") {\n                        val = Recur.numericDayToIcalDay(val);\n                    }\n                } else if (Array.isArray(val)) {\n                    val = val.join(\",\");\n                }\n                str += k.toUpperCase() + \"=\" + val + \";\";\n            }\n            return str.slice(0, Math.max(0, str.length - 1));\n        },\n        decorate: function decorate(aValue) {\n            return Recur.fromData(aValue);\n        },\n        undecorate: function(aRecur) {\n            return aRecur.toJSON();\n        }\n    },\n    time: {\n        fromICAL: function(aValue) {\n            // from: MMHHSS(Z)?\n            // to: HH:MM:SS(Z)?\n            if (aValue.length < 6) {\n                // TODO: parser exception?\n                return aValue;\n            }\n            // HH::MM::SSZ?\n            let result = aValue.slice(0, 2) + \":\" + aValue.slice(2, 4) + \":\" + aValue.slice(4, 6);\n            if (aValue[6] === \"Z\") {\n                result += \"Z\";\n            }\n            return result;\n        },\n        toICAL: function(aValue) {\n            // from: HH:MM:SS(Z)?\n            // to: MMHHSS(Z)?\n            if (aValue.length < 8) {\n                //TODO: error\n                return aValue;\n            }\n            let result = aValue.slice(0, 2) + aValue.slice(3, 5) + aValue.slice(6, 8);\n            if (aValue[8] === \"Z\") {\n                result += \"Z\";\n            }\n            return result;\n        }\n    }\n});\nlet icalProperties = extend(commonProperties, {\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": {\n        defaultType: \"uri\"\n    },\n    \"attendee\": {\n        defaultType: \"cal-address\"\n    },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": {\n        defaultType: \"duration\"\n    },\n    \"exdate\": {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ],\n        multiValue: \",\"\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": {\n        defaultType: \"period\",\n        multiValue: \",\"\n    },\n    \"geo\": {\n        defaultType: \"float\",\n        structuredValue: \";\"\n    },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": {\n        defaultType: \"cal-address\"\n    },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\",\n            \"period\"\n        ],\n        multiValue: \",\",\n        detectType: function(string) {\n            if (string.indexOf(\"/\") !== -1) {\n                return \"period\";\n            }\n            return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n        }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": {\n        defaultType: \"duration\",\n        allowedTypes: [\n            \"duration\",\n            \"date-time\"\n        ]\n    },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n});\n// When adding a value here, be sure to add it to the parameter types!\nconst vcardValues = extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    date: {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            if (aValue.length == 8) {\n                return icalValues.date.fromICAL(aValue);\n            } else if (aValue[0] == \"-\" && aValue.length == 6) {\n                return aValue.slice(0, 4) + \"-\" + aValue.slice(4);\n            } else {\n                return aValue;\n            }\n        },\n        toICAL: function(aValue) {\n            if (aValue.length == 10) {\n                return icalValues.date.toICAL(aValue);\n            } else if (aValue[0] == \"-\" && aValue.length == 7) {\n                return aValue.slice(0, 4) + aValue.slice(5);\n            } else {\n                return aValue;\n            }\n        }\n    },\n    time: {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            let splitzone = vcardValues.time._splitZone(aValue, true);\n            let zone = splitzone[0], value = splitzone[1];\n            //console.log(\"SPLIT: \",splitzone);\n            if (value.length == 6) {\n                value = value.slice(0, 2) + \":\" + value.slice(2, 4) + \":\" + value.slice(4, 6);\n            } else if (value.length == 4 && value[0] != \"-\") {\n                value = value.slice(0, 2) + \":\" + value.slice(2, 4);\n            } else if (value.length == 5) {\n                value = value.slice(0, 3) + \":\" + value.slice(3, 5);\n            }\n            if (zone.length == 5 && (zone[0] == \"-\" || zone[0] == \"+\")) {\n                zone = zone.slice(0, 3) + \":\" + zone.slice(3);\n            }\n            return value + zone;\n        },\n        toICAL: function(aValue) {\n            let splitzone = vcardValues.time._splitZone(aValue);\n            let zone = splitzone[0], value = splitzone[1];\n            if (value.length == 8) {\n                value = value.slice(0, 2) + value.slice(3, 5) + value.slice(6, 8);\n            } else if (value.length == 5 && value[0] != \"-\") {\n                value = value.slice(0, 2) + value.slice(3, 5);\n            } else if (value.length == 6) {\n                value = value.slice(0, 3) + value.slice(4, 6);\n            }\n            if (zone.length == 6 && (zone[0] == \"-\" || zone[0] == \"+\")) {\n                zone = zone.slice(0, 3) + zone.slice(4);\n            }\n            return value + zone;\n        },\n        _splitZone: function(aValue, isFromIcal) {\n            let lastChar = aValue.length - 1;\n            let signChar = aValue.length - (isFromIcal ? 5 : 6);\n            let sign = aValue[signChar];\n            let zone, value;\n            if (aValue[lastChar] == \"Z\") {\n                zone = aValue[lastChar];\n                value = aValue.slice(0, Math.max(0, lastChar));\n            } else if (aValue.length > 6 && (sign == \"-\" || sign == \"+\")) {\n                zone = aValue.slice(signChar);\n                value = aValue.slice(0, Math.max(0, signChar));\n            } else {\n                zone = \"\";\n                value = aValue;\n            }\n            return [\n                zone,\n                value\n            ];\n        }\n    },\n    \"date-time\": {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            return vcardValues[\"date-and-or-time\"].fromICAL(aValue);\n        },\n        toICAL: function(aValue) {\n            return vcardValues[\"date-and-or-time\"].toICAL(aValue);\n        }\n    },\n    \"date-and-or-time\": {\n        decorate: function(aValue) {\n            return VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        },\n        fromICAL: function(aValue) {\n            let parts = aValue.split(\"T\");\n            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : \"\") + (parts[1] ? \"T\" + vcardValues.time.fromICAL(parts[1]) : \"\");\n        },\n        toICAL: function(aValue) {\n            let parts = aValue.split(\"T\");\n            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? \"T\" + vcardValues.time.toICAL(parts[1]) : \"\");\n        }\n    },\n    timestamp: icalValues[\"date-time\"],\n    \"language-tag\": {\n        matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n    },\n    \"phone-number\": {\n        fromICAL: function(aValue) {\n            return Array.from(aValue).filter(function(c) {\n                return c === \"\\\\\" ? undefined : c;\n            }).join(\"\");\n        },\n        toICAL: function(aValue) {\n            return Array.from(aValue).map(function(c) {\n                return c === \",\" || c === \";\" ? \"\\\\\" + c : c;\n            }).join(\"\");\n        }\n    }\n});\nlet vcardParams = {\n    \"type\": {\n        valueType: \"text\",\n        multiValue: \",\"\n    },\n    \"value\": {\n        // since the value here is a 'type' lowercase is used.\n        values: [\n            \"text\",\n            \"uri\",\n            \"date\",\n            \"time\",\n            \"date-time\",\n            \"date-and-or-time\",\n            \"timestamp\",\n            \"boolean\",\n            \"integer\",\n            \"float\",\n            \"utc-offset\",\n            \"language-tag\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    }\n};\nlet vcardProperties = extend(commonProperties, {\n    \"adr\": {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": {\n        defaultType: \"language-tag\"\n    },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": {\n        defaultType: \"text\",\n        structuredValue: \";\"\n    },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": {\n        defaultType: \"timestamp\"\n    },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": {\n        defaultType: \"uri\",\n        allowedTypes: [\n            \"uri\",\n            \"text\"\n        ]\n    },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": {\n        defaultType: \"text\",\n        allowedTypes: [\n            \"text\",\n            \"utc-offset\",\n            \"uri\"\n        ]\n    },\n    \"xml\": DEFAULT_TYPE_TEXT\n});\nlet vcard3Values = extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": vcardValues[\"phone-number\"],\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n        toICAL: function(aValue) {\n            return aValue.slice(0, 7);\n        },\n        fromICAL: function(aValue) {\n            return aValue.slice(0, 7);\n        },\n        decorate: function(aValue) {\n            return UtcOffset.fromString(aValue);\n        },\n        undecorate: function(aValue) {\n            return aValue.toString();\n        }\n    }\n});\nlet vcard3Params = {\n    \"type\": {\n        valueType: \"text\",\n        multiValue: \",\"\n    },\n    \"value\": {\n        // since the value here is a 'type' lowercase is used.\n        values: [\n            \"text\",\n            \"uri\",\n            \"date\",\n            \"date-time\",\n            \"phone-number\",\n            \"time\",\n            \"boolean\",\n            \"integer\",\n            \"float\",\n            \"utc-offset\",\n            \"vcard\",\n            \"binary\"\n        ],\n        allowXName: true,\n        allowIanaToken: true\n    }\n};\nlet vcard3Properties = extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"uri\"\n        ]\n    },\n    bday: {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ],\n        detectType: function(string) {\n            return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n        }\n    },\n    adr: {\n        defaultType: \"text\",\n        structuredValue: \";\",\n        multiValue: \",\"\n    },\n    label: DEFAULT_TYPE_TEXT,\n    tel: {\n        defaultType: \"phone-number\"\n    },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n    tz: {\n        defaultType: \"utc-offset\",\n        allowedTypes: [\n            \"utc-offset\",\n            \"text\"\n        ]\n    },\n    geo: {\n        defaultType: \"float\",\n        structuredValue: \";\"\n    },\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"uri\"\n        ]\n    },\n    agent: {\n        defaultType: \"vcard\",\n        allowedTypes: [\n            \"vcard\",\n            \"text\",\n            \"uri\"\n        ]\n    },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n        defaultType: \"date-time\",\n        allowedTypes: [\n            \"date-time\",\n            \"date\"\n        ],\n        detectType: function(string) {\n            return string.indexOf(\"T\") === -1 ? \"date\" : \"date-time\";\n        }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"uri\"\n        ]\n    },\n    class: DEFAULT_TYPE_TEXT,\n    key: {\n        defaultType: \"binary\",\n        allowedTypes: [\n            \"binary\",\n            \"text\"\n        ]\n    }\n});\n/**\n * iCalendar design set\n * @type {designSet}\n */ let icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties,\n    propertyGroups: false\n};\n/**\n * vCard 4.0 design set\n * @type {designSet}\n */ let vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties,\n    propertyGroups: true\n};\n/**\n * vCard 3.0 design set\n * @type {designSet}\n */ let vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties,\n    propertyGroups: true\n};\n/**\n * The design data, used by the parser to determine types for properties and\n * other metadata needed to produce correct jCard/jCal data.\n *\n * @alias ICAL.design\n * @exports module:ICAL.design\n */ const design = {\n    /**\n   * Can be set to false to make the parser more lenient.\n   */ strict: true,\n    /**\n   * The default set for new properties and components if none is specified.\n   * @type {designSet}\n   */ defaultSet: icalSet,\n    /**\n   * The default type for unknown properties\n   * @type {String}\n   */ defaultType: \"unknown\",\n    /**\n   * Holds the design set for known top-level components\n   *\n   * @type {Object}\n   * @property {designSet} vcard       vCard VCARD\n   * @property {designSet} vevent      iCalendar VEVENT\n   * @property {designSet} vtodo       iCalendar VTODO\n   * @property {designSet} vjournal    iCalendar VJOURNAL\n   * @property {designSet} valarm      iCalendar VALARM\n   * @property {designSet} vtimezone   iCalendar VTIMEZONE\n   * @property {designSet} daylight    iCalendar DAYLIGHT\n   * @property {designSet} standard    iCalendar STANDARD\n   *\n   * @example\n   * let propertyName = 'fn';\n   * let componentDesign = ICAL.design.components.vcard;\n   * let propertyDetails = componentDesign.property[propertyName];\n   * if (propertyDetails.defaultType == 'text') {\n   *   // Yep, sure is...\n   * }\n   */ components: {\n        vcard: vcardSet,\n        vcard3: vcard3Set,\n        vevent: icalSet,\n        vtodo: icalSet,\n        vjournal: icalSet,\n        valarm: icalSet,\n        vtimezone: icalSet,\n        daylight: icalSet,\n        standard: icalSet\n    },\n    /**\n   * The design set for iCalendar (rfc5545/rfc7265) components.\n   * @type {designSet}\n   */ icalendar: icalSet,\n    /**\n   * The design set for vCard (rfc6350/rfc7095) components.\n   * @type {designSet}\n   */ vcard: vcardSet,\n    /**\n   * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\n   * @type {designSet}\n   */ vcard3: vcard3Set,\n    /**\n   * Gets the design set for the given component name.\n   *\n   * @param {String} componentName        The name of the component\n   * @return {designSet}      The design set for the component\n   */ getDesignSet: function(componentName) {\n        let isInDesign = componentName && componentName in design.components;\n        return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n};\nvar design$1 = design;\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n *\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n */ const LINE_ENDING = \"\\r\\n\";\nconst DEFAULT_VALUE_TYPE = \"unknown\";\nconst RFC6868_REPLACE_MAP = {\n    '\"': \"^'\",\n    \"\\n\": \"^n\",\n    \"^\": \"^^\"\n};\n/**\n * Convert a full jCal/jCard array into a iCalendar/vCard string.\n *\n * @function ICAL.stringify\n * @variation function\n * @param {Array} jCal    The jCal/jCard document\n * @return {String}       The stringified iCalendar/vCard document\n */ function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n        // This is a single component\n        jCal = [\n            jCal\n        ];\n    }\n    let i = 0;\n    let len = jCal.length;\n    let result = \"\";\n    for(; i < len; i++){\n        result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n    return result;\n}\n/**\n * Converts an jCal component array into a ICAL string.\n * Recursive will resolve sub-components.\n *\n * Exact component/property order is not saved all\n * properties will come before subcomponents.\n *\n * @function ICAL.stringify.component\n * @param {Array} component\n *        jCal/jCard fragment of a component\n * @param {designSet} designSet\n *        The design data to use for this component\n * @return {String}       The iCalendar/vCard string\n */ stringify.component = function(component, designSet) {\n    let name = component[0].toUpperCase();\n    let result = \"BEGIN:\" + name + LINE_ENDING;\n    let props = component[1];\n    let propIdx = 0;\n    let propLen = props.length;\n    let designSetName = component[0];\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n    if (designSetName === \"vcard\" && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n        designSetName = \"vcard3\";\n    }\n    designSet = designSet || design$1.getDesignSet(designSetName);\n    for(; propIdx < propLen; propIdx++){\n        result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    }\n    // Ignore subcomponents if none exist, e.g. in vCard.\n    let comps = component[2] || [];\n    let compIdx = 0;\n    let compLen = comps.length;\n    for(; compIdx < compLen; compIdx++){\n        result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n    result += \"END:\" + name;\n    return result;\n};\n/**\n * Converts a single jCal/jCard property to a iCalendar/vCard string.\n *\n * @function ICAL.stringify.property\n * @param {Array} property\n *        jCal/jCard property array\n * @param {designSet} designSet\n *        The design data to use for this property\n * @param {Boolean} noFold\n *        If true, the line is not folded\n * @return {String}       The iCalendar/vCard string\n */ stringify.property = function(property, designSet, noFold) {\n    let name = property[0].toUpperCase();\n    let jsName = property[0];\n    let params = property[1];\n    if (!designSet) {\n        designSet = design$1.defaultSet;\n    }\n    let groupName = params.group;\n    let line;\n    if (designSet.propertyGroups && groupName) {\n        line = groupName.toUpperCase() + \".\" + name;\n    } else {\n        line = name;\n    }\n    for (let [paramName, value] of Object.entries(params)){\n        if (designSet.propertyGroups && paramName == \"group\") {\n            continue;\n        }\n        let paramDesign = designSet.param[paramName];\n        let multiValue = paramDesign && paramDesign.multiValue;\n        if (multiValue && Array.isArray(value)) {\n            value = value.map(function(val) {\n                val = stringify._rfc6868Unescape(val);\n                val = stringify.paramPropertyValue(val, paramDesign.multiValueSeparateDQuote);\n                return val;\n            });\n            value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n            value = stringify._rfc6868Unescape(value);\n            value = stringify.paramPropertyValue(value);\n        }\n        line += \";\" + paramName.toUpperCase() + \"=\" + value;\n    }\n    if (property.length === 3) {\n        // If there are no values, we must assume a blank value\n        return line + \":\";\n    }\n    let valueType = property[2];\n    let propDetails;\n    let multiValue = false;\n    let structuredValue = false;\n    let isDefault = false;\n    if (jsName in designSet.property) {\n        propDetails = designSet.property[jsName];\n        if (\"multiValue\" in propDetails) {\n            multiValue = propDetails.multiValue;\n        }\n        if (\"structuredValue\" in propDetails && Array.isArray(property[3])) {\n            structuredValue = propDetails.structuredValue;\n        }\n        if (\"defaultType\" in propDetails) {\n            if (valueType === propDetails.defaultType) {\n                isDefault = true;\n            }\n        } else {\n            if (valueType === DEFAULT_VALUE_TYPE) {\n                isDefault = true;\n            }\n        }\n    } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n            isDefault = true;\n        }\n    }\n    // push the VALUE property if type is not the default\n    // for the current property.\n    if (!isDefault) {\n        // value will never contain ;/:/, so we don't escape it here.\n        line += \";VALUE=\" + valueType.toUpperCase();\n    }\n    line += \":\";\n    if (multiValue && structuredValue) {\n        line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n    } else if (multiValue) {\n        line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n    } else if (structuredValue) {\n        line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n    } else {\n        line += stringify.value(property[3], valueType, designSet, false);\n    }\n    return noFold ? line : foldline(line);\n};\n/**\n * Handles escaping of property values that may contain:\n *\n *    COLON (:), SEMICOLON (;), or COMMA (,)\n *\n * If any of the above are present the result is wrapped\n * in double quotes.\n *\n * @function ICAL.stringify.paramPropertyValue\n * @param {String} value      Raw property value\n * @param {boolean} force     If value should be escaped even when unnecessary\n * @return {String}           Given or escaped value when needed\n */ stringify.paramPropertyValue = function(value, force) {\n    if (!force && value.indexOf(\",\") === -1 && value.indexOf(\":\") === -1 && value.indexOf(\";\") === -1) {\n        return value;\n    }\n    return '\"' + value + '\"';\n};\n/**\n * Converts an array of ical values into a single\n * string based on a type and a delimiter value (like \",\").\n *\n * @function ICAL.stringify.multiValue\n * @param {Array} values      List of values to convert\n * @param {String} delim      Used to join the values (\",\", \";\", \":\")\n * @param {String} type       Lowecase ical value type\n *        (like boolean, date-time, etc..)\n * @param {?String} innerMulti If set, each value will again be processed\n *        Used for structured values\n * @param {designSet} designSet\n *        The design data to use for this property\n *\n * @return {String}           iCalendar/vCard string for value\n */ stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\n    let result = \"\";\n    let len = values.length;\n    let i = 0;\n    for(; i < len; i++){\n        if (innerMulti && Array.isArray(values[i])) {\n            result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n        } else {\n            result += stringify.value(values[i], type, designSet, structuredValue);\n        }\n        if (i !== len - 1) {\n            result += delim;\n        }\n    }\n    return result;\n};\n/**\n * Processes a single ical value runs the associated \"toICAL\" method from the\n * design value type if available to convert the value.\n *\n * @function ICAL.stringify.value\n * @param {String|Number} value       A formatted value\n * @param {String} type               Lowercase iCalendar/vCard value type\n *  (like boolean, date-time, etc..)\n * @return {String}                   iCalendar/vCard value for single value\n */ stringify.value = function(value, type, designSet, structuredValue) {\n    if (type in designSet.value && \"toICAL\" in designSet.value[type]) {\n        return designSet.value[type].toICAL(value, structuredValue);\n    }\n    return value;\n};\n/**\n * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\n * hackers can disable the rfc6868 parsing if the really need to.\n *\n * @param {String} val        The value to unescape\n * @return {String}           The escaped value\n */ stringify._rfc6868Unescape = function(val) {\n    return val.replace(/[\\n^\"]/g, function(x) {\n        return RFC6868_REPLACE_MAP[x];\n    });\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ const NAME_INDEX$1 = 0;\nconst PROP_INDEX = 1;\nconst TYPE_INDEX = 2;\nconst VALUE_INDEX = 3;\n/**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").Geo} Geo\n * Imports the 'Geo' type from the \"types.js\" module\n */ /**\n * Provides a layer on top of the raw jCal object for manipulating a single property, with its\n * parameters and value.\n *\n * @memberof ICAL\n */ class Property {\n    /**\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\n   *\n   * @param {String} str            The iCalendar string to parse\n   * @param {designSet=} designSet  The design data to use for this property\n   * @return {Property}             The created iCalendar property\n   */ static fromString(str, designSet) {\n        return new Property(parse.property(str, designSet));\n    }\n    /**\n   * The value type for this property\n   * @type {String}\n   */ get type() {\n        return this.jCal[TYPE_INDEX];\n    }\n    /**\n   * The name of this property, in lowercase.\n   * @type {String}\n   */ get name() {\n        return this.jCal[NAME_INDEX$1];\n    }\n    /**\n   * The parent component for this property.\n   * @type {Component}\n   */ get parent() {\n        return this._parent;\n    }\n    set parent(p) {\n        // Before setting the parent, check if the design set has changed. If it\n        // has, we later need to update the type if it was unknown before.\n        let designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n        this._parent = p;\n        if (this.type == design$1.defaultType && designSetChanged) {\n            this.jCal[TYPE_INDEX] = this.getDefaultType();\n            this._updateType();\n        }\n    }\n    /**\n   * The design set for this property, e.g. icalendar vs vcard\n   *\n   * @type {designSet}\n   * @private\n   */ get _designSet() {\n        return this.parent ? this.parent._designSet : design$1.defaultSet;\n    }\n    /**\n   * Updates the type metadata from the current jCal type and design set.\n   *\n   * @private\n   */ _updateType() {\n        let designSet = this._designSet;\n        if (this.type in designSet.value) {\n            if (\"decorate\" in designSet.value[this.type]) {\n                this.isDecorated = true;\n            } else {\n                this.isDecorated = false;\n            }\n            if (this.name in designSet.property) {\n                this.isMultiValue = \"multiValue\" in designSet.property[this.name];\n                this.isStructuredValue = \"structuredValue\" in designSet.property[this.name];\n            }\n        }\n    }\n    /**\n   * Hydrate a single value. The act of hydrating means turning the raw jCal\n   * value into a potentially wrapped object, for example {@link ICAL.Time}.\n   *\n   * @private\n   * @param {Number} index        The index of the value to hydrate\n   * @return {?Object}             The decorated value.\n   */ _hydrateValue(index) {\n        if (this._values && this._values[index]) {\n            return this._values[index];\n        }\n        // for the case where there is no value.\n        if (this.jCal.length <= VALUE_INDEX + index) {\n            return null;\n        }\n        if (this.isDecorated) {\n            if (!this._values) {\n                this._values = [];\n            }\n            return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n        } else {\n            return this.jCal[VALUE_INDEX + index];\n        }\n    }\n    /**\n   * Decorate a single value, returning its wrapped object. This is used by\n   * the hydrate function to actually wrap the value.\n   *\n   * @private\n   * @param {?} value         The value to decorate\n   * @return {Object}         The decorated value\n   */ _decorate(value) {\n        return this._designSet.value[this.type].decorate(value, this);\n    }\n    /**\n   * Undecorate a single value, returning its raw jCal data.\n   *\n   * @private\n   * @param {Object} value         The value to undecorate\n   * @return {?}                   The undecorated value\n   */ _undecorate(value) {\n        return this._designSet.value[this.type].undecorate(value, this);\n    }\n    /**\n   * Sets the value at the given index while also hydrating it. The passed\n   * value can either be a decorated or undecorated value.\n   *\n   * @private\n   * @param {?} value             The value to set\n   * @param {Number} index        The index to set it at\n   */ _setDecoratedValue(value, index) {\n        if (!this._values) {\n            this._values = [];\n        }\n        if (typeof value === \"object\" && \"icaltype\" in value) {\n            // decorated value\n            this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n            this._values[index] = value;\n        } else {\n            // undecorated value\n            this.jCal[VALUE_INDEX + index] = value;\n            this._values[index] = this._decorate(value);\n        }\n    }\n    /**\n   * Gets a parameter on the property.\n   *\n   * @param {String}        name   Parameter name (lowercase)\n   * @return {Array|String}        Parameter value\n   */ getParameter(name) {\n        if (name in this.jCal[PROP_INDEX]) {\n            return this.jCal[PROP_INDEX][name];\n        } else {\n            return undefined;\n        }\n    }\n    /**\n   * Gets first parameter on the property.\n   *\n   * @param {String}        name   Parameter name (lowercase)\n   * @return {String}        Parameter value\n   */ getFirstParameter(name) {\n        let parameters = this.getParameter(name);\n        if (Array.isArray(parameters)) {\n            return parameters[0];\n        }\n        return parameters;\n    }\n    /**\n   * Sets a parameter on the property.\n   *\n   * @param {String}       name     The parameter name\n   * @param {Array|String} value    The parameter value\n   */ setParameter(name, value) {\n        let lcname = name.toLowerCase();\n        if (typeof value === \"string\" && lcname in this._designSet.param && \"multiValue\" in this._designSet.param[lcname]) {\n            value = [\n                value\n            ];\n        }\n        this.jCal[PROP_INDEX][name] = value;\n    }\n    /**\n   * Removes a parameter\n   *\n   * @param {String} name     The parameter name\n   */ removeParameter(name) {\n        delete this.jCal[PROP_INDEX][name];\n    }\n    /**\n   * Get the default type based on this property's name.\n   *\n   * @return {String}     The default type for this property\n   */ getDefaultType() {\n        let name = this.jCal[NAME_INDEX$1];\n        let designSet = this._designSet;\n        if (name in designSet.property) {\n            let details = designSet.property[name];\n            if (\"defaultType\" in details) {\n                return details.defaultType;\n            }\n        }\n        return design$1.defaultType;\n    }\n    /**\n   * Sets type of property and clears out any existing values of the current\n   * type.\n   *\n   * @param {String} type     New iCAL type (see design.*.values)\n   */ resetType(type) {\n        this.removeAllValues();\n        this.jCal[TYPE_INDEX] = type;\n        this._updateType();\n    }\n    /**\n   * Finds the first property value.\n   *\n   * @return {Binary | Duration | Period |\n   * Recur | Time | UtcOffset | Geo | string | null}         First property value\n   */ getFirstValue() {\n        return this._hydrateValue(0);\n    }\n    /**\n   * Gets all values on the property.\n   *\n   * NOTE: this creates an array during each call.\n   *\n   * @return {Array}          List of values\n   */ getValues() {\n        let len = this.jCal.length - VALUE_INDEX;\n        if (len < 1) {\n            // it is possible for a property to have no value.\n            return [];\n        }\n        let i = 0;\n        let result = [];\n        for(; i < len; i++){\n            result[i] = this._hydrateValue(i);\n        }\n        return result;\n    }\n    /**\n   * Removes all values from this property\n   */ removeAllValues() {\n        if (this._values) {\n            this._values.length = 0;\n        }\n        this.jCal.length = 3;\n    }\n    /**\n   * Sets the values of the property.  Will overwrite the existing values.\n   * This can only be used for multi-value properties.\n   *\n   * @param {Array} values    An array of values\n   */ setValues(values) {\n        if (!this.isMultiValue) {\n            throw new Error(this.name + \": does not not support mulitValue.\\n\" + \"override isMultiValue\");\n        }\n        let len = values.length;\n        let i = 0;\n        this.removeAllValues();\n        if (len > 0 && typeof values[0] === \"object\" && \"icaltype\" in values[0]) {\n            this.resetType(values[0].icaltype);\n        }\n        if (this.isDecorated) {\n            for(; i < len; i++){\n                this._setDecoratedValue(values[i], i);\n            }\n        } else {\n            for(; i < len; i++){\n                this.jCal[VALUE_INDEX + i] = values[i];\n            }\n        }\n    }\n    /**\n   * Sets the current value of the property. If this is a multi-value\n   * property, all other values will be removed.\n   *\n   * @param {String|Object} value     New property value.\n   */ setValue(value) {\n        this.removeAllValues();\n        if (typeof value === \"object\" && \"icaltype\" in value) {\n            this.resetType(value.icaltype);\n        }\n        if (this.isDecorated) {\n            this._setDecoratedValue(value, 0);\n        } else {\n            this.jCal[VALUE_INDEX] = value;\n        }\n    }\n    /**\n   * Returns the Object representation of this component. The returned object\n   * is a live jCal object and should be cloned if modified.\n   * @return {Object}\n   */ toJSON() {\n        return this.jCal;\n    }\n    /**\n   * The string representation of this component.\n   * @return {String}\n   */ toICALString() {\n        return stringify.property(this.jCal, this._designSet, true);\n    }\n    /**\n   * Creates a new ICAL.Property instance.\n   *\n   * It is important to note that mutations done in the wrapper directly mutate the jCal object used\n   * to initialize.\n   *\n   * Can also be used to create new properties by passing the name of the property (as a String).\n   *\n   * @param {Array|String} jCal         Raw jCal representation OR the new name of the property\n   * @param {Component=} parent         Parent component\n   */ constructor(jCal, parent){\n        this._parent = parent || null;\n        if (typeof jCal === \"string\") {\n            // We are creating the property by name and need to detect the type\n            this.jCal = [\n                jCal,\n                {},\n                design$1.defaultType\n            ];\n            this.jCal[TYPE_INDEX] = this.getDefaultType();\n        } else {\n            this.jCal = jCal;\n        }\n        this._updateType();\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").designSet} designSet\n * Imports the 'designSet' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").Geo} Geo\n * Imports the 'Geo' type from the \"types.js\" module\n */ const NAME_INDEX = 0;\nconst PROPERTY_INDEX = 1;\nconst COMPONENT_INDEX = 2;\n/**\n * Wraps a jCal component, adding convenience methods to add, remove and update subcomponents and\n * properties.\n *\n * @memberof ICAL\n */ class Component {\n    /**\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\n   *\n   * @param {String} str        The iCalendar string to parse\n   */ static fromString(str) {\n        return new Component(parse.component(str));\n    }\n    /**\n   * The name of this component\n   *\n   * @type {String}\n   */ get name() {\n        return this.jCal[NAME_INDEX];\n    }\n    /**\n   * The design set for this component, e.g. icalendar vs vcard\n   *\n   * @type {designSet}\n   * @private\n   */ get _designSet() {\n        let parentDesign = this.parent && this.parent._designSet;\n        return parentDesign || design$1.getDesignSet(this.name);\n    }\n    /**\n   * @private\n   */ _hydrateComponent(index) {\n        if (!this._components) {\n            this._components = [];\n            this._hydratedComponentCount = 0;\n        }\n        if (this._components[index]) {\n            return this._components[index];\n        }\n        let comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n        this._hydratedComponentCount++;\n        return this._components[index] = comp;\n    }\n    /**\n   * @private\n   */ _hydrateProperty(index) {\n        if (!this._properties) {\n            this._properties = [];\n            this._hydratedPropertyCount = 0;\n        }\n        if (this._properties[index]) {\n            return this._properties[index];\n        }\n        let prop = new Property(this.jCal[PROPERTY_INDEX][index], this);\n        this._hydratedPropertyCount++;\n        return this._properties[index] = prop;\n    }\n    /**\n   * Finds first sub component, optionally filtered by name.\n   *\n   * @param {String=} name        Optional name to filter by\n   * @return {?Component}     The found subcomponent\n   */ getFirstSubcomponent(name) {\n        if (name) {\n            let i = 0;\n            let comps = this.jCal[COMPONENT_INDEX];\n            let len = comps.length;\n            for(; i < len; i++){\n                if (comps[i][NAME_INDEX] === name) {\n                    let result = this._hydrateComponent(i);\n                    return result;\n                }\n            }\n        } else {\n            if (this.jCal[COMPONENT_INDEX].length) {\n                return this._hydrateComponent(0);\n            }\n        }\n        // ensure we return a value (strict mode)\n        return null;\n    }\n    /**\n   * Finds all sub components, optionally filtering by name.\n   *\n   * @param {String=} name            Optional name to filter by\n   * @return {Component[]}       The found sub components\n   */ getAllSubcomponents(name) {\n        let jCalLen = this.jCal[COMPONENT_INDEX].length;\n        let i = 0;\n        if (name) {\n            let comps = this.jCal[COMPONENT_INDEX];\n            let result = [];\n            for(; i < jCalLen; i++){\n                if (name === comps[i][NAME_INDEX]) {\n                    result.push(this._hydrateComponent(i));\n                }\n            }\n            return result;\n        } else {\n            if (!this._components || this._hydratedComponentCount !== jCalLen) {\n                for(; i < jCalLen; i++){\n                    this._hydrateComponent(i);\n                }\n            }\n            return this._components || [];\n        }\n    }\n    /**\n   * Returns true when a named property exists.\n   *\n   * @param {String} name     The property name\n   * @return {Boolean}        True, when property is found\n   */ hasProperty(name) {\n        let props = this.jCal[PROPERTY_INDEX];\n        let len = props.length;\n        let i = 0;\n        for(; i < len; i++){\n            // 0 is property name\n            if (props[i][NAME_INDEX] === name) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Finds the first property, optionally with the given name.\n   *\n   * @param {String=} name        Lowercase property name\n   * @return {?Property}     The found property\n   */ getFirstProperty(name) {\n        if (name) {\n            let i = 0;\n            let props = this.jCal[PROPERTY_INDEX];\n            let len = props.length;\n            for(; i < len; i++){\n                if (props[i][NAME_INDEX] === name) {\n                    let result = this._hydrateProperty(i);\n                    return result;\n                }\n            }\n        } else {\n            if (this.jCal[PROPERTY_INDEX].length) {\n                return this._hydrateProperty(0);\n            }\n        }\n        return null;\n    }\n    /**\n   * Returns first property's value, if available.\n   *\n   * @param {String=} name                    Lowercase property name\n   * @return {Binary | Duration | Period |\n   * Recur | Time | UtcOffset | Geo | string | null}         The found property value.\n   */ getFirstPropertyValue(name) {\n        let prop = this.getFirstProperty(name);\n        if (prop) {\n            return prop.getFirstValue();\n        }\n        return null;\n    }\n    /**\n   * Get all properties in the component, optionally filtered by name.\n   *\n   * @param {String=} name        Lowercase property name\n   * @return {Property[]}    List of properties\n   */ getAllProperties(name) {\n        let jCalLen = this.jCal[PROPERTY_INDEX].length;\n        let i = 0;\n        if (name) {\n            let props = this.jCal[PROPERTY_INDEX];\n            let result = [];\n            for(; i < jCalLen; i++){\n                if (name === props[i][NAME_INDEX]) {\n                    result.push(this._hydrateProperty(i));\n                }\n            }\n            return result;\n        } else {\n            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n                for(; i < jCalLen; i++){\n                    this._hydrateProperty(i);\n                }\n            }\n            return this._properties || [];\n        }\n    }\n    /**\n   * @private\n   */ _removeObjectByIndex(jCalIndex, cache, index) {\n        cache = cache || [];\n        // remove cached version\n        if (cache[index]) {\n            let obj = cache[index];\n            if (\"parent\" in obj) {\n                obj.parent = null;\n            }\n        }\n        cache.splice(index, 1);\n        // remove it from the jCal\n        this.jCal[jCalIndex].splice(index, 1);\n    }\n    /**\n   * @private\n   */ _removeObject(jCalIndex, cache, nameOrObject) {\n        let i = 0;\n        let objects = this.jCal[jCalIndex];\n        let len = objects.length;\n        let cached = this[cache];\n        if (typeof nameOrObject === \"string\") {\n            for(; i < len; i++){\n                if (objects[i][NAME_INDEX] === nameOrObject) {\n                    this._removeObjectByIndex(jCalIndex, cached, i);\n                    return true;\n                }\n            }\n        } else if (cached) {\n            for(; i < len; i++){\n                if (cached[i] && cached[i] === nameOrObject) {\n                    this._removeObjectByIndex(jCalIndex, cached, i);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n   * @private\n   */ _removeAllObjects(jCalIndex, cache, name) {\n        let cached = this[cache];\n        // Unfortunately we have to run through all children to reset their\n        // parent property.\n        let objects = this.jCal[jCalIndex];\n        let i = objects.length - 1;\n        // descending search required because splice\n        // is used and will effect the indices.\n        for(; i >= 0; i--){\n            if (!name || objects[i][NAME_INDEX] === name) {\n                this._removeObjectByIndex(jCalIndex, cached, i);\n            }\n        }\n    }\n    /**\n   * Adds a single sub component.\n   *\n   * @param {Component} component        The component to add\n   * @return {Component}                 The passed in component\n   */ addSubcomponent(component) {\n        if (!this._components) {\n            this._components = [];\n            this._hydratedComponentCount = 0;\n        }\n        if (component.parent) {\n            component.parent.removeSubcomponent(component);\n        }\n        let idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n        this._components[idx - 1] = component;\n        this._hydratedComponentCount++;\n        component.parent = this;\n        return component;\n    }\n    /**\n   * Removes a single component by name or the instance of a specific\n   * component.\n   *\n   * @param {Component|String} nameOrComp    Name of component, or component\n   * @return {Boolean}                            True when comp is removed\n   */ removeSubcomponent(nameOrComp) {\n        let removed = this._removeObject(COMPONENT_INDEX, \"_components\", nameOrComp);\n        if (removed) {\n            this._hydratedComponentCount--;\n        }\n        return removed;\n    }\n    /**\n   * Removes all components or (if given) all components by a particular\n   * name.\n   *\n   * @param {String=} name            Lowercase component name\n   */ removeAllSubcomponents(name) {\n        let removed = this._removeAllObjects(COMPONENT_INDEX, \"_components\", name);\n        this._hydratedComponentCount = 0;\n        return removed;\n    }\n    /**\n   * Adds an {@link ICAL.Property} to the component.\n   *\n   * @param {Property} property      The property to add\n   * @return {Property}              The passed in property\n   */ addProperty(property) {\n        if (!(property instanceof Property)) {\n            throw new TypeError(\"must be instance of ICAL.Property\");\n        }\n        if (!this._properties) {\n            this._properties = [];\n            this._hydratedPropertyCount = 0;\n        }\n        if (property.parent) {\n            property.parent.removeProperty(property);\n        }\n        let idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n        this._properties[idx - 1] = property;\n        this._hydratedPropertyCount++;\n        property.parent = this;\n        return property;\n    }\n    /**\n   * Helper method to add a property with a value to the component.\n   *\n   * @param {String}               name         Property name to add\n   * @param {String|Number|Object} value        Property value\n   * @return {Property}                    The created property\n   */ addPropertyWithValue(name, value) {\n        let prop = new Property(name);\n        prop.setValue(value);\n        this.addProperty(prop);\n        return prop;\n    }\n    /**\n   * Helper method that will update or create a property of the given name\n   * and sets its value. If multiple properties with the given name exist,\n   * only the first is updated.\n   *\n   * @param {String}               name         Property name to update\n   * @param {String|Number|Object} value        Property value\n   * @return {Property}                    The created property\n   */ updatePropertyWithValue(name, value) {\n        let prop = this.getFirstProperty(name);\n        if (prop) {\n            prop.setValue(value);\n        } else {\n            prop = this.addPropertyWithValue(name, value);\n        }\n        return prop;\n    }\n    /**\n   * Removes a single property by name or the instance of the specific\n   * property.\n   *\n   * @param {String|Property} nameOrProp     Property name or instance to remove\n   * @return {Boolean}                            True, when deleted\n   */ removeProperty(nameOrProp) {\n        let removed = this._removeObject(PROPERTY_INDEX, \"_properties\", nameOrProp);\n        if (removed) {\n            this._hydratedPropertyCount--;\n        }\n        return removed;\n    }\n    /**\n   * Removes all properties associated with this component, optionally\n   * filtered by name.\n   *\n   * @param {String=} name        Lowercase property name\n   * @return {Boolean}            True, when deleted\n   */ removeAllProperties(name) {\n        let removed = this._removeAllObjects(PROPERTY_INDEX, \"_properties\", name);\n        this._hydratedPropertyCount = 0;\n        return removed;\n    }\n    /**\n   * Returns the Object representation of this component. The returned object\n   * is a live jCal object and should be cloned if modified.\n   * @return {Object}\n   */ toJSON() {\n        return this.jCal;\n    }\n    /**\n   * The string representation of this component.\n   * @return {String}\n   */ toString() {\n        return stringify.component(this.jCal, this._designSet);\n    }\n    /**\n   * Retrieve a time zone definition from the component tree, if any is present.\n   * If the tree contains no time zone definitions or the TZID cannot be\n   * matched, returns null.\n   *\n   * @param {String} tzid     The ID of the time zone to retrieve\n   * @return {Timezone}  The time zone corresponding to the ID, or null\n   */ getTimeZoneByID(tzid) {\n        // VTIMEZONE components can only appear as a child of the VCALENDAR\n        // component; walk the tree if we're not the root.\n        if (this.parent) {\n            return this.parent.getTimeZoneByID(tzid);\n        }\n        // If there is no time zone cache, we are probably parsing an incomplete\n        // file and will have no time zone definitions.\n        if (!this._timezoneCache) {\n            return null;\n        }\n        if (this._timezoneCache.has(tzid)) {\n            return this._timezoneCache.get(tzid);\n        }\n        // If the time zone is not already cached, hydrate it from the\n        // subcomponents.\n        const zones = this.getAllSubcomponents(\"vtimezone\");\n        for (const zone of zones){\n            if (zone.getFirstProperty(\"tzid\").getFirstValue() === tzid) {\n                const hydratedZone = new Timezone({\n                    component: zone,\n                    tzid: tzid\n                });\n                this._timezoneCache.set(tzid, hydratedZone);\n                return hydratedZone;\n            }\n        }\n        // Per the standard, we should always have a time zone defined in a file\n        // for any referenced TZID, but don't blow up if the file is invalid.\n        return null;\n    }\n    /**\n   * Creates a new Component instance.\n   *\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\n   *                                      component\n   * @param {Component=} parent     Parent component to associate\n   */ constructor(jCal, parent){\n        /**\n   * Hydrated properties are inserted into the _properties array at the same\n   * position as in the jCal array, so it is possible that the array contains\n   * undefined values for unhydrdated properties. To avoid iterating the\n   * array when checking if all properties have been hydrated, we save the\n   * count here.\n   *\n   * @type {Number}\n   * @private\n   */ this._hydratedPropertyCount = 0;\n        /**\n   * The same count as for _hydratedPropertyCount, but for subcomponents\n   *\n   * @type {Number}\n   * @private\n   */ this._hydratedComponentCount = 0;\n        /**\n   * A cache of hydrated time zone objects which may be used by consumers, keyed\n   * by time zone ID.\n   *\n   * @type {Map}\n   * @private\n   */ this._timezoneCache = null;\n        /**\n   * @private\n   */ this._components = null;\n        /**\n   * @private\n   */ this._properties = null;\n        if (typeof jCal === \"string\") {\n            // jCal spec (name, properties, components)\n            jCal = [\n                jCal,\n                [],\n                []\n            ];\n        }\n        // mostly for legacy reasons.\n        this.jCal = jCal;\n        this.parent = parent || null;\n        if (!this.parent && this.name === \"vcalendar\") {\n            this._timezoneCache = new Map();\n        }\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * Primary class for expanding recurring rules.  Can take multiple rrules, rdates, exdate(s) and\n * iterate (in order) over each next occurrence.\n *\n * Once initialized this class can also be serialized saved and continue iteration from the last\n * point.\n *\n * NOTE: it is intended that this class is to be used with {@link ICAL.Event} which handles recurrence\n * exceptions.\n *\n * @example\n * // assuming event is a parsed ical component\n * var event;\n *\n * var expand = new ICAL.RecurExpansion({\n *   component: event,\n *   dtstart: event.getFirstPropertyValue('dtstart')\n * });\n *\n * // remember there are infinite rules so it is a good idea to limit the scope of the iterations\n * // then resume later on.\n *\n * // next is always an ICAL.Time or null\n * var next;\n *\n * while (someCondition && (next = expand.next())) {\n *   // do something with next\n * }\n *\n * // save instance for later\n * var json = JSON.stringify(expand);\n *\n * //...\n *\n * // NOTE: if the component's properties have changed you will need to rebuild the class and start\n * // over. This only works when the component's recurrence info is the same.\n * var expand = new ICAL.RecurExpansion(JSON.parse(json));\n *\n * @memberof ICAL\n */ class RecurExpansion {\n    /**\n   * Initialize the recurrence expansion from the data object. The options\n   * object may also contain additional members, see the\n   * {@link ICAL.RecurExpansion constructor} for more details.\n   *\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {Time} options.dtstart\n   *        Start time of the event\n   * @param {Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */ fromData(options) {\n        let start = formatClassType(options.dtstart, Time);\n        if (!start) {\n            throw new Error(\".dtstart (ICAL.Time) must be given\");\n        } else {\n            this.dtstart = start;\n        }\n        if (options.component) {\n            this._init(options.component);\n        } else {\n            this.last = formatClassType(options.last, Time) || start.clone();\n            if (!options.ruleIterators) {\n                throw new Error(\".ruleIterators or .component must be given\");\n            }\n            this.ruleIterators = options.ruleIterators.map(function(item) {\n                return formatClassType(item, RecurIterator);\n            });\n            this.ruleDateInc = options.ruleDateInc;\n            this.exDateInc = options.exDateInc;\n            if (options.ruleDates) {\n                this.ruleDates = options.ruleDates.map((item)=>formatClassType(item, Time));\n                this.ruleDate = this.ruleDates[this.ruleDateInc];\n            }\n            if (options.exDates) {\n                this.exDates = options.exDates.map((item)=>formatClassType(item, Time));\n                this.exDate = this.exDates[this.exDateInc];\n            }\n            if (typeof options.complete !== \"undefined\") {\n                this.complete = options.complete;\n            }\n        }\n    }\n    /**\n   * Retrieve the next occurrence in the series.\n   * @return {Time}\n   */ next() {\n        let iter;\n        let next;\n        let compare;\n        let maxTries = 500;\n        let currentTry = 0;\n        while(true){\n            if (currentTry++ > maxTries) {\n                throw new Error(\"max tries have occurred, rule may be impossible to fulfill.\");\n            }\n            next = this.ruleDate;\n            iter = this._nextRecurrenceIter(this.last);\n            // no more matches\n            // because we increment the rule day or rule\n            // _after_ we choose a value this should be\n            // the only spot where we need to worry about the\n            // end of events.\n            if (!next && !iter) {\n                // there are no more iterators or rdates\n                this.complete = true;\n                break;\n            }\n            // no next rule day or recurrence rule is first.\n            if (!next || iter && next.compare(iter.last) > 0) {\n                // must be cloned, recur will reuse the time element.\n                next = iter.last.clone();\n                // move to next so we can continue\n                iter.next();\n            }\n            // if the ruleDate is still next increment it.\n            if (this.ruleDate === next) {\n                this._nextRuleDay();\n            }\n            this.last = next;\n            // check the negative rules\n            if (this.exDate) {\n                compare = this.exDate.compare(this.last);\n                if (compare < 0) {\n                    this._nextExDay();\n                }\n                // if the current rule is excluded skip it.\n                if (compare === 0) {\n                    this._nextExDay();\n                    continue;\n                }\n            }\n            //XXX: The spec states that after we resolve the final\n            //     list of dates we execute exdate this seems somewhat counter\n            //     intuitive to what I have seen most servers do so for now\n            //     I exclude based on the original date not the one that may\n            //     have been modified by the exception.\n            return this.last;\n        }\n    }\n    /**\n   * Converts object into a serialize-able format. This format can be passed\n   * back into the expansion to resume iteration.\n   * @return {Object}\n   */ toJSON() {\n        function toJSON(item) {\n            return item.toJSON();\n        }\n        let result = Object.create(null);\n        result.ruleIterators = this.ruleIterators.map(toJSON);\n        if (this.ruleDates) {\n            result.ruleDates = this.ruleDates.map(toJSON);\n        }\n        if (this.exDates) {\n            result.exDates = this.exDates.map(toJSON);\n        }\n        result.ruleDateInc = this.ruleDateInc;\n        result.exDateInc = this.exDateInc;\n        result.last = this.last.toJSON();\n        result.dtstart = this.dtstart.toJSON();\n        result.complete = this.complete;\n        return result;\n    }\n    /**\n   * Extract all dates from the properties in the given component. The\n   * properties will be filtered by the property name.\n   *\n   * @private\n   * @param {Component} component             The component to search in\n   * @param {String} propertyName             The property name to search for\n   * @return {Time[]}                         The extracted dates.\n   */ _extractDates(component, propertyName) {\n        let result = [];\n        let props = component.getAllProperties(propertyName);\n        for(let i = 0, len = props.length; i < len; i++){\n            for (let prop of props[i].getValues()){\n                let idx = binsearchInsert(result, prop, (a, b)=>a.compare(b));\n                // ordered insert\n                result.splice(idx, 0, prop);\n            }\n        }\n        return result;\n    }\n    /**\n   * Initialize the recurrence expansion.\n   *\n   * @private\n   * @param {Component} component    The component to initialize from.\n   */ _init(component) {\n        this.ruleIterators = [];\n        this.last = this.dtstart.clone();\n        // to provide api consistency non-recurring\n        // events can also use the iterator though it will\n        // only return a single time.\n        if (!component.hasProperty(\"rdate\") && !component.hasProperty(\"rrule\") && !component.hasProperty(\"recurrence-id\")) {\n            this.ruleDate = this.last.clone();\n            this.complete = true;\n            return;\n        }\n        if (component.hasProperty(\"rdate\")) {\n            this.ruleDates = this._extractDates(component, \"rdate\");\n            // special hack for cases where first rdate is prior\n            // to the start date. We only check for the first rdate.\n            // This is mostly for google's crazy recurring date logic\n            // (contacts birthdays).\n            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n                this.ruleDateInc = 0;\n                this.last = this.ruleDates[0].clone();\n            } else {\n                this.ruleDateInc = binsearchInsert(this.ruleDates, this.last, (a, b)=>a.compare(b));\n            }\n            this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n        if (component.hasProperty(\"rrule\")) {\n            let rules = component.getAllProperties(\"rrule\");\n            let i = 0;\n            let len = rules.length;\n            let rule;\n            let iter;\n            for(; i < len; i++){\n                rule = rules[i].getFirstValue();\n                iter = rule.iterator(this.dtstart);\n                this.ruleIterators.push(iter);\n                // increment to the next occurrence so future\n                // calls to next return times beyond the initial iteration.\n                // XXX: I find this suspicious might be a bug?\n                iter.next();\n            }\n        }\n        if (component.hasProperty(\"exdate\")) {\n            this.exDates = this._extractDates(component, \"exdate\");\n            // if we have a .last day we increment the index to beyond it.\n            this.exDateInc = binsearchInsert(this.exDates, this.last, (a, b)=>a.compare(b));\n            this.exDate = this.exDates[this.exDateInc];\n        }\n    }\n    /**\n   * Advance to the next exdate\n   * @private\n   */ _nextExDay() {\n        this.exDate = this.exDates[++this.exDateInc];\n    }\n    /**\n   * Advance to the next rule date\n   * @private\n   */ _nextRuleDay() {\n        this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    }\n    /**\n   * Find and return the recurrence rule with the most recent event and\n   * return it.\n   *\n   * @private\n   * @return {?RecurIterator}    Found iterator.\n   */ _nextRecurrenceIter() {\n        let iters = this.ruleIterators;\n        if (iters.length === 0) {\n            return null;\n        }\n        let len = iters.length;\n        let iter;\n        let iterTime;\n        let iterIdx = 0;\n        let chosenIter;\n        // loop through each iterator\n        for(; iterIdx < len; iterIdx++){\n            iter = iters[iterIdx];\n            iterTime = iter.last;\n            // if iteration is complete\n            // then we must exclude it from\n            // the search and remove it.\n            if (iter.completed) {\n                len--;\n                if (iterIdx !== 0) {\n                    iterIdx--;\n                }\n                iters.splice(iterIdx, 1);\n                continue;\n            }\n            // find the most recent possible choice\n            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n                // that iterator is saved\n                chosenIter = iter;\n            }\n        }\n        // the chosen iterator is returned but not mutated\n        // this iterator contains the most recent event.\n        return chosenIter;\n    }\n    /**\n   * Creates a new ICAL.RecurExpansion instance.\n   *\n   * The options object can be filled with the specified initial values. It can also contain\n   * additional members, as a result of serializing a previous expansion state, as shown in the\n   * example.\n   *\n   * @param {Object} options\n   *        Recurrence expansion options\n   * @param {Time} options.dtstart\n   *        Start time of the event\n   * @param {Component=} options.component\n   *        Component for expansion, required if not resuming.\n   */ constructor(options){\n        /**\n   * True when iteration is fully completed.\n   * @type {Boolean}\n   */ this.complete = false;\n        /**\n   * Array of rrule iterators.\n   *\n   * @type {RecurIterator[]}\n   * @private\n   */ this.ruleIterators = null;\n        /**\n   * Array of rdate instances.\n   *\n   * @type {Time[]}\n   * @private\n   */ this.ruleDates = null;\n        /**\n   * Array of exdate instances.\n   *\n   * @type {Time[]}\n   * @private\n   */ this.exDates = null;\n        /**\n   * Current position in ruleDates array.\n   * @type {Number}\n   * @private\n   */ this.ruleDateInc = 0;\n        /**\n   * Current position in exDates array\n   * @type {Number}\n   * @private\n   */ this.exDateInc = 0;\n        /**\n   * Current negative date.\n   *\n   * @type {Time}\n   * @private\n   */ this.exDate = null;\n        /**\n   * Current additional date.\n   *\n   * @type {Time}\n   * @private\n   */ this.ruleDate = null;\n        /**\n   * Start date of recurring rules.\n   *\n   * @type {Time}\n   */ this.dtstart = null;\n        /**\n   * Last expanded time\n   *\n   * @type {Time}\n   */ this.last = null;\n        this.ruleDates = [];\n        this.exDates = [];\n        this.fromData(options);\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * This lets typescript resolve our custom types in the\n * generated d.ts files (jsdoc typedefs are converted to typescript types).\n * Ignore prevents the typedefs from being documented more than once.\n * @ignore\n * @typedef {import(\"./types.js\").frequencyValues} frequencyValues\n * Imports the 'frequencyValues' type from the \"types.js\" module\n * @typedef {import(\"./types.js\").occurrenceDetails} occurrenceDetails\n * Imports the 'occurrenceDetails' type from the \"types.js\" module\n */ /**\n * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\n * object, followed by the component/property layer. The highest level is the\n * event representation, which this class is part of. See the\n * {@tutorial layers} guide for more details.\n *\n * @memberof ICAL\n */ class Event {\n    /**\n   * Relates a given event exception to this object.  If the given component\n   * does not share the UID of this event it cannot be related and will throw\n   * an exception.\n   *\n   * If this component is an exception it cannot have other exceptions\n   * related to it.\n   *\n   * @param {Component|Event} obj       Component or event\n   */ relateException(obj) {\n        if (this.isRecurrenceException()) {\n            throw new Error(\"cannot relate exception to exceptions\");\n        }\n        if (obj instanceof Component) {\n            obj = new Event(obj);\n        }\n        if (this.strictExceptions && obj.uid !== this.uid) {\n            throw new Error(\"attempted to relate unrelated exception\");\n        }\n        let id = obj.recurrenceId.toString();\n        // we don't sort or manage exceptions directly\n        // here the recurrence expander handles that.\n        this.exceptions[id] = obj;\n        // index RANGE=THISANDFUTURE exceptions so we can\n        // look them up later in getOccurrenceDetails.\n        if (obj.modifiesFuture()) {\n            let item = [\n                obj.recurrenceId.toUnixTime(),\n                id\n            ];\n            // we keep them sorted so we can find the nearest\n            // value later on...\n            let idx = binsearchInsert(this.rangeExceptions, item, compareRangeException);\n            this.rangeExceptions.splice(idx, 0, item);\n        }\n    }\n    /**\n   * Checks if this record is an exception and has the RANGE=THISANDFUTURE\n   * value.\n   *\n   * @return {Boolean}        True, when exception is within range\n   */ modifiesFuture() {\n        if (!this.component.hasProperty(\"recurrence-id\")) {\n            return false;\n        }\n        let range = this.component.getFirstProperty(\"recurrence-id\").getParameter(\"range\");\n        return range === Event.THISANDFUTURE;\n    }\n    /**\n   * Finds the range exception nearest to the given date.\n   *\n   * @param {Time} time   usually an occurrence time of an event\n   * @return {?Event}     the related event/exception or null\n   */ findRangeException(time) {\n        if (!this.rangeExceptions.length) {\n            return null;\n        }\n        let utc = time.toUnixTime();\n        let idx = binsearchInsert(this.rangeExceptions, [\n            utc\n        ], compareRangeException);\n        idx -= 1;\n        // occurs before\n        if (idx < 0) {\n            return null;\n        }\n        let rangeItem = this.rangeExceptions[idx];\n        /* c8 ignore next 4 */ if (utc < rangeItem[0]) {\n            // sanity check only\n            return null;\n        }\n        return rangeItem[1];\n    }\n    /**\n   * Returns the occurrence details based on its start time.  If the\n   * occurrence has an exception will return the details for that exception.\n   *\n   * NOTE: this method is intend to be used in conjunction\n   *       with the {@link ICAL.Event#iterator iterator} method.\n   *\n   * @param {Time} occurrence               time occurrence\n   * @return {occurrenceDetails}            Information about the occurrence\n   */ getOccurrenceDetails(occurrence) {\n        let id = occurrence.toString();\n        let utcId = occurrence.convertToZone(Timezone.utcTimezone).toString();\n        let item;\n        let result = {\n            //XXX: Clone?\n            recurrenceId: occurrence\n        };\n        if (id in this.exceptions) {\n            item = result.item = this.exceptions[id];\n            result.startDate = item.startDate;\n            result.endDate = item.endDate;\n            result.item = item;\n        } else if (utcId in this.exceptions) {\n            item = this.exceptions[utcId];\n            result.startDate = item.startDate;\n            result.endDate = item.endDate;\n            result.item = item;\n        } else {\n            // range exceptions (RANGE=THISANDFUTURE) have a\n            // lower priority then direct exceptions but\n            // must be accounted for first. Their item is\n            // always the first exception with the range prop.\n            let rangeExceptionId = this.findRangeException(occurrence);\n            let end;\n            if (rangeExceptionId) {\n                let exception = this.exceptions[rangeExceptionId];\n                // range exception must modify standard time\n                // by the difference (if any) in start/end times.\n                result.item = exception;\n                let startDiff = this._rangeExceptionCache[rangeExceptionId];\n                if (!startDiff) {\n                    let original = exception.recurrenceId.clone();\n                    let newStart = exception.startDate.clone();\n                    // zones must be same otherwise subtract may be incorrect.\n                    original.zone = newStart.zone;\n                    startDiff = newStart.subtractDate(original);\n                    this._rangeExceptionCache[rangeExceptionId] = startDiff;\n                }\n                let start = occurrence.clone();\n                start.zone = exception.startDate.zone;\n                start.addDuration(startDiff);\n                end = start.clone();\n                end.addDuration(exception.duration);\n                result.startDate = start;\n                result.endDate = end;\n            } else {\n                // no range exception standard expansion\n                end = occurrence.clone();\n                end.addDuration(this.duration);\n                result.endDate = end;\n                result.startDate = occurrence;\n                result.item = this;\n            }\n        }\n        return result;\n    }\n    /**\n   * Builds a recur expansion instance for a specific point in time (defaults\n   * to startDate).\n   *\n   * @param {Time=} startTime     Starting point for expansion\n   * @return {RecurExpansion}    Expansion object\n   */ iterator(startTime) {\n        return new RecurExpansion({\n            component: this.component,\n            dtstart: startTime || this.startDate\n        });\n    }\n    /**\n   * Checks if the event is recurring\n   *\n   * @return {Boolean}        True, if event is recurring\n   */ isRecurring() {\n        let comp = this.component;\n        return comp.hasProperty(\"rrule\") || comp.hasProperty(\"rdate\");\n    }\n    /**\n   * Checks if the event describes a recurrence exception. See\n   * {@tutorial terminology} for details.\n   *\n   * @return {Boolean}    True, if the event describes a recurrence exception\n   */ isRecurrenceException() {\n        return this.component.hasProperty(\"recurrence-id\");\n    }\n    /**\n   * Returns the types of recurrences this event may have.\n   *\n   * Returned as an object with the following possible keys:\n   *\n   *    - YEARLY\n   *    - MONTHLY\n   *    - WEEKLY\n   *    - DAILY\n   *    - MINUTELY\n   *    - SECONDLY\n   *\n   * @return {Object.<frequencyValues, Boolean>}\n   *          Object of recurrence flags\n   */ getRecurrenceTypes() {\n        let rules = this.component.getAllProperties(\"rrule\");\n        let i = 0;\n        let len = rules.length;\n        let result = Object.create(null);\n        for(; i < len; i++){\n            let value = rules[i].getFirstValue();\n            result[value.freq] = true;\n        }\n        return result;\n    }\n    /**\n   * The uid of this event\n   * @type {String}\n   */ get uid() {\n        return this._firstProp(\"uid\");\n    }\n    set uid(value) {\n        this._setProp(\"uid\", value);\n    }\n    /**\n   * The start date\n   * @type {Time}\n   */ get startDate() {\n        return this._firstProp(\"dtstart\");\n    }\n    set startDate(value) {\n        this._setTime(\"dtstart\", value);\n    }\n    /**\n   * The end date. This can be the result directly from the property, or the\n   * end date calculated from start date and duration. Setting the property\n   * will remove any duration properties.\n   * @type {Time}\n   */ get endDate() {\n        let endDate = this._firstProp(\"dtend\");\n        if (!endDate) {\n            let duration = this._firstProp(\"duration\");\n            endDate = this.startDate.clone();\n            if (duration) {\n                endDate.addDuration(duration);\n            } else if (endDate.isDate) {\n                endDate.day += 1;\n            }\n        }\n        return endDate;\n    }\n    set endDate(value) {\n        if (this.component.hasProperty(\"duration\")) {\n            this.component.removeProperty(\"duration\");\n        }\n        this._setTime(\"dtend\", value);\n    }\n    /**\n   * The duration. This can be the result directly from the property, or the\n   * duration calculated from start date and end date. Setting the property\n   * will remove any `dtend` properties.\n   * @type {Duration}\n   */ get duration() {\n        let duration = this._firstProp(\"duration\");\n        if (!duration) {\n            return this.endDate.subtractDateTz(this.startDate);\n        }\n        return duration;\n    }\n    set duration(value) {\n        if (this.component.hasProperty(\"dtend\")) {\n            this.component.removeProperty(\"dtend\");\n        }\n        this._setProp(\"duration\", value);\n    }\n    /**\n   * The location of the event.\n   * @type {String}\n   */ get location() {\n        return this._firstProp(\"location\");\n    }\n    set location(value) {\n        this._setProp(\"location\", value);\n    }\n    /**\n   * The attendees in the event\n   * @type {Property[]}\n   */ get attendees() {\n        //XXX: This is way lame we should have a better\n        //     data structure for this later.\n        return this.component.getAllProperties(\"attendee\");\n    }\n    /**\n   * The event summary\n   * @type {String}\n   */ get summary() {\n        return this._firstProp(\"summary\");\n    }\n    set summary(value) {\n        this._setProp(\"summary\", value);\n    }\n    /**\n   * The event description.\n   * @type {String}\n   */ get description() {\n        return this._firstProp(\"description\");\n    }\n    set description(value) {\n        this._setProp(\"description\", value);\n    }\n    /**\n   * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)\n   * @type {String}\n   */ get color() {\n        return this._firstProp(\"color\");\n    }\n    set color(value) {\n        this._setProp(\"color\", value);\n    }\n    /**\n   * The organizer value as an uri. In most cases this is a mailto: uri, but\n   * it can also be something else, like urn:uuid:...\n   * @type {String}\n   */ get organizer() {\n        return this._firstProp(\"organizer\");\n    }\n    set organizer(value) {\n        this._setProp(\"organizer\", value);\n    }\n    /**\n   * The sequence value for this event. Used for scheduling\n   * see {@tutorial terminology}.\n   * @type {Number}\n   */ get sequence() {\n        return this._firstProp(\"sequence\");\n    }\n    set sequence(value) {\n        this._setProp(\"sequence\", value);\n    }\n    /**\n   * The recurrence id for this event. See {@tutorial terminology} for details.\n   * @type {Time}\n   */ get recurrenceId() {\n        return this._firstProp(\"recurrence-id\");\n    }\n    set recurrenceId(value) {\n        this._setTime(\"recurrence-id\", value);\n    }\n    /**\n   * Set/update a time property's value.\n   * This will also update the TZID of the property.\n   *\n   * TODO: this method handles the case where we are switching\n   * from a known timezone to an implied timezone (one without TZID).\n   * This does _not_ handle the case of moving between a known\n   *  (by TimezoneService) timezone to an unknown timezone...\n   *\n   * We will not add/remove/update the VTIMEZONE subcomponents\n   *  leading to invalid ICAL data...\n   * @private\n   * @param {String} propName     The property name\n   * @param {Time} time           The time to set\n   */ _setTime(propName, time) {\n        let prop = this.component.getFirstProperty(propName);\n        if (!prop) {\n            prop = new Property(propName);\n            this.component.addProperty(prop);\n        }\n        // utc and local don't get a tzid\n        if (time.zone === Timezone.localTimezone || time.zone === Timezone.utcTimezone) {\n            // remove the tzid\n            prop.removeParameter(\"tzid\");\n        } else {\n            prop.setParameter(\"tzid\", time.zone.tzid);\n        }\n        prop.setValue(time);\n    }\n    _setProp(name, value) {\n        this.component.updatePropertyWithValue(name, value);\n    }\n    _firstProp(name) {\n        return this.component.getFirstPropertyValue(name);\n    }\n    /**\n   * The string representation of this event.\n   * @return {String}\n   */ toString() {\n        return this.component.toString();\n    }\n    /**\n   * Creates a new ICAL.Event instance.\n   *\n   * @param {Component=} component              The ICAL.Component to base this event on\n   * @param {Object} [options]                  Options for this event\n   * @param {Boolean=} options.strictExceptions  When true, will verify exceptions are related by\n   *                                              their UUID\n   * @param {Array<Component|Event>=} options.exceptions\n   *          Exceptions to this event, either as components or events. If not\n   *            specified exceptions will automatically be set in relation of\n   *            component's parent\n   */ constructor(component, options){\n        /**\n   * List of related event exceptions.\n   *\n   * @type {Event[]}\n   */ this.exceptions = null;\n        /**\n   * When true, will verify exceptions are related by their UUID.\n   *\n   * @type {Boolean}\n   */ this.strictExceptions = false;\n        if (!(component instanceof Component)) {\n            options = component;\n            component = null;\n        }\n        if (component) {\n            this.component = component;\n        } else {\n            this.component = new Component(\"vevent\");\n        }\n        this._rangeExceptionCache = Object.create(null);\n        this.exceptions = Object.create(null);\n        this.rangeExceptions = [];\n        if (options && options.strictExceptions) {\n            this.strictExceptions = options.strictExceptions;\n        }\n        if (options && options.exceptions) {\n            options.exceptions.forEach(this.relateException, this);\n        } else if (this.component.parent && !this.isRecurrenceException()) {\n            this.component.parent.getAllSubcomponents(\"vevent\").forEach(function(event) {\n                if (event.hasProperty(\"recurrence-id\")) {\n                    this.relateException(event);\n                }\n            }, this);\n        }\n    }\n}\nEvent.THISANDFUTURE = \"THISANDFUTURE\";\nfunction compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * The ComponentParser is used to process a String or jCal Object,\n * firing callbacks for various found components, as well as completion.\n *\n * @example\n * var options = {\n *   // when false no events will be emitted for type\n *   parseEvent: true,\n *   parseTimezone: true\n * };\n *\n * var parser = new ICAL.ComponentParser(options);\n *\n * parser.onevent(eventComponent) {\n *   //...\n * }\n *\n * // ontimezone, etc...\n *\n * parser.oncomplete = function() {\n *\n * };\n *\n * parser.process(stringOrComponent);\n *\n * @memberof ICAL\n */ class ComponentParser {\n    /**\n   * Process a string or parse ical object.  This function itself will return\n   * nothing but will start the parsing process.\n   *\n   * Events must be registered prior to calling this method.\n   *\n   * @param {Component|String|Object} ical      The component to process,\n   *        either in its final form, as a jCal Object, or string representation\n   */ process(ical) {\n        //TODO: this is sync now in the future we will have a incremental parser.\n        if (typeof ical === \"string\") {\n            ical = parse(ical);\n        }\n        if (!(ical instanceof Component)) {\n            ical = new Component(ical);\n        }\n        let components = ical.getAllSubcomponents();\n        let i = 0;\n        let len = components.length;\n        let component;\n        for(; i < len; i++){\n            component = components[i];\n            switch(component.name){\n                case \"vtimezone\":\n                    if (this.parseTimezone) {\n                        let tzid = component.getFirstPropertyValue(\"tzid\");\n                        if (tzid) {\n                            this.ontimezone(new Timezone({\n                                tzid: tzid,\n                                component: component\n                            }));\n                        }\n                    }\n                    break;\n                case \"vevent\":\n                    if (this.parseEvent) {\n                        this.onevent(new Event(component));\n                    }\n                    break;\n                default:\n                    continue;\n            }\n        }\n        //XXX: ideally we should do a \"nextTick\" here\n        //     so in all cases this is actually async.\n        this.oncomplete();\n    }\n    /**\n   * Creates a new ICAL.ComponentParser instance.\n   *\n   * @param {Object=} options                   Component parser options\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\n   */ constructor(options){\n        /**\n   * When true, parse events\n   *\n   * @type {Boolean}\n   */ this.parseEvent = true;\n        /**\n   * When true, parse timezones\n   *\n   * @type {Boolean}\n   */ this.parseTimezone = true;\n        /* SAX like events here for reference */ /**\n   * Fired when parsing is complete\n   * @callback\n   */ this.oncomplete = /* c8 ignore next */ function() {};\n        /**\n   * Fired if an error occurs during parsing.\n   *\n   * @callback\n   * @param {Error} err details of error\n   */ this.onerror = /* c8 ignore next */ function(err) {};\n        /**\n   * Fired when a top level component (VTIMEZONE) is found\n   *\n   * @callback\n   * @param {Timezone} component     Timezone object\n   */ this.ontimezone = /* c8 ignore next */ function(component) {};\n        /**\n   * Fired when a top level component (VEVENT) is found.\n   *\n   * @callback\n   * @param {Event} component    Top level component\n   */ this.onevent = /* c8 ignore next */ function(component) {};\n        if (typeof options === \"undefined\") {\n            options = {};\n        }\n        for (let [key, value] of Object.entries(options)){\n            this[key] = value;\n        }\n    }\n}\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n * Portions Copyright (C) Philipp Kewisch */ /**\n * The main ICAL module. Provides access to everything else.\n *\n * @alias ICAL\n * @namespace ICAL\n * @property {ICAL.design} design\n * @property {ICAL.helpers} helpers\n */ var ICALmodule = {\n    /**\n   * The number of characters before iCalendar line folding should occur\n   * @type {Number}\n   * @default 75\n   */ foldLength: 75,\n    debug: false,\n    /**\n   * The character(s) to be used for a newline. The default value is provided by\n   * rfc5545.\n   * @type {String}\n   * @default \"\\r\\n\"\n   */ newLineChar: \"\\r\\n\",\n    Binary,\n    Component,\n    ComponentParser,\n    Duration,\n    Event,\n    Period,\n    Property,\n    Recur,\n    RecurExpansion,\n    RecurIterator,\n    Time,\n    Timezone,\n    TimezoneService,\n    UtcOffset,\n    VCardTime,\n    parse,\n    stringify,\n    design: design$1,\n    helpers\n};\n\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"REVERSE_DOW_MAP$Object.fromEntries$Object.entries(DOW_MAP).map\");\n$RefreshReg$(_c1, \"REVERSE_DOW_MAP$Object.fromEntries\");\n$RefreshReg$(_c2, \"REVERSE_DOW_MAP\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pY2FsLmpzL2Rpc3QvaWNhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OzBDQUcwQyxHQUUxQzs7OztDQUlDOztBQUNELE1BQU1BO0lBQ0o7Ozs7O0dBS0MsR0FDRCxPQUFPQyxXQUFXQyxPQUFPLEVBQUU7UUFDekIsT0FBTyxJQUFJRixPQUFPRTtJQUNwQjtJQWtCQTs7OztHQUlDLEdBQ0RDLGNBQWM7UUFDWixPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDLElBQUksQ0FBQ0MsS0FBSztJQUNwQztJQUVBOzs7OztHQUtDLEdBQ0RDLGdCQUFnQkMsTUFBTSxFQUFFO1FBQ3RCLElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQ0csV0FBVyxDQUFDRDtJQUNoQztJQUVBQyxZQUFZQyxJQUFJLEVBQUU7UUFDaEIsZ0NBQWdDO1FBQ2hDLG1EQUFtRDtRQUNuRCxrQ0FBa0M7UUFDbEMsNkJBQTZCO1FBQzdCLHVFQUF1RTtRQUN2RSwwQ0FBMEM7UUFDMUMsdUVBQXVFO1FBQ3ZFLHVEQUF1RDtRQUN2RCx5REFBeUQ7UUFDekQsa0RBQWtEO1FBQ2xELDBCQUEwQjtRQUMxQiw0QkFBNEI7UUFDNUIsaURBQWlEO1FBQ2pELHdCQUF3QjtRQUN4QixHQUFHO1FBQ0gsSUFBSUMsTUFBTSwrQkFDQTtRQUNWLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLE1BQU1DLElBQUksR0FDeENDLEtBQUssR0FDTEMsTUFBTSxJQUNOQyxVQUFVLEVBQUU7UUFFZCxJQUFJLENBQUNiLE1BQU07WUFDVCxPQUFPQTtRQUNUO1FBRUEsR0FBRztZQUNERSxLQUFLRixLQUFLYyxVQUFVLENBQUNKO1lBQ3JCUCxLQUFLSCxLQUFLYyxVQUFVLENBQUNKO1lBQ3JCTixLQUFLSixLQUFLYyxVQUFVLENBQUNKO1lBRXJCRCxPQUFPUCxNQUFNLEtBQUtDLE1BQU0sSUFBSUM7WUFFNUJDLEtBQUtJ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LFlBQVl3WixPQUFPLENBQUU7UUFVckI7Ozs7R0FJQyxRQUNEMmUsYUFBYTtRQUViOzs7O0dBSUMsUUFDREYsZ0JBQWdCO1FBR2hCLHNDQUFzQyxHQUV0Qzs7O0dBR0MsUUFDREksYUFBYSxrQkFBa0IsR0FBRyxZQUFZO1FBRTlDOzs7OztHQUtDLFFBQ0RDLFVBQVUsa0JBQWtCLEdBQUcsU0FBUzFwQixHQUFHLEdBQUc7UUFFOUM7Ozs7O0dBS0MsUUFDRHNwQixhQUFhLGtCQUFrQixHQUFHLFNBQVN6cEIsU0FBUyxHQUFHO1FBRXZEOzs7OztHQUtDLFFBQ0QycEIsVUFBVSxrQkFBa0IsR0FBRyxTQUFTM3BCLFNBQVMsR0FBRztRQXREbEQsSUFBSSxPQUFPK0ssWUFBYSxhQUFhO1lBQ25DQSxVQUFVLENBQUM7UUFDYjtRQUVBLEtBQUssSUFBSSxDQUFDMVIsS0FBSzNKLE1BQU0sSUFBSXlDLE9BQU9tSCxPQUFPLENBQUN5UixTQUFVO1lBQ2hELElBQUksQ0FBQzFSLElBQUksR0FBRzNKO1FBQ2Q7SUFDRjtBQXNHRjtBQUVBOzs7MENBRzBDLEdBRTFDOzs7Ozs7O0NBT0MsR0FDRCxJQUFJd2EsYUFBYTtJQUNmOzs7O0dBSUMsR0FDREMsWUFBWTtJQUVaMmYsT0FBTztJQUVQOzs7OztHQUtDLEdBQ0QxZixhQUFhO0lBRWIvYTtJQUNBaVY7SUFDQStrQjtJQUNBMTNCO0lBQ0FpMUI7SUFDQWhOO0lBQ0ErSDtJQUNBelU7SUFDQW9ZO0lBQ0F0WTtJQUNBclk7SUFDQXNCO0lBQ0FzRDtJQUNBdVI7SUFDQUc7SUFFQXJMO0lBQ0E0Z0I7SUFFQTFELFFBQVE5ZjtJQUNSMk47QUFDRjtBQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWNhbC5qcy9kaXN0L2ljYWwuanM/YzEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBCSU5BUlkgdmFsdWUgdHlwZSwgd2hpY2ggY29udGFpbnMgZXh0cmEgbWV0aG9kcyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIEJpbmFyeSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmluYXJ5IHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgc3RyaW5nXG4gICAqIEByZXR1cm4ge0JpbmFyeX0gICAgICAgICAgICAgICBUaGUgYmluYXJ5IHZhbHVlIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhhU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBCaW5hcnkoYVN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLkJpbmFyeSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgYmluYXJ5IGRhdGEgZm9yIHRoaXMgdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFWYWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSBhVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAqIEBkZWZhdWx0IFwiYmluYXJ5XCJcbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBpY2FsdHlwZSA9IFwiYmluYXJ5XCI7XG5cbiAgLyoqXG4gICAqIEJhc2U2NCBkZWNvZGUgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIFRoZSBiYXNlNjQtZGVjb2RlZCB2YWx1ZVxuICAgKi9cbiAgZGVjb2RlVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2I2NF9kZWNvZGUodGhpcy52YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgcGFzc2VkIHBhcmFtZXRlciB3aXRoIGJhc2U2NCBhbmQgc2V0cyB0aGUgaW50ZXJuYWxcbiAgICogdmFsdWUgdG8gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgIFRoZSByYXcgYmluYXJ5IHZhbHVlIHRvIGVuY29kZVxuICAgKi9cbiAgc2V0RW5jb2RlZFZhbHVlKGFWYWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLl9iNjRfZW5jb2RlKGFWYWx1ZSk7XG4gIH1cblxuICBfYjY0X2VuY29kZShkYXRhKSB7XG4gICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IEJheXJvbiBHdWV2YXJhXG4gICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBSYWZhxYIgS3VrYXdza2kgKGh0dHA6Ly9rdWthd3NraS5wbClcbiAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgICAvLyAqICAgICByZXR1cm5zIDE6ICdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09J1xuICAgIC8vIG1vemlsbGEgaGFzIHRoaXMgbmF0aXZlXG4gICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgIC8vaWYgKHR5cGVvZiB0aGlzLndpbmRvd1snYXRvYiddID09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICByZXR1cm4gYXRvYihkYXRhKTtcbiAgICAvL31cbiAgICBsZXQgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiICtcbiAgICAgICAgICAgICAgXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICBsZXQgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgYWMgPSAwLFxuICAgICAgZW5jID0gXCJcIixcbiAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZG8geyAvLyBwYWNrIHRocmVlIG9jdGV0cyBpbnRvIGZvdXIgaGV4ZXRzXG4gICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIG8zID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgIGgyID0gYml0cyA+PiAxMiAmIDB4M2Y7XG4gICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAvLyB1c2UgaGV4ZXRzIHRvIGluZGV4IGludG8gYjY0LCBhbmQgYXBwZW5kIHJlc3VsdCB0byBlbmNvZGVkIHN0cmluZ1xuICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICBlbmMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgbGV0IHIgPSBkYXRhLmxlbmd0aCAlIDM7XG5cbiAgICByZXR1cm4gKHIgPyBlbmMuc2xpY2UoMCwgciAtIDMpIDogZW5jKSArICc9PT0nLnNsaWNlKHIgfHwgMyk7XG5cbiAgfVxuXG4gIF9iNjRfZGVjb2RlKGRhdGEpIHtcbiAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgIC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG4gICAgLy8gKyAgICAgIGlucHV0IGJ5OiBBbWFuIEd1cHRhXG4gICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgLy8gKyAgICAgIGlucHV0IGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuICAgIC8vICsgICBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgLy8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZGVjb2RlKCdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09Jyk7XG4gICAgLy8gKiAgICAgcmV0dXJucyAxOiAnS2V2aW4gdmFuIFpvbm5ldmVsZCdcbiAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgIC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcbiAgICAvL2lmICh0eXBlb2YgdGhpcy53aW5kb3dbJ2J0b2EnXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgcmV0dXJuIGJ0b2EoZGF0YSk7XG4gICAgLy99XG4gICAgbGV0IGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiArXG4gICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgbGV0IG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgIGFjID0gMCxcbiAgICAgIGRlYyA9IFwiXCIsXG4gICAgICB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEgKz0gJyc7XG5cbiAgICBkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG4gICAgICBoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgaDIgPSBiNjQuaW5kZXhPZihkYXRhLmNoYXJBdChpKyspKTtcbiAgICAgIGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICBoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG4gICAgICBiaXRzID0gaDEgPDwgMTggfCBoMiA8PCAxMiB8IGgzIDw8IDYgfCBoNDtcblxuICAgICAgbzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcbiAgICAgIG8yID0gYml0cyA+PiA4ICYgMHhmZjtcbiAgICAgIG8zID0gYml0cyAmIDB4ZmY7XG5cbiAgICAgIGlmIChoMyA9PSA2NCkge1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSk7XG4gICAgICB9IGVsc2UgaWYgKGg0ID09IDY0KSB7XG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIsIG8zKTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgZGVjID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgIHJldHVybiBkZWM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG5jb25zdCBEVVJBVElPTl9MRVRURVJTID0gLyhbUERXSE1UU117MSwxfSkvO1xuY29uc3QgREFUQV9QUk9QU19UT19DT1BZID0gW1wid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcImlzTmVnYXRpdmVcIl07XG5cbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcImR1cmF0aW9uXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgRHVyYXRpb24ge1xuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLkR1cmF0aW9uIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIHNlY29uZHMgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgICAgICAgICAgICBUaGUgbmV3bHkgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgcmV0dXJuIChuZXcgRHVyYXRpb24oKSkuZnJvbVNlY29uZHMoYVNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGlDYWxlbmRhciBkdXJhdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgVGhlIHJhdyBpY2FsIHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiBpY2FsIHR5cGVcbiAgICovXG4gIHN0YXRpYyBpc1ZhbHVlU3RyaW5nKHN0cmluZykge1xuICAgIHJldHVybiAoc3RyaW5nWzBdID09PSAnUCcgfHwgc3RyaW5nWzFdID09PSAnUCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuRHVyYXRpb259IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhU3RyICAgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7RHVyYXRpb259ICAgICAgICAgVGhlIGNyZWF0ZWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKGFTdHIpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNodW5rcyA9IDA7XG5cbiAgICB3aGlsZSAoKHBvcyA9IGFTdHIuc2VhcmNoKERVUkFUSU9OX0xFVFRFUlMpKSAhPT0gLTEpIHtcbiAgICAgIGxldCB0eXBlID0gYVN0cltwb3NdO1xuICAgICAgbGV0IG51bWVyaWMgPSBhU3RyLnNsaWNlKDAsIE1hdGgubWF4KDAsIHBvcykpO1xuICAgICAgYVN0ciA9IGFTdHIuc2xpY2UocG9zICsgMSk7XG5cbiAgICAgIGNodW5rcyArPSBwYXJzZUR1cmF0aW9uQ2h1bmsodHlwZSwgbnVtZXJpYywgZGljdCk7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcyA8IDIpIHtcbiAgICAgIC8vIFRoZXJlIG11c3QgYmUgYXQgbGVhc3QgYSBjaHVuayB3aXRoIFwiUFwiIGFuZCBzb21lIHVuaXQgY2h1bmtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE5vdCBlbm91Z2ggZHVyYXRpb24gY29tcG9uZW50cyBpbiBcIicgKyBhU3RyICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKGRpY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEud2Vla3MgICAgICAgICBEdXJhdGlvbiBpbiB3ZWVrc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzICAgICAgIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn0gICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWFkIGR1cmF0aW9uIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKGFEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuRHVyYXRpb24gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEud2Vla3MgICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmRheXMgICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXJzICAgICAgICAgIER1cmF0aW9uIGluIGhvdXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGVzICAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5zZWNvbmRzICAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGRhdGEuaXNOZWdhdGl2ZSAgICBJZiB0cnVlLCB0aGUgZHVyYXRpb24gaXMgbmVnYXRpdmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgd2Vla3MgaW4gdGhpcyBkdXJhdGlvblxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB3ZWVrcyA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBkYXlzIGluIHRoaXMgZHVyYXRpb25cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZGF5cyA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBkYXlzIGluIHRoaXMgZHVyYXRpb25cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgaG91cnMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgbWludXRlcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIG1pbnV0ZXMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHNlY29uZHMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgc2Vjb25kcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaXNOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwiaWNhbGR1cmF0aW9uXCJcbiAgICovXG4gIGljYWxjbGFzcyA9IFwiaWNhbGR1cmF0aW9uXCI7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJkdXJhdGlvblwiXG4gICAqL1xuICBpY2FsdHlwZSA9IFwiZHVyYXRpb25cIjtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbURhdGEodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIHZhbHVlIGV4cHJlc3NlZCBhcyBhIG51bWJlciBvZiBzZWNvbmRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgIFRoZSBkdXJhdGlvbiB2YWx1ZSBpbiBzZWNvbmRzXG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgbGV0IHNlY29uZHMgPSB0aGlzLnNlY29uZHMgKyA2MCAqIHRoaXMubWludXRlcyArIDM2MDAgKiB0aGlzLmhvdXJzICtcbiAgICAgICAgICAgICAgICAgIDg2NDAwICogdGhpcy5kYXlzICsgNyAqIDg2NDAwICogdGhpcy53ZWVrcztcbiAgICByZXR1cm4gKHRoaXMuaXNOZWdhdGl2ZSA/IC1zZWNvbmRzIDogc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlIGludG8gdGhpcyBkdXJhdGlvbiBvYmplY3QuIEFmdGVyd2FyZHMsXG4gICAqIG1lbWJlcnMgbGlrZSB7QGxpbmsgSUNBTC5EdXJhdGlvbiNkYXlzIGRheXN9IGFuZCB7QGxpbmsgSUNBTC5EdXJhdGlvbiN3ZWVrcyB3ZWVrc30gd2lsbCBiZSBzZXQgdXBcbiAgICogYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgVGhlIGR1cmF0aW9uIHZhbHVlIGluIHNlY29uZHNcbiAgICogQHJldHVybiB7RHVyYXRpb259ICAgICAgICAgICBSZXR1cm5zIHRoaXMgaW5zdGFuY2VcbiAgICovXG4gIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgbGV0IHNlY3MgPSBNYXRoLmFicyhhU2Vjb25kcyk7XG5cbiAgICB0aGlzLmlzTmVnYXRpdmUgPSAoYVNlY29uZHMgPCAwKTtcbiAgICB0aGlzLmRheXMgPSB0cnVuYyhzZWNzIC8gODY0MDApO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGZsYXQgbnVtYmVyIG9mIHdlZWtzLCB1c2UgdGhlbS5cbiAgICBpZiAodGhpcy5kYXlzICUgNyA9PSAwKSB7XG4gICAgICB0aGlzLndlZWtzID0gdGhpcy5kYXlzIC8gNztcbiAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2Vla3MgPSAwO1xuICAgIH1cblxuICAgIHNlY3MgLT0gKHRoaXMuZGF5cyArIDcgKiB0aGlzLndlZWtzKSAqIDg2NDAwO1xuXG4gICAgdGhpcy5ob3VycyA9IHRydW5jKHNlY3MgLyAzNjAwKTtcbiAgICBzZWNzIC09IHRoaXMuaG91cnMgKiAzNjAwO1xuXG4gICAgdGhpcy5taW51dGVzID0gdHJ1bmMoc2VjcyAvIDYwKTtcbiAgICBzZWNzIC09IHRoaXMubWludXRlcyAqIDYwO1xuXG4gICAgdGhpcy5zZWNvbmRzID0gc2VjcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqL1xuICBmcm9tRGF0YShhRGF0YSkge1xuICAgIGZvciAobGV0IHByb3Agb2YgREFUQV9QUk9QU19UT19DT1BZKSB7XG4gICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBkdXJhdGlvbiBpbnN0YW5jZSB0byB0aGUgZGVmYXVsdCB2YWx1ZXMsIGkuZS4gUFQwU1xuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgdGhpcy53ZWVrcyA9IDA7XG4gICAgdGhpcy5kYXlzID0gMDtcbiAgICB0aGlzLmhvdXJzID0gMDtcbiAgICB0aGlzLm1pbnV0ZXMgPSAwO1xuICAgIHRoaXMuc2Vjb25kcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IGFPdGhlciAgICAgICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICovXG4gIGNvbXBhcmUoYU90aGVyKSB7XG4gICAgbGV0IHRoaXNTZWNvbmRzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICBsZXQgb3RoZXJTZWNvbmRzID0gYU90aGVyLnRvU2Vjb25kcygpO1xuICAgIHJldHVybiAodGhpc1NlY29uZHMgPiBvdGhlclNlY29uZHMpIC0gKHRoaXNTZWNvbmRzIDwgb3RoZXJTZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBkdXJhdGlvbiBpbnN0YW5jZS4gRm9yIGV4YW1wbGUsIGEgZHVyYXRpb24gd2l0aCBhIHZhbHVlXG4gICAqIG9mIDYxIHNlY29uZHMgd2lsbCBiZSBub3JtYWxpemVkIHRvIDEgbWludXRlIGFuZCAxIHNlY29uZC5cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICB0aGlzLmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkdXJhdGlvbi5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMudG9TZWNvbmRzKCkgPT0gMCkge1xuICAgICAgcmV0dXJuIFwiUFQwU1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUpIHN0ciArPSBcIi1cIjtcbiAgICAgIHN0ciArPSBcIlBcIjtcbiAgICAgIGlmICh0aGlzLndlZWtzKSBzdHIgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgICAgaWYgKHRoaXMuZGF5cykgc3RyICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuXG4gICAgICBpZiAodGhpcy5ob3VycyB8fCB0aGlzLm1pbnV0ZXMgfHwgdGhpcy5zZWNvbmRzKSB7XG4gICAgICAgIHN0ciArPSBcIlRcIjtcbiAgICAgICAgaWYgKHRoaXMuaG91cnMpIHN0ciArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgICAgIGlmICh0aGlzLm1pbnV0ZXMpIHN0ciArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kcykgc3RyICs9IHRoaXMuc2Vjb25kcyArIFwiU1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlDYWxlbmRhciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkdXJhdGlvbi5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9JQ0FMU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGEgY2h1bmsgb2YgYSBkdXJhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGxldHRlciB0eXBlIG9mIGR1cmF0aW9uIGNodW5rXG4gKiBAcGFyYW0ge1N0cmluZ30gbnVtYmVyIG51bWVyaWMgdmFsdWUgb3IgLS8rXG4gKiBAcGFyYW0ge09iamVjdH0gZGljdCB0YXJnZXQgdG8gYXNzaWduIHZhbHVlcyB0b1xuICovXG5mdW5jdGlvbiBwYXJzZUR1cmF0aW9uQ2h1bmsobGV0dGVyLCBudW1iZXIsIG9iamVjdCkge1xuICBsZXQgdHlwZTtcbiAgc3dpdGNoIChsZXR0ZXIpIHtcbiAgICBjYXNlICdQJzpcbiAgICAgIGlmIChudW1iZXIgJiYgbnVtYmVyID09PSAnLScpIHtcbiAgICAgICAgb2JqZWN0LmlzTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0LmlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHBlcmlvZFxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRCc6XG4gICAgICB0eXBlID0gJ2RheXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnVyc6XG4gICAgICB0eXBlID0gJ3dlZWtzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0gnOlxuICAgICAgdHlwZSA9ICdob3Vycyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNJzpcbiAgICAgIHR5cGUgPSAnbWludXRlcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdTJzpcbiAgICAgIHR5cGUgPSAnc2Vjb25kcyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gTm90IGEgdmFsaWQgY2h1bmtcbiAgICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIW51bWJlciAmJiBudW1iZXIgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE1pc3NpbmcgbnVtYmVyIGJlZm9yZSBcIicgKyBsZXR0ZXIgKyAnXCInXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgbnVtID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgaWYgKGlzU3RyaWN0bHlOYU4obnVtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBkdXJhdGlvbiB2YWx1ZTogSW52YWxpZCBudW1iZXIgXCInICsgbnVtYmVyICsgJ1wiIGJlZm9yZSBcIicgKyBsZXR0ZXIgKyAnXCInXG4gICAgICApO1xuICAgIH1cbiAgICBvYmplY3RbdHlwZV0gPSBudW07XG4gIH1cblxuICByZXR1cm4gMTtcbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS53ZWVrRGF5fSB3ZWVrRGF5XG4gKiBJbXBvcnRzIHRoZSAnd2Vla0RheScgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBpQ2FsZW5kYXIgVGltZSByZXByZXNlbnRhdGlvbiAoc2ltaWxhciB0byBKUyBEYXRlIG9iamVjdCkuICBGdWxseVxuICogaW5kZXBlbmRlbnQgb2Ygc3lzdGVtIChPUykgdGltZXpvbmUgLyB0aW1lLiAgVW5saWtlIEpTIERhdGUsIHRoZSBtb250aFxuICogSmFudWFyeSBpcyAxLCBub3QgemVyby5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKHtcbiAqICAgeWVhcjogMjAxMixcbiAqICAgbW9udGg6IDEwLFxuICogICBkYXk6IDExXG4gKiAgIG1pbnV0ZTogMCxcbiAqICAgc2Vjb25kOiAwLFxuICogICBpc0RhdGU6IGZhbHNlXG4gKiB9KTtcbiAqXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiovXG5jbGFzcyBUaW1lIHtcbiAgc3RhdGljIF9kb3dDYWNoZSA9IHt9O1xuICBzdGF0aWMgX3duQ2FjaGUgPSB7fTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF5cyBpbiB0aGUgZ2l2ZW4gbW9udGhcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgVGhlIG1vbnRoIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhcbiAgICovXG4gIHN0YXRpYyBkYXlzSW5Nb250aChtb250aCwgeWVhcikge1xuICAgIGxldCBfZGF5c0luTW9udGggPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG4gICAgbGV0IGRheXMgPSAzMDtcblxuICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikgcmV0dXJuIGRheXM7XG5cbiAgICBkYXlzID0gX2RheXNJbk1vbnRoW21vbnRoXTtcblxuICAgIGlmIChtb250aCA9PSAyKSB7XG4gICAgICBkYXlzICs9IFRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHllYXIgaXMgYSBsZWFwIHllYXJcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgVGhlIHllYXIgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgVHJ1ZSwgaWYgdGhlIHllYXIgaXMgYSBsZWFwIHllYXJcbiAgICovXG4gIHN0YXRpYyBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICBpZiAoeWVhciA8PSAxNzUyKSB7XG4gICAgICByZXR1cm4gKCh5ZWFyICUgNCkgPT0gMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKCh5ZWFyICUgNCA9PSAwKSAmJiAoeWVhciAlIDEwMCAhPSAwKSkgfHwgKHllYXIgJSA0MDAgPT0gMCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSUNBTC5UaW1lIGZyb20gdGhlIGRheSBvZiB5ZWFyIGFuZCB5ZWFyLiBUaGUgZGF0ZSBpcyByZXR1cm5lZFxuICAgKiBpbiBmbG9hdGluZyB0aW1lem9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZlllYXIgICAgIFRoZSBkYXkgb2YgeWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgVGhlIHllYXIgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBpblxuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaW5zdGFuY2Ugd2l0aCB0aGUgY2FsY3VsYXRlZCBkYXRlXG4gICAqL1xuICBzdGF0aWMgZnJvbURheU9mWWVhcihhRGF5T2ZZZWFyLCBhWWVhcikge1xuICAgIGxldCB5ZWFyID0gYVllYXI7XG4gICAgbGV0IGRveSA9IGFEYXlPZlllYXI7XG4gICAgbGV0IHR0ID0gbmV3IFRpbWUoKTtcbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IGZhbHNlO1xuICAgIGxldCBpc19sZWFwID0gKFRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcblxuICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICB5ZWFyLS07XG4gICAgICBpc19sZWFwID0gKFRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcbiAgICAgIGRveSArPSBUaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVsxMl07XG4gICAgICByZXR1cm4gVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfSBlbHNlIGlmIChkb3kgPiBUaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVsxMl0pIHtcbiAgICAgIGlzX2xlYXAgPSAoVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95IC09IFRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXTtcbiAgICAgIHllYXIrKztcbiAgICAgIHJldHVybiBUaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKTtcbiAgICB9XG5cbiAgICB0dC55ZWFyID0geWVhcjtcbiAgICB0dC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgbW9udGggPSAxMTsgbW9udGggPj0gMDsgbW9udGgtLSkge1xuICAgICAgaWYgKGRveSA+IFRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdW21vbnRoXSkge1xuICAgICAgICB0dC5tb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgdHQuZGF5ID0gZG95IC0gVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bbW9udGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IHRydWU7XG4gICAgcmV0dXJuIHR0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkICAgICAgICAgICAgICAgIFVzZSB7QGxpbmsgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nfSBpbnN0ZWFkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmd2MihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFRpbWUoe1xuICAgICAgeWVhcjogcGFyc2VJbnQoc3RyLnNsaWNlKDAsIDQpLCAxMCksXG4gICAgICBtb250aDogcGFyc2VJbnQoc3RyLnNsaWNlKDUsIDcpLCAxMCksXG4gICAgICBkYXk6IHBhcnNlSW50KHN0ci5zbGljZSg4LCAxMCksIDEwKSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlU3RyaW5nKGFWYWx1ZSkge1xuICAgIC8vIERhdGVzIHNob3VsZCBoYXZlIG5vIHRpbWV6b25lLlxuICAgIC8vIEdvb2dsZSBsaWtlcyB0byBzb21ldGltZXMgc3BlY2lmeSBaIG9uIGRhdGVzXG4gICAgLy8gd2Ugc3BlY2lmaWNhbGx5IGlnbm9yZSB0aGF0IHRvIGF2b2lkIGlzc3Vlcy5cblxuICAgIC8vIFlZWVktTU0tRERcbiAgICAvLyAyMDEyLTEwLTEwXG4gICAgcmV0dXJuIG5ldyBUaW1lKHtcbiAgICAgIHllYXI6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSgwLCA0KSksXG4gICAgICBtb250aDogc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnNsaWNlKDUsIDcpKSxcbiAgICAgIGRheTogc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnNsaWNlKDgsIDEwKSksXG4gICAgICBpc0RhdGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZS10aW1lIHN0cmluZywgZS5nXG4gICAqIDIwMTUtMDEtMDJUMDM6MDQ6MDUuIElmIGEgcHJvcGVydHkgaXMgc3BlY2lmaWVkLCB0aGUgdGltZXpvbmUgaXMgc2V0IHVwXG4gICAqIGZyb20gdGhlIHByb3BlcnR5J3MgVFpJRCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7UHJvcGVydHk9fSBwcm9wICAgICAgICBUaGUgcHJvcGVydHkgdGhlIGRhdGUgYmVsb25ncyB0b1xuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlVGltZVN0cmluZyhhVmFsdWUsIHByb3ApIHtcbiAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDE5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGRhdGUtdGltZSB2YWx1ZTogXCInICsgYVZhbHVlICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgem9uZTtcbiAgICBsZXQgem9uZUlkO1xuXG4gICAgaWYgKGFWYWx1ZVsxOV0gJiYgYVZhbHVlWzE5XSA9PT0gJ1onKSB7XG4gICAgICB6b25lID0gVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgfSBlbHNlIGlmIChwcm9wKSB7XG4gICAgICB6b25lSWQgPSBwcm9wLmdldFBhcmFtZXRlcigndHppZCcpO1xuXG4gICAgICBpZiAocHJvcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb3AucGFyZW50Lm5hbWUgPT09ICdzdGFuZGFyZCcgfHwgcHJvcC5wYXJlbnQubmFtZSA9PT0gJ2RheWxpZ2h0Jykge1xuICAgICAgICAgIC8vIFBlciBSRkMgNTU0NSAzLjguMi40IGFuZCAzLjguMi4yLCBzdGFydC9lbmQgZGF0ZS10aW1lcyB3aXRoaW5cbiAgICAgICAgICAvLyB0aGVzZSBjb21wb25lbnRzIE1VU1QgYmUgc3BlY2lmaWVkIGluIGxvY2FsIHRpbWUuXG4gICAgICAgICAgem9uZSA9IFRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgIH0gZWxzZSBpZiAoem9uZUlkKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlc2lyZWQgdGltZSB6b25lIGlzIGRlZmluZWQgd2l0aGluIHRoZSBjb21wb25lbnQgdHJlZSxcbiAgICAgICAgICAvLyBmZXRjaCBpdHMgZGVmaW5pdGlvbiBhbmQgcHJlZmVyIHRoYXQuXG4gICAgICAgICAgem9uZSA9IHByb3AucGFyZW50LmdldFRpbWVab25lQnlJRCh6b25lSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGltZURhdGEgPSB7XG4gICAgICB5ZWFyOiBzdHJpY3RQYXJzZUludChhVmFsdWUuc2xpY2UoMCwgNCkpLFxuICAgICAgbW9udGg6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSg1LCA3KSksXG4gICAgICBkYXk6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSg4LCAxMCkpLFxuICAgICAgaG91cjogc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnNsaWNlKDExLCAxMykpLFxuICAgICAgbWludXRlOiBzdHJpY3RQYXJzZUludChhVmFsdWUuc2xpY2UoMTQsIDE2KSksXG4gICAgICBzZWNvbmQ6IHN0cmljdFBhcnNlSW50KGFWYWx1ZS5zbGljZSgxNywgMTkpKSxcbiAgICB9O1xuXG4gICAgLy8gQWx0aG91Z2ggUkZDIDU1NDUgcmVxdWlyZXMgdGhhdCBhbGwgVFpJRHMgdXNlZCB3aXRoaW4gYSBmaWxlIGhhdmUgYVxuICAgIC8vIGNvcnJlc3BvbmRpbmcgdGltZSB6b25lIGRlZmluaXRpb24sIHdlIG1heSBub3QgYmUgcGFyc2luZyB0aGUgZnVsbCBmaWxlXG4gICAgLy8gb3Igd2UgbWF5IGJlIGRlYWxpbmcgd2l0aCBhIG5vbi1jb21wbGlhbnQgZmlsZTsgaW4gZWl0aGVyIGNhc2UsIHdlIGNhblxuICAgIC8vIGNoZWNrIG91ciBvd24gdGltZSB6b25lIHNlcnZpY2UgZm9yIHRoZSBUWklEIGluIGEgbGFzdC1kaXRjaCBlZmZvcnQuXG4gICAgaWYgKHpvbmVJZCAmJiAhem9uZSkge1xuICAgICAgdGltZURhdGEudGltZXpvbmUgPSB6b25lSWQ7XG4gICAgfVxuXG4gICAgLy8gMjAxMi0xMC0xMFQxMDoxMDoxMChaKT9cbiAgICByZXR1cm4gbmV3IFRpbWUodGltZURhdGEsIHpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIG9yIGRhdGUtdGltZSBzdHJpbmcsXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7UHJvcGVydHk9fSBwcm9wICAgICAgICBUaGUgcHJvcGVydHkgdGhlIGRhdGUgYmVsb25ncyB0b1xuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcGVydHkpIHtcbiAgICBpZiAoYVZhbHVlLmxlbmd0aCA+IDEwKSB7XG4gICAgICByZXR1cm4gVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBKYXZhc2NyaXB0IERhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICAgICAgICAgIFRoZSBKYXZhc2NyaXB0IERhdGUgdG8gcmVhZCwgb3IgbnVsbCB0byByZXNldFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VVVEM9ZmFsc2VdICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICBsZXQgdHQgPSBuZXcgVGltZSgpO1xuICAgIHJldHVybiB0dC5mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheSAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmQgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge1RpbWV6b25lPX0gYVpvbmUgICAgICAgICBUaW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgbGV0IHQgPSBuZXcgVGltZSgpO1xuICAgIHJldHVybiB0LmZyb21EYXRhKGFEYXRhLCBhWm9uZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgbW9tZW50LlxuICAgKiBUaGUgaW5zdGFuY2UgaXMg4oCcZmxvYXRpbmfigJ0gLSBoYXMgbm8gdGltZXpvbmUgcmVsYXRpb24uXG4gICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBjb25zaWRlcmluZyB0aGUgdGltZSB6b25lLCBjYWxsXG4gICAqIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIHRydWUpXG4gICAqIEByZXR1cm4ge1RpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBUaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGUgb24gd2hpY2ggSVNPIHdlZWsgbnVtYmVyIDEgc3RhcnRzLlxuICAgKlxuICAgKiBAc2VlIFRpbWUjd2Vla051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgICAgICAgICBUaGUgeWVhciB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYVdlZWtTdGFydCAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgdXNlZCBmb3IgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkYXRlIG9uIHdoaWNoIHdlZWsgbnVtYmVyIDEgc3RhcnRzXG4gICAqL1xuICBzdGF0aWMgd2Vla09uZVN0YXJ0cyhhWWVhciwgYVdlZWtTdGFydCkge1xuICAgIGxldCB0ID0gVGltZS5mcm9tRGF0YSh7XG4gICAgICB5ZWFyOiBhWWVhcixcbiAgICAgIG1vbnRoOiAxLFxuICAgICAgZGF5OiAxLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBsZXQgZG93ID0gdC5kYXlPZldlZWsoKTtcbiAgICBsZXQgd2tzdCA9IGFXZWVrU3RhcnQgfHwgVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQ7XG4gICAgaWYgKGRvdyA+IFRpbWUuVEhVUlNEQVkpIHtcbiAgICAgIHQuZGF5ICs9IDc7XG4gICAgfVxuICAgIGlmICh3a3N0ID4gVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgLT0gNztcbiAgICB9XG5cbiAgICB0LmRheSAtPSBkb3cgLSB3a3N0O1xuXG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb21pbmljYWwgbGV0dGVyIGZvciB0aGUgZ2l2ZW4geWVhci4gTGV0dGVycyByYW5nZSBmcm9tIEEgLSBHIGZvclxuICAgKiBjb21tb24geWVhcnMsIGFuZCBBRyB0byBHRiBmb3IgbGVhcCB5ZWFycy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlyICAgICAgICAgICBUaGUgeWVhciB0byByZXRyaWV2ZSB0aGUgbGV0dGVyIGZvclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBkb21pbmljYWwgbGV0dGVyLlxuICAgKi9cbiAgc3RhdGljIGdldERvbWluaWNhbExldHRlcih5cikge1xuICAgIGxldCBMVFJTID0gXCJHRkVEQ0JBXCI7XG4gICAgbGV0IGRvbSA9ICh5ciArICh5ciAvIDQgfCAwKSArICh5ciAvIDQwMCB8IDApIC0gKHlyIC8gMTAwIHwgMCkgLSAxKSAlIDc7XG4gICAgbGV0IGlzTGVhcCA9IFRpbWUuaXNMZWFwWWVhcih5cik7XG4gICAgaWYgKGlzTGVhcCkge1xuICAgICAgcmV0dXJuIExUUlNbKGRvbSArIDYpICUgN10gKyBMVFJTW2RvbV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMVFJTW2RvbV07XG4gICAgfVxuICB9XG5cbiAgc3RhdGljICNlcG9jaFRpbWUgPSBudWxsO1xuICAvKipcbiAgICogSmFudWFyeSAxc3QsIDE5NzAgYXMgYW4gSUNBTC5UaW1lLlxuICAgKiBAdHlwZSB7VGltZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGdldCBlcG9jaFRpbWUoKSB7XG4gICAgaWYgKCF0aGlzLiNlcG9jaFRpbWUpIHtcbiAgICAgIHRoaXMuI2Vwb2NoVGltZSA9IFRpbWUuZnJvbURhdGEoe1xuICAgICAgICB5ZWFyOiAxOTcwLFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgZGF5OiAxLFxuICAgICAgICBob3VyOiAwLFxuICAgICAgICBtaW51dGU6IDAsXG4gICAgICAgIHNlY29uZDogMCxcbiAgICAgICAgaXNEYXRlOiBmYWxzZSxcbiAgICAgICAgdGltZXpvbmU6IFwiWlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2Vwb2NoVGltZTtcbiAgfVxuXG4gIHN0YXRpYyBfY21wX2F0dHIoYSwgYiwgYXR0cikge1xuICAgIGlmIChhW2F0dHJdID4gYlthdHRyXSkgcmV0dXJuIDE7XG4gICAgaWYgKGFbYXR0cl0gPCBiW2F0dHJdKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRheXMgdGhhdCBoYXZlIHBhc3NlZCBpbiB0aGUgeWVhciBhZnRlciBhIGdpdmVuIG1vbnRoLiBUaGUgYXJyYXkgaGFzXG4gICAqIHR3byBtZW1iZXJzLCBvbmUgYmVpbmcgYW4gYXJyYXkgb2YgcGFzc2VkIGRheXMgZm9yIG5vbi1sZWFwIHllYXJzLCB0aGVcbiAgICogb3RoZXIgYW5hbG9nIGZvciBsZWFwIHllYXJzLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaXNMZWFwWWVhciA9IElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpO1xuICAgKiB2YXIgcGFzc2VkRGF5cyA9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNMZWFwWWVhcl1bbW9udGhdO1xuICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxOdW1iZXI+Pn1cbiAgICovXG4gIHN0YXRpYyBkYXlzSW5ZZWFyUGFzc2VkTW9udGggPSBbXG4gICAgWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0LCAzNjVdLFxuICAgIFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNSwgMzY2XVxuICBdO1xuXG4gIHN0YXRpYyBTVU5EQVkgPSAxO1xuICBzdGF0aWMgTU9OREFZID0gMjtcbiAgc3RhdGljIFRVRVNEQVkgPSAzO1xuICBzdGF0aWMgV0VETkVTREFZID0gNDtcbiAgc3RhdGljIFRIVVJTREFZID0gNTtcbiAgc3RhdGljIEZSSURBWSA9IDY7XG4gIHN0YXRpYyBTQVRVUkRBWSA9IDc7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHdlZWtkYXkgZm9yIHRoZSBXS1NUIHBhcnQuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdCBJQ0FMLlRpbWUuTU9OREFZXG4gICAqL1xuICBzdGF0aWMgREVGQVVMVF9XRUVLX1NUQVJUID0gMjsgLy8gTU9OREFZXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgVGltZSBpbml0aWFsaXphdGlvblxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEueWVhciAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubW9udGggICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmRheSAgICAgIFRoZSBkYXkgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaG91ciAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubWludXRlICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5zZWNvbmQgICBUaGUgc2Vjb25kIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtCb29sZWFuPX0gZGF0YS5pc0RhdGUgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZSAoYXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Bwb3NlZCB0byBhIGRhdGUtdGltZSlcbiAgICogQHBhcmFtIHtUaW1lem9uZX0gem9uZSAgICAgICAgIHRpbWV6b25lIHRoaXMgcG9zaXRpb24gb2NjdXJzIGluXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCB6b25lKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIGxldCB0aW1lID0gdGhpcy5fdGltZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKiB0aW1lIGRlZmF1bHRzICovXG4gICAgdGltZS55ZWFyID0gMDtcbiAgICB0aW1lLm1vbnRoID0gMTtcbiAgICB0aW1lLmRheSA9IDE7XG4gICAgdGltZS5ob3VyID0gMDtcbiAgICB0aW1lLm1pbnV0ZSA9IDA7XG4gICAgdGltZS5zZWNvbmQgPSAwO1xuICAgIHRpbWUuaXNEYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLmZyb21EYXRhKGRhdGEsIHpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJpY2FsdGltZVwiXG4gICAqL1xuICBpY2FsY2xhc3MgPSBcImljYWx0aW1lXCI7XG4gIF9jYWNoZWRVbml4VGltZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LiBUaGlzIHZhbHVlIG1heSBjaGFuZ2UgYW5kXG4gICAqIGlzIHN0cmljdGx5IGRlZmluZWQgYnkgdGhlIHtAbGluayBJQ0FMLlRpbWUjaXNEYXRlIGlzRGF0ZX0gbWVtYmVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcImRhdGUtdGltZVwiXG4gICAqL1xuICBnZXQgaWNhbHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEYXRlID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRpbWV6b25lIGZvciB0aGlzIHRpbWUuXG4gICAqIEB0eXBlIHtUaW1lem9uZX1cbiAgICovXG4gIHpvbmUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCB1c2VzIHRvIGluZGljYXRlIHRoYXQgYSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBhbmQgdGhlIG5leHQgcmVhZFxuICAgKiBvcGVyYXRpb24gbXVzdCBhdHRlbXB0IHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgKGZvciBleGFtcGxlIGNoYW5naW5nIHRoZVxuICAgKiBkYXkgdG8gMzMpLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHRpbWUgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIGVwb2NoIHRpbWVcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZnJvbURhdGEoVGltZS5lcG9jaFRpbWUpO1xuICAgIHRoaXMuem9uZSA9IFRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIHRoZSBnaXZlbiBkYXRlL3RpbWUgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICAgICAgICBUaGUgeWVhciB0byBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICAgICAgVGhlIG1vbnRoIHRvIHNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF5ICAgICAgICAgICAgICBUaGUgZGF5IHRvIHNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gaG91ciAgICAgICAgICAgICBUaGUgaG91ciB0byBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZSAgICAgICAgICAgVGhlIG1pbnV0ZSB0byBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCAgICAgICAgICAgVGhlIHNlY29uZCB0byBzZXRcbiAgICogQHBhcmFtIHtUaW1lem9uZX0gdGltZXpvbmUgICAgICAgVGhlIHRpbWV6b25lIHRvIHNldFxuICAgKi9cbiAgcmVzZXRUbyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgdGltZXpvbmUpIHtcbiAgICB0aGlzLmZyb21EYXRhKHtcbiAgICAgIHllYXI6IHllYXIsXG4gICAgICBtb250aDogbW9udGgsXG4gICAgICBkYXk6IGRheSxcbiAgICAgIGhvdXI6IGhvdXIsXG4gICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgIHNlY29uZDogc2Vjb25kLFxuICAgICAgem9uZTogdGltZXpvbmVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgSmF2YXNjcmlwdCBkYXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gez9EYXRlfSBhRGF0ZSAgICAgICAgICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlVVRDPWZhbHNlXSAgSWYgdHJ1ZSwgdGhlIFVUQyB2YWx1ZXMgb2YgdGhlIGRhdGUgd2lsbCBiZSB1c2VkXG4gICAqL1xuICBmcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICBpZiAoIWFEYXRlKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1c2VVVEMpIHtcbiAgICAgICAgdGhpcy56b25lID0gVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgIHRoaXMubW9udGggPSBhRGF0ZS5nZXRVVENNb250aCgpICsgMTtcbiAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgIHRoaXMubWludXRlID0gYURhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuem9uZSA9IFRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHRoaXMubW9udGggPSBhRGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldEhvdXJzKCk7XG4gICAgICAgIHRoaXMubWludXRlID0gYURhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheSAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmQgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge1RpbWV6b25lPX0gYVpvbmUgICAgICAgICBUaW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgaWYgKGFEYXRhKSB7XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYURhdGEpKSB7XG4gICAgICAgICAgLy8gaWNhbCB0eXBlIGNhbm5vdCBiZSBzZXRcbiAgICAgICAgICBpZiAoa2V5ID09PSAnaWNhbHR5cGUnKSBjb250aW51ZTtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFab25lKSB7XG4gICAgICB0aGlzLnpvbmUgPSBhWm9uZTtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgIShcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgdGhpcy5pc0RhdGUgPSAhKFwiaG91clwiIGluIGFEYXRhKTtcbiAgICB9IGVsc2UgaWYgKGFEYXRhICYmIChcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgdGhpcy5pc0RhdGUgPSBhRGF0YS5pc0RhdGU7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmIFwidGltZXpvbmVcIiBpbiBhRGF0YSkge1xuICAgICAgbGV0IHpvbmUgPSBUaW1lem9uZVNlcnZpY2UuZ2V0KFxuICAgICAgICBhRGF0YS50aW1lem9uZVxuICAgICAgKTtcblxuICAgICAgdGhpcy56b25lID0gem9uZSB8fCBUaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiBcInpvbmVcIiBpbiBhRGF0YSkge1xuICAgICAgdGhpcy56b25lID0gYURhdGEuem9uZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuem9uZSkge1xuICAgICAgdGhpcy56b25lID0gVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBkYXkgb2Ygd2Vlay5cbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge3dlZWtEYXl9XG4gICAqL1xuICBkYXlPZldlZWsoYVdlZWtTdGFydCkge1xuICAgIGxldCBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgVGltZS5TVU5EQVk7XG4gICAgbGV0IGRvd0NhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGZpcnN0RG93O1xuICAgIGlmIChkb3dDYWNoZUtleSBpbiBUaW1lLl9kb3dDYWNoZSkge1xuICAgICAgcmV0dXJuIFRpbWUuX2Rvd0NhY2hlW2Rvd0NhY2hlS2V5XTtcbiAgICB9XG5cbiAgICAvLyBVc2luZyBaZWxsZXIncyBhbGdvcml0aG1cbiAgICBsZXQgcSA9IHRoaXMuZGF5O1xuICAgIGxldCBtID0gdGhpcy5tb250aCArICh0aGlzLm1vbnRoIDwgMyA/IDEyIDogMCk7XG4gICAgbGV0IFkgPSB0aGlzLnllYXIgLSAodGhpcy5tb250aCA8IDMgPyAxIDogMCk7XG5cbiAgICBsZXQgaCA9IChxICsgWSArIHRydW5jKCgobSArIDEpICogMjYpIC8gMTApICsgdHJ1bmMoWSAvIDQpKTtcbiAgICB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICBoICs9IHRydW5jKFkgLyAxMDApICogNiArIHRydW5jKFkgLyA0MDApO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSB0byAxID0gd2tzdFxuICAgIGggPSAoKGggKyA3IC0gZmlyc3REb3cpICUgNykgKyAxO1xuICAgIFRpbWUuX2Rvd0NhY2hlW2Rvd0NhY2hlS2V5XSA9IGg7XG4gICAgcmV0dXJuIGg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBkYXkgb2YgeWVhci5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZGF5T2ZZZWFyKCkge1xuICAgIGxldCBpc19sZWFwID0gKFRpbWUuaXNMZWFwWWVhcih0aGlzLnllYXIpID8gMSA6IDApO1xuICAgIGxldCBkaXlwbSA9IFRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoO1xuICAgIHJldHVybiBkaXlwbVtpc19sZWFwXVt0aGlzLm1vbnRoIC0gMV0gKyB0aGlzLmRheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiB3ZWVrLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmIHRoaXNcbiAgICogaXMgYSBkYXRlLXRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgd2VlayAoY2xvbmVkKVxuICAgKi9cbiAgc3RhcnRPZldlZWsoYVdlZWtTdGFydCkge1xuICAgIGxldCBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgVGltZS5TVU5EQVk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXN1bHQuZGF5IC09ICgodGhpcy5kYXlPZldlZWsoKSArIDcgLSBmaXJzdERvdykgJSA3KTtcbiAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGUgd2Vlay5cbiAgICogVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZiB0aGlzIGlzIGFcbiAgICogZGF0ZS10aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3dlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICogQHJldHVybiB7VGltZX0gICAgICBUaGUgZW5kIG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAqL1xuICBlbmRPZldlZWsoYVdlZWtTdGFydCkge1xuICAgIGxldCBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgVGltZS5TVU5EQVk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXN1bHQuZGF5ICs9ICg3IC0gdGhpcy5kYXlPZldlZWsoKSArIGZpcnN0RG93IC0gVGltZS5TVU5EQVkpICUgNztcbiAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBtb250aC4gVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICovXG4gIHN0YXJ0T2ZNb250aCgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgIHJlc3VsdC5kYXkgPSAxO1xuICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICByZXN1bHQubWludXRlID0gMDtcbiAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZVxuICAgKiBtb250aC4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICpcbiAgICogQHJldHVybiB7VGltZX0gICAgICBUaGUgZW5kIG9mIHRoZSBtb250aCAoY2xvbmVkKVxuICAgKi9cbiAgZW5kT2ZNb250aCgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgIHJlc3VsdC5kYXkgPSBUaW1lLmRheXNJbk1vbnRoKHJlc3VsdC5tb250aCwgcmVzdWx0LnllYXIpO1xuICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICByZXN1bHQubWludXRlID0gMDtcbiAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIHllYXIuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICpcbiAgICogQHJldHVybiB7VGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICovXG4gIHN0YXJ0T2ZZZWFyKCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgcmVzdWx0LmRheSA9IDE7XG4gICAgcmVzdWx0Lm1vbnRoID0gMTtcbiAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICogeWVhci4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICpcbiAgICogQHJldHVybiB7VGltZX0gICAgICBUaGUgZW5kIG9mIHRoZSB5ZWFyIChjbG9uZWQpXG4gICAqL1xuICBlbmRPZlllYXIoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXN1bHQuZGF5ID0gMzE7XG4gICAgcmVzdWx0Lm1vbnRoID0gMTI7XG4gICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmlyc3QgY2FsY3VsYXRlcyB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIHRoZW4gcmV0dXJucyB0aGUgZGF5IG9mIHllYXIgZm9yXG4gICAqIHRoaXMgZGF0ZS4gSWYgdGhlIGRheSBmYWxscyBpbnRvIHRoZSBwcmV2aW91cyB5ZWFyLCB0aGUgZGF5IGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7d2Vla0RheT19IGFGaXJzdERheU9mV2Vla1xuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRoZSBjYWxjdWxhdGVkIGRheSBvZiB5ZWFyXG4gICAqL1xuICBzdGFydERveVdlZWsoYUZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgbGV0IGZpcnN0RG93ID0gYUZpcnN0RGF5T2ZXZWVrIHx8IFRpbWUuU1VOREFZO1xuICAgIGxldCBkZWx0YSA9IHRoaXMuZGF5T2ZXZWVrKCkgLSBmaXJzdERvdztcbiAgICBpZiAoZGVsdGEgPCAwKSBkZWx0YSArPSA3O1xuICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpIC0gZGVsdGE7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb21pbmljYWwgbGV0dGVyIGZvciB0aGUgY3VycmVudCB5ZWFyLiBMZXR0ZXJzIHJhbmdlIGZyb20gQSAtIEdcbiAgICogZm9yIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geXIgICAgICAgICAgIFRoZSB5ZWFyIHRvIHJldHJpZXZlIHRoZSBsZXR0ZXIgZm9yXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAqL1xuICBnZXREb21pbmljYWxMZXR0ZXIoKSB7XG4gICAgcmV0dXJuIFRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIG50aFdlZWtEYXkgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgbW9udGggKG5vdCBkYXkpLiAgVGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGlzIGEgZGF5IHJlbGF0aXZlIHRoZSBtb250aCB0aGF0IHRoaXMgbW9udGggYmVsb25ncyB0byBzb1xuICAgKiAxIHdvdWxkIGluZGljYXRlIHRoZSBmaXJzdCBvZiB0aGUgbW9udGggYW5kIDQwIHdvdWxkIGluZGljYXRlIGEgZGF5IGluXG4gICAqIHRoZSBmb2xsb3dpbmcgbW9udGguXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZXZWVrICAgRGF5IG9mIHRoZSB3ZWVrIHNlZSB0aGUgZGF5IG5hbWUgY29uc3RhbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhUG9zICAgICAgICAgTnRoIG9jY3VycmVuY2Ugb2YgYSBnaXZlbiB3ZWVrIGRheSB2YWx1ZXNcbiAgICogICAgICAgIG9mIDEgYW5kIDAgYm90aCBpbmRpY2F0ZSB0aGUgZmlyc3Qgd2Vla2RheSBvZiB0aGF0IHR5cGUuIGFQb3MgbWF5XG4gICAqICAgICAgICBiZSBlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmVcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBudW1lcmljIHZhbHVlIGluZGljYXRpbmcgYSBkYXkgcmVsYXRpdmVcbiAgICogICAgICAgICAgICAgICAgICAgdG8gdGhlIGN1cnJlbnQgbW9udGggb2YgdGhpcyB0aW1lIG9iamVjdFxuICAgKi9cbiAgbnRoV2Vla0RheShhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgbGV0IGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aCh0aGlzLm1vbnRoLCB0aGlzLnllYXIpO1xuICAgIGxldCB3ZWVrZGF5O1xuICAgIGxldCBwb3MgPSBhUG9zO1xuXG4gICAgbGV0IHN0YXJ0ID0gMDtcblxuICAgIGxldCBvdGhlckRheSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgb3RoZXJEYXkuZGF5ID0gMTtcblxuICAgICAgLy8gYmVjYXVzZSAwIG1lYW5zIG5vIHBvc2l0aW9uIGhhcyBiZWVuIGdpdmVuXG4gICAgICAvLyAxIGFuZCAwIGluZGljYXRlIHRoZSBzYW1lIGRheS5cbiAgICAgIGlmIChwb3MgIT0gMCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGV4dHJhIG51bWVyaWMgdmFsdWVcbiAgICAgICAgcG9zLS07XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjdXJyZW50IHN0YXJ0IG9mZnNldCB0byBjdXJyZW50IGRheS5cbiAgICAgIHN0YXJ0ID0gb3RoZXJEYXkuZGF5O1xuXG4gICAgICAvLyBmaW5kIHRoZSBjdXJyZW50IGRheSBvZiB3ZWVrXG4gICAgICBsZXQgc3RhcnREb3cgPSBvdGhlckRheS5kYXlPZldlZWsoKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudFxuICAgICAgLy8gZGF5IG9mIHRoZSB3ZWVrIGFuZCBkZXNpcmVkIGRheSBvZiB0aGUgd2Vla1xuICAgICAgbGV0IG9mZnNldCA9IGFEYXlPZldlZWsgLSBzdGFydERvdztcblxuXG4gICAgICAvLyBpZiB0aGUgb2Zmc2V0IGdvZXMgaW50byB0aGUgcGFzdFxuICAgICAgLy8gd2VlayB3ZSBhZGQgNyBzbyBpdCBnb2VzIGludG8gdGhlIG5leHRcbiAgICAgIC8vIHdlZWsuIFdlIG9ubHkgd2FudCB0byBnbyBmb3J3YXJkIGluIHRpbWUgaGVyZS5cbiAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAvLyB0aGlzIGlzIHJlYWxseSBpbXBvcnRhbnQgb3RoZXJ3aXNlIHdlIHdvdWxkXG4gICAgICAgIC8vIGVuZCB1cCB3aXRoIGRhdGVzIGZyb20gaW4gdGhlIHBhc3QuXG4gICAgICAgIG9mZnNldCArPSA3O1xuXG4gICAgICAvLyBhZGQgb2Zmc2V0IHRvIHN0YXJ0IHNvIHN0YXJ0IGlzIHRoZSBzYW1lXG4gICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYXMgdGhlIGRlc2lyZWQgZGF5IG9mIHdlZWsuXG4gICAgICBzdGFydCArPSBvZmZzZXQ7XG5cbiAgICAgIC8vIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIGFkZCAoYW5kIG11bHRpcGx5KVxuICAgICAgLy8gdGhlIG51bWVyaWMgdmFsdWUgb2YgdGhlIGRheSB3ZSBzdWJ0cmFjdCBpdFxuICAgICAgLy8gZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24gc28gbm90IHRvIGFkZCBpdCB0d2ljZS5cbiAgICAgIHN0YXJ0IC09IGFEYXlPZldlZWs7XG5cbiAgICAgIC8vIHNldCB3ZWVrIGRheVxuICAgICAgd2Vla2RheSA9IGFEYXlPZldlZWs7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gdGhlbiB3ZSBzZXQgaXQgdG8gdGhlIGxhc3QgZGF5IGluIHRoZSBjdXJyZW50IG1vbnRoXG4gICAgICBvdGhlckRheS5kYXkgPSBkYXlzSW5Nb250aDtcblxuICAgICAgLy8gZmluZCB0aGUgZW5kcyB3ZWVrZGF5XG4gICAgICBsZXQgZW5kRG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgIHBvcysrO1xuXG4gICAgICB3ZWVrZGF5ID0gKGVuZERvdyAtIGFEYXlPZldlZWspO1xuXG4gICAgICBpZiAod2Vla2RheSA8IDApIHtcbiAgICAgICAgd2Vla2RheSArPSA3O1xuICAgICAgfVxuXG4gICAgICB3ZWVrZGF5ID0gZGF5c0luTW9udGggLSB3ZWVrZGF5O1xuICAgIH1cblxuICAgIHdlZWtkYXkgKz0gcG9zICogNztcblxuICAgIHJldHVybiBzdGFydCArIHdlZWtkYXk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGN1cnJlbnQgdGltZSBpcyB0aGUgbnRoIHdlZWtkYXksIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50XG4gICAqIG1vbnRoLiAgV2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIHdoZW4gcnVsZSByZXNvbHZlcyBvdXRzaWRlIG9mIGN1cnJlbnRcbiAgICogbW9udGguXG4gICAqXG4gICAqIEBwYXJhbSB7d2Vla0RheX0gYURheU9mV2VlayAgICAgICAgICAgICAgICAgRGF5IG9mIHdlZWsgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICAgICAgICAgICAgICAgICBSZWxhdGl2ZSBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgIFRydWUsIGlmIGl0IGlzIHRoZSBudGggd2Vla2RheVxuICAgKi9cbiAgaXNOdGhXZWVrRGF5KGFEYXlPZldlZWssIGFQb3MpIHtcbiAgICBsZXQgZG93ID0gdGhpcy5kYXlPZldlZWsoKTtcblxuICAgIGlmIChhUG9zID09PSAwICYmIGRvdyA9PT0gYURheU9mV2Vlaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHBvc1xuICAgIGxldCBkYXkgPSB0aGlzLm50aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcyk7XG5cbiAgICBpZiAoZGF5ID09PSB0aGlzLmRheSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIElTTyA4NjAxIHdlZWsgbnVtYmVyLiBUaGUgZmlyc3Qgd2VlayBvZiBhIHllYXIgaXMgdGhlXG4gICAqIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3QgVGh1cnNkYXkuIFRoZSB5ZWFyIGNhbiBoYXZlIDUzIHdlZWtzLCBpZlxuICAgKiBKYW51YXJ5IDFzdCBpcyBhIEZyaWRheS5cbiAgICpcbiAgICogTm90ZSB0aGVyZSBhcmUgcmVnaW9ucyB3aGVyZSB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBpcyB0aGUgb25lIHRoYXRcbiAgICogc3RhcnRzIG9uIEphbnVhcnkgMXN0LCB3aGljaCBtYXkgb2Zmc2V0IHRoZSB3ZWVrIG51bWJlci4gQWxzbywgaWYgYVxuICAgKiBkaWZmZXJlbnQgd2VlayBzdGFydCBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCBhbHNvIGFmZmVjdCB0aGUgd2Vla1xuICAgKiBudW1iZXIuXG4gICAqXG4gICAqIEBzZWUgVGltZS53ZWVrT25lU3RhcnRzXG4gICAqIEBwYXJhbSB7d2Vla0RheX0gYVdlZWtTdGFydCAgICAgICAgICAgICAgICAgIFRoZSB3ZWVrZGF5IHRoZSB3ZWVrIHN0YXJ0cyB3aXRoXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBJU08gd2VlayBudW1iZXJcbiAgICovXG4gIHdlZWtOdW1iZXIoYVdlZWtTdGFydCkge1xuICAgIGxldCB3bkNhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGFXZWVrU3RhcnQ7XG4gICAgaWYgKHduQ2FjaGVLZXkgaW4gVGltZS5fd25DYWNoZSkge1xuICAgICAgcmV0dXJuIFRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV07XG4gICAgfVxuICAgIC8vIFRoaXMgZnVuY3Rpb24gY291cnRlc3R5IG9mIEp1bGlhbiBCdWNrbmFsbCwgcHVibGlzaGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgIC8vIGh0dHA6Ly93d3cuYm95ZXQuY29tL2FydGljbGVzL3B1Ymxpc2hlZGFydGljbGVzL2NhbGN1bGF0aW5ndGhlaXNvd2Vla251bWIuaHRtbFxuICAgIC8vIHBsdXMgc29tZSBmaXhlcyB0byBiZSBhYmxlIHRvIHVzZSBkaWZmZXJlbnQgd2VlayBzdGFydHMuXG4gICAgbGV0IHdlZWsxO1xuXG4gICAgbGV0IGR0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGR0LmlzRGF0ZSA9IHRydWU7XG4gICAgbGV0IGlzb3llYXIgPSB0aGlzLnllYXI7XG5cbiAgICBpZiAoZHQubW9udGggPT0gMTIgJiYgZHQuZGF5ID4gMjUpIHtcbiAgICAgIHdlZWsxID0gVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIgKyAxLCBhV2Vla1N0YXJ0KTtcbiAgICAgIGlmIChkdC5jb21wYXJlKHdlZWsxKSA8IDApIHtcbiAgICAgICAgd2VlazEgPSBUaW1lLndlZWtPbmVTdGFydHMoaXNveWVhciwgYVdlZWtTdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc295ZWFyKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdlZWsxID0gVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICB3ZWVrMSA9IFRpbWUud2Vla09uZVN0YXJ0cygtLWlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkYXlzQmV0d2VlbiA9IChkdC5zdWJ0cmFjdERhdGUod2VlazEpLnRvU2Vjb25kcygpIC8gODY0MDApO1xuICAgIGxldCBhbnN3ZXIgPSB0cnVuYyhkYXlzQmV0d2VlbiAvIDcpICsgMTtcbiAgICBUaW1lLl93bkNhY2hlW3duQ2FjaGVLZXldID0gYW5zd2VyO1xuICAgIHJldHVybiBhbnN3ZXI7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZHVyYXRpb24gdG8gdGhlIGN1cnJlbnQgdGltZS4gVGhlIGluc3RhbmNlIGlzIG1vZGlmaWVkIGluXG4gICAqIHBsYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBhRHVyYXRpb24gICAgICAgICBUaGUgZHVyYXRpb24gdG8gYWRkXG4gICAqL1xuICBhZGREdXJhdGlvbihhRHVyYXRpb24pIHtcbiAgICBsZXQgbXVsdCA9IChhRHVyYXRpb24uaXNOZWdhdGl2ZSA/IC0xIDogMSk7XG5cbiAgICAvLyBiZWNhdXNlIG9mIHRoZSBkdXJhdGlvbiBvcHRpbWl6YXRpb25zIGl0IGlzIG11Y2hcbiAgICAvLyBtb3JlIGVmZmljaWVudCB0byBncmFiIGFsbCB0aGUgdmFsdWVzIHVwIGZyb250XG4gICAgLy8gdGhlbiBzZXQgdGhlbSBkaXJlY3RseSAod2hpY2ggd2lsbCBhdm9pZCBhIG5vcm1hbGl6YXRpb24gY2FsbCkuXG4gICAgLy8gU28gd2UgZG9uJ3QgYWN0dWFsbHkgbm9ybWFsaXplIHVudGlsIHdlIG5lZWQgaXQuXG4gICAgbGV0IHNlY29uZCA9IHRoaXMuc2Vjb25kO1xuICAgIGxldCBtaW51dGUgPSB0aGlzLm1pbnV0ZTtcbiAgICBsZXQgaG91ciA9IHRoaXMuaG91cjtcbiAgICBsZXQgZGF5ID0gdGhpcy5kYXk7XG5cbiAgICBzZWNvbmQgKz0gbXVsdCAqIGFEdXJhdGlvbi5zZWNvbmRzO1xuICAgIG1pbnV0ZSArPSBtdWx0ICogYUR1cmF0aW9uLm1pbnV0ZXM7XG4gICAgaG91ciArPSBtdWx0ICogYUR1cmF0aW9uLmhvdXJzO1xuICAgIGRheSArPSBtdWx0ICogYUR1cmF0aW9uLmRheXM7XG4gICAgZGF5ICs9IG11bHQgKiA3ICogYUR1cmF0aW9uLndlZWtzO1xuXG4gICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgdGhpcy5taW51dGUgPSBtaW51dGU7XG4gICAgdGhpcy5ob3VyID0gaG91cjtcbiAgICB0aGlzLmRheSA9IGRheTtcblxuICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzIChfZXhjbHVkaW5nXyB0aW1lem9uZSkuICBVc2VmdWwgZm9yIGZpbmRpbmdcbiAgICogdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGltZSBvYmplY3RzIGV4Y2x1ZGluZyB0aGVpclxuICAgKiB0aW1lem9uZSBkaWZmZXJlbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lfSBhRGF0ZSAgICAgVGhlIGRhdGUgdG8gc3VidHJhY3RcbiAgICogQHJldHVybiB7RHVyYXRpb259ICAgICAgVGhlIGRpZmZlcmVuY2UgYXMgYSBkdXJhdGlvblxuICAgKi9cbiAgc3VidHJhY3REYXRlKGFEYXRlKSB7XG4gICAgbGV0IHVuaXhUaW1lID0gdGhpcy50b1VuaXhUaW1lKCkgKyB0aGlzLnV0Y09mZnNldCgpO1xuICAgIGxldCBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKSArIGFEYXRlLnV0Y09mZnNldCgpO1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tU2Vjb25kcyh1bml4VGltZSAtIG90aGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzLCB0YWtpbmcgdGltZXpvbmVzIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lfSBhRGF0ZSAgVGhlIGRhdGUgdG8gc3VidHJhY3RcbiAgICogQHJldHVybiB7RHVyYXRpb259ICAgVGhlIGRpZmZlcmVuY2UgaW4gZHVyYXRpb25cbiAgICovXG4gIHN1YnRyYWN0RGF0ZVR6KGFEYXRlKSB7XG4gICAgbGV0IHVuaXhUaW1lID0gdGhpcy50b1VuaXhUaW1lKCk7XG4gICAgbGV0IG90aGVyID0gYURhdGUudG9Vbml4VGltZSgpO1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tU2Vjb25kcyh1bml4VGltZSAtIG90aGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGUgSUNBTC5UaW1lIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAqL1xuICBjb21wYXJlKG90aGVyKSB7XG4gICAgbGV0IGEgPSB0aGlzLnRvVW5peFRpbWUoKTtcbiAgICBsZXQgYiA9IG90aGVyLnRvVW5peFRpbWUoKTtcblxuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgaWYgKGIgPiBhKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgb25seSB0aGUgZGF0ZSBwYXJ0IG9mIHRoaXMgaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gb3RoZXIgICAgICAgICAgICAgIFRoZSBpbnN0YW5jZSB0byBjb21wYXJlIHdpdGhcbiAgICogQHBhcmFtIHtUaW1lem9uZX0gdHogICAgICAgICAgICAgICAgIFRoZSB0aW1lem9uZSB0byBjb21wYXJlIGluXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICovXG4gIGNvbXBhcmVEYXRlT25seVR6KG90aGVyLCB0eikge1xuICAgIGxldCBhID0gdGhpcy5jb252ZXJ0VG9ab25lKHR6KTtcbiAgICBsZXQgYiA9IG90aGVyLmNvbnZlcnRUb1pvbmUodHopO1xuICAgIGxldCByYyA9IDA7XG5cbiAgICBpZiAoKHJjID0gVGltZS5fY21wX2F0dHIoYSwgYiwgXCJ5ZWFyXCIpKSAhPSAwKSByZXR1cm4gcmM7XG4gICAgaWYgKChyYyA9IFRpbWUuX2NtcF9hdHRyKGEsIGIsIFwibW9udGhcIikpICE9IDApIHJldHVybiByYztcbiAgICBpZiAoKHJjID0gVGltZS5fY21wX2F0dHIoYSwgYiwgXCJkYXlcIikpICE9IDApIHJldHVybiByYztcblxuICAgIHJldHVybiByYztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBpbnN0YW5jZSBpbnRvIGFub3RoZXIgdGltZXpvbmUuIFRoZSByZXR1cm5lZCBJQ0FMLlRpbWVcbiAgICogaW5zdGFuY2UgaXMgYWx3YXlzIGEgY29weS5cbiAgICpcbiAgICogQHBhcmFtIHtUaW1lem9uZX0gem9uZSAgICAgIFRoZSB6b25lIHRvIGNvbnZlcnQgdG9cbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgICAgIFRoZSBjb3B5LCBjb252ZXJ0ZWQgdG8gdGhlIHpvbmVcbiAgICovXG4gIGNvbnZlcnRUb1pvbmUoem9uZSkge1xuICAgIGxldCBjb3B5ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCB6b25lX2VxdWFscyA9ICh0aGlzLnpvbmUudHppZCA9PSB6b25lLnR6aWQpO1xuXG4gICAgaWYgKCF0aGlzLmlzRGF0ZSAmJiAhem9uZV9lcXVhbHMpIHtcbiAgICAgIFRpbWV6b25lLmNvbnZlcnRfdGltZShjb3B5LCB0aGlzLnpvbmUsIHpvbmUpO1xuICAgIH1cblxuICAgIGNvcHkuem9uZSA9IHpvbmU7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgVVRDIG9mZnNldCBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUgaW4gdGhlIHRpbWV6b25lIGl0IGlzXG4gICAqIGluLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBVVEMgb2Zmc2V0IGluIHNlY29uZHNcbiAgICovXG4gIHV0Y09mZnNldCgpIHtcbiAgICBpZiAodGhpcy56b25lID09IFRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgdGhpcy56b25lID09IFRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS51dGNPZmZzZXQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDU1NDUgY29tcGxpYW50IGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaWNhbCBkYXRlL2RhdGUtdGltZVxuICAgKi9cbiAgdG9JQ0FMU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEwKSB7XG4gICAgICByZXR1cm4gZGVzaWduJDEuaWNhbGVuZGFyLnZhbHVlWydkYXRlLXRpbWUnXS50b0lDQUwoc3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlc2lnbiQxLmljYWxlbmRhci52YWx1ZS5kYXRlLnRvSUNBTChzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZS90aW1lLCBpbiBqQ2FsIGZvcm1cbiAgICogKGluY2x1ZGluZyA6IGFuZCAtIHNlcGFyYXRvcnMpLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy55ZWFyICsgJy0nICtcbiAgICAgICAgICAgICAgICAgcGFkMih0aGlzLm1vbnRoKSArICctJyArXG4gICAgICAgICAgICAgICAgIHBhZDIodGhpcy5kYXkpO1xuXG4gICAgaWYgKCF0aGlzLmlzRGF0ZSkge1xuICAgICAgICByZXN1bHQgKz0gJ1QnICsgcGFkMih0aGlzLmhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgIHBhZDIodGhpcy5taW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAgIHBhZDIodGhpcy5zZWNvbmQpO1xuXG4gICAgICBpZiAodGhpcy56b25lID09PSBUaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdG8gYSBKYXZhc2NyaXB0IGRhdGVcbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIGlmICh0aGlzLnpvbmUgPT0gVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgaWYgKHRoaXMuaXNEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxLCB0aGlzLmRheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRvVW5peFRpbWUoKSAqIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIF9ub3JtYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWUuaXNEYXRlKSB7XG4gICAgICB0aGlzLl90aW1lLmhvdXIgPSAwO1xuICAgICAgdGhpcy5fdGltZS5taW51dGUgPSAwO1xuICAgICAgdGhpcy5fdGltZS5zZWNvbmQgPSAwO1xuICAgIH1cbiAgICB0aGlzLmFkanVzdCgwLCAwLCAwLCAwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgZGF0ZS90aW1lIGJ5IHRoZSBnaXZlbiBvZmZzZXRcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYURheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFIb3VycyAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYU1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFTZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgKiBAcGFyYW0ge051bWJlcj19IGFUaW1lICAgICAgICAgICBUaGUgdGltZSB0byBhZGp1c3QsIGRlZmF1bHRzIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAqL1xuICBhZGp1c3QoYUV4dHJhRGF5cywgYUV4dHJhSG91cnMsIGFFeHRyYU1pbnV0ZXMsIGFFeHRyYVNlY29uZHMsIGFUaW1lKSB7XG5cbiAgICBsZXQgbWludXRlc092ZXJmbG93LCBob3Vyc092ZXJmbG93LFxuICAgICAgICBkYXlzT3ZlcmZsb3cgPSAwLCB5ZWFyc092ZXJmbG93ID0gMDtcblxuICAgIGxldCBzZWNvbmQsIG1pbnV0ZSwgaG91ciwgZGF5O1xuICAgIGxldCBkYXlzSW5Nb250aDtcblxuICAgIGxldCB0aW1lID0gYVRpbWUgfHwgdGhpcy5fdGltZTtcblxuICAgIGlmICghdGltZS5pc0RhdGUpIHtcbiAgICAgIHNlY29uZCA9IHRpbWUuc2Vjb25kICsgYUV4dHJhU2Vjb25kcztcbiAgICAgIHRpbWUuc2Vjb25kID0gc2Vjb25kICUgNjA7XG4gICAgICBtaW51dGVzT3ZlcmZsb3cgPSB0cnVuYyhzZWNvbmQgLyA2MCk7XG4gICAgICBpZiAodGltZS5zZWNvbmQgPCAwKSB7XG4gICAgICAgIHRpbWUuc2Vjb25kICs9IDYwO1xuICAgICAgICBtaW51dGVzT3ZlcmZsb3ctLTtcbiAgICAgIH1cblxuICAgICAgbWludXRlID0gdGltZS5taW51dGUgKyBhRXh0cmFNaW51dGVzICsgbWludXRlc092ZXJmbG93O1xuICAgICAgdGltZS5taW51dGUgPSBtaW51dGUgJSA2MDtcbiAgICAgIGhvdXJzT3ZlcmZsb3cgPSB0cnVuYyhtaW51dGUgLyA2MCk7XG4gICAgICBpZiAodGltZS5taW51dGUgPCAwKSB7XG4gICAgICAgIHRpbWUubWludXRlICs9IDYwO1xuICAgICAgICBob3Vyc092ZXJmbG93LS07XG4gICAgICB9XG5cbiAgICAgIGhvdXIgPSB0aW1lLmhvdXIgKyBhRXh0cmFIb3VycyArIGhvdXJzT3ZlcmZsb3c7XG5cbiAgICAgIHRpbWUuaG91ciA9IGhvdXIgJSAyNDtcbiAgICAgIGRheXNPdmVyZmxvdyA9IHRydW5jKGhvdXIgLyAyNCk7XG4gICAgICBpZiAodGltZS5ob3VyIDwgMCkge1xuICAgICAgICB0aW1lLmhvdXIgKz0gMjQ7XG4gICAgICAgIGRheXNPdmVyZmxvdy0tO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gQWRqdXN0IG1vbnRoIGFuZCB5ZWFyIGZpcnN0LCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB3aGF0IG1vbnRoIHRoZSBkYXlcbiAgICAvLyBpcyBpbiBiZWZvcmUgYWRqdXN0aW5nIGl0LlxuICAgIGlmICh0aW1lLm1vbnRoID4gMTIpIHtcbiAgICAgIHllYXJzT3ZlcmZsb3cgPSB0cnVuYygodGltZS5tb250aCAtIDEpIC8gMTIpO1xuICAgIH0gZWxzZSBpZiAodGltZS5tb250aCA8IDEpIHtcbiAgICAgIHllYXJzT3ZlcmZsb3cgPSB0cnVuYyh0aW1lLm1vbnRoIC8gMTIpIC0gMTtcbiAgICB9XG5cbiAgICB0aW1lLnllYXIgKz0geWVhcnNPdmVyZmxvdztcbiAgICB0aW1lLm1vbnRoIC09IDEyICogeWVhcnNPdmVyZmxvdztcblxuICAgIC8vIE5vdyB0YWtlIGNhcmUgb2YgdGhlIGRheXMgKGFuZCBhZGp1c3QgbW9udGggaWYgbmVlZGVkKVxuICAgIGRheSA9IHRpbWUuZGF5ICsgYUV4dHJhRGF5cyArIGRheXNPdmVyZmxvdztcblxuICAgIGlmIChkYXkgPiAwKSB7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICBpZiAoZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lLm1vbnRoKys7XG4gICAgICAgIGlmICh0aW1lLm1vbnRoID4gMTIpIHtcbiAgICAgICAgICB0aW1lLnllYXIrKztcbiAgICAgICAgICB0aW1lLm1vbnRoID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGRheSA8PSAwKSB7XG4gICAgICAgIGlmICh0aW1lLm1vbnRoID09IDEpIHtcbiAgICAgICAgICB0aW1lLnllYXItLTtcbiAgICAgICAgICB0aW1lLm1vbnRoID0gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZS5tb250aC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF5ICs9IFRpbWUuZGF5c0luTW9udGgodGltZS5tb250aCwgdGltZS55ZWFyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lLmRheSA9IGRheTtcblxuICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdW5peCB0aW1lLCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICogSmFudWFyeSAxc3QsIDE5NzAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgICAgVGhlIHNlY29uZHMgdG8gc2V0IHVwIHdpdGhcbiAgICovXG4gIGZyb21Vbml4VGltZShzZWNvbmRzKSB7XG4gICAgdGhpcy56b25lID0gVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgLy8gV2UgY291bGQgdXNlIGBmcm9tSlNEYXRlYCBoZXJlLCBidXQgdGhpcyBpcyBhYm91dCB0d2ljZSBhcyBmYXN0LlxuICAgIC8vIFdlIGNvdWxkIGFsc28gY2xvbmUgYGVwb2NoVGltZWAgYW5kIHVzZSBgYWRqdXN0YCBmb3IgYSBtb3JlXG4gICAgLy8gaWNhbC5qcy1jZW50cmljIGFwcHJvYWNoLCBidXQgdGhpcyBpcyBhYm91dCAxMDAgdGltZXMgYXMgZmFzdC5cbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwKTtcbiAgICB0aGlzLnllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgdGhpcy5tb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgdGhpcy5kYXkgPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICBpZiAodGhpcy5fdGltZS5pc0RhdGUpIHtcbiAgICAgIHRoaXMuaG91ciA9IDA7XG4gICAgICB0aGlzLm1pbnV0ZSA9IDA7XG4gICAgICB0aGlzLnNlY29uZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaG91ciA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgIHRoaXMubWludXRlID0gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICB0aGlzLnNlY29uZCA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICAgIH1cblxuICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBzZWNvbmRzIHNpbmNlIEphbnVhcnkgMXN0IDE5NzAuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBTZWNvbmRzIHNpbmNlIDE5NzBcbiAgICovXG4gIHRvVW5peFRpbWUoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFVuaXhUaW1lICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVW5peFRpbWU7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuXG4gICAgLy8gd2UgdXNlIHRoZSBvZmZzZXQgdHJpY2sgdG8gZW5zdXJlXG4gICAgLy8gdGhhdCB3ZSBhcmUgZ2V0dGluZyB0aGUgYWN0dWFsIFVUQyB0aW1lXG4gICAgbGV0IG1zID0gRGF0ZS5VVEMoXG4gICAgICB0aGlzLnllYXIsXG4gICAgICB0aGlzLm1vbnRoIC0gMSxcbiAgICAgIHRoaXMuZGF5LFxuICAgICAgdGhpcy5ob3VyLFxuICAgICAgdGhpcy5taW51dGUsXG4gICAgICB0aGlzLnNlY29uZCAtIG9mZnNldFxuICAgICk7XG5cbiAgICAvLyBzZWNvbmRzXG4gICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBtcyAvIDEwMDA7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRpbWUgdG8gaW50byBPYmplY3Qgd2hpY2ggY2FuIGJlIHNlcmlhbGl6ZWQgdGhlbiByZS1jcmVhdGVkXG4gICAqIHVzaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gdG9KU09OIHdpbGwgYXV0b21hdGljYWxseSBiZSBjYWxsZWRcbiAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShteXRpbWUpO1xuICAgKlxuICAgKiB2YXIgZGVzZXJpYWxpemVkID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICpcbiAgICogdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKGRlc2VyaWFsaXplZCk7XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBsZXQgY29weSA9IFtcbiAgICAgICd5ZWFyJyxcbiAgICAgICdtb250aCcsXG4gICAgICAnZGF5JyxcbiAgICAgICdob3VyJyxcbiAgICAgICdtaW51dGUnLFxuICAgICAgJ3NlY29uZCcsXG4gICAgICAnaXNEYXRlJ1xuICAgIF07XG5cbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuID0gY29weS5sZW5ndGg7XG4gICAgbGV0IHByb3A7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwcm9wID0gY29weVtpXTtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuem9uZSkge1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGhpcy56b25lLnR6aWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4oZnVuY3Rpb24gc2V0dXBOb3JtYWxpemVBdHRyaWJ1dGVzKCkge1xuICAvLyBUaGlzIG5lZWRzIHRvIHJ1biBiZWZvcmUgYW55IGluc3RhbmNlcyBhcmUgY3JlYXRlZCFcbiAgZnVuY3Rpb24gZGVmaW5lQXR0cihhdHRyKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWUucHJvdG90eXBlLCBhdHRyLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldFRpbWVBdHRyKCkge1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ05vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVbYXR0cl07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXRUaW1lQXR0cih2YWwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXNEYXRlIHdpbGwgYmUgc2V0IGFuZCBpZiB3YXMgbm90IHNldCB0byBub3JtYWxpemUgZGF0ZS5cbiAgICAgICAgLy8gVGhpcyBhdm9pZHMgbG9zaW5nIGRheXMgd2hlbiBzZWNvbmRzLCBtaW51dGVzIGFuZCBob3VycyBhcmUgemVyb2VkXG4gICAgICAgIC8vIHdoYXQgbm9ybWFsaXplIHdpbGwgZG8gd2hlbiB0aW1lIGlzIGEgZGF0ZS5cbiAgICAgICAgaWYgKGF0dHIgPT09IFwiaXNEYXRlXCIgJiYgdmFsICYmICF0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLl90aW1lW2F0dHJdID0gdmFsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxuICAgIGRlZmluZUF0dHIoXCJ5ZWFyXCIpO1xuICAgIGRlZmluZUF0dHIoXCJtb250aFwiKTtcbiAgICBkZWZpbmVBdHRyKFwiZGF5XCIpO1xuICAgIGRlZmluZUF0dHIoXCJob3VyXCIpO1xuICAgIGRlZmluZUF0dHIoXCJtaW51dGVcIik7XG4gICAgZGVmaW5lQXR0cihcInNlY29uZFwiKTtcbiAgICBkZWZpbmVBdHRyKFwiaXNEYXRlXCIpO1xufSkoKTtcblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5wYXJzZXJTdGF0ZX0gcGFyc2VyU3RhdGVcbiAqIEltcG9ydHMgdGhlICdwYXJzZXJTdGF0ZScgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5kZXNpZ25TZXR9IGRlc2lnblNldFxuICogSW1wb3J0cyB0aGUgJ2Rlc2lnblNldCcgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuY29uc3QgQ0hBUiA9IC9bXiBcXHRdLztcbmNvbnN0IFZBTFVFX0RFTElNSVRFUiA9ICc6JztcbmNvbnN0IFBBUkFNX0RFTElNSVRFUiA9ICc7JztcbmNvbnN0IFBBUkFNX05BTUVfREVMSU1JVEVSID0gJz0nO1xuY29uc3QgREVGQVVMVF9WQUxVRV9UWVBFJDEgPSAndW5rbm93bic7XG5jb25zdCBERUZBVUxUX1BBUkFNX1RZUEUgPSAndGV4dCc7XG5jb25zdCBSRkM2ODY4X1JFUExBQ0VfTUFQJDEgPSB7IFwiXidcIjogJ1wiJywgXCJeblwiOiBcIlxcblwiLCBcIl5eXCI6IFwiXlwiIH07XG5cbi8qKlxuICogUGFyc2VzIGlDYWxlbmRhciBvciB2Q2FyZCBkYXRhIGludG8gYSByYXcgakNhbCBvYmplY3QuIENvbnN1bHRcbiAqIGRvY3VtZW50YXRpb24gb24gdGhlIHtAdHV0b3JpYWwgbGF5ZXJzfGxheWVycyBvZiBwYXJzaW5nfSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5wYXJzZVxuICogQG1lbWJlcm9mIElDQUxcbiAqIEB2YXJpYXRpb24gZnVuY3Rpb25cbiAqIEB0b2RvIEZpeCB0aGUgQVBJIHRvIGJlIG1vcmUgY2xlYXIgb24gdGhlIHJldHVybiB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgICAgICBUaGUgc3RyaW5nIGRhdGEgdG8gcGFyc2VcbiAqIEByZXR1cm4ge09iamVjdHxPYmplY3RbXX0gIEEgc2luZ2xlIGpDYWwgb2JqZWN0LCBvciBhbiBhcnJheSB0aGVyZW9mXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gIGxldCBzdGF0ZSA9IHt9O1xuICBsZXQgcm9vdCA9IHN0YXRlLmNvbXBvbmVudCA9IFtdO1xuXG4gIHN0YXRlLnN0YWNrID0gW3Jvb3RdO1xuXG4gIHBhcnNlLl9lYWNoTGluZShpbnB1dCwgZnVuY3Rpb24oZXJyLCBsaW5lKSB7XG4gICAgcGFyc2UuX2hhbmRsZUNvbnRlbnRMaW5lKGxpbmUsIHN0YXRlKTtcbiAgfSk7XG5cblxuICAvLyB3aGVuIHRoZXJlIGFyZSBzdGlsbCBpdGVtcyBvbiB0aGUgc3RhY2tcbiAgLy8gdGhyb3cgYSBmYXRhbCBlcnJvciwgYSBjb21wb25lbnQgd2FzIG5vdCBjbG9zZWRcbiAgLy8gY29ycmVjdGx5IGluIHRoYXQgY2FzZS5cbiAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAnaW52YWxpZCBpY2FsIGJvZHkuIGNvbXBvbmVudCBiZWdhbiBidXQgZGlkIG5vdCBlbmQnXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gKHJvb3QubGVuZ3RoID09IDEgPyByb290WzBdIDogcm9vdCk7XG59XG5cbi8qKlxuICogUGFyc2UgYW4gaUNhbGVuZGFyIHByb3BlcnR5IHZhbHVlIGludG8gdGhlIGpDYWwgZm9yIGEgc2luZ2xlIHByb3BlcnR5XG4gKlxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UucHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqICAgVGhlIGlDYWxlbmRhciBwcm9wZXJ0eSBzdHJpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB7ZGVzaWduU2V0PX0gZGVzaWduU2V0XG4gKiAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnR5XG4gKi9cbnBhcnNlLnByb3BlcnR5ID0gZnVuY3Rpb24oc3RyLCBkZXNpZ25TZXQpIHtcbiAgbGV0IHN0YXRlID0ge1xuICAgIGNvbXBvbmVudDogW1tdLCBbXV0sXG4gICAgZGVzaWduU2V0OiBkZXNpZ25TZXQgfHwgZGVzaWduJDEuZGVmYXVsdFNldFxuICB9O1xuICBwYXJzZS5faGFuZGxlQ29udGVudExpbmUoc3RyLCBzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZS5jb21wb25lbnRbMV1bMF07XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBwYXJzZSBhIGNvbXBvbmVudC4gWW91IGNhbiB1c2UgSUNBTC5wYXJzZSgpIGRpcmVjdGx5XG4gKiBpbnN0ZWFkLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLmNvbXBvbmVudFxuICogQHNlZSBJQ0FMLnBhcnNlKGZ1bmN0aW9uKVxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICBUaGUgaUNhbGVuZGFyIGNvbXBvbmVudCBzdHJpbmcgdG8gcGFyc2VcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudFxuICovXG5wYXJzZS5jb21wb25lbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHBhcnNlKHN0cik7XG59O1xuXG5cbi8qKlxuICogQW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAgICAgICAgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBtZW1iZXJvZiBJQ0FMLnBhcnNlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKi9cbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG4vLyBjbGFzc2VzICYgY29uc3RhbnRzXG5wYXJzZS5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuXG5cbi8qKlxuICogSGFuZGxlcyBhIHNpbmdsZSBsaW5lIG9mIGlDYWxlbmRhci92Q2FyZCwgdXBkYXRpbmcgdGhlIHN0YXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5faGFuZGxlQ29udGVudExpbmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lICAgICAgICAgIFRoZSBjb250ZW50IGxpbmUgdG8gcHJvY2Vzc1xuICogQHBhcmFtIHtwYXJzZXJTdGF0ZX0gc3RhdGUgICAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGxpbmUgcGFyc2luZ1xuICovXG5wYXJzZS5faGFuZGxlQ29udGVudExpbmUgPSBmdW5jdGlvbihsaW5lLCBzdGF0ZSkge1xuICAvLyBicmVhayB1cCB0aGUgcGFydHMgb2YgdGhlIGxpbmVcbiAgbGV0IHZhbHVlUG9zID0gbGluZS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUik7XG4gIGxldCBwYXJhbVBvcyA9IGxpbmUuaW5kZXhPZihQQVJBTV9ERUxJTUlURVIpO1xuXG4gIGxldCBsYXN0UGFyYW1JbmRleDtcbiAgbGV0IGxhc3RWYWx1ZVBvcztcblxuICAvLyBuYW1lIG9mIHByb3BlcnR5IG9yIGJlZ2luL2VuZFxuICBsZXQgbmFtZTtcbiAgbGV0IHZhbHVlO1xuICAvLyBwYXJhbXMgaXMgb25seSBvdmVycmlkZGVuIGlmIHBhcmFtUG9zICE9PSAtMS5cbiAgLy8gd2UgY2FuJ3QgZG8gcGFyYW1zID0gcGFyYW1zIHx8IHt9IGxhdGVyIG9uXG4gIC8vIGJlY2F1c2UgaXQgc2FjcmlmaWNlcyBvcHMuXG4gIGxldCBwYXJhbXMgPSB7fTtcblxuICAvKipcbiAgICogRGlmZmVyZW50IHByb3BlcnR5IGNhc2VzXG4gICAqXG4gICAqXG4gICAqIDEuIFJSVUxFOkZSRVE9Zm9vXG4gICAqICAgIC8vIEZSRVE9IGlzIG5vdCBhIHBhcmFtIGJ1dCB0aGUgdmFsdWVcbiAgICpcbiAgICogMi4gQVRURU5ERUU7Uk9MRT1SRVEtUEFSVElDSVBBTlQ7XG4gICAqICAgIC8vIFJPTEU9IGlzIGEgcGFyYW0gYmVjYXVzZSA6IGhhcyBub3QgaGFwcGVuZWQgeWV0XG4gICAqL1xuICAgIC8vIHdoZW4gdGhlIHBhcmFtZXRlciBkZWxpbWl0ZXIgaXMgYWZ0ZXIgdGhlXG4gICAgLy8gdmFsdWUgZGVsaW1pdGVyIHRoZW4gaXQgaXMgbm90IGEgcGFyYW1ldGVyLlxuXG4gIGlmICgocGFyYW1Qb3MgIT09IC0xICYmIHZhbHVlUG9zICE9PSAtMSkpIHtcbiAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgIC8vIHZhbHVlIGRlbGltaXRlciB0aGVuIGl0IGlzIG5vdCBhIHBhcmFtZXRlci5cbiAgICBpZiAocGFyYW1Qb3MgPiB2YWx1ZVBvcykge1xuICAgICAgcGFyYW1Qb3MgPSAtMTtcbiAgICB9XG4gIH1cblxuICBsZXQgcGFyc2VkUGFyYW1zO1xuICBpZiAocGFyYW1Qb3MgIT09IC0xKSB7XG4gICAgbmFtZSA9IGxpbmUuc2xpY2UoMCwgTWF0aC5tYXgoMCwgcGFyYW1Qb3MpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHBhcnNlZFBhcmFtcyA9IHBhcnNlLl9wYXJzZVBhcmFtZXRlcnMobGluZS5zbGljZShNYXRoLm1heCgwLCBwYXJhbVBvcykpLCAwLCBzdGF0ZS5kZXNpZ25TZXQpO1xuICAgIGlmIChwYXJzZWRQYXJhbXNbMl0gPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIkludmFsaWQgcGFyYW1ldGVycyBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgIH1cbiAgICBwYXJhbXMgPSBwYXJzZWRQYXJhbXNbMF07XG4gICAgbGFzdFBhcmFtSW5kZXggPSBwYXJzZWRQYXJhbXNbMV0ubGVuZ3RoICsgcGFyc2VkUGFyYW1zWzJdICsgcGFyYW1Qb3M7XG4gICAgaWYgKChsYXN0VmFsdWVQb3MgPVxuICAgICAgbGluZS5zbGljZShNYXRoLm1heCgwLCBsYXN0UGFyYW1JbmRleCkpLmluZGV4T2YoVkFMVUVfREVMSU1JVEVSKSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdFBhcmFtSW5kZXggKyBsYXN0VmFsdWVQb3MgKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIHZhbHVlIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlUG9zICE9PSAtMSkge1xuICAgIC8vIHdpdGhvdXQgcGFybWV0ZXJzIChCRUdJTjpWQ0FFTkRBUiwgQ0xBU1M6UFVCTElDKVxuICAgIG5hbWUgPSBsaW5lLnNsaWNlKDAsIE1hdGgubWF4KDAsIHZhbHVlUG9zKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWx1ZSA9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgdmFsdWVQb3MgKyAxKSk7XG5cbiAgICBpZiAobmFtZSA9PT0gJ2JlZ2luJykge1xuICAgICAgbGV0IG5ld0NvbXBvbmVudCA9IFt2YWx1ZS50b0xvd2VyQ2FzZSgpLCBbXSwgW11dO1xuICAgICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGF0ZS5jb21wb25lbnQucHVzaChuZXdDb21wb25lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50WzJdLnB1c2gobmV3Q29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUuY29tcG9uZW50KTtcbiAgICAgIHN0YXRlLmNvbXBvbmVudCA9IG5ld0NvbXBvbmVudDtcbiAgICAgIGlmICghc3RhdGUuZGVzaWduU2V0KSB7XG4gICAgICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbiQxLmdldERlc2lnblNldChzdGF0ZS5jb21wb25lbnRbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHN0YXRlLmNvbXBvbmVudCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiBpdCBpcyBub3QgYmVnaW4vZW5kLCB0aGVuIHRoaXMgaXMgYSBwcm9wZXJ0eSB3aXRoIGFuIGVtcHR5IHZhbHVlLFxuICAgIC8vIHdoaWNoIHNob3VsZCBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEludmFsaWQgbGluZS5cbiAgICAgKiBUaGUgcmF0aW9uYWwgdG8gdGhyb3cgYW4gZXJyb3IgaXMgd2Ugd2lsbFxuICAgICAqIG5ldmVyIGJlIGNlcnRhaW4gdGhhdCB0aGUgcmVzdCBvZiB0aGUgZmlsZVxuICAgICAqIGlzIHNhbmUgYW5kIGl0IGlzIHVubGlrZWx5IHRoYXQgd2UgY2FuIHNlcmlhbGl6ZVxuICAgICAqIHRoZSByZXN1bHQgY29ycmVjdGx5IGVpdGhlci5cbiAgICAgKi9cbiAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAnaW52YWxpZCBsaW5lIChubyB0b2tlbiBcIjtcIiBvciBcIjpcIikgXCInICsgbGluZSArICdcIidcbiAgICApO1xuICB9XG5cbiAgbGV0IHZhbHVlVHlwZTtcbiAgbGV0IG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgbGV0IHN0cnVjdHVyZWRWYWx1ZSA9IGZhbHNlO1xuICBsZXQgcHJvcGVydHlEZXRhaWxzO1xuICBsZXQgc3BsaXROYW1lO1xuICBsZXQgdW5ncm91cGVkTmFtZTtcblxuICAvLyBmZXRjaCB0aGUgdW5ncm91cGVkIHBhcnQgb2YgdGhlIG5hbWVcbiAgaWYgKHN0YXRlLmRlc2lnblNldC5wcm9wZXJ0eUdyb3VwcyAmJiBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICBzcGxpdE5hbWUgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgcGFyYW1zLmdyb3VwID0gc3BsaXROYW1lWzBdO1xuICAgIHVuZ3JvdXBlZE5hbWUgPSBzcGxpdE5hbWVbMV07XG4gIH0gZWxzZSB7XG4gICAgdW5ncm91cGVkTmFtZSA9IG5hbWU7XG4gIH1cblxuICBpZiAodW5ncm91cGVkTmFtZSBpbiBzdGF0ZS5kZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICBwcm9wZXJ0eURldGFpbHMgPSBzdGF0ZS5kZXNpZ25TZXQucHJvcGVydHlbdW5ncm91cGVkTmFtZV07XG5cbiAgICBpZiAoJ211bHRpVmFsdWUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgbXVsdGlWYWx1ZSA9IHByb3BlcnR5RGV0YWlscy5tdWx0aVZhbHVlO1xuICAgIH1cblxuICAgIGlmICgnc3RydWN0dXJlZFZhbHVlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgIHN0cnVjdHVyZWRWYWx1ZSA9IHByb3BlcnR5RGV0YWlscy5zdHJ1Y3R1cmVkVmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmICdkZXRlY3RUeXBlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgIHZhbHVlVHlwZSA9IHByb3BlcnR5RGV0YWlscy5kZXRlY3RUeXBlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB2YWx1ZVxuICBpZiAoIXZhbHVlVHlwZSkge1xuICAgIGlmICghKCd2YWx1ZScgaW4gcGFyYW1zKSkge1xuICAgICAgaWYgKHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICB2YWx1ZVR5cGUgPSBwcm9wZXJ0eURldGFpbHMuZGVmYXVsdFR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZVR5cGUgPSBERUZBVUxUX1ZBTFVFX1RZUEUkMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9zc2libGUgdG8gYXZvaWQgdGhpcz9cbiAgICAgIHZhbHVlVHlwZSA9IHBhcmFtcy52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZSBwYXJhbXMudmFsdWU7XG5cbiAgLyoqXG4gICAqIE5vdGUgb24gYHZhciByZXN1bHRgIGp1Z2dsaW5nOlxuICAgKlxuICAgKiBJIG9ic2VydmVkIHRoYXQgYnVpbGRpbmcgdGhlIGFycmF5IGluIHBpZWNlcyBoYXMgYWR2ZXJzZVxuICAgKiBlZmZlY3RzIG9uIHBlcmZvcm1hbmNlLCBzbyB3aGVyZSBwb3NzaWJsZSB3ZSBpbmxpbmUgdGhlIGNyZWF0aW9uLlxuICAgKiBJdCBpcyBhIGxpdHRsZSB1Z2x5IGJ1dCByZXN1bHRlZCBpbiB+MjAwMCBhZGRpdGlvbmFsIG9wcy9zZWMuXG4gICAqL1xuXG4gIGxldCByZXN1bHQ7XG4gIGlmIChtdWx0aVZhbHVlICYmIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIFtdLCBtdWx0aVZhbHVlLCBzdGF0ZS5kZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgcmVzdWx0ID0gW3VuZ3JvdXBlZE5hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgIHJlc3VsdCA9IFt1bmdyb3VwZWROYW1lLCBwYXJhbXMsIHZhbHVlVHlwZV07XG4gICAgcGFyc2UuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgbXVsdGlWYWx1ZSwgdmFsdWVUeXBlLCByZXN1bHQsIG51bGwsIHN0YXRlLmRlc2lnblNldCwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIFtdLCBudWxsLCBzdGF0ZS5kZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgcmVzdWx0ID0gW3VuZ3JvdXBlZE5hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBwYXJzZS5fcGFyc2VWYWx1ZSh2YWx1ZSwgdmFsdWVUeXBlLCBzdGF0ZS5kZXNpZ25TZXQsIGZhbHNlKTtcbiAgICByZXN1bHQgPSBbdW5ncm91cGVkTmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGUsIHZhbHVlXTtcbiAgfVxuICAvLyByZmM2MzUwIHJlcXVpcmVzIHRoYXQgaW4gdkNhcmQgNC4wIHRoZSBmaXJzdCBjb21wb25lbnQgaXMgdGhlIFZFUlNJT05cbiAgLy8gY29tcG9uZW50IHdpdGggYXMgdmFsdWUgNC4wLCBub3RlIHRoYXQgMy4wIGRvZXMgbm90IGhhdmUgdGhpcyByZXF1aXJlbWVudC5cbiAgaWYgKHN0YXRlLmNvbXBvbmVudFswXSA9PT0gJ3ZjYXJkJyAmJiBzdGF0ZS5jb21wb25lbnRbMV0ubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIShuYW1lID09PSAndmVyc2lvbicgJiYgdmFsdWUgPT09ICc0LjAnKSkge1xuICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbiQxLmdldERlc2lnblNldChcInZjYXJkM1wiKTtcbiAgfVxuICBzdGF0ZS5jb21wb25lbnRbMV0ucHVzaChyZXN1bHQpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIHZhbHVlIGZyb20gdGhlIHJhdyB2YWx1ZSBpbnRvIHRoZSBqQ2FyZC9qQ2FsIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcGFyc2VWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgICAgIE9yaWdpbmFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICAgICAgVHlwZSBvZiB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgdmFsdWVcbiAqIEByZXR1cm4ge09iamVjdH0gdmFyaWVzIG9uIHR5cGVcbiAqL1xucGFyc2UuX3BhcnNlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICdmcm9tSUNBTCcgaW4gZGVzaWduU2V0LnZhbHVlW3R5cGVdKSB7XG4gICAgcmV0dXJuIGRlc2lnblNldC52YWx1ZVt0eXBlXS5mcm9tSUNBTCh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFBhcnNlIHBhcmFtZXRlcnMgZnJvbSBhIHN0cmluZyB0byBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlUGFyYW1ldGVyc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lICAgICAgICAgICBBIHNpbmdsZSB1bmZvbGRlZCBsaW5lXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgICAgICAgICBQb3NpdGlvbiB0byBzdGFydCBsb29raW5nIGZvciBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzaWduU2V0ICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICogQHJldHVybiB7T2JqZWN0fSBrZXkvdmFsdWUgcGFpcnNcbiAqL1xucGFyc2UuX3BhcnNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKGxpbmUsIHN0YXJ0LCBkZXNpZ25TZXQpIHtcbiAgbGV0IGxhc3RQYXJhbSA9IHN0YXJ0O1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IGRlbGltID0gUEFSQU1fTkFNRV9ERUxJTUlURVI7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgbGV0IG5hbWUsIGxjbmFtZTtcbiAgbGV0IHZhbHVlLCB2YWx1ZVBvcyA9IC0xO1xuICBsZXQgdHlwZSwgbXVsdGlWYWx1ZSwgbXZkZWxpbTtcblxuICAvLyBmaW5kIHRoZSBuZXh0ICc9JyBzaWduXG4gIC8vIHVzZSBsYXN0UGFyYW0gYW5kIHBvcyB0byBmaW5kIG5hbWVcbiAgLy8gY2hlY2sgaWYgXCIgaXMgdXNlZCBpZiBzbyBnZXQgdmFsdWUgZnJvbSBcIi0+XCJcbiAgLy8gdGhlbiBpbmNyZW1lbnQgcG9zIHRvIGZpbmQgbmV4dCA7XG5cbiAgd2hpbGUgKChwb3MgIT09IGZhbHNlKSAmJlxuICAgICAgICAgKHBvcyA9IGxpbmUuaW5kZXhPZihkZWxpbSwgcG9zICsgMSkpICE9PSAtMSkge1xuXG4gICAgbmFtZSA9IGxpbmUuc2xpY2UobGFzdFBhcmFtICsgMSwgcG9zKTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiRW1wdHkgcGFyYW1ldGVyIG5hbWUgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICB9XG4gICAgbGNuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIG12ZGVsaW0gPSBmYWxzZTtcbiAgICBtdWx0aVZhbHVlID0gZmFsc2U7XG5cbiAgICBpZiAobGNuYW1lIGluIGRlc2lnblNldC5wYXJhbSAmJiBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGUpIHtcbiAgICAgIHR5cGUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBERUZBVUxUX1BBUkFNX1RZUEU7XG4gICAgfVxuXG4gICAgaWYgKGxjbmFtZSBpbiBkZXNpZ25TZXQucGFyYW0pIHtcbiAgICAgIG11bHRpVmFsdWUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS5tdWx0aVZhbHVlO1xuICAgICAgaWYgKGRlc2lnblNldC5wYXJhbVtsY25hbWVdLm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSkge1xuICAgICAgICBtdmRlbGltID0gcGFyc2UuX3JmYzY4NjhFc2NhcGUoJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmV4dENoYXIgPSBsaW5lW3BvcyArIDFdO1xuICAgIGlmIChuZXh0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgdmFsdWVQb3MgPSBwb3MgKyAyO1xuICAgICAgcG9zID0gbGluZS5pbmRleE9mKCdcIicsIHZhbHVlUG9zKTtcbiAgICAgIGlmIChtdWx0aVZhbHVlICYmIHBvcyAhPSAtMSkge1xuICAgICAgICAgIGxldCBleHRlbmRlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB3aGlsZSAoZXh0ZW5kZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGxpbmVbcG9zICsgMV0gPT0gbXVsdGlWYWx1ZSAmJiBsaW5lW3BvcyArIDJdID09ICdcIicpIHtcbiAgICAgICAgICAgICAgcG9zID0gbGluZS5pbmRleE9mKCdcIicsIHBvcyArIDMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXh0ZW5kZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGxpbmUgKG5vIG1hdGNoaW5nIGRvdWJsZSBxdW90ZSkgXCInICsgbGluZSArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gbGluZS5zbGljZSh2YWx1ZVBvcywgcG9zKTtcbiAgICAgIGxhc3RQYXJhbSA9IGxpbmUuaW5kZXhPZihQQVJBTV9ERUxJTUlURVIsIHBvcyk7XG4gICAgICBsZXQgcHJvcFZhbHVlUG9zID0gbGluZS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUiwgcG9zKTtcbiAgICAgIC8vIGlmIGVpdGhlciBubyBuZXh0IHBhcmFtZXRlciBvciBkZWxpbWV0ZXIgaW4gcHJvcGVydHkgdmFsdWUsIGxldCdzIHN0b3AgaGVyZVxuICAgICAgaWYgKGxhc3RQYXJhbSA9PT0gLTEgfHwgKHByb3BWYWx1ZVBvcyAhPT0gLTEgJiYgbGFzdFBhcmFtID4gcHJvcFZhbHVlUG9zKSkge1xuICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVQb3MgPSBwb3MgKyAxO1xuXG4gICAgICAvLyBtb3ZlIHRvIG5leHQgXCI7XCJcbiAgICAgIGxldCBuZXh0UG9zID0gbGluZS5pbmRleE9mKFBBUkFNX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgbGV0IHByb3BWYWx1ZVBvcyA9IGxpbmUuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIsIHZhbHVlUG9zKTtcbiAgICAgIGlmIChwcm9wVmFsdWVQb3MgIT09IC0xICYmIG5leHRQb3MgPiBwcm9wVmFsdWVQb3MpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGRlbGltaXRlciBpbiB0aGUgcHJvcGVydHkgdmFsdWUsIGxldCdzIHN0b3AgaGVyZVxuICAgICAgICBuZXh0UG9zID0gcHJvcFZhbHVlUG9zO1xuICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFBvcyA9PT0gLTEpIHtcbiAgICAgICAgLy8gbm8gXCI7XCJcbiAgICAgICAgaWYgKHByb3BWYWx1ZVBvcyA9PT0gLTEpIHtcbiAgICAgICAgICBuZXh0UG9zID0gbGluZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFBvcyA9IHByb3BWYWx1ZVBvcztcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RQYXJhbSA9IG5leHRQb3M7XG4gICAgICAgIHBvcyA9IG5leHRQb3M7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gbGluZS5zbGljZSh2YWx1ZVBvcywgbmV4dFBvcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoX2JlZm9yZSA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YWx1ZSA9IHBhcnNlLl9yZmM2ODY4RXNjYXBlKHZhbHVlKTtcbiAgICB2YWx1ZVBvcyArPSBsZW5ndGhfYmVmb3JlIC0gdmFsdWUubGVuZ3RoO1xuICAgIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICBsZXQgZGVsaW1pdGVyID0gbXZkZWxpbSB8fCBtdWx0aVZhbHVlO1xuICAgICAgdmFsdWUgPSBwYXJzZS5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBkZWxpbWl0ZXIsIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQpO1xuICAgIH1cblxuICAgIGlmIChtdWx0aVZhbHVlICYmIChsY25hbWUgaW4gcmVzdWx0KSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2xjbmFtZV0pKSB7XG4gICAgICAgIHJlc3VsdFtsY25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xjbmFtZV0gPSBbXG4gICAgICAgICAgcmVzdWx0W2xjbmFtZV0sXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtyZXN1bHQsIHZhbHVlLCB2YWx1ZVBvc107XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnBhcnNlIHNvIHRoYXRcbiAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gKlxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3JmYzY4NjhFc2NhcGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byBlc2NhcGVcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBlc2NhcGVkIHZhbHVlXG4gKi9cbnBhcnNlLl9yZmM2ODY4RXNjYXBlID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwucmVwbGFjZSgvXFxeWyduXl0vZywgZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBSRkM2ODY4X1JFUExBQ0VfTUFQJDFbeF07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIG11bHRpIHZhbHVlIHN0cmluZy4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGVpdGhlciBmb3IgcGFyc2luZ1xuICogYWN0dWFsIG11bHRpLXZhbHVlIHByb3BlcnR5J3MgdmFsdWVzLCBvciBmb3IgaGFuZGxpbmcgcGFyYW1ldGVyIHZhbHVlcy4gSXRcbiAqIGNhbiBiZSB1c2VkIGZvciBib3RoIG11bHRpLXZhbHVlIHByb3BlcnRpZXMgYW5kIHN0cnVjdHVyZWQgdmFsdWUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlTXVsdGlWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgICAgVGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBmdWxsIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVsaW0gICAgICAgICAgICBUaGUgbXVsdGktdmFsdWUgZGVsaW1pdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICAgICAgICBUaGUgdmFsdWUgdHlwZSB0byBiZSBwYXJzZWRcbiAqIEBwYXJhbSB7QXJyYXkuPD8+fSByZXN1bHQgICAgICAgIFRoZSBhcnJheSB0byBhcHBlbmQgcmVzdWx0cyB0bywgdmFyaWVzIG9uIHZhbHVlIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbm5lck11bHRpICAgICAgIFRoZSBpbm5lciBkZWxpbWl0ZXIgdG8gc3BsaXQgZWFjaCB2YWx1ZSB3aXRoXG4gKiBAcGFyYW0ge2Rlc2lnblNldH0gZGVzaWduU2V0ICAgICBUaGUgZGVzaWduIGRhdGEgZm9yIHRoaXMgdmFsdWVcbiAqIEByZXR1cm4gez98QXJyYXkuPD8+fSAgICAgICAgICAgIEVpdGhlciBhbiBhcnJheSBvZiByZXN1bHRzLCBvciB0aGUgZmlyc3QgcmVzdWx0XG4gKi9cbnBhcnNlLl9wYXJzZU11bHRpVmFsdWUgPSBmdW5jdGlvbihidWZmZXIsIGRlbGltLCB0eXBlLCByZXN1bHQsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgbGFzdFBvcyA9IDA7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKGRlbGltLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICAvLyBzcGxpdCBlYWNoIHBpZWNlXG4gIHdoaWxlICgocG9zID0gdW5lc2NhcGVkSW5kZXhPZihidWZmZXIsIGRlbGltLCBsYXN0UG9zKSkgIT09IC0xKSB7XG4gICAgdmFsdWUgPSBidWZmZXIuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICBpZiAoaW5uZXJNdWx0aSkge1xuICAgICAgdmFsdWUgPSBwYXJzZS5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBpbm5lck11bHRpLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICBsYXN0UG9zID0gcG9zICsgZGVsaW0ubGVuZ3RoO1xuICB9XG5cbiAgLy8gb24gdGhlIGxhc3QgcGllY2UgdGFrZSB0aGUgcmVzdCBvZiBzdHJpbmdcbiAgdmFsdWUgPSBidWZmZXIuc2xpY2UobGFzdFBvcyk7XG4gIGlmIChpbm5lck11bHRpKSB7XG4gICAgdmFsdWUgPSBwYXJzZS5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBpbm5lck11bHRpLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gcGFyc2UuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgfVxuICByZXN1bHQucHVzaCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIGNvbXBsZXRlIGJ1ZmZlciBvZiBpQ2FsZW5kYXIvdkNhcmQgZGF0YSBsaW5lIGJ5IGxpbmUsIGNvcnJlY3RseVxuICogdW5mb2xkaW5nIGNvbnRlbnQuIEVhY2ggbGluZSB3aWxsIGJlIHByb2Nlc3NlZCB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fZWFjaExpbmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXIgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJ1ZmZlciB0byBwcm9jZXNzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD9TdHJpbmcsIFN0cmluZyl9IGNhbGxiYWNrICAgIFRoZSBjYWxsYmFjayBmb3IgZWFjaCBsaW5lXG4gKi9cbnBhcnNlLl9lYWNoTGluZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgbGV0IGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gIGxldCBsYXN0UG9zID0gYnVmZmVyLnNlYXJjaChDSEFSKTtcbiAgbGV0IHBvcyA9IGxhc3RQb3M7XG4gIGxldCBsaW5lO1xuICBsZXQgZmlyc3RDaGFyO1xuXG4gIGxldCBuZXdsaW5lT2Zmc2V0O1xuXG4gIGRvIHtcbiAgICBwb3MgPSBidWZmZXIuaW5kZXhPZignXFxuJywgbGFzdFBvcykgKyAxO1xuXG4gICAgaWYgKHBvcyA+IDEgJiYgYnVmZmVyW3BvcyAtIDJdID09PSAnXFxyJykge1xuICAgICAgbmV3bGluZU9mZnNldCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld2xpbmVPZmZzZXQgPSAxO1xuICAgIH1cblxuICAgIGlmIChwb3MgPT09IDApIHtcbiAgICAgIHBvcyA9IGxlbjtcbiAgICAgIG5ld2xpbmVPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGZpcnN0Q2hhciA9IGJ1ZmZlcltsYXN0UG9zXTtcblxuICAgIGlmIChmaXJzdENoYXIgPT09ICcgJyB8fCBmaXJzdENoYXIgPT09ICdcXHQnKSB7XG4gICAgICAvLyBhZGQgdG8gbGluZVxuICAgICAgbGluZSArPSBidWZmZXIuc2xpY2UobGFzdFBvcyArIDEsIHBvcyAtIG5ld2xpbmVPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGluZSlcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbGluZSk7XG4gICAgICAvLyBwdXNoIGxpbmVcbiAgICAgIGxpbmUgPSBidWZmZXIuc2xpY2UobGFzdFBvcywgcG9zIC0gbmV3bGluZU9mZnNldCk7XG4gICAgfVxuXG4gICAgbGFzdFBvcyA9IHBvcztcbiAgfSB3aGlsZSAocG9zICE9PSBsZW4pO1xuXG4gIC8vIGV4dHJhIGVuZGluZyBsaW5lXG4gIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICBpZiAobGluZS5sZW5ndGgpXG4gICAgY2FsbGJhY2sobnVsbCwgbGluZSk7XG59O1xuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuY29uc3QgT1BUSU9OUyA9IFtcInR6aWRcIiwgXCJsb2NhdGlvblwiLCBcInR6bmFtZXNcIiwgXCJsYXRpdHVkZVwiLCBcImxvbmdpdHVkZVwiXTtcblxuLyoqXG4gKiBUaW1lem9uZSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHZjYWxlbmRhcjtcbiAqIHZhciB0aW1lem9uZUNvbXAgPSB2Y2FsZW5kYXIuZ2V0Rmlyc3RTdWJjb21wb25lbnQoJ3Z0aW1lem9uZScpO1xuICogdmFyIHR6aWQgPSB0aW1lem9uZUNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gKlxuICogdmFyIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUoe1xuICogICBjb21wb25lbnQ6IHRpbWV6b25lQ29tcCxcbiAqICAgdHppZFxuICogfSk7XG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgVGltZXpvbmUge1xuICBzdGF0aWMgX2NvbXBhcmVfY2hhbmdlX2ZuKGEsIGIpIHtcbiAgICBpZiAoYS55ZWFyIDwgYi55ZWFyKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS55ZWFyID4gYi55ZWFyKSByZXR1cm4gMTtcblxuICAgIGlmIChhLm1vbnRoIDwgYi5tb250aCkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEubW9udGggPiBiLm1vbnRoKSByZXR1cm4gMTtcblxuICAgIGlmIChhLmRheSA8IGIuZGF5KSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5kYXkgPiBiLmRheSkgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5ob3VyIDwgYi5ob3VyKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5ob3VyID4gYi5ob3VyKSByZXR1cm4gMTtcblxuICAgIGlmIChhLm1pbnV0ZSA8IGIubWludXRlKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5taW51dGUgPiBiLm1pbnV0ZSkgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5zZWNvbmQgPCBiLnNlY29uZCkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuc2Vjb25kID4gYi5zZWNvbmQpIHJldHVybiAxO1xuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgZGF0ZS90aW1lIGZyb20gb25lIHpvbmUgdG8gdGhlIG5leHQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZX0gdHQgICAgICAgICAgICAgICAgICBUaGUgdGltZSB0byBjb252ZXJ0XG4gICAqIEBwYXJhbSB7VGltZXpvbmV9IGZyb21fem9uZSAgICAgICBUaGUgc291cmNlIHpvbmUgdG8gY29udmVydCBmcm9tXG4gICAqIEBwYXJhbSB7VGltZXpvbmV9IHRvX3pvbmUgICAgICAgICBUaGUgdGFyZ2V0IHpvbmUgdG8gY29udmVydCB0b1xuICAgKiBAcmV0dXJuIHtUaW1lfSAgICAgICAgICAgICAgICAgICAgVGhlIGNvbnZlcnRlZCBkYXRlL3RpbWUgb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgY29udmVydF90aW1lKHR0LCBmcm9tX3pvbmUsIHRvX3pvbmUpIHtcbiAgICBpZiAodHQuaXNEYXRlIHx8XG4gICAgICAgIGZyb21fem9uZS50emlkID09IHRvX3pvbmUudHppZCB8fFxuICAgICAgICBmcm9tX3pvbmUgPT0gVGltZXpvbmUubG9jYWxUaW1lem9uZSB8fFxuICAgICAgICB0b196b25lID09IFRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgIHR0LnpvbmUgPSB0b196b25lO1xuICAgICAgcmV0dXJuIHR0O1xuICAgIH1cblxuICAgIGxldCB1dGNPZmZzZXQgPSBmcm9tX3pvbmUudXRjT2Zmc2V0KHR0KTtcbiAgICB0dC5hZGp1c3QoMCwgMCwgMCwgLSB1dGNPZmZzZXQpO1xuXG4gICAgdXRjT2Zmc2V0ID0gdG9fem9uZS51dGNPZmZzZXQodHQpO1xuICAgIHR0LmFkanVzdCgwLCAwLCAwLCB1dGNPZmZzZXQpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWV6b25lIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR8T2JqZWN0fSBhRGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xDb21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLmxvY2F0aW9uICBUaGUgdGltZXpvbmUgbG9jYXRpb253XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRhKGFEYXRhKSB7XG4gICAgbGV0IHR0ID0gbmV3IFRpbWV6b25lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21EYXRhKGFEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgVVRDIHRpbWV6b25lXG4gICAqIEB0eXBlIHtUaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljICN1dGNUaW1lem9uZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgdXRjVGltZXpvbmUoKSB7XG4gICAgaWYgKCF0aGlzLiN1dGNUaW1lem9uZSkge1xuICAgICAgdGhpcy4jdXRjVGltZXpvbmUgPSBUaW1lem9uZS5mcm9tRGF0YSh7XG4gICAgICAgIHR6aWQ6IFwiVVRDXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jdXRjVGltZXpvbmU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIGxvY2FsIHRpbWV6b25lXG4gICAqIEB0eXBlIHtUaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljICNsb2NhbFRpbWV6b25lID0gbnVsbDtcbiAgc3RhdGljIGdldCBsb2NhbFRpbWV6b25lKCkge1xuICAgIGlmICghdGhpcy4jbG9jYWxUaW1lem9uZSkge1xuICAgICAgdGhpcy4jbG9jYWxUaW1lem9uZSA9IFRpbWV6b25lLmZyb21EYXRhKHtcbiAgICAgICAgdHppZDogXCJmbG9hdGluZ1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2xvY2FsVGltZXpvbmU7XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IGEgdGltZXpvbmUgY2hhbmdlIG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZSAgICAgVGhlIHRpbWV6b25lIGNoYW5nZSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgKi9cbiAgc3RhdGljIGFkanVzdF9jaGFuZ2UoY2hhbmdlLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgIHJldHVybiBUaW1lLnByb3RvdHlwZS5hZGp1c3QuY2FsbChcbiAgICAgIGNoYW5nZSxcbiAgICAgIGRheXMsXG4gICAgICBob3VycyxcbiAgICAgIG1pbnV0ZXMsXG4gICAgICBzZWNvbmRzLFxuICAgICAgY2hhbmdlXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBfbWluaW11bUV4cGFuc2lvblllYXIgPSAtMTtcbiAgc3RhdGljIEVYVFJBX0NPVkVSQUdFID0gNTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWV6b25lIGluc3RhbmNlLCBieSBwYXNzaW5nIGluIGEgdHppZCBhbmQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudHxPYmplY3R9IGRhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8Q29tcG9uZW50fSBkYXRhLmNvbXBvbmVudFxuICAgKiAgICAgICAgSWYgZGF0YSBpcyBhIHNpbXBsZSBvYmplY3QsIHRoZW4gdGhpcyBtZW1iZXIgY2FuIGJlIHNldCB0byBlaXRoZXIgYVxuICAgKiAgICAgICAgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudCBkYXRhLCBvciBhbiBhbHJlYWR5IHBhcnNlZFxuICAgKiAgICAgICAgSUNBTC5Db21wb25lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudHppZCAgICAgIFRoZSB0aW1lem9uZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmxvY2F0aW9uICBUaGUgdGltZXpvbmUgbG9jYXRpb253XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR6bmFtZXMgICBBbiBhbHRlcm5hdGl2ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB0aGlzLmZyb21EYXRhKGRhdGEpO1xuICB9XG5cblxuICAvKipcbiAgICogVGltZXpvbmUgaWRlbnRpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdHppZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIFRpbWV6b25lIGxvY2F0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBsb2NhdGlvbiA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEFsdGVybmF0aXZlIHRpbWV6b25lIG5hbWUsIGZvciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICB0em5hbWVzID0gXCJcIjtcblxuICAvKipcbiAgICogVGhlIHByaW1hcnkgbGF0aXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGxhdGl0dWRlID0gMC4wO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJpbWFyeSBsb25naXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGxvbmdpdHVkZSA9IDAuMDtcblxuICAvKipcbiAgICogVGhlIHZ0aW1lem9uZSBjb21wb25lbnQgZm9yIHRoaXMgdGltZXpvbmUuXG4gICAqIEB0eXBlIHtDb21wb25lbnR9XG4gICAqL1xuICBjb21wb25lbnQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgeWVhciB0aGlzIHRpbWV6b25lIGhhcyBiZWVuIGV4cGFuZGVkIHRvLiBBbGwgdGltZXpvbmUgdHJhbnNpdGlvblxuICAgKiBkYXRlcyB1bnRpbCB0aGlzIHllYXIgYXJlIGtub3duIGFuZCBjYW4gYmUgdXNlZCBmb3IgY2FsY3VsYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGV4cGFuZGVkVW50aWxZZWFyID0gMDtcblxuICAvKipcbiAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcImljYWx0aW1lem9uZVwiXG4gICAqL1xuICBpY2FsY2xhc3MgPSBcImljYWx0aW1lem9uZVwiO1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfENvbXBvbmVudH0gYURhdGEuY29tcG9uZW50XG4gICAqICAgICAgICBJZiBhRGF0YSBpcyBhIHNpbXBsZSBvYmplY3QsIHRoZW4gdGhpcyBtZW1iZXIgY2FuIGJlIHNldCB0byBlaXRoZXIgYVxuICAgKiAgICAgICAgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudCBkYXRhLCBvciBhbiBhbHJlYWR5IHBhcnNlZFxuICAgKiAgICAgICAgSUNBTC5Db21wb25lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLnR6bmFtZXMgICBBbiBhbHRlcm5hdGl2ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqL1xuICBmcm9tRGF0YShhRGF0YSkge1xuICAgIHRoaXMuZXhwYW5kZWRVbnRpbFllYXIgPSAwO1xuICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuXG4gICAgaWYgKGFEYXRhIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICAvLyBFaXRoZXIgYSBjb21wb25lbnQgaXMgcGFzc2VkIGRpcmVjdGx5XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgaW4gdGhlIGRhdGEgb2JqZWN0XG4gICAgICBpZiAoYURhdGEgJiYgXCJjb21wb25lbnRcIiBpbiBhRGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGFEYXRhLmNvbXBvbmVudCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy8gSWYgYSBzdHJpbmcgd2FzIHBhc3NlZCwgcGFyc2UgaXQgYXMgYSBjb21wb25lbnRcbiAgICAgICAgICBsZXQgakNhbCA9IHBhcnNlKGFEYXRhLmNvbXBvbmVudCk7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KGpDYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKGFEYXRhLmNvbXBvbmVudCBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgIC8vIElmIGl0IHdhcyBhIGNvbXBvbmVudCBhbHJlYWR5LCB0aGVuIGp1c3Qgc2V0IGl0XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YS5jb21wb25lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgbnVsbCBvdXQgdGhlIGNvbXBvbmVudFxuICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHJlbWFpbmluZyBwYXNzZWQgcHJvcGVydGllc1xuICAgICAgZm9yIChsZXQgcHJvcCBvZiBPUFRJT05TKSB7XG4gICAgICAgIGlmIChhRGF0YSAmJiBwcm9wIGluIGFEYXRhKSB7XG4gICAgICAgICAgdGhpc1twcm9wXSA9IGFEYXRhW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvbmVudCBidXQgbm8gVFpJRCwgYXR0ZW1wdCB0byBnZXQgaXQgZnJvbSB0aGVcbiAgICAvLyBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgIGlmICh0aGlzLmNvbXBvbmVudCBpbnN0YW5jZW9mIENvbXBvbmVudCAmJiAhdGhpcy50emlkKSB7XG4gICAgICB0aGlzLnR6aWQgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgdXRjT2Zmc2V0IHRoZSBnaXZlbiB0aW1lIHdvdWxkIG9jY3VyIGluIHRoaXMgdGltZXpvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZX0gdHQgICAgICAgICBUaGUgdGltZSB0byBjaGVjayBmb3JcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIHV0YyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgKi9cbiAgdXRjT2Zmc2V0KHR0KSB7XG4gICAgaWYgKHRoaXMgPT0gVGltZXpvbmUudXRjVGltZXpvbmUgfHwgdGhpcyA9PSBUaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9lbnN1cmVDb3ZlcmFnZSh0dC55ZWFyKTtcblxuICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgbGV0IHR0X2NoYW5nZSA9IHtcbiAgICAgIHllYXI6IHR0LnllYXIsXG4gICAgICBtb250aDogdHQubW9udGgsXG4gICAgICBkYXk6IHR0LmRheSxcbiAgICAgIGhvdXI6IHR0LmhvdXIsXG4gICAgICBtaW51dGU6IHR0Lm1pbnV0ZSxcbiAgICAgIHNlY29uZDogdHQuc2Vjb25kXG4gICAgfTtcblxuICAgIGxldCBjaGFuZ2VfbnVtID0gdGhpcy5fZmluZE5lYXJieUNoYW5nZSh0dF9jaGFuZ2UpO1xuICAgIGxldCBjaGFuZ2VfbnVtX3RvX3VzZSA9IC0xO1xuICAgIGxldCBzdGVwID0gMTtcblxuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBiaW4gc2VhcmNoP1xuICAgIGZvciAoOzspIHtcbiAgICAgIGxldCBjaGFuZ2UgPSBjbG9uZSh0aGlzLmNoYW5nZXNbY2hhbmdlX251bV0sIHRydWUpO1xuICAgICAgaWYgKGNoYW5nZS51dGNPZmZzZXQgPCBjaGFuZ2UucHJldlV0Y09mZnNldCkge1xuICAgICAgICBUaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgY2hhbmdlLnV0Y09mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBjbXAgPSBUaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4odHRfY2hhbmdlLCBjaGFuZ2UpO1xuXG4gICAgICBpZiAoY21wID49IDApIHtcbiAgICAgICAgY2hhbmdlX251bV90b191c2UgPSBjaGFuZ2VfbnVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCA9PSAtMSAmJiBjaGFuZ2VfbnVtX3RvX3VzZSAhPSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2hhbmdlX251bSArPSBzdGVwO1xuXG4gICAgICBpZiAoY2hhbmdlX251bSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VfbnVtID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHpvbmVfY2hhbmdlID0gdGhpcy5jaGFuZ2VzW2NoYW5nZV9udW1fdG9fdXNlXTtcbiAgICBsZXQgdXRjT2Zmc2V0X2NoYW5nZSA9IHpvbmVfY2hhbmdlLnV0Y09mZnNldCAtIHpvbmVfY2hhbmdlLnByZXZVdGNPZmZzZXQ7XG5cbiAgICBpZiAodXRjT2Zmc2V0X2NoYW5nZSA8IDAgJiYgY2hhbmdlX251bV90b191c2UgPiAwKSB7XG4gICAgICBsZXQgdG1wX2NoYW5nZSA9IGNsb25lKHpvbmVfY2hhbmdlLCB0cnVlKTtcbiAgICAgIFRpbWV6b25lLmFkanVzdF9jaGFuZ2UodG1wX2NoYW5nZSwgMCwgMCwgMCwgdG1wX2NoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcblxuICAgICAgaWYgKFRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbih0dF9jaGFuZ2UsIHRtcF9jaGFuZ2UpIDwgMCkge1xuICAgICAgICBsZXQgcHJldl96b25lX2NoYW5nZSA9IHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtX3RvX3VzZSAtIDFdO1xuXG4gICAgICAgIGxldCB3YW50X2RheWxpZ2h0ID0gZmFsc2U7IC8vIFRPRE9cblxuICAgICAgICBpZiAoem9uZV9jaGFuZ2UuaXNfZGF5bGlnaHQgIT0gd2FudF9kYXlsaWdodCAmJlxuICAgICAgICAgICAgcHJldl96b25lX2NoYW5nZS5pc19kYXlsaWdodCA9PSB3YW50X2RheWxpZ2h0KSB7XG4gICAgICAgICAgem9uZV9jaGFuZ2UgPSBwcmV2X3pvbmVfY2hhbmdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyByZXR1cm4gaXNfZGF5bGlnaHQ/XG4gICAgcmV0dXJuIHpvbmVfY2hhbmdlLnV0Y09mZnNldDtcbiAgfVxuXG4gIF9maW5kTmVhcmJ5Q2hhbmdlKGNoYW5nZSkge1xuICAgIC8vIGZpbmQgdGhlIGNsb3Nlc3QgbWF0Y2hcbiAgICBsZXQgaWR4ID0gYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgdGhpcy5jaGFuZ2VzLFxuICAgICAgY2hhbmdlLFxuICAgICAgVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuXG4gICAgKTtcblxuICAgIGlmIChpZHggPj0gdGhpcy5jaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICBfZW5zdXJlQ292ZXJhZ2UoYVllYXIpIHtcbiAgICBpZiAoVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID09IC0xKSB7XG4gICAgICBsZXQgdG9kYXkgPSBUaW1lLm5vdygpO1xuICAgICAgVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID0gdG9kYXkueWVhcjtcbiAgICB9XG5cbiAgICBsZXQgY2hhbmdlc0VuZFllYXIgPSBhWWVhcjtcbiAgICBpZiAoY2hhbmdlc0VuZFllYXIgPCBUaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIpIHtcbiAgICAgIGNoYW5nZXNFbmRZZWFyID0gVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyO1xuICAgIH1cblxuICAgIGNoYW5nZXNFbmRZZWFyICs9IFRpbWV6b25lLkVYVFJBX0NPVkVSQUdFO1xuXG4gICAgaWYgKCF0aGlzLmNoYW5nZXMubGVuZ3RoIHx8IHRoaXMuZXhwYW5kZWRVbnRpbFllYXIgPCBhWWVhcikge1xuICAgICAgbGV0IHN1YmNvbXBzID0gdGhpcy5jb21wb25lbnQuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgICAgbGV0IGNvbXBMZW4gPSBzdWJjb21wcy5sZW5ndGg7XG4gICAgICBsZXQgY29tcElkeCA9IDA7XG5cbiAgICAgIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZENvbXBvbmVudChcbiAgICAgICAgICBzdWJjb21wc1tjb21wSWR4XSwgY2hhbmdlc0VuZFllYXIsIHRoaXMuY2hhbmdlc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoYW5nZXMuc29ydChUaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4pO1xuICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IGNoYW5nZXNFbmRZZWFyO1xuICAgIH1cbiAgfVxuXG4gIF9leHBhbmRDb21wb25lbnQoYUNvbXBvbmVudCwgYVllYXIsIGNoYW5nZXMpIHtcbiAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJkdHN0YXJ0XCIpIHx8XG4gICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXR0b1wiKSB8fFxuICAgICAgICAhYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInR6b2Zmc2V0ZnJvbVwiKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGR0c3RhcnQgPSBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJkdHN0YXJ0XCIpLmdldEZpcnN0VmFsdWUoKTtcbiAgICBsZXQgY2hhbmdlO1xuXG4gICAgZnVuY3Rpb24gY29udmVydF90em9mZnNldChvZmZzZXQpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuZmFjdG9yICogKG9mZnNldC5ob3VycyAqIDM2MDAgKyBvZmZzZXQubWludXRlcyAqIDYwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0X2NoYW5nZXMoKSB7XG4gICAgICBsZXQgY2hhbmdlYmFzZSA9IHt9O1xuICAgICAgY2hhbmdlYmFzZS5pc19kYXlsaWdodCA9IChhQ29tcG9uZW50Lm5hbWUgPT0gXCJkYXlsaWdodFwiKTtcbiAgICAgIGNoYW5nZWJhc2UudXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwidHpvZmZzZXR0b1wiKS5nZXRGaXJzdFZhbHVlKClcbiAgICAgICk7XG5cbiAgICAgIGNoYW5nZWJhc2UucHJldlV0Y09mZnNldCA9IGNvbnZlcnRfdHpvZmZzZXQoXG4gICAgICAgIGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInR6b2Zmc2V0ZnJvbVwiKS5nZXRGaXJzdFZhbHVlKClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBjaGFuZ2ViYXNlO1xuICAgIH1cblxuICAgIGlmICghYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJydWxlXCIpICYmICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwicmRhdGVcIikpIHtcbiAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuICAgICAgY2hhbmdlLnllYXIgPSBkdHN0YXJ0LnllYXI7XG4gICAgICBjaGFuZ2UubW9udGggPSBkdHN0YXJ0Lm1vbnRoO1xuICAgICAgY2hhbmdlLmRheSA9IGR0c3RhcnQuZGF5O1xuICAgICAgY2hhbmdlLmhvdXIgPSBkdHN0YXJ0LmhvdXI7XG4gICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgIFRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLCAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwcm9wcyA9IGFDb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcyhcInJkYXRlXCIpO1xuICAgICAgZm9yIChsZXQgcmRhdGUgb2YgcHJvcHMpIHtcbiAgICAgICAgbGV0IHRpbWUgPSByZGF0ZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgIGNoYW5nZS55ZWFyID0gdGltZS55ZWFyO1xuICAgICAgICBjaGFuZ2UubW9udGggPSB0aW1lLm1vbnRoO1xuICAgICAgICBjaGFuZ2UuZGF5ID0gdGltZS5kYXk7XG5cbiAgICAgICAgaWYgKHRpbWUuaXNEYXRlKSB7XG4gICAgICAgICAgY2hhbmdlLmhvdXIgPSBkdHN0YXJ0LmhvdXI7XG4gICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSBkdHN0YXJ0LnNlY29uZDtcblxuICAgICAgICAgIGlmIChkdHN0YXJ0LnpvbmUgIT0gVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgIFRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLCAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2UuaG91ciA9IHRpbWUuaG91cjtcbiAgICAgICAgICBjaGFuZ2UubWludXRlID0gdGltZS5taW51dGU7XG4gICAgICAgICAgY2hhbmdlLnNlY29uZCA9IHRpbWUuc2Vjb25kO1xuXG4gICAgICAgICAgaWYgKHRpbWUuem9uZSAhPSBUaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBycnVsZSA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInJydWxlXCIpO1xuXG4gICAgICBpZiAocnJ1bGUpIHtcbiAgICAgICAgcnJ1bGUgPSBycnVsZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgIGlmIChycnVsZS51bnRpbCAmJiBycnVsZS51bnRpbC56b25lID09IFRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgcnJ1bGUudW50aWwuYWRqdXN0KDAsIDAsIDAsIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICBycnVsZS51bnRpbC56b25lID0gVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVyYXRvciA9IHJydWxlLml0ZXJhdG9yKGR0c3RhcnQpO1xuXG4gICAgICAgIGxldCBvY2M7XG4gICAgICAgIHdoaWxlICgob2NjID0gaXRlcmF0b3IubmV4dCgpKSkge1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuICAgICAgICAgIGlmIChvY2MueWVhciA+IGFZZWFyIHx8ICFvY2MpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZS55ZWFyID0gb2NjLnllYXI7XG4gICAgICAgICAgY2hhbmdlLm1vbnRoID0gb2NjLm1vbnRoO1xuICAgICAgICAgIGNoYW5nZS5kYXkgPSBvY2MuZGF5O1xuICAgICAgICAgIGNoYW5nZS5ob3VyID0gb2NjLmhvdXI7XG4gICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IG9jYy5taW51dGU7XG4gICAgICAgICAgY2hhbmdlLnNlY29uZCA9IG9jYy5zZWNvbmQ7XG4gICAgICAgICAgY2hhbmdlLmlzRGF0ZSA9IG9jYy5pc0RhdGU7XG5cbiAgICAgICAgICBUaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgLWNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0aW1lem9uZS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICh0aGlzLnR6bmFtZXMgPyB0aGlzLnR6bmFtZXMgOiB0aGlzLnR6aWQpO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG5sZXQgem9uZXMgPSBudWxsO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNpbmdsZXRvbiBjbGFzcyB0byBjb250YWluIHRpbWV6b25lcy4gIFJpZ2h0IG5vdyBpdCBpcyBhbGwgbWFudWFsIHJlZ2lzdHJ5IGluXG4gKiB0aGUgZnV0dXJlIHdlIG1heSB1c2UgdGhpcyBjbGFzcyB0byBkb3dubG9hZCB0aW1lem9uZSBpbmZvcm1hdGlvbiBvciBoYW5kbGVcbiAqIGxvYWRpbmcgcHJlLWV4cGFuZGVkIHRpbWV6b25lcy5cbiAqXG4gKiBAZXhwb3J0cyBtb2R1bGU6SUNBTC5UaW1lem9uZVNlcnZpY2VcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNvbnN0IFRpbWV6b25lU2VydmljZSA9IHtcbiAgZ2V0IGNvdW50KCkge1xuICAgIGlmICh6b25lcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHpvbmVzKS5sZW5ndGg7XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHpvbmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgdXRjID0gVGltZXpvbmUudXRjVGltZXpvbmU7XG5cbiAgICB6b25lcy5aID0gdXRjO1xuICAgIHpvbmVzLlVUQyA9IHV0YztcbiAgICB6b25lcy5HTVQgPSB1dGM7XG4gIH0sXG4gIF9oYXJkX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB6b25lcyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aW1lem9uZSBpZCBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgRmFsc2UsIHdoZW4gbm90IHByZXNlbnRcbiAgICovXG4gIGhhczogZnVuY3Rpb24odHppZCkge1xuICAgIGlmICh6b25lcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIXpvbmVzW3R6aWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGltZXpvbmUgYnkgaXRzIHR6aWQgaWYgcHJlc2VudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgICAgICAgICAgICBUaW1lem9uZSBpZGVudGlmaWVyIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpXG4gICAqIEByZXR1cm4ge1RpbWV6b25lIHwgdW5kZWZpbmVkfSAgICAgVGhlIHRpbWV6b25lLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHR6aWQpIHtcbiAgICBpZiAoem9uZXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gem9uZXNbdHppZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHRpbWV6b25lIG9iamVjdCBvciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fFRpbWV6b25lfSB0aW1lem9uZVxuICAgKiAgICAgICAgVGhlIGluaXRpYWxpemVkIHpvbmUgb3IgdnRpbWV6b25lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSB0aW1lem9uZS4gRGVmYXVsdHMgdG8gdGhlIGNvbXBvbmVudCdzIFRaSUQgaWYgbm90XG4gICAqICAgICAgICBwYXNzZWQuXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24odGltZXpvbmUsIG5hbWUpIHtcbiAgICBpZiAoem9uZXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGF2b2lkcyBhIGJyZWFraW5nIGNoYW5nZSBieSB0aGUgY2hhbmdlIG9mIGFyZ3VtZW50IG9yZGVyXG4gICAgLy8gVE9ETyByZW1vdmUgaW4gdjNcbiAgICBpZiAodHlwZW9mIHRpbWV6b25lID09PSBcInN0cmluZ1wiICYmIG5hbWUgaW5zdGFuY2VvZiBUaW1lem9uZSkge1xuICAgICAgW3RpbWV6b25lLCBuYW1lXSA9IFtuYW1lLCB0aW1lem9uZV07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBpZiAodGltZXpvbmUgaW5zdGFuY2VvZiBUaW1lem9uZSkge1xuICAgICAgICBuYW1lID0gdGltZXpvbmUudHppZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aW1lem9uZS5uYW1lID09PSAndnRpbWV6b25lJykge1xuICAgICAgICAgIHRpbWV6b25lID0gbmV3IFRpbWV6b25lKHRpbWV6b25lKTtcbiAgICAgICAgICBuYW1lID0gdGltZXpvbmUudHppZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5laXRoZXIgYSB0aW1lem9uZSBub3IgYSBuYW1lIHdhcyBwYXNzZWRcIik7XG4gICAgfVxuXG4gICAgaWYgKHRpbWV6b25lIGluc3RhbmNlb2YgVGltZXpvbmUpIHtcbiAgICAgIHpvbmVzW25hbWVdID0gdGltZXpvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RpbWV6b25lIG11c3QgYmUgSUNBTC5UaW1lem9uZSBvciBJQ0FMLkNvbXBvbmVudCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0emlkICAgICBUaW1lem9uZSBpZGVudGlmaWVyIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpXG4gICAqIEByZXR1cm4gez9UaW1lem9uZX0gICAgICBUaGUgcmVtb3ZlZCB0aW1lem9uZSwgb3IgbnVsbCBpZiBub3QgcmVnaXN0ZXJlZFxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbih0emlkKSB7XG4gICAgaWYgKHpvbmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gKGRlbGV0ZSB6b25lc1t0emlkXSk7XG4gIH1cbn07XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcyB3aXRoaW4gaWNhbC5qc1xuICogQG1vZHVsZSBJQ0FMLmhlbHBlcnNcbiAqL1xuXG4vKipcbiAqIENvbXBpbGVzIGEgbGlzdCBvZiBhbGwgcmVmZXJlbmNlZCBUWklEcyBpbiBhbGwgc3ViY29tcG9uZW50cyBhbmRcbiAqIHJlbW92ZXMgYW55IGV4dHJhIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzLiBJbiBhZGRpdGlvbiwgaWYgYW55IFRaSURzXG4gKiBhcmUgcmVmZXJlbmNlZCBieSBhIGNvbXBvbmVudCwgYnV0IGEgVlRJTUVaT05FIGRvZXMgbm90IGV4aXN0LFxuICogYW4gYXR0ZW1wdCB3aWxsIGJlIG1hZGUgdG8gZ2VuZXJhdGUgYSBWVElNRVpPTkUgdXNpbmcgSUNBTC5UaW1lem9uZVNlcnZpY2UuXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IHZjYWwgICAgIFRoZSB0b3AtbGV2ZWwgVkNBTEVOREFSIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge0NvbXBvbmVudH0gICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiB1cGRhdGVUaW1lem9uZXModmNhbCkge1xuICBsZXQgYWxsc3VicywgcHJvcGVydGllcywgdnRpbWV6b25lcywgcmVxVHppZCwgaTtcblxuICBpZiAoIXZjYWwgfHwgdmNhbC5uYW1lICE9PSBcInZjYWxlbmRhclwiKSB7XG4gICAgLy9ub3QgYSB0b3AtbGV2ZWwgdmNhbGVuZGFyIGNvbXBvbmVudFxuICAgIHJldHVybiB2Y2FsO1xuICB9XG5cbiAgLy9TdG9yZSB2dGltZXpvbmUgc3ViY29tcG9uZW50cyBpbiBhbiBvYmplY3QgcmVmZXJlbmNlIGJ5IHR6aWQuXG4gIC8vU3RvcmUgcHJvcGVydGllcyBmcm9tIGV2ZXJ5dGhpbmcgZWxzZSBpbiBhbm90aGVyIGFycmF5XG4gIGFsbHN1YnMgPSB2Y2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgcHJvcGVydGllcyA9IFtdO1xuICB2dGltZXpvbmVzID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCBhbGxzdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFsbHN1YnNbaV0ubmFtZSA9PT0gXCJ2dGltZXpvbmVcIikge1xuICAgICAgbGV0IHR6aWQgPSBhbGxzdWJzW2ldLmdldEZpcnN0UHJvcGVydHkoXCJ0emlkXCIpLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgIHZ0aW1lem9uZXNbdHppZF0gPSBhbGxzdWJzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jb25jYXQoYWxsc3Vic1tpXS5nZXRBbGxQcm9wZXJ0aWVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vY3JlYXRlIGFuIG9iamVjdCB3aXRoIG9uZSBlbnRyeSBmb3IgZWFjaCByZXF1aXJlZCB0elxuICByZXFUemlkID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHR6aWQgPSBwcm9wZXJ0aWVzW2ldLmdldFBhcmFtZXRlcihcInR6aWRcIik7XG4gICAgaWYgKHR6aWQpIHtcbiAgICAgIHJlcVR6aWRbdHppZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vZGVsZXRlIGFueSB2dGltZXpvbmVzIHRoYXQgYXJlIG5vdCBvbiB0aGUgcmVxVHppZCBsaXN0LlxuICBmb3IgKGxldCBbdHppZCwgY29tcF0gb2YgT2JqZWN0LmVudHJpZXModnRpbWV6b25lcykpIHtcbiAgICBpZiAoIXJlcVR6aWRbdHppZF0pIHtcbiAgICAgIHZjYWwucmVtb3ZlU3ViY29tcG9uZW50KGNvbXApO1xuICAgIH1cbiAgfVxuXG4gIC8vY3JlYXRlIGFueSBtaXNzaW5nLCBidXQgcmVnaXN0ZXJlZCB0aW1lem9uZXNcbiAgZm9yIChsZXQgdHppZCBvZiBPYmplY3Qua2V5cyhyZXFUemlkKSkge1xuICAgIGlmICghdnRpbWV6b25lc1t0emlkXSAmJiBUaW1lem9uZVNlcnZpY2UuaGFzKHR6aWQpKSB7XG4gICAgICB2Y2FsLmFkZFN1YmNvbXBvbmVudChUaW1lem9uZVNlcnZpY2UuZ2V0KHR6aWQpLmNvbXBvbmVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZjYWw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB0eXBlIGlzIG9mIHRoZSBudW1iZXIgdHlwZSBhbmQgYWxzbyBOYU4uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAgICAgVGhlIG51bWJlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgVHJ1ZSwgaWYgdGhlIG51bWJlciBpcyBzdHJpY3RseSBOYU5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RseU5hTihudW1iZXIpIHtcbiAgcmV0dXJuIHR5cGVvZihudW1iZXIpID09PSAnbnVtYmVyJyAmJiBpc05hTihudW1iZXIpO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIsIHdoZW4gdGhlIHZhbGlkIGlzXG4gKiBub3QgYW4gaW50ZWdlciB0aHJvd3MgYSBkZWNvcmF0aW9uIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFJhdyBzdHJpbmcgaW5wdXRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFBhcnNlZCBpbnRlZ2VyXG4gKi9cbmZ1bmN0aW9uIHN0cmljdFBhcnNlSW50KHN0cmluZykge1xuICBsZXQgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG5cbiAgaWYgKGlzU3RyaWN0bHlOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDb3VsZCBub3QgZXh0cmFjdCBpbnRlZ2VyIGZyb20gXCInICsgc3RyaW5nICsgJ1wiJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgb3IgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlIG9mIGEgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBpbml0aWFsaXphdGlvblxuICogZGF0YSBpZiB0aGUgZGF0YSBpcyBub3QgYWxyZWFkeSBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKC4uLik7XG4gKiB2YXIgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh0aW1lLCBJQ0FMLlRpbWUpO1xuICpcbiAqIChyZXN1bHQgaW5zdGFuY2VvZiBJQ0FMLlRpbWUpXG4gKiAvLyA9PiB0cnVlXG4gKlxuICogcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh7fSwgSUNBTC5UaW1lKTtcbiAqIChyZXN1bHQgaXNudGFuY2VvZiBJQ0FMLlRpbWUpXG4gKiAvLyA9PiB0cnVlXG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgIG9iamVjdCBpbml0aWFsaXphdGlvbiBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZSAgICAgICBvYmplY3QgdHlwZSAobGlrZSBJQ0FMLlRpbWUpXG4gKiBAcmV0dXJuIHs/fSAgICAgICAgICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgZm91bmQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0Q2xhc3NUeXBlKGRhdGEsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIG5ldyB0eXBlKGRhdGEpO1xufVxuXG4vKipcbiAqIElkZW50aWNhbCB0byBpbmRleE9mIGJ1dCB3aWxsIG9ubHkgbWF0Y2ggdmFsdWVzIHdoZW4gdGhleSBhcmUgbm90IHByZWNlZGVkXG4gKiBieSBhIGJhY2tzbGFzaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgIFN0cmluZyB0byBzZWFyY2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2ggICAgICAgICBWYWx1ZSB0byBsb29rIGZvclxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyAgICAgICAgICAgIFN0YXJ0IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIHBvc2l0aW9uLCBvciAtMSBpZiBub3QgZm91bmRcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGVkSW5kZXhPZihidWZmZXIsIHNlYXJjaCwgcG9zKSB7XG4gIHdoaWxlICgocG9zID0gYnVmZmVyLmluZGV4T2Yoc2VhcmNoLCBwb3MpKSAhPT0gLTEpIHtcbiAgICBpZiAocG9zID4gMCAmJiBidWZmZXJbcG9zIC0gMV0gPT09ICdcXFxcJykge1xuICAgICAgcG9zICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBpbmRleCBmb3IgaW5zZXJ0aW9uIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCAgICAgICAgICAgIFRoZSBsaXN0IHRvIHNlYXJjaFxuICogQHBhcmFtIHs/fSBzZWVrVmFsICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBpbnNlcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oPyw/KX0gY21wZnVuYyBUaGUgY29tcGFyaXNvbiBmdW5jLCB0aGF0IGNhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSB0d28gc2Vla1ZhbHNcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICBUaGUgaW5zZXJ0IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGJpbnNlYXJjaEluc2VydChsaXN0LCBzZWVrVmFsLCBjbXBmdW5jKSB7XG4gIGlmICghbGlzdC5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG5cbiAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBsaXN0Lmxlbmd0aCAtIDEsXG4gICAgICBtaWQsIGNtcHZhbDtcblxuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgIGNtcHZhbCA9IGNtcGZ1bmMoc2Vla1ZhbCwgbGlzdFttaWRdKTtcblxuICAgIGlmIChjbXB2YWwgPCAwKVxuICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgZWxzZSBpZiAoY21wdmFsID4gMClcbiAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgZWxzZVxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAoY21wdmFsIDwgMClcbiAgICByZXR1cm4gbWlkOyAvLyBpbnNlcnRpb24gaXMgZGlzcGxhY2luZywgc28gdXNlIG1pZCBvdXRyaWdodC5cbiAgZWxzZSBpZiAoY21wdmFsID4gMClcbiAgICByZXR1cm4gbWlkICsgMTtcbiAgZWxzZVxuICAgIHJldHVybiBtaWQ7XG59XG5cbi8qKlxuICogQ2xvbmUgdGhlIHBhc3NlZCBvYmplY3Qgb3IgcHJpbWl0aXZlLiBCeSBkZWZhdWx0IGEgc2hhbGxvdyBjbG9uZSB3aWxsIGJlXG4gKiBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGFTcmMgICAgICAgICAgICBUaGUgdGhpbmcgdG8gY2xvbmVcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEZWVwICAgIElmIHRydWUsIGEgZGVlcCBjbG9uZSB3aWxsIGJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgVGhlIGNvcHkgb2YgdGhlIHRoaW5nXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGFTcmMsIGFEZWVwKSB7XG4gIGlmICghYVNyYyB8fCB0eXBlb2YgYVNyYyAhPSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGFTcmM7XG4gIH0gZWxzZSBpZiAoYVNyYyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYVNyYy5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKFwiY2xvbmVcIiBpbiBhU3JjKSB7XG4gICAgcmV0dXJuIGFTcmMuY2xvbmUoKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFTcmMpKSB7XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYVNyYy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyLnB1c2goYURlZXAgPyBjbG9uZShhU3JjW2ldLCB0cnVlKSA6IGFTcmNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2Uge1xuICAgIGxldCBvYmogPSB7fTtcbiAgICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFTcmMpKSB7XG4gICAgICBpZiAoYURlZXApIHtcbiAgICAgICAgb2JqW25hbWVdID0gY2xvbmUodmFsdWUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBpQ2FsZW5kYXIgbGluZSBmb2xkaW5nLiBBIGxpbmUgZW5kaW5nIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBhbmRcbiAqIHRoZSBuZXh0IGxpbmUgYmVnaW5zIHdpdGggYSB3aGl0ZXNwYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBTVU1NQVJZOlRoaXMgbGluZSB3aWxsIGJlIGZvbGRcbiAqICBlZCByaWdodCBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYUxpbmUgICAgICBUaGUgbGluZSB0byBmb2xkXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZm9sZGVkIGxpbmVcbiAqL1xuZnVuY3Rpb24gZm9sZGxpbmUoYUxpbmUpIHtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBsaW5lID0gYUxpbmUgfHwgXCJcIiwgcG9zID0gMCwgbGluZV9sZW5ndGggPSAwO1xuICAvL3BvcyBjb3VudHMgcG9zaXRpb24gaW4gbGluZSBmb3IgdGhlIFVURi0xNiBwcmVzZW50YXRpb25cbiAgLy9saW5lX2xlbmd0aCBjb3VudHMgdGhlIGJ5dGVzIGZvciB0aGUgVVRGLTggcHJlc2VudGF0aW9uXG4gIHdoaWxlIChsaW5lLmxlbmd0aCkge1xuICAgIGxldCBjcCA9IGxpbmUuY29kZVBvaW50QXQocG9zKTtcbiAgICBpZiAoY3AgPCAxMjgpICsrbGluZV9sZW5ndGg7XG4gICAgZWxzZSBpZiAoY3AgPCAyMDQ4KSBsaW5lX2xlbmd0aCArPSAyOy8vbmVlZHMgMiBVVEYtOCBieXRlc1xuICAgIGVsc2UgaWYgKGNwIDwgNjU1MzYpIGxpbmVfbGVuZ3RoICs9IDM7XG4gICAgZWxzZSBsaW5lX2xlbmd0aCArPSA0OyAvL2NwIGlzIGxlc3MgdGhhbiAxMTE0MTEyXG4gICAgaWYgKGxpbmVfbGVuZ3RoIDwgSUNBTG1vZHVsZS5mb2xkTGVuZ3RoICsgMSlcbiAgICAgIHBvcyArPSBjcCA+IDY1NTM1ID8gMiA6IDE7XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgKz0gSUNBTG1vZHVsZS5uZXdMaW5lQ2hhciArIFwiIFwiICsgbGluZS5zbGljZSgwLCBNYXRoLm1heCgwLCBwb3MpKTtcbiAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIHBvcykpO1xuICAgICAgcG9zID0gbGluZV9sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0LnNsaWNlKElDQUxtb2R1bGUubmV3TGluZUNoYXIubGVuZ3RoICsgMSk7XG59XG5cbi8qKlxuICogUGFkcyB0aGUgZ2l2ZW4gc3RyaW5nIG9yIG51bWJlciB3aXRoIHplcm9zIHNvIGl0IHdpbGwgaGF2ZSBhdCBsZWFzdCB0d29cbiAqIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBkYXRhICAgIFRoZSBzdHJpbmcgb3IgbnVtYmVyIHRvIHBhZFxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgIFRoZSBudW1iZXIgcGFkZGVkIGFzIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHBhZDIoZGF0YSkge1xuICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGhhbmRsZSBmcmFjdGlvbnMuXG4gICAgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGRhdGEgPSBwYXJzZUludChkYXRhKTtcbiAgICB9XG4gICAgZGF0YSA9IFN0cmluZyhkYXRhKTtcbiAgfVxuXG4gIGxldCBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAnMDAnO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAnMCcgKyBkYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIFRydW5jYXRlcyB0aGUgZ2l2ZW4gbnVtYmVyLCBjb3JyZWN0bHkgaGFuZGxpbmcgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyICAgICBUaGUgbnVtYmVyIHRvIHRydW5jYXRlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgdHJ1bmNhdGVkIG51bWJlclxuICovXG5mdW5jdGlvbiB0cnVuYyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcikpO1xufVxuXG4vKipcbiAqIFBvb3ItbWFuJ3MgY3Jvc3MtYnJvd3NlciBvYmplY3QgZXh0ZW5zaW9uLiBEb2Vzbid0IHN1cHBvcnQgYWxsIHRoZVxuICogZmVhdHVyZXMsIGJ1dCBlbm91Z2ggZm9yIG91ciB1c2FnZS4gTm90ZSB0aGF0IHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGFyZVxuICogbm90IG92ZXJ3cml0dGVuIHdpdGggdGhlIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgY2hpbGQgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKHBhcmVudCwge1xuICogICBcImJhclwiOiAxMjNcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgICAgIFRoZSBvYmplY3QgdG8gZXh0ZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0ICAgICBUaGUgb2JqZWN0IHRvIGV4dGVuZCB3aXRoXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBSZXR1cm5zIHRoZSB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChzb3VyY2UsIHRhcmdldCkge1xuICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgbGV0IGRlc2NyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgaWYgKGRlc2NyICYmICFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBoZWxwZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHVwZGF0ZVRpbWV6b25lczogdXBkYXRlVGltZXpvbmVzLFxuICBpc1N0cmljdGx5TmFOOiBpc1N0cmljdGx5TmFOLFxuICBzdHJpY3RQYXJzZUludDogc3RyaWN0UGFyc2VJbnQsXG4gIGZvcm1hdENsYXNzVHlwZTogZm9ybWF0Q2xhc3NUeXBlLFxuICB1bmVzY2FwZWRJbmRleE9mOiB1bmVzY2FwZWRJbmRleE9mLFxuICBiaW5zZWFyY2hJbnNlcnQ6IGJpbnNlYXJjaEluc2VydCxcbiAgY2xvbmU6IGNsb25lLFxuICBmb2xkbGluZTogZm9sZGxpbmUsXG4gIHBhZDI6IHBhZDIsXG4gIHRydW5jOiB0cnVuYyxcbiAgZXh0ZW5kOiBleHRlbmRcbn0pO1xuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIFwidXRjLW9mZnNldFwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvbiBhbmQgbWFuaXB1bGF0aW9uXG4gKiBtZXRob2RzLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIFV0Y09mZnNldCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlV0Y09mZnNldH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn0gICAgICAgICBUaGUgY3JlYXRlZCB1dGMtb2Zmc2V0IGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhhU3RyaW5nKSB7XG4gICAgLy8gLTA1OjAwXG4gICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAvL1RPRE86IHN1cHBvcnQgc2Vjb25kcyBwZXIgcmZjNTU0NSA/XG4gICAgb3B0aW9ucy5mYWN0b3IgPSAoYVN0cmluZ1swXSA9PT0gJysnKSA/IDEgOiAtMTtcbiAgICBvcHRpb25zLmhvdXJzID0gc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zbGljZSgxLCAzKSk7XG4gICAgb3B0aW9ucy5taW51dGVzID0gc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zbGljZSg0LCA2KSk7XG5cbiAgICByZXR1cm4gbmV3IFV0Y09mZnNldChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlV0Y09mZnNldH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHNlY29uZHNcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgICBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gY29udmVydFxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgbGV0IGluc3RhbmNlID0gbmV3IFV0Y09mZnNldCgpO1xuICAgIGluc3RhbmNlLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlV0Y09mZnNldCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VycyAgIFRoZSBob3VycyBmb3IgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzIFRoZSBtaW51dGVzIGluIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFEYXRhKSB7XG4gICAgdGhpcy5mcm9tRGF0YShhRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGhvdXJzIGluIHRoZSB1dGMtb2Zmc2V0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBob3VycyA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBtaW51dGVzIGluIHRoZSB1dGMtb2Zmc2V0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBtaW51dGVzID0gMDtcblxuICAvKipcbiAgICogVGhlIHNpZ24gb2YgdGhlIHV0YyBvZmZzZXQsIDEgZm9yIHBvc2l0aXZlIG9mZnNldCwgLTEgZm9yIG5lZ2F0aXZlXG4gICAqIG9mZnNldHMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBmYWN0b3IgPSAxO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwidXRjLW9mZnNldFwiXG4gICAqL1xuICBpY2FsdHlwZSA9IFwidXRjLW9mZnNldFwiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHV0YyBvZmZzZXQgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtVdGNPZmZzZXR9ICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIFV0Y09mZnNldC5mcm9tU2Vjb25kcyh0aGlzLnRvU2Vjb25kcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgVGhlIGhvdXJzIGZvciB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZXMgVGhlIG1pbnV0ZXMgaW4gdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5mYWN0b3IgIFRoZSBmYWN0b3IgZm9yIHRoZSB1dGMtb2Zmc2V0LCBlaXRoZXIgLTEgb3IgMVxuICAgKi9cbiAgZnJvbURhdGEoYURhdGEpIHtcbiAgICBpZiAoYURhdGEpIHtcbiAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhRGF0YSkpIHtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX25vcm1hbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc2Vjb25kcyB2YWx1ZS4gVGhlIHNlY29uZHNcbiAgICogdmFsdWUgaXMgdHJ1bmNhdGVkIHRvIHRoZSBtaW51dGUuIE9mZnNldHMgYXJlIHdyYXBwZWQgd2hlbiB0aGUgd29ybGRcbiAgICogZW5kcywgdGhlIGhvdXIgYWZ0ZXIgVVRDKzE0OjAwIGlzIFVUQy0xMjowMC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgICAgVGhlIHNlY29uZHMgdG8gY29udmVydCBpbnRvIGFuIG9mZnNldFxuICAgKi9cbiAgZnJvbVNlY29uZHMoYVNlY29uZHMpIHtcbiAgICBsZXQgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgIHRoaXMuZmFjdG9yID0gYVNlY29uZHMgPCAwID8gLTEgOiAxO1xuICAgIHRoaXMuaG91cnMgPSB0cnVuYyhzZWNzIC8gMzYwMCk7XG5cbiAgICBzZWNzIC09ICh0aGlzLmhvdXJzICogMzYwMCk7XG4gICAgdGhpcy5taW51dGVzID0gdHJ1bmMoc2VjcyAvIDYwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBjdXJyZW50IG9mZnNldCB0byBhIHZhbHVlIGluIHNlY29uZHNcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIG9mZnNldCBpbiBzZWNvbmRzXG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yICogKDYwICogdGhpcy5taW51dGVzICsgMzYwMCAqIHRoaXMuaG91cnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdGhpcyB1dGMgb2Zmc2V0IHdpdGggYW5vdGhlciBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VXRjT2Zmc2V0fSBvdGhlciAgICAgICAgICAgICBUaGUgb3RoZXIgb2Zmc2V0IHRvIGNvbXBhcmUgd2l0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAqL1xuICBjb21wYXJlKG90aGVyKSB7XG4gICAgbGV0IGEgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgIGxldCBiID0gb3RoZXIudG9TZWNvbmRzKCk7XG4gICAgcmV0dXJuIChhID4gYikgLSAoYiA+IGEpO1xuICB9XG5cbiAgX25vcm1hbGl6ZSgpIHtcbiAgICAvLyBSYW5nZTogOTcyMDAgc2Vjb25kcyAod2l0aCAxIGhvdXIgaW5iZXR3ZWVuKVxuICAgIGxldCBzZWNzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICBsZXQgZmFjdG9yID0gdGhpcy5mYWN0b3I7XG4gICAgd2hpbGUgKHNlY3MgPCAtNDMyMDApIHsgLy8gPSBVVEMtMTI6MDBcbiAgICAgIHNlY3MgKz0gOTcyMDA7XG4gICAgfVxuICAgIHdoaWxlIChzZWNzID4gNTA0MDApIHsgLy8gPSBVVEMrMTQ6MDBcbiAgICAgIHNlY3MgLT0gOTcyMDA7XG4gICAgfVxuXG4gICAgdGhpcy5mcm9tU2Vjb25kcyhzZWNzKTtcblxuICAgIC8vIEF2b2lkIGNoYW5naW5nIHRoZSBmYWN0b3Igd2hlbiBvbiB6ZXJvIHNlY29uZHNcbiAgICBpZiAoc2VjcyA9PSAwKSB7XG4gICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlDYWxlbmRhciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB1dGMtb2Zmc2V0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b0lDQUxTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlc2lnbiQxLmljYWxlbmRhci52YWx1ZVsndXRjLW9mZnNldCddLnRvSUNBTCh0aGlzLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB1dGMtb2Zmc2V0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmFjdG9yID09IDEgPyBcIitcIiA6IFwiLVwiKSArIHBhZDIodGhpcy5ob3VycykgKyAnOicgKyBwYWQyKHRoaXMubWludXRlcyk7XG4gIH1cbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogRGVzY3JpYmVzIGEgdkNhcmQgdGltZSwgd2hpY2ggaGFzIHNsaWdodCBkaWZmZXJlbmNlcyB0byB0aGUgSUNBTC5UaW1lLlxuICogUHJvcGVydGllcyBjYW4gYmUgbnVsbCBpZiBub3Qgc3BlY2lmaWVkLCBmb3IgZXhhbXBsZSBmb3IgZGF0ZXMgd2l0aFxuICogcmVkdWNlZCBhY2N1cmFjeSBvciB0cnVuY2F0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBjdXJyZW50bHkgbm90IGFsbCBtZXRob2RzIGFyZSBjb3JyZWN0bHkgcmUtaW1wbGVtZW50ZWQgZm9yXG4gKiBWQ2FyZFRpbWUuIEZvciBleGFtcGxlLCBjb21wYXJpc29uIHdpbGwgaGF2ZSB1bmRlZmluZWQgcmVzdWx0cyB3aGVuIHNvbWVcbiAqIG1lbWJlcnMgYXJlIG51bGwuXG4gKlxuICogQWxzbywgbm9ybWFsaXphdGlvbiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIGNsYXNzIVxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKiBAZXh0ZW5kcyB7SUNBTC5UaW1lfVxuICovXG5jbGFzcyBWQ2FyZFRpbWUgZXh0ZW5kcyBUaW1lIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5WQ2FyZFRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUgYW5kL29yIHRpbWUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhSWNhbFR5cGUgIFRoZSB0eXBlIGZvciB0aGlzIGluc3RhbmNlLCBlLmcuIGRhdGUtYW5kLW9yLXRpbWVcbiAgICogQHJldHVybiB7VkNhcmRUaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgYUljYWxUeXBlKSB7XG4gICAgZnVuY3Rpb24gcGFydCh2LCBzLCBlKSB7XG4gICAgICByZXR1cm4gdiA/IHN0cmljdFBhcnNlSW50KHYuc2xpY2UocywgcyArIGUpKSA6IG51bGw7XG4gICAgfVxuICAgIGxldCBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgIGxldCBkdCA9IHBhcnRzWzBdLCB0bXogPSBwYXJ0c1sxXTtcbiAgICBsZXQgc3BsaXR6b25lID0gdG16ID8gZGVzaWduJDEudmNhcmQudmFsdWUudGltZS5fc3BsaXRab25lKHRteikgOiBbXTtcbiAgICBsZXQgem9uZSA9IHNwbGl0em9uZVswXSwgdG0gPSBzcGxpdHpvbmVbMV07XG5cbiAgICBsZXQgZHRsZW4gPSBkdCA/IGR0Lmxlbmd0aCA6IDA7XG4gICAgbGV0IHRtbGVuID0gdG0gPyB0bS5sZW5ndGggOiAwO1xuXG4gICAgbGV0IGhhc0Rhc2hEYXRlID0gZHQgJiYgZHRbMF0gPT0gJy0nICYmIGR0WzFdID09ICctJztcbiAgICBsZXQgaGFzRGFzaFRpbWUgPSB0bSAmJiB0bVswXSA9PSAnLSc7XG5cbiAgICBsZXQgbyA9IHtcbiAgICAgIHllYXI6IGhhc0Rhc2hEYXRlID8gbnVsbCA6IHBhcnQoZHQsIDAsIDQpLFxuICAgICAgbW9udGg6IGhhc0Rhc2hEYXRlICYmIChkdGxlbiA9PSA0IHx8IGR0bGVuID09IDcpID8gcGFydChkdCwgMiwgMikgOiBkdGxlbiA9PSA3ID8gcGFydChkdCwgNSwgMikgOiBkdGxlbiA9PSAxMCA/IHBhcnQoZHQsIDUsIDIpIDogbnVsbCxcbiAgICAgIGRheTogZHRsZW4gPT0gNSA/IHBhcnQoZHQsIDMsIDIpIDogZHRsZW4gPT0gNyAmJiBoYXNEYXNoRGF0ZSA/IHBhcnQoZHQsIDUsIDIpIDogZHRsZW4gPT0gMTAgPyBwYXJ0KGR0LCA4LCAyKSA6IG51bGwsXG5cbiAgICAgIGhvdXI6IGhhc0Rhc2hUaW1lID8gbnVsbCA6IHBhcnQodG0sIDAsIDIpLFxuICAgICAgbWludXRlOiBoYXNEYXNoVGltZSAmJiB0bWxlbiA9PSAzID8gcGFydCh0bSwgMSwgMikgOiB0bWxlbiA+IDQgPyBoYXNEYXNoVGltZSA/IHBhcnQodG0sIDEsIDIpIDogcGFydCh0bSwgMywgMikgOiBudWxsLFxuICAgICAgc2Vjb25kOiB0bWxlbiA9PSA0ID8gcGFydCh0bSwgMiwgMikgOiB0bWxlbiA9PSA2ID8gcGFydCh0bSwgNCwgMikgOiB0bWxlbiA9PSA4ID8gcGFydCh0bSwgNiwgMikgOiBudWxsXG4gICAgfTtcblxuICAgIGlmICh6b25lID09ICdaJykge1xuICAgICAgem9uZSA9IFRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgIH0gZWxzZSBpZiAoem9uZSAmJiB6b25lWzNdID09ICc6Jykge1xuICAgICAgem9uZSA9IFV0Y09mZnNldC5mcm9tU3RyaW5nKHpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6b25lID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFZDYXJkVGltZShvLCB6b25lLCBhSWNhbFR5cGUpO1xuICB9XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlZDYXJkVGltZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF0YSBmb3IgdGhlIHRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgICAgICAgICAgICAgICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICAgICAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmRheSAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgICAgICAgICAgICAgICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICAgICAgICAgICAgICAgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5zZWNvbmQgICAgICAgICAgICAgICAgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7VGltZXpvbmV8VXRjT2Zmc2V0fSB6b25lICAgICAgICAgICAgICAgVGhlIHRpbWV6b25lIHRvIHVzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWNhbHR5cGUgICAgICAgICAgICAgICAgICAgICAgIFRoZSB0eXBlIGZvciB0aGlzIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEsIHpvbmUsIGljYWx0eXBlKSB7XG4gICAgc3VwZXIoZGF0YSwgem9uZSk7XG4gICAgdGhpcy5pY2FsdHlwZSA9IGljYWx0eXBlIHx8IFwiZGF0ZS1hbmQtb3ItdGltZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgXCJ2Y2FyZHRpbWVcIlxuICAgKi9cbiAgaWNhbGNsYXNzID0gXCJ2Y2FyZHRpbWVcIjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwiZGF0ZS1hbmQtb3ItdGltZVwiXG4gICAqL1xuICBpY2FsdHlwZSA9IFwiZGF0ZS1hbmQtb3ItdGltZVwiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHZjYXJkIGRhdGUvdGltZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1ZDYXJkVGltZX0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFZDYXJkVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUsIHRoaXMuaWNhbHR5cGUpO1xuICB9XG5cbiAgX25vcm1hbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgdXRjT2Zmc2V0KCkge1xuICAgIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBVdGNPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUudG9TZWNvbmRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBUaW1lLnByb3RvdHlwZS51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBSRkMgNjM1MCBjb21wbGlhbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICB2Y2FyZCBkYXRlL3RpbWUgc3RyaW5nXG4gICAqL1xuICB0b0lDQUxTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlc2lnbiQxLnZjYXJkLnZhbHVlW3RoaXMuaWNhbHR5cGVdLnRvSUNBTCh0aGlzLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYXJkIGZvcm1cbiAgICogKGluY2x1ZGluZyA6IGFuZCAtIHNlcGFyYXRvcnMpLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgeSA9IHRoaXMueWVhciwgbSA9IHRoaXMubW9udGgsIGQgPSB0aGlzLmRheTtcbiAgICBsZXQgaCA9IHRoaXMuaG91ciwgbW0gPSB0aGlzLm1pbnV0ZSwgcyA9IHRoaXMuc2Vjb25kO1xuXG4gICAgbGV0IGhhc1llYXIgPSB5ICE9PSBudWxsLCBoYXNNb250aCA9IG0gIT09IG51bGwsIGhhc0RheSA9IGQgIT09IG51bGw7XG4gICAgbGV0IGhhc0hvdXIgPSBoICE9PSBudWxsLCBoYXNNaW51dGUgPSBtbSAhPT0gbnVsbCwgaGFzU2Vjb25kID0gcyAhPT0gbnVsbDtcblxuICAgIGxldCBkYXRlcGFydCA9IChoYXNZZWFyID8gcGFkMih5KSArIChoYXNNb250aCB8fCBoYXNEYXkgPyAnLScgOiAnJykgOiAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0tJyA6ICcnKSkgK1xuICAgICAgICAgICAgICAgICAgIChoYXNNb250aCA/IHBhZDIobSkgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgIChoYXNEYXkgPyAnLScgKyBwYWQyKGQpIDogJycpO1xuICAgIGxldCB0aW1lcGFydCA9IChoYXNIb3VyID8gcGFkMihoKSA6ICctJykgKyAoaGFzSG91ciAmJiBoYXNNaW51dGUgPyAnOicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgPyBwYWQyKG1tKSA6ICcnKSArICghaGFzSG91ciAmJiAhaGFzTWludXRlID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAoaGFzTWludXRlICYmIGhhc1NlY29uZCA/ICc6JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgKGhhc1NlY29uZCA/IHBhZDIocykgOiAnJyk7XG5cbiAgICBsZXQgem9uZTtcbiAgICBpZiAodGhpcy56b25lID09PSBUaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgem9uZSA9ICdaJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIFV0Y09mZnNldCkge1xuICAgICAgem9uZSA9IHRoaXMuem9uZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy56b25lID09PSBUaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICB6b25lID0gJyc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBUaW1lem9uZSkge1xuICAgICAgbGV0IG9mZnNldCA9IFV0Y09mZnNldC5mcm9tU2Vjb25kcyh0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpKTtcbiAgICAgIHpvbmUgPSBvZmZzZXQudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgem9uZSA9ICcnO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5pY2FsdHlwZSkge1xuICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgcmV0dXJuIHRpbWVwYXJ0ICsgem9uZTtcbiAgICAgIGNhc2UgXCJkYXRlLWFuZC1vci10aW1lXCI6XG4gICAgICBjYXNlIFwiZGF0ZS10aW1lXCI6XG4gICAgICAgIHJldHVybiBkYXRlcGFydCArICh0aW1lcGFydCA9PSAnLS0nID8gJycgOiAnVCcgKyB0aW1lcGFydCArIHpvbmUpO1xuICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgcmV0dXJuIGRhdGVwYXJ0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGxldHMgdHlwZXNjcmlwdCByZXNvbHZlIG91ciBjdXN0b20gdHlwZXMgaW4gdGhlXG4gKiBnZW5lcmF0ZWQgZC50cyBmaWxlcyAoanNkb2MgdHlwZWRlZnMgYXJlIGNvbnZlcnRlZCB0byB0eXBlc2NyaXB0IHR5cGVzKS5cbiAqIElnbm9yZSBwcmV2ZW50cyB0aGUgdHlwZWRlZnMgZnJvbSBiZWluZyBkb2N1bWVudGVkIG1vcmUgdGhhbiBvbmNlLlxuICpcbiAqIEBpZ25vcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLndlZWtEYXl9IHdlZWtEYXlcbiAqIEltcG9ydHMgdGhlICd3ZWVrRGF5JyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIEFuIGl0ZXJhdG9yIGZvciBhIHNpbmdsZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgY2xhc3MgdXN1YWxseSBkb2Vzbid0IGhhdmUgdG8gYmUgaW5zdGFuY2lhdGVkXG4gKiBkaXJlY3RseSwgdGhlIGNvbnZlbmllbmNlIG1ldGhvZCB7QGxpbmsgSUNBTC5SZWN1ciNpdGVyYXRvcn0gY2FuIGJlIHVzZWQuXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgUmVjdXJJdGVyYXRvciB7XG4gIHN0YXRpYyBfaW5kZXhNYXAgPSB7XG4gICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgIFwiQllNSU5VVEVcIjogMSxcbiAgICBcIkJZSE9VUlwiOiAyLFxuICAgIFwiQllEQVlcIjogMyxcbiAgICBcIkJZTU9OVEhEQVlcIjogNCxcbiAgICBcIkJZWUVBUkRBWVwiOiA1LFxuICAgIFwiQllXRUVLTk9cIjogNixcbiAgICBcIkJZTU9OVEhcIjogNyxcbiAgICBcIkJZU0VUUE9TXCI6IDhcbiAgfTtcblxuICBzdGF0aWMgX2V4cGFuZE1hcCA9IHtcbiAgICBcIlNFQ09ORExZXCI6IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIk1JTlVURUxZXCI6IFsyLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIkhPVVJMWVwiOiBbMiwgMiwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJEQUlMWVwiOiBbMiwgMiwgMiwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJXRUVLTFlcIjogWzIsIDIsIDIsIDIsIDMsIDMsIDEsIDFdLFxuICAgIFwiTU9OVEhMWVwiOiBbMiwgMiwgMiwgMiwgMiwgMywgMywgMV0sXG4gICAgXCJZRUFSTFlcIjogWzIsIDIsIDIsIDIsIDIsIDIsIDIsIDJdXG4gIH07XG5cbiAgc3RhdGljIFVOS05PV04gPSAwO1xuICBzdGF0aWMgQ09OVFJBQ1QgPSAxO1xuICBzdGF0aWMgRVhQQU5EID0gMjtcbiAgc3RhdGljIElMTEVHQUwgPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuUmVjdXJJdGVyYXRvciBpbnN0YW5jZS4gVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVyc1xuICAgKiB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvbiBmcm9tIGEgcHJldmlvdXMgcnVuLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICBUaGUgaXRlcmF0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlY3VyfSBvcHRpb25zLnJ1bGUgICAgICAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge1RpbWV9IG9wdGlvbnMuZHRzdGFydCAgICAgICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IG9wdGlvbnMuaW5pdGlhbGl6ZWQgIFdoZW4gdHJ1ZSwgYXNzdW1lIHRoYXQgb3B0aW9ucyBhcmVcbiAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZpbmlzaGVkLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGNvbXBsZXRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgcnVsZSB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkXG4gICAqIEB0eXBlIHtSZWN1cn1cbiAgICovXG4gIHJ1bGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQgYmVpbmcgaXRlcmF0ZWQuXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKi9cbiAgZHRzdGFydCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IG9jY3VycmVuY2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGVcbiAgICoge0BsaW5rIFJlY3VySXRlcmF0b3IjbmV4dH0gbWV0aG9kLlxuICAgKiBAdHlwZSB7VGltZX1cbiAgICovXG4gIGxhc3QgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VxdWVuY2UgbnVtYmVyIGZyb20gdGhlIG9jY3VycmVuY2VcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIG9jY3VycmVuY2VfbnVtYmVyID0gMDtcblxuICAvKipcbiAgICogVGhlIGluZGljZXMgdXNlZCBmb3IgdGhlIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjYnlfZGF0YX0gb2JqZWN0LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnlfaW5kaWNlcyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZSBpdGVyYXRvciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGluaXRpYWxpemQgYnktZGF0YS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ5X2RhdGEgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwYW5kZWQgeWVhcmRheXNcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF5cyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBpbiB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNkYXlzfSBhcnJheS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRheXNfaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGl0ZXJhdG9yIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC4gVGhpc1xuICAgKiBtZXRob2QgaXMgdXN1YWxseSBub3QgY2FsbGVkIGRpcmVjdGx5LCB5b3UgY2FuIGluaXRpYWxpemUgdGhlIGl0ZXJhdG9yXG4gICAqIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICBUaGUgaXRlcmF0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlY3VyfSBvcHRpb25zLnJ1bGUgICAgICAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge1RpbWV9IG9wdGlvbnMuZHRzdGFydCAgICAgICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IG9wdGlvbnMuaW5pdGlhbGl6ZWQgIFdoZW4gdHJ1ZSwgYXNzdW1lIHRoYXQgb3B0aW9ucyBhcmVcbiAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAqL1xuICBmcm9tRGF0YShvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlID0gZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMucnVsZSwgUmVjdXIpO1xuXG4gICAgaWYgKCF0aGlzLnJ1bGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgcmVxdWlyZXMgYSAoSUNBTC5SZWN1cikgcnVsZScpO1xuICAgIH1cblxuICAgIHRoaXMuZHRzdGFydCA9IGZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIFRpbWUpO1xuXG4gICAgaWYgKCF0aGlzLmR0c3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgcmVxdWlyZXMgYSAoSUNBTC5UaW1lKSBkdHN0YXJ0Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYnlfZGF0YSkge1xuICAgICAgdGhpcy5ieV9kYXRhID0gb3B0aW9ucy5ieV9kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ5X2RhdGEgPSBjbG9uZSh0aGlzLnJ1bGUucGFydHMsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm9jY3VycmVuY2VfbnVtYmVyKVxuICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlciA9IG9wdGlvbnMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICB0aGlzLmRheXMgPSBvcHRpb25zLmRheXMgfHwgW107XG4gICAgaWYgKG9wdGlvbnMubGFzdCkge1xuICAgICAgdGhpcy5sYXN0ID0gZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMubGFzdCwgVGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ieV9pbmRpY2VzID0gb3B0aW9ucy5ieV9pbmRpY2VzO1xuXG4gICAgaWYgKCF0aGlzLmJ5X2luZGljZXMpIHtcbiAgICAgIHRoaXMuYnlfaW5kaWNlcyA9IHtcbiAgICAgICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgICAgICBcIkJZTUlOVVRFXCI6IDAsXG4gICAgICAgIFwiQllIT1VSXCI6IDAsXG4gICAgICAgIFwiQllEQVlcIjogMCxcbiAgICAgICAgXCJCWU1PTlRIXCI6IDAsXG4gICAgICAgIFwiQllXRUVLTk9cIjogMCxcbiAgICAgICAgXCJCWU1PTlRIREFZXCI6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdGlvbnMuaW5pdGlhbGl6ZWQgfHwgZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEludmFsaWRSZWN1cnJlbmNlUnVsZUVycm9yKSB7XG4gICAgICAgICAgLy8gSW5pdCBtYXkgZXJyb3IgaWYgdGhlcmUgYXJlIG5vIHBvc3NpYmxlIHJlY3VycmVuY2UgaW5zdGFuY2VzIGZyb21cbiAgICAgICAgICAvLyB0aGUgcnVsZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gYnViYmxlIHRoaXMgZXJyb3IgdXAuIEluc3RlYWQsIHdlXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IGl0ZXJhdG9yLlxuICAgICAgICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQcm9wYWdhdGUgb3RoZXIgZXJyb3JzIHRvIGNvbnN1bWVycy5cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGl0ZXJhdG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMubGFzdCA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgIGxldCBwYXJ0cyA9IHRoaXMuYnlfZGF0YTtcblxuICAgIGlmIChcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgIC8vIGxpYmljYWwgZG9lcyB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcnVsZSBpcyBsb2FkZWQsIGJ1dCB3ZSBwb3N0cG9uZSB0b1xuICAgICAgLy8gbm93IHNvIHdlIGNhbiBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgb3JkZXIuXG4gICAgICB0aGlzLnNvcnRfYnlkYXlfcnVsZXMocGFydHMuQllEQVkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBCWVlFQVJEQVkgYXBwYXJlcywgbm8gb3RoZXIgZGF0ZSBydWxlIHBhcnQgbWF5IGFwcGVhclxuICAgIGlmIChcIkJZWUVBUkRBWVwiIGluIHBhcnRzKSB7XG4gICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzIHx8XG4gICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgfHwgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQllZRUFSREFZIHJ1bGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQllXRUVLTk8gYW5kIEJZTU9OVEhEQVkgcnVsZSBwYXJ0cyBtYXkgbm90IGJvdGggYXBwZWFyXG4gICAgaWYgKFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllXRUVLTk8gZG9lcyBub3QgZml0IHRvIEJZTU9OVEhEQVlcIik7XG4gICAgfVxuXG4gICAgLy8gRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgKEZSRVE9TU9OVEhMWSkgbmVpdGhlciBCWVlFQVJEQVkgbm9yXG4gICAgLy8gQllXRUVLTk8gbWF5IGFwcGVhci5cbiAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIgJiZcbiAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWVlFQVJEQVkgbm9yIEJZV0VFS05PIG1heSBhcHBlYXJcIik7XG4gICAgfVxuXG4gICAgLy8gRm9yIFdFRUtMWSByZWN1cnJlbmNlcyAoRlJFUT1XRUVLTFkpIG5laXRoZXIgQllNT05USERBWSBub3JcbiAgICAvLyBCWVlFQVJEQVkgbWF5IGFwcGVhci5cbiAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJXRUVLTFlcIiAmJlxuICAgICAgICAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvciBXRUVLTFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWU1PTlRIREFZIG5vciBCWVlFQVJEQVkgbWF5IGFwcGVhclwiKTtcbiAgICB9XG5cbiAgICAvLyBCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1xuICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSBcIllFQVJMWVwiICYmIFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJZWUVBUkRBWSBtYXkgb25seSBhcHBlYXIgaW4gWUVBUkxZIHJ1bGVzXCIpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdC5zZWNvbmQgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCB0aGlzLmR0c3RhcnQuc2Vjb25kKTtcbiAgICB0aGlzLmxhc3QubWludXRlID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTUlOVVRFXCIsIFwiTUlOVVRFTFlcIiwgdGhpcy5kdHN0YXJ0Lm1pbnV0ZSk7XG4gICAgdGhpcy5sYXN0LmhvdXIgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIHRoaXMuZHRzdGFydC5ob3VyKTtcbiAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhEQVlcIiwgXCJEQUlMWVwiLCB0aGlzLmR0c3RhcnQuZGF5KTtcbiAgICB0aGlzLmxhc3QubW9udGggPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNT05USFwiLCBcIk1PTlRITFlcIiwgdGhpcy5kdHN0YXJ0Lm1vbnRoKTtcblxuICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiKSB7XG4gICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIGxldCBbLCBkb3ddID0gdGhpcy5ydWxlRGF5T2ZXZWVrKHBhcnRzLkJZREFZWzBdLCB0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgIGxldCB3a2R5ID0gZG93IC0gdGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgIGlmICgodGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCkgPCBkb3cgJiYgd2tkeSA+PSAwKSB8fCB3a2R5IDwgMCkge1xuICAgICAgICAgIC8vIEluaXRpYWwgdGltZSBpcyBhZnRlciBmaXJzdCBkYXkgb2YgQllEQVkgZGF0YVxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgKz0gd2tkeTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRheU5hbWUgPSBSZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMuZHRzdGFydC5kYXlPZldlZWsoKSk7XG4gICAgICAgIHBhcnRzLkJZREFZID0gW2RheU5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIllFQVJMWVwiKSB7XG4gICAgICAvLyBTb21lIHllYXJseSByZWN1cnJlbmNlIHJ1bGVzIG1heSBiZSBzcGVjaWZpYyBlbm91Z2ggdG8gbm90IGFjdHVhbGx5XG4gICAgICAvLyBvY2N1ciBvbiBhIHllYXJseSBiYXNpcywgZS5nLiB0aGUgMjl0aCBkYXkgb2YgRmVicnVhcnkgb3IgdGhlIGZpZnRoXG4gICAgICAvLyBNb25kYXkgb2YgYSBnaXZlbiBtb250aC4gVGhlIHN0YW5kYXJkIGlzbid0IGNsZWFyIG9uIHRoZSBpbnRlbmRlZFxuICAgICAgLy8gYmVoYXZpb3IgaW4gdGhlc2UgY2FzZXMsIGJ1dCBgbGliaWNhbGAgYXQgbGVhc3Qgd2lsbCBpdGVyYXRlIHVudGlsIGl0XG4gICAgICAvLyBmaW5kcyBhIG1hdGNoaW5nIHllYXIuXG4gICAgICAvLyBDQVJFRlVMOiBTb21lIHJ1bGVzIG1heSBzcGVjaWZ5IGFuIG9jY3VycmVuY2UgdGhhdCBjYW4gbmV2ZXIgaGFwcGVuLFxuICAgICAgLy8gZS5nLiB0aGUgZmlyc3QgTW9uZGF5IG9mIEFwcmlsIHNvIGxvbmcgYXMgaXQgZmFsbHMgb24gdGhlIDE1dGhcbiAgICAgIC8vIHRocm91Z2ggdGhlIDIxc3QuIERldGVjdGluZyB0aGVzZSBpcyBub24tdHJpdmlhbCwgc28gZW5zdXJlIHRoYXQgd2VcbiAgICAgIC8vIHN0b3AgaXRlcmF0aW5nIGF0IHNvbWUgcG9pbnQuXG4gICAgICBjb25zdCB1bnRpbFllYXIgPSB0aGlzLnJ1bGUudW50aWwgPyB0aGlzLnJ1bGUudW50aWwueWVhciA6IDIwMDAwO1xuICAgICAgd2hpbGUgKHRoaXMubGFzdC55ZWFyIDw9IHVudGlsWWVhcikge1xuICAgICAgICB0aGlzLmV4cGFuZF95ZWFyX2RheXModGhpcy5sYXN0LnllYXIpO1xuICAgICAgICBpZiAodGhpcy5kYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRheXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZWN1cnJlbmNlUnVsZUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX25leHRCeVllYXJEYXkoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIpIHtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgbGV0IHRlbXBMYXN0ID0gbnVsbDtcbiAgICAgICAgbGV0IGluaXRMYXN0ID0gdGhpcy5sYXN0LmNsb25lKCk7XG4gICAgICAgIGxldCBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgd2Vla2RheSBpbiBCWURBWSB3aXRoIHJlbGF0aXZlIGRvdyBhbmQgcG9zLlxuICAgICAgICBmb3IgKGxldCBieWRvdyBvZiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgICB0aGlzLmxhc3QgPSBpbml0TGFzdC5jbG9uZSgpO1xuICAgICAgICAgIGxldCBbcG9zLCBkb3ddID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGJ5ZG93KTtcbiAgICAgICAgICBsZXQgZGF5T2ZNb250aCA9IHRoaXMubGFzdC5udGhXZWVrRGF5KGRvdywgcG9zKTtcblxuICAgICAgICAgIC8vIElmIHxwb3N8ID49IDYsIHRoZSBieWRheSBpcyBpbnZhbGlkIGZvciBhIG1vbnRobHkgcnVsZS5cbiAgICAgICAgICBpZiAocG9zID49IDYgfHwgcG9zIDw9IC02KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIHBhcnRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgYSBCeWRheSB3aXRoIHBvcz0rLy01IGlzIG5vdCBpbiB0aGUgY3VycmVudCBtb250aCBpdFxuICAgICAgICAgIC8vIG11c3QgYmUgc2VhcmNoZWQgaW4gdGhlIG5leHQgbW9udGhzLlxuICAgICAgICAgIGlmIChkYXlPZk1vbnRoID4gZGF5c0luTW9udGggfHwgZGF5T2ZNb250aCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGlmIHdlIGhhdmUgYWxyZWFkeSBmb3VuZCBhIFwibGFzdFwiIGluIHRoaXMgbW9udGguXG4gICAgICAgICAgICBpZiAodGVtcExhc3QgJiYgdGVtcExhc3QubW9udGggPT0gaW5pdExhc3QubW9udGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZGF5T2ZNb250aCA+IGRheXNJbk1vbnRoIHx8IGRheU9mTW9udGggPD0gMCkge1xuICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICAgICAgICBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgICAgIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheU9mTW9udGg7XG4gICAgICAgICAgaWYgKCF0ZW1wTGFzdCB8fCB0aGlzLmxhc3QuY29tcGFyZSh0ZW1wTGFzdCkgPCAwKSB7XG4gICAgICAgICAgICB0ZW1wTGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3QgPSB0ZW1wTGFzdC5jbG9uZSgpO1xuXG4gICAgICAgIC8vWFhYOiBUaGlzIGZlZWxzIGxpa2UgYSBoYWNrLCBidXQgd2UgbmVlZCB0byBpbml0aWFsaXplXG4gICAgICAgIC8vICAgICB0aGUgQllNT05USERBWSBjYXNlIGNvcnJlY3RseSBhbmQgYnlEYXlBbmRNb250aERheSBoYW5kbGVzXG4gICAgICAgIC8vICAgICB0aGlzIGNhc2UuIEl0IGFjY2VwdHMgYSBzcGVjaWFsIGZsYWcgd2hpY2ggd2lsbCBhdm9pZCBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gICAgIHRoZSBpbml0aWFsIHZhbHVlIHdpdGhvdXQgdGhlIGZsYWcgZGF5cyB0aGF0IG1hdGNoIHRoZSBzdGFydCB0aW1lXG4gICAgICAgIC8vICAgICB3b3VsZCBiZSBtaXNzZWQuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWU1PTlRIREFZJykpIHtcbiAgICAgICAgICB0aGlzLl9ieURheUFuZE1vbnRoRGF5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPiBkYXlzSW5Nb250aCB8fCB0aGlzLmxhc3QuZGF5ID09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIHBhcnRcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBkYXkgdmFsdWUgc28gdGhhdCBub3JtYWxpc2F0aW9uIHdvbid0IGNoYW5nZSB0aGUgbW9udGguXG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuXG4gICAgICAgIC8vIEdldCBhIHNvcnRlZCBsaXN0IG9mIGRheXMgaW4gdGhlIHN0YXJ0aW5nIG1vbnRoIHRoYXQgbWF0Y2ggdGhlIHJ1bGUuXG4gICAgICAgIGxldCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMoXG4gICAgICAgICAgdGhpcy5sYXN0LnllYXIsXG4gICAgICAgICAgdGhpcy5sYXN0Lm1vbnRoLFxuICAgICAgICAgIHRoaXMucnVsZS5wYXJ0cy5CWU1PTlRIREFZXG4gICAgICAgICkuZmlsdGVyKGQgPT4gZCA+PSB0aGlzLmxhc3QuZGF5KTtcblxuICAgICAgICBpZiAobm9ybWFsaXplZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGVyZSdzIGF0IGxlYXN0IG9uZSB2YWxpZCBkYXksIHVzZSBpdC5cbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbm9ybWFsaXplZFswXTtcbiAgICAgICAgICB0aGlzLmJ5X2RhdGEuQllNT05USERBWSA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBubyBvY2N1cnJlbmNlIGluIHRoaXMgbW9udGgsIGZpbmQgdGhlIG5leHQgdmFsaWQgbW9udGguXG4gICAgICAgICAgLy8gVGhlIGxvbmdlc3QgcG9zc2libGUgc2VxdWVuY2Ugb2Ygc2tpcHBlZCBtb250aHMgaXMgRmVicnVhcnktQXByaWwtSnVuZSxcbiAgICAgICAgICAvLyBzbyB3ZSBtaWdodCBuZWVkIHRvIGNhbGwgbmV4dF9tb250aCB1cCB0byB0aHJlZSB0aW1lcy5cbiAgICAgICAgICBpZiAoIXRoaXMubmV4dF9tb250aCgpICYmICF0aGlzLm5leHRfbW9udGgoKSAmJiAhdGhpcy5uZXh0X21vbnRoKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHBvc3NpYmxlIG9jY3VycmVuY2VzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgKiBAcmV0dXJuIHtUaW1lfVxuICAgKi9cbiAgbmV4dChhZ2FpbiA9IGZhbHNlKSB7XG4gICAgbGV0IGJlZm9yZSA9ICh0aGlzLmxhc3QgPyB0aGlzLmxhc3QuY2xvbmUoKSA6IG51bGwpO1xuXG4gICAgaWYgKCh0aGlzLnJ1bGUuY291bnQgJiYgdGhpcy5vY2N1cnJlbmNlX251bWJlciA+PSB0aGlzLnJ1bGUuY291bnQpIHx8XG4gICAgICAgICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29tcGxldGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vY2N1cnJlbmNlX251bWJlciA9PSAwICYmIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPj0gMCkge1xuICAgICAgLy8gRmlyc3Qgb2YgYWxsLCBnaXZlIHRoZSBpbnN0YW5jZSB0aGF0IHdhcyBpbml0aWFsaXplZFxuICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICB9XG5cbiAgICBsZXQgdmFsaWQ7XG4gICAgZG8ge1xuICAgICAgdmFsaWQgPSAxO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMucnVsZS5mcmVxKSB7XG4gICAgICBjYXNlIFwiU0VDT05ETFlcIjpcbiAgICAgICAgdGhpcy5uZXh0X3NlY29uZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJNSU5VVEVMWVwiOlxuICAgICAgICB0aGlzLm5leHRfbWludXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhPVVJMWVwiOlxuICAgICAgICB0aGlzLm5leHRfaG91cigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJEQUlMWVwiOlxuICAgICAgICB0aGlzLm5leHRfZGF5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIldFRUtMWVwiOlxuICAgICAgICB0aGlzLm5leHRfd2VlaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJNT05USExZXCI6XG4gICAgICAgIHZhbGlkID0gdGhpcy5uZXh0X21vbnRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIllFQVJMWVwiOlxuICAgICAgICB0aGlzLm5leHRfeWVhcigpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXRoaXMuY2hlY2tfY29udHJhY3RpbmdfcnVsZXMoKSB8fFxuICAgICAgICAgICAgIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPCAwIHx8XG4gICAgICAgICAgICAgIXZhbGlkKTtcblxuICAgIGlmICh0aGlzLmxhc3QuY29tcGFyZShiZWZvcmUpID09IDApIHtcbiAgICAgIGlmIChhZ2Fpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTYW1lIG9jY3VycmVuY2UgZm91bmQgdHdpY2UsIHByb3RlY3RpbmcgeW91IGZyb20gZGVhdGggYnkgcmVjdXJzaW9uXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApIHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9jY3VycmVuY2VfbnVtYmVyKys7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgIH1cbiAgfVxuXG4gIG5leHRfc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLm5leHRfZ2VuZXJpYyhcIkJZU0VDT05EXCIsIFwiU0VDT05ETFlcIiwgXCJzZWNvbmRcIiwgXCJtaW51dGVcIik7XG4gIH1cblxuICBpbmNyZW1lbnRfc2Vjb25kKGluYykge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJzZWNvbmRcIiwgNjAsIFwibWludXRlXCIpO1xuICB9XG5cbiAgbmV4dF9taW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllNSU5VVEVcIiwgXCJNSU5VVEVMWVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZVwiLCBcImhvdXJcIiwgXCJuZXh0X3NlY29uZFwiKTtcbiAgfVxuXG4gIGluY3JlbWVudF9taW51dGUoaW5jKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50X2dlbmVyaWMoaW5jLCBcIm1pbnV0ZVwiLCA2MCwgXCJob3VyXCIpO1xuICB9XG5cbiAgbmV4dF9ob3VyKCkge1xuICAgIHJldHVybiB0aGlzLm5leHRfZ2VuZXJpYyhcIkJZSE9VUlwiLCBcIkhPVVJMWVwiLCBcImhvdXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtb250aGRheVwiLCBcIm5leHRfbWludXRlXCIpO1xuICB9XG5cbiAgaW5jcmVtZW50X2hvdXIoaW5jKSB7XG4gICAgdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwiaG91clwiLCAyNCwgXCJtb250aGRheVwiKTtcbiAgfVxuXG4gIG5leHRfZGF5KCkge1xuICAgIGxldCB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gXCJEQUlMWVwiKTtcblxuICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoZGF5KHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoZGF5KDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgbmV4dF93ZWVrKCkge1xuICAgIGxldCBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICBpZiAodGhpcy5uZXh0X3dlZWtkYXlfYnlfd2VlaygpID09IDApIHtcbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZV0VFS05PXCIpKSB7XG4gICAgICB0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8rKztcblxuICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTyA9PSB0aGlzLmJ5X2RhdGEuQllXRUVLTk8ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTyA9IDA7XG4gICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gSEFDSyBzaG91bGQgYmUgZmlyc3QgbW9udGggb2YgdGhlIHllYXJcbiAgICAgIHRoaXMubGFzdC5tb250aCA9IDE7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcblxuICAgICAgbGV0IHdlZWtfbm8gPSB0aGlzLmJ5X2RhdGEuQllXRUVLTk9bdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PXTtcblxuICAgICAgdGhpcy5sYXN0LmRheSArPSA3ICogd2Vla19ubztcblxuICAgICAgaWYgKGVuZF9vZl9kYXRhKSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEp1bXAgdG8gdGhlIG5leHQgd2Vla1xuICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoNyAqIHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBlYWNoIGJ5IGRheSBydWxlIGZvciBhIGdpdmVuIHllYXIvbW9udGguXG4gICAqIFRha2VzIGludG8gYWNjb3VudCBvcmRlcmluZyBhbmQgbmVnYXRpdmUgcnVsZXNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICBDdXJyZW50IHllYXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aCAgICAgICAgQ3VycmVudCBtb250aC5cbiAgICogQHBhcmFtIHtBcnJheX0gIHJ1bGVzICAgICAgICBBcnJheSBvZiBydWxlcy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBhbmQgbm9ybWFsaXplZCBydWxlcy5cbiAgICogICAgICAgICAgICAgICAgIE5lZ2F0aXZlIHJ1bGVzIHdpbGwgYmUgZXhwYW5kZWQgdG8gdGhlaXJcbiAgICogICAgICAgICAgICAgICAgIGNvcnJlY3QgcG9zaXRpdmUgdmFsdWVzIGZvciBlYXNpZXIgcHJvY2Vzc2luZy5cbiAgICovXG4gIG5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyh5ZWFyLCBtb250aCwgcnVsZXMpIHtcbiAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcblxuICAgIC8vIFhYWDogVGhpcyBpcyBwcm9iYWJseSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGFsbG9jYXRlXG4gICAgLy8gICAgICBhIG5ldyBhcnJheSBmb3IgZWFjaCBtb250aCB3ZSBzY2FuLCBpZiBwb3NzaWJsZVxuICAgIC8vICAgICAgd2Ugc2hvdWxkIHRyeSB0byBvcHRpbWl6ZSB0aGlzLi4uXG4gICAgbGV0IG5ld1J1bGVzID0gW107XG5cbiAgICBsZXQgcnVsZUlkeCA9IDA7XG4gICAgbGV0IGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICBsZXQgcnVsZTtcblxuICAgIGZvciAoOyBydWxlSWR4IDwgbGVuOyBydWxlSWR4KyspIHtcbiAgICAgIHJ1bGUgPSBwYXJzZUludChydWxlc1tydWxlSWR4XSwgMTApO1xuICAgICAgaWYgKGlzTmFOKHJ1bGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBCWU1PTlRIREFZIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoaXMgcnVsZSBmYWxscyBvdXRzaWRlIG9mIGdpdmVuXG4gICAgICAvLyBtb250aCBkaXNjYXJkIGl0LlxuICAgICAgaWYgKE1hdGguYWJzKHJ1bGUpID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG5lZ2F0aXZlIGNhc2VcbiAgICAgIGlmIChydWxlIDwgMCkge1xuICAgICAgICAvLyB3ZSBhZGQgKG5vdCBzdWJ0cmFjdCBpdCBpcyBhIG5lZ2F0aXZlIG51bWJlcilcbiAgICAgICAgLy8gb25lIGZyb20gdGhlIHJ1bGUgYmVjYXVzZSAxID09PSBsYXN0IGRheSBvZiBtb250aFxuICAgICAgICBydWxlID0gZGF5c0luTW9udGggKyAocnVsZSArIDEpO1xuICAgICAgfSBlbHNlIGlmIChydWxlID09PSAwKSB7XG4gICAgICAgIC8vIHNraXAgemVybzogaXQgaXMgaW52YWxpZC5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgYWRkIHVuaXF1ZSBpdGVtcy4uLlxuICAgICAgaWYgKG5ld1J1bGVzLmluZGV4T2YocnVsZSkgPT09IC0xKSB7XG4gICAgICAgIG5ld1J1bGVzLnB1c2gocnVsZSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB1bmlxdWUgYW5kIHNvcnRcbiAgICByZXR1cm4gbmV3UnVsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gIH1cblxuICAvKipcbiAgICogTk9URVM6XG4gICAqIFdlIGFyZSBnaXZlbiBhIGxpc3Qgb2YgZGF0ZXMgaW4gdGhlIG1vbnRoIChCWU1PTlRIREFZKSAoMjMsIGV0Yy4uKVxuICAgKiBBbHNvIHdlIGFyZSBnaXZlbiBhIGxpc3Qgb2YgZGF5cyAoQllEQVkpIChNTywgMlNVLCBldGMuLikgd2hlblxuICAgKiBib3RoIGNvbmRpdGlvbnMgbWF0Y2ggYSBnaXZlbiBkYXRlICh0aGlzLmxhc3QuZGF5KSBpdGVyYXRpb24gc3RvcHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGlzSW5pdCAgICAgV2hlbiBnaXZlbiB0cnVlIHdpbGwgbm90IGluY3JlbWVudCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgZGF5ICh0aGlzLmxhc3QpLlxuICAgKi9cbiAgX2J5RGF5QW5kTW9udGhEYXkoaXNJbml0KSB7XG4gICAgbGV0IGJ5TW9udGhEYXk7IC8vIHNldHVwIGluIGluaXRNb250aFxuICAgIGxldCBieURheSA9IHRoaXMuYnlfZGF0YS5CWURBWTtcblxuICAgIGxldCBkYXRlO1xuICAgIGxldCBkYXRlSWR4ID0gMDtcbiAgICBsZXQgZGF0ZUxlbjsgLy8gc2V0dXAgaW4gaW5pdE1vbnRoXG4gICAgbGV0IGRheUxlbiA9IGJ5RGF5Lmxlbmd0aDtcblxuICAgIC8vIHdlIGFyZSBub3QgdmFsaWQgYnkgZGVmYXVsdFxuICAgIGxldCBkYXRhSXNWYWxpZCA9IDA7XG5cbiAgICBsZXQgZGF5c0luTW9udGg7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIC8vIHdlIG5lZWQgYSBjb3B5IG9mIHRoaXMsIGJlY2F1c2UgYSBEYXRlVGltZSBnZXRzIG5vcm1hbGl6ZWRcbiAgICAvLyBhdXRvbWF0aWNhbGx5IGlmIHRoZSBkYXkgaXMgb3V0IG9mIHJhbmdlLiBBdCBzb21lIHBvaW50cyB3ZVxuICAgIC8vIHNldCB0aGUgbGFzdCBkYXkgdG8gMCB0byBzdGFydCBjb3VudGluZy5cbiAgICBsZXQgbGFzdERheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICBmdW5jdGlvbiBpbml0TW9udGgoKSB7XG4gICAgICBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgoXG4gICAgICAgIHNlbGYubGFzdC5tb250aCwgc2VsZi5sYXN0LnllYXJcbiAgICAgICk7XG5cbiAgICAgIGJ5TW9udGhEYXkgPSBzZWxmLm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyhcbiAgICAgICAgc2VsZi5sYXN0LnllYXIsXG4gICAgICAgIHNlbGYubGFzdC5tb250aCxcbiAgICAgICAgc2VsZi5ieV9kYXRhLkJZTU9OVEhEQVlcbiAgICAgICk7XG5cbiAgICAgIGRhdGVMZW4gPSBieU1vbnRoRGF5Lmxlbmd0aDtcblxuICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIG1vcmUgdGhhbiBvbmUgb2NjdXJyZW5jZSBpbiBvbmUgbW9udGhcbiAgICAgIC8vIHdlIGhhdmUgdG8gYmUgc3VyZSB0byBzdGFydCBzZWFyY2hpbmcgYWZ0ZXIgdGhlIGxhc3RcbiAgICAgIC8vIGZvdW5kIGRhdGUgb3IgYXQgdGhlIGxhc3QgQllNT05USERBWSwgdW5sZXNzIHdlIGFyZVxuICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSBpdGVyYXRvciBiZWNhdXNlIGluIHRoaXMgY2FzZSB3ZSBoYXZlXG4gICAgICAvLyB0byBjb25zaWRlciB0aGUgbGFzdCBmb3VuZCBkYXRlIHRvby5cbiAgICAgIHdoaWxlIChieU1vbnRoRGF5W2RhdGVJZHhdIDw9IGxhc3REYXkgJiZcbiAgICAgICAgICAgICAhKGlzSW5pdCAmJiBieU1vbnRoRGF5W2RhdGVJZHhdID09IGxhc3REYXkpICYmXG4gICAgICAgICAgICAgZGF0ZUlkeCA8IGRhdGVMZW4gLSAxKSB7XG4gICAgICAgIGRhdGVJZHgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0TW9udGgoKSB7XG4gICAgICAvLyBzaW5jZSB0aGUgZGF5IGlzIGluY3JlbWVudGVkIGF0IHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIGxvb3AgYmVsb3csIHdlIG5lZWQgdG8gc3RhcnQgYXQgMFxuICAgICAgbGFzdERheSA9IDA7XG4gICAgICBzZWxmLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgZGF0ZUlkeCA9IDA7XG4gICAgICBpbml0TW9udGgoKTtcbiAgICB9XG5cbiAgICBpbml0TW9udGgoKTtcblxuICAgIC8vIHNob3VsZCBjb21lIGFmdGVyIGluaXRNb250aFxuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIGxhc3REYXkgLT0gMTtcbiAgICB9XG5cbiAgICAvLyBVc2UgYSBjb3VudGVyIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3Agd2l0aCBtYWxmb3JtZWQgcnVsZXMuXG4gICAgLy8gU3RvcCBjaGVja2luZyBhZnRlciA0IHllYXJzIHNvIHdlIGNvbnNpZGVyIGFsc28gYSBsZWFwIHllYXIuXG4gICAgbGV0IG1vbnRoc0NvdW50ZXIgPSA0ODtcblxuICAgIHdoaWxlICghZGF0YUlzVmFsaWQgJiYgbW9udGhzQ291bnRlcikge1xuICAgICAgbW9udGhzQ291bnRlci0tO1xuICAgICAgLy8gaW5jcmVtZW50IHRoZSBjdXJyZW50IGRhdGUuIFRoaXMgaXMgcmVhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgb3RoZXJ3aXNlIHdlIG1heSBmYWxsIGludG8gdGhlIGluZmluaXRlXG4gICAgICAvLyBsb29wIHRyYXAuIFRoZSBpbml0aWFsIGRhdGUgdGFrZXMgY2FyZSBvZiB0aGUgY2FzZVxuICAgICAgLy8gd2hlcmUgdGhlIGN1cnJlbnQgZGF0ZSBpcyB0aGUgZGF0ZSB3ZSBhcmUgbG9va2luZ1xuICAgICAgLy8gZm9yLlxuICAgICAgZGF0ZSA9IGxhc3REYXkgKyAxO1xuXG4gICAgICBpZiAoZGF0ZSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBuZXh0IGRhdGVcbiAgICAgIGxldCBuZXh0ID0gYnlNb250aERheVtkYXRlSWR4KytdO1xuXG4gICAgICAvLyB0aGlzIGxvZ2ljIGlzIGRlcGVuZGVudCBvbiB0aGUgQllNT05USERBWVNcbiAgICAgIC8vIGJlaW5nIGluIG9yZGVyICh3aGljaCBpcyBkb25lIGJ5ICNub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMpXG4gICAgICBpZiAobmV4dCA+PSBkYXRlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBuZXh0IG1vbnRoIGRheSBpcyBpbiB0aGUgZnV0dXJlIGp1bXAgdG8gaXQuXG4gICAgICAgIGxhc3REYXkgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSAnbmV4dCcgbW9udGhkYXkgaGFzIHBhc3RcbiAgICAgICAgLy8gd2UgbXVzdCBtb3ZlIHRvIHRoZSBtb250aC5cbiAgICAgICAgbmV4dE1vbnRoKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgd2UgY2FuIGxvb3AgdGhyb3VnaCB0aGUgZGF5IHJ1bGVzIHRvIHNlZVxuICAgICAgLy8gaWYgb25lIG1hdGNoZXMgdGhlIGN1cnJlbnQgbW9udGggZGF0ZS5cbiAgICAgIGZvciAobGV0IGRheUlkeCA9IDA7IGRheUlkeCA8IGRheUxlbjsgZGF5SWR4KyspIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGJ5RGF5W2RheUlkeF0pO1xuICAgICAgICBsZXQgcG9zID0gcGFydHNbMF07XG4gICAgICAgIGxldCBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbGFzdERheTtcbiAgICAgICAgaWYgKHRoaXMubGFzdC5pc050aFdlZWtEYXkoZG93LCBwb3MpKSB7XG4gICAgICAgICAgLy8gd2hlbiB3ZSBmaW5kIHRoZSB2YWxpZCBvbmUgd2UgY2FuIG1hcmtcbiAgICAgICAgICAvLyB0aGUgY29uZGl0aW9ucyBhcyBtZXQgYW5kIGJyZWFrIHRoZSBsb29wLlxuICAgICAgICAgIC8vIChCZWNhdXNlIHdlIGhhdmUgdGhpcyBjb25kaXRpb24gYWJvdmVcbiAgICAgICAgICAvLyAgaXQgd2lsbCBhbHNvIGJyZWFrIHRoZSBwYXJlbnQgbG9vcCkuXG4gICAgICAgICAgZGF0YUlzVmFsaWQgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEl0IGlzIGNvbXBsZXRlbHkgcG9zc2libGUgdGhhdCB0aGUgY29tYmluYXRpb25cbiAgICAgIC8vIGNhbm5vdCBiZSBtYXRjaGVkIGluIHRoZSBjdXJyZW50IG1vbnRoLlxuICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHBvc3NpYmxlIGNvbWJpbmF0aW9uc1xuICAgICAgLy8gaW4gdGhlIGN1cnJlbnQgbW9udGggd2UgaXRlcmF0ZSB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBzaW5jZSBkYXRlSWR4IGlzIGluY3JlbWVudGVkIHJpZ2h0IGFmdGVyIGdldHRpbmdcbiAgICAgIC8vIFwibmV4dFwiLCB3ZSBkb24ndCBuZWVkIGRhdGVMZW4gLTEgaGVyZS5cbiAgICAgIGlmICghZGF0YUlzVmFsaWQgJiYgZGF0ZUlkeCA9PT0gZGF0ZUxlbikge1xuICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoc0NvdW50ZXIgPD0gMCkge1xuICAgICAgLy8gQ2hlY2tlZCA0IHllYXJzIHdpdGhvdXQgZmluZGluZyBhIEJ5ZGF5IHRoYXQgbWF0Y2hlc1xuICAgICAgLy8gYSBCeW1vbnRoZGF5LiBNYXliZSB0aGUgcnVsZSBpcyBub3QgY29ycmVjdC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB2YWx1ZXMgaW4gQllEQVkgY29tYmluZWQgd2l0aCBCWU1PTlRIREFZIHBhcnRzXCIpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIGRhdGFJc1ZhbGlkO1xuICB9XG5cbiAgbmV4dF9tb250aCgpIHtcbiAgICBsZXQgZGF0YV92YWxpZCA9IDE7XG5cbiAgICBpZiAodGhpcy5uZXh0X2hvdXIoKSA9PSAwKSB7XG4gICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpICYmIHRoaXMuaGFzX2J5X2RhdGEoXCJCWU1PTlRIREFZXCIpKSB7XG4gICAgICBkYXRhX3ZhbGlkID0gdGhpcy5fYnlEYXlBbmRNb250aERheSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgbGV0IHNldHBvcyA9IDA7XG4gICAgICBsZXQgc2V0cG9zX3RvdGFsID0gMDtcblxuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSkge1xuICAgICAgICBsZXQgbGFzdF9kYXkgPSB0aGlzLmxhc3QuZGF5O1xuICAgICAgICBmb3IgKGxldCBkYXkgPSAxOyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSsrKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgc2V0cG9zX3RvdGFsKys7XG4gICAgICAgICAgICBpZiAoZGF5IDw9IGxhc3RfZGF5KSB7XG4gICAgICAgICAgICAgIHNldHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbGFzdF9kYXk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgbGV0IGRheTtcbiAgICAgIGZvciAoZGF5ID0gdGhpcy5sYXN0LmRheSArIDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcblxuICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpIHx8XG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKCsrc2V0cG9zKSB8fFxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzZXRwb3MgLSBzZXRwb3NfdG90YWwgLSAxKSkge1xuXG4gICAgICAgICAgICBkYXRhX3ZhbGlkID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHRoaXMubGFzdCkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSB8fCB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbigxKSkge1xuICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkrKztcblxuICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWU1PTlRIREFZID49IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA9IDA7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA+PSB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgbGV0IGRheSA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIREFZXTtcblxuICAgICAgaWYgKGRheSA8IDApIHtcbiAgICAgICAgZGF5ID0gZGF5c0luTW9udGggKyBkYXkgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG4gICAgICAgIGRhdGFfdmFsaWQgPSB0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgIGxldCBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF0gPiBkYXlzSW5Nb250aCkge1xuICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVswXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgfVxuXG4gIG5leHRfd2Vla2RheV9ieV93ZWVrKCkge1xuICAgIGxldCBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICBpZiAodGhpcy5uZXh0X2hvdXIoKSA9PSAwKSB7XG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGZvciAoOzspIHtcbiAgICAgIGxldCB0dCA9IG5ldyBUaW1lKCk7XG4gICAgICB0aGlzLmJ5X2luZGljZXMuQllEQVkrKztcblxuICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9PSBPYmplY3Qua2V5cyh0aGlzLmJ5X2RhdGEuQllEQVkpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllEQVkgPSAwO1xuICAgICAgICBlbmRfb2ZfZGF0YSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbdGhpcy5ieV9pbmRpY2VzLkJZREFZXTtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayhjb2RlZF9kYXkpO1xuICAgICAgbGV0IGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICBkb3cgLT0gdGhpcy5ydWxlLndrc3Q7XG5cbiAgICAgIGlmIChkb3cgPCAwKSB7XG4gICAgICAgIGRvdyArPSA3O1xuICAgICAgfVxuXG4gICAgICB0dC55ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICB0dC5tb250aCA9IHRoaXMubGFzdC5tb250aDtcbiAgICAgIHR0LmRheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgIGxldCBzdGFydE9mV2VlayA9IHR0LnN0YXJ0RG95V2Vlayh0aGlzLnJ1bGUud2tzdCk7XG5cbiAgICAgIGlmIChkb3cgKyBzdGFydE9mV2VlayA8IDEpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGRhdGUgaXMgaW4gdGhlIHByZXZpb3VzIHllYXJcbiAgICAgICAgaWYgKCFlbmRfb2ZfZGF0YSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXh0ID0gVGltZS5mcm9tRGF5T2ZZZWFyKHN0YXJ0T2ZXZWVrICsgZG93LCB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5vcm1hbGl6YXRpb24gaG9ycm9ycyBiZWxvdyBhcmUgZHVlIHRvXG4gICAgICAgKiB0aGUgZmFjdCB0aGF0IHdoZW4gdGhlIHllYXIvbW9udGgvZGF5IGNoYW5nZXNcbiAgICAgICAqIGl0IGNhbiBlZmZlY3QgdGhlIG90aGVyIG9wZXJhdGlvbnMgdGhhdCBjb21lIGFmdGVyLlxuICAgICAgICovXG4gICAgICB0aGlzLmxhc3QueWVhciA9IG5leHQueWVhcjtcbiAgICAgIHRoaXMubGFzdC5tb250aCA9IG5leHQubW9udGg7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9XG4gIH1cblxuICBuZXh0X3llYXIoKSB7XG4gICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKCsrdGhpcy5kYXlzX2luZGV4ID09IHRoaXMuZGF5cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZGF5c19pbmRleCA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWU1PTlRIREFZXCIpKSB7XG4gICAgICAgICAgdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkgPSB0aGlzLm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyhcbiAgICAgICAgICAgIHRoaXMubGFzdC55ZWFyLFxuICAgICAgICAgICAgdGhpcy5sYXN0Lm1vbnRoLFxuICAgICAgICAgICAgdGhpcy5ydWxlLnBhcnRzLkJZTU9OVEhEQVlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwYW5kX3llYXJfZGF5cyh0aGlzLmxhc3QueWVhcik7XG4gICAgICB9IHdoaWxlICh0aGlzLmRheXMubGVuZ3RoID09IDApO1xuICAgIH1cblxuICAgIHRoaXMuX25leHRCeVllYXJEYXkoKTtcblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgX25leHRCeVllYXJEYXkoKSB7XG4gICAgbGV0IGRveSA9IHRoaXMuZGF5c1t0aGlzLmRheXNfaW5kZXhdO1xuICAgIGxldCB5ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgaWYgKGRveSA8IDEpIHtcbiAgICAgICAgLy8gVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcikgaW5kZXhlcyByZWxhdGl2ZSB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGdpdmVuIHllYXIuIFRoYXQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgICAgIC8vIHNlbWFudGljcyBvZiBCWVlFQVJEQVkgd2hlcmUgbmVnYXRpdmUgaW5kZXhlcyBhcmUgYW5cbiAgICAgICAgLy8gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4geWVhci5cbiAgICAgICAgZG95ICs9IDE7XG4gICAgICAgIHllYXIgKz0gMTtcbiAgICB9XG4gICAgbGV0IG5leHQgPSBUaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKTtcbiAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG4gICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZG93IChlZzogJzFUVScsICctMU1PJylcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYVdlZWtTdGFydCBUaGUgd2VlayBzdGFydCB3ZWVrZGF5XG4gICAqIEByZXR1cm4gW3BvcywgbnVtZXJpY0Rvd10gKGVnOiBbMSwgM10pIG51bWVyaWNEb3cgaXMgcmVsYXRpdmUgdG8gYVdlZWtTdGFydFxuICAgKi9cbiAgcnVsZURheU9mV2Vlayhkb3csIGFXZWVrU3RhcnQpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGRvdy5tYXRjaCgvKFsrLV0/WzAtOV0pPyhNT3xUVXxXRXxUSHxGUnxTQXxTVSkvKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgbGV0IHBvcyA9IHBhcnNlSW50KG1hdGNoZXNbMV0gfHwgMCwgMTApO1xuICAgICAgZG93ID0gUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheShtYXRjaGVzWzJdLCBhV2Vla1N0YXJ0KTtcbiAgICAgIHJldHVybiBbcG9zLCBkb3ddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cbiAgfVxuXG4gIG5leHRfZ2VuZXJpYyhhUnVsZVR5cGUsIGFJbnRlcnZhbCwgYURhdGVBdHRyLCBhRm9sbG93aW5nQXR0ciwgYVByZXZpb3VzSW5jcikge1xuICAgIGxldCBoYXNfYnlfcnVsZSA9IChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICBsZXQgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IGFJbnRlcnZhbCk7XG4gICAgbGV0IGVuZF9vZl9kYXRhID0gMDtcblxuICAgIGlmIChhUHJldmlvdXNJbmNyICYmIHRoaXNbYVByZXZpb3VzSW5jcl0oKSA9PSAwKSB7XG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGhhc19ieV9ydWxlKSB7XG4gICAgICB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSsrO1xuICAgICAgbGV0IGR0YSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICBpZiAodGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPT0gZHRhLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSA9IDA7XG4gICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFthRGF0ZUF0dHJdID0gZHRhW3RoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdXTtcbiAgICB9IGVsc2UgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFEYXRlQXR0cl0odGhpcy5ydWxlLmludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzX2J5X3J1bGUgJiYgZW5kX29mX2RhdGEgJiYgdGhpc19mcmVxKSB7XG4gICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYUZvbGxvd2luZ0F0dHJdKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgfVxuXG4gIGluY3JlbWVudF9tb250aGRheShpbmMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluYzsgaSsrKSB7XG4gICAgICBsZXQgZGF5c0luTW9udGggPSBUaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgdGhpcy5sYXN0LmRheSsrO1xuXG4gICAgICBpZiAodGhpcy5sYXN0LmRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgLT0gZGF5c0luTW9udGg7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5jcmVtZW50X21vbnRoKCkge1xuICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USFwiKSkge1xuICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEgrKztcblxuICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWU1PTlRIID09IHRoaXMuYnlfZGF0YS5CWU1PTlRILmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCA9IDA7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiKSB7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCArPSB0aGlzLnJ1bGUuaW50ZXJ2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3QubW9udGgrKztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Lm1vbnRoLS07XG4gICAgICBsZXQgeWVhcnMgPSB0cnVuYyh0aGlzLmxhc3QubW9udGggLyAxMik7XG4gICAgICB0aGlzLmxhc3QubW9udGggJT0gMTI7XG4gICAgICB0aGlzLmxhc3QubW9udGgrKztcblxuICAgICAgaWYgKHllYXJzICE9IDApIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcih5ZWFycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWU1PTlRIREFZXCIpKSB7XG4gICAgICB0aGlzLmJ5X2RhdGEuQllNT05USERBWSA9IHRoaXMubm9ybWFsaXplQnlNb250aERheVJ1bGVzKFxuICAgICAgICB0aGlzLmxhc3QueWVhcixcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoLFxuICAgICAgICB0aGlzLnJ1bGUucGFydHMuQllNT05USERBWVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpbmNyZW1lbnRfeWVhcihpbmMpIHtcbiAgICAvLyBEb24ndCBqdW1wIGludG8gdGhlIG5leHQgbW9udGggaWYgdGhpcy5sYXN0IGlzIEZlYiAyOS5cbiAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICB0aGlzLmxhc3QueWVhciArPSBpbmM7XG4gIH1cblxuICBpbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIGFEYXRlQXR0ciwgYUZhY3RvciwgYU5leHRJbmNyZW1lbnQpIHtcbiAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSArPSBpbmM7XG4gICAgbGV0IG5leHR1bml0ID0gdHJ1bmModGhpcy5sYXN0W2FEYXRlQXR0cl0gLyBhRmFjdG9yKTtcbiAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSAlPSBhRmFjdG9yO1xuICAgIGlmIChuZXh0dW5pdCAhPSAwKSB7XG4gICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYU5leHRJbmNyZW1lbnRdKG5leHR1bml0KTtcbiAgICB9XG4gIH1cblxuICBoYXNfYnlfZGF0YShhUnVsZVR5cGUpIHtcbiAgICByZXR1cm4gKGFSdWxlVHlwZSBpbiB0aGlzLnJ1bGUucGFydHMpO1xuICB9XG5cbiAgZXhwYW5kX3llYXJfZGF5cyhhWWVhcikge1xuICAgIGxldCB0ID0gbmV3IFRpbWUoKTtcbiAgICB0aGlzLmRheXMgPSBbXTtcblxuICAgIC8vIFdlIG5lZWQgb3VyIG93biBjb3B5IHdpdGggYSBmZXcga2V5cyBzZXRcbiAgICBsZXQgcGFydHMgPSB7fTtcbiAgICBsZXQgcnVsZXMgPSBbXCJCWURBWVwiLCBcIkJZV0VFS05PXCIsIFwiQllNT05USERBWVwiLCBcIkJZTU9OVEhcIiwgXCJCWVlFQVJEQVlcIl07XG4gICAgZm9yIChsZXQgcGFydCBvZiBydWxlcykge1xuICAgICAgaWYgKHBhcnQgaW4gdGhpcy5ydWxlLnBhcnRzKSB7XG4gICAgICAgIHBhcnRzW3BhcnRdID0gdGhpcy5ydWxlLnBhcnRzW3BhcnRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcIkJZTU9OVEhcIiBpbiBwYXJ0cyAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgIGxldCB2YWxpZCA9IDE7XG4gICAgICBsZXQgdmFsaWRXZWVrcyA9IHt9O1xuICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgIGZvciAobGV0IG1vbnRoSWR4ID0gMDsgbW9udGhJZHggPCB0aGlzLmJ5X2RhdGEuQllNT05USC5sZW5ndGg7IG1vbnRoSWR4KyspIHtcbiAgICAgICAgbGV0IG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhJZHhdO1xuICAgICAgICB0Lm1vbnRoID0gbW9udGg7XG4gICAgICAgIHQuZGF5ID0gMTtcbiAgICAgICAgbGV0IGZpcnN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICB0LmRheSA9IFRpbWUuZGF5c0luTW9udGgobW9udGgsIGFZZWFyKTtcbiAgICAgICAgbGV0IGxhc3Rfd2VlayA9IHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgIGZvciAobW9udGhJZHggPSBmaXJzdF93ZWVrOyBtb250aElkeCA8IGxhc3Rfd2VlazsgbW9udGhJZHgrKykge1xuICAgICAgICAgIHZhbGlkV2Vla3NbbW9udGhJZHhdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCB3ZWVrSWR4ID0gMDsgd2Vla0lkeCA8IHRoaXMuYnlfZGF0YS5CWVdFRUtOTy5sZW5ndGggJiYgdmFsaWQ7IHdlZWtJZHgrKykge1xuICAgICAgICBsZXQgd2Vla25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3dlZWtJZHhdO1xuICAgICAgICBpZiAod2Vla25vIDwgNTIpIHtcbiAgICAgICAgICB2YWxpZCAmPSB2YWxpZFdlZWtzW3dlZWtJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgZGVsZXRlIHBhcnRzLkJZTU9OVEg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFydHMuQllXRUVLTk87XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBhcnRDb3VudCA9IE9iamVjdC5rZXlzKHBhcnRzKS5sZW5ndGg7XG5cbiAgICBpZiAocGFydENvdW50ID09IDApIHtcbiAgICAgIGxldCB0MSA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgdDEueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgdGhpcy5kYXlzLnB1c2godDEuZGF5T2ZZZWFyKCkpO1xuICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgIGZvciAobGV0IG1vbnRoIG9mIHRoaXMuYnlfZGF0YS5CWU1PTlRIKSB7XG4gICAgICAgIGxldCB0MiA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICB0Mi55ZWFyID0gYVllYXI7XG4gICAgICAgIHQyLm1vbnRoID0gbW9udGg7XG4gICAgICAgIHQyLmlzRGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF5cy5wdXNoKHQyLmRheU9mWWVhcigpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICBmb3IgKGxldCBtb250aGRheSBvZiB0aGlzLmJ5X2RhdGEuQllNT05USERBWSkge1xuICAgICAgICBsZXQgdDMgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgaWYgKG1vbnRoZGF5IDwgMCkge1xuICAgICAgICAgIGxldCBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgodDMubW9udGgsIGFZZWFyKTtcbiAgICAgICAgICBtb250aGRheSA9IG1vbnRoZGF5ICsgZGF5c0luTW9udGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHQzLmRheSA9IG1vbnRoZGF5O1xuICAgICAgICB0My55ZWFyID0gYVllYXI7XG4gICAgICAgIHQzLmlzRGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF5cy5wdXNoKHQzLmRheU9mWWVhcigpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmXG4gICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgIGZvciAobGV0IG1vbnRoIG9mIHRoaXMuYnlfZGF0YS5CWU1PTlRIKSB7XG4gICAgICAgIGxldCBkYXlzSW5Nb250aCA9IFRpbWUuZGF5c0luTW9udGgobW9udGgsIGFZZWFyKTtcbiAgICAgICAgZm9yIChsZXQgbW9udGhkYXkgb2YgdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICBpZiAobW9udGhkYXkgPCAwKSB7XG4gICAgICAgICAgICBtb250aGRheSA9IG1vbnRoZGF5ICsgZGF5c0luTW9udGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0LmRheSA9IG1vbnRoZGF5O1xuICAgICAgICAgIHQubW9udGggPSBtb250aDtcbiAgICAgICAgICB0LnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0LmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSA7IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmXG4gICAgICAgICAgICAgICBcIkJZV0VFS05PXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSA7IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgdGhpcy5kYXlzID0gdGhpcy5kYXlzLmNvbmNhdCh0aGlzLmV4cGFuZF9ieV9kYXkoYVllYXIpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgZm9yIChsZXQgbW9udGggb2YgdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgbGV0IGRheXNJbk1vbnRoID0gVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuXG4gICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICB0Lm1vbnRoID0gbW9udGg7XG4gICAgICAgIHQuZGF5ID0gMTtcbiAgICAgICAgdC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICAgIGxldCBmaXJzdF9kb3cgPSB0LmRheU9mV2VlaygpO1xuICAgICAgICBsZXQgZG95X29mZnNldCA9IHQuZGF5T2ZZZWFyKCkgLSAxO1xuXG4gICAgICAgIHQuZGF5ID0gZGF5c0luTW9udGg7XG4gICAgICAgIGxldCBsYXN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSkge1xuICAgICAgICAgIGxldCBieV9tb250aF9kYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBkYXkgPSAxOyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSsrKSB7XG4gICAgICAgICAgICB0LmRheSA9IGRheTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0KSkge1xuICAgICAgICAgICAgICBieV9tb250aF9kYXkucHVzaChkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IHNwSW5kZXggPSAwOyBzcEluZGV4IDwgYnlfbW9udGhfZGF5Lmxlbmd0aDsgc3BJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCArIDEpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCAtIGJ5X21vbnRoX2RheS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBieV9tb250aF9kYXlbc3BJbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBjb2RlZF9kYXkgb2YgdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgICBsZXQgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayhjb2RlZF9kYXkpO1xuICAgICAgICAgICAgbGV0IHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgICBsZXQgZG93ID0gYnlkYXlQYXJ0c1sxXTtcbiAgICAgICAgICAgIGxldCBtb250aF9kYXk7XG5cbiAgICAgICAgICAgIGxldCBmaXJzdF9tYXRjaGluZ19kYXkgPSAoKGRvdyArIDcgLSBmaXJzdF9kb3cpICUgNykgKyAxO1xuICAgICAgICAgICAgbGV0IGxhc3RfbWF0Y2hpbmdfZGF5ID0gZGF5c0luTW9udGggLSAoKGxhc3RfZG93ICsgNyAtIGRvdykgJSA3KTtcblxuICAgICAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGRheSA9IGZpcnN0X21hdGNoaW5nX2RheTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkgKz0gNykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBkYXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgbW9udGhfZGF5ID0gZmlyc3RfbWF0Y2hpbmdfZGF5ICsgKHBvcyAtIDEpICogNztcblxuICAgICAgICAgICAgICBpZiAobW9udGhfZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIG1vbnRoX2RheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1vbnRoX2RheSA9IGxhc3RfbWF0Y2hpbmdfZGF5ICsgKHBvcyArIDEpICogNztcblxuICAgICAgICAgICAgICBpZiAobW9udGhfZGF5ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBtb250aF9kYXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4gZGF0ZXMgaW4gb3JkZXIgb2Ygb2NjdXJyZW5jZSAoMSwyLDMsLi4uKSBpbnN0ZWFkXG4gICAgICAvLyBvZiBieSBncm91cHMgb2Ygd2Vla2RheXMgKDEsOCwxNSwuLi4sMiw5LDE2LC4uLikuXG4gICAgICB0aGlzLmRheXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7IC8vIENvbXBhcmF0b3IgZnVuY3Rpb24gYWxsb3dzIHRvIHNvcnQgbnVtYmVycy5cbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgbGV0IGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgIGZvciAobGV0IGRheSBvZiBleHBhbmRlZERheXMpIHtcbiAgICAgICAgbGV0IHR0ID0gVGltZS5mcm9tRGF5T2ZZZWFyKGRheSwgYVllYXIpO1xuICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaW5kZXhPZih0dC5kYXkpID49IDApIHtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgXCJCWURBWVwiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgIGxldCBleHBhbmRlZERheXMgPSB0aGlzLmV4cGFuZF9ieV9kYXkoYVllYXIpO1xuXG4gICAgICBmb3IgKGxldCBkYXkgb2YgZXhwYW5kZWREYXlzKSB7XG4gICAgICAgIGxldCB0dCA9IFRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcblxuICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEguaW5kZXhPZih0dC5tb250aCkgPj0gMCAmJlxuICAgICAgICAgICAgdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaW5kZXhPZih0dC5kYXkpID49IDApIHtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICBsZXQgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgZm9yIChsZXQgZGF5IG9mIGV4cGFuZGVkRGF5cykge1xuICAgICAgICBsZXQgdHQgPSBUaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG4gICAgICAgIGxldCB3ZWVrbm8gPSB0dC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZV0VFS05PLmluZGV4T2Yod2Vla25vKSkge1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAzICYmXG4gICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgIFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIDsgZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgdGhpcy5kYXlzID0gdGhpcy5kYXlzLmNvbmNhdCh0aGlzLmJ5X2RhdGEuQllZRUFSREFZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXlzID0gW107XG4gICAgfVxuXG4gICAgbGV0IGRheXNJblllYXIgPSBUaW1lLmlzTGVhcFllYXIoYVllYXIpID8gMzY2IDogMzY1O1xuICAgIHRoaXMuZGF5cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYSA8IDApIGEgKz0gZGF5c0luWWVhciArIDE7XG4gICAgICBpZiAoYiA8IDApIGIgKz0gZGF5c0luWWVhciArIDE7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGV4cGFuZF9ieV9kYXkoYVllYXIpIHtcblxuICAgIGxldCBkYXlzX2xpc3QgPSBbXTtcbiAgICBsZXQgdG1wID0gdGhpcy5sYXN0LmNsb25lKCk7XG5cbiAgICB0bXAueWVhciA9IGFZZWFyO1xuICAgIHRtcC5tb250aCA9IDE7XG4gICAgdG1wLmRheSA9IDE7XG4gICAgdG1wLmlzRGF0ZSA9IHRydWU7XG5cbiAgICBsZXQgc3RhcnRfZG93ID0gdG1wLmRheU9mV2VlaygpO1xuXG4gICAgdG1wLm1vbnRoID0gMTI7XG4gICAgdG1wLmRheSA9IDMxO1xuICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgbGV0IGVuZF9kb3cgPSB0bXAuZGF5T2ZXZWVrKCk7XG4gICAgbGV0IGVuZF95ZWFyX2RheSA9IHRtcC5kYXlPZlllYXIoKTtcblxuICAgIGZvciAobGV0IGRheSBvZiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgbGV0IHBvcyA9IHBhcnRzWzBdO1xuICAgICAgbGV0IGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgbGV0IHRtcF9zdGFydF9kb3kgPSAoKGRvdyArIDcgLSBzdGFydF9kb3cpICUgNykgKyAxO1xuXG4gICAgICAgIGZvciAobGV0IGRveSA9IHRtcF9zdGFydF9kb3k7IGRveSA8PSBlbmRfeWVhcl9kYXk7IGRveSArPSA3KSB7XG4gICAgICAgICAgZGF5c19saXN0LnB1c2goZG95KTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgbGV0IGZpcnN0O1xuICAgICAgICBpZiAoZG93ID49IHN0YXJ0X2Rvdykge1xuICAgICAgICAgIGZpcnN0ID0gZG93IC0gc3RhcnRfZG93ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDg7XG4gICAgICAgIH1cblxuICAgICAgICBkYXlzX2xpc3QucHVzaChmaXJzdCArIChwb3MgLSAxKSAqIDcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIHBvcyA9IC1wb3M7XG5cbiAgICAgICAgaWYgKGRvdyA8PSBlbmRfZG93KSB7XG4gICAgICAgICAgbGFzdCA9IGVuZF95ZWFyX2RheSAtIGVuZF9kb3cgKyBkb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGVuZF95ZWFyX2RheSAtIGVuZF9kb3cgKyBkb3cgLSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF5c19saXN0LnB1c2gobGFzdCAtIChwb3MgLSAxKSAqIDcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF5c19saXN0O1xuICB9XG5cbiAgaXNfZGF5X2luX2J5ZGF5KHR0KSB7XG4gICAgaWYgKHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgZm9yIChsZXQgZGF5IG9mIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICBsZXQgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoZGF5KTtcbiAgICAgICAgbGV0IHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICBsZXQgZG93ID0gcGFydHNbMV07XG4gICAgICAgIGxldCB0aGlzX2RvdyA9IHR0LmRheU9mV2VlaygpO1xuXG4gICAgICAgIGlmICgocG9zID09IDAgJiYgZG93ID09IHRoaXNfZG93KSB8fFxuICAgICAgICAgICAgKHR0Lm50aFdlZWtEYXkoZG93LCBwb3MpID09IHR0LmRheSkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBpbiBCWVNFVFBPUy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1lcmljfSBhUG9zIHBvc2l0aW9uIHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgdW5sZXNzIEJZU0VUUE9TIHJ1bGVzIGV4aXN0XG4gICAqICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBydWxlcy5cbiAgICovXG4gIGNoZWNrX3NldF9wb3NpdGlvbihhUG9zKSB7XG4gICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoJ0JZU0VUUE9TJykpIHtcbiAgICAgIGxldCBpZHggPSB0aGlzLmJ5X2RhdGEuQllTRVRQT1MuaW5kZXhPZihhUG9zKTtcbiAgICAgIC8vIG5lZ2F0aXZlIG51bWJlcnMgYXJlIG5vdCBmYWxzZS15XG4gICAgICByZXR1cm4gaWR4ICE9PSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc29ydF9ieWRheV9ydWxlcyhhUnVsZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMucnVsZURheU9mV2VlayhhUnVsZXNbal0sIHRoaXMucnVsZS53a3N0KVsxXTtcbiAgICAgICAgbGV0IHR3byA9IHRoaXMucnVsZURheU9mV2VlayhhUnVsZXNbaV0sIHRoaXMucnVsZS53a3N0KVsxXTtcblxuICAgICAgICBpZiAob25lID4gdHdvKSB7XG4gICAgICAgICAgbGV0IHRtcCA9IGFSdWxlc1tpXTtcbiAgICAgICAgICBhUnVsZXNbaV0gPSBhUnVsZXNbal07XG4gICAgICAgICAgYVJ1bGVzW2pdID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oYVJ1bGVUeXBlLCB2KSB7XG4gICAgbGV0IGluZGV4TWFwVmFsdWUgPSBSZWN1ckl0ZXJhdG9yLl9pbmRleE1hcFthUnVsZVR5cGVdO1xuICAgIGxldCBydWxlTWFwVmFsdWUgPSBSZWN1ckl0ZXJhdG9yLl9leHBhbmRNYXBbdGhpcy5ydWxlLmZyZXFdW2luZGV4TWFwVmFsdWVdO1xuICAgIGxldCBwYXNzID0gZmFsc2U7XG5cbiAgICBpZiAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSAmJlxuICAgICAgICBydWxlTWFwVmFsdWUgPT0gUmVjdXJJdGVyYXRvci5DT05UUkFDVCkge1xuXG4gICAgICBsZXQgcnVsZVR5cGUgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgZm9yIChsZXQgYnlkYXRhIG9mIHJ1bGVUeXBlKSB7XG4gICAgICAgIGlmIChieWRhdGEgPT0gdikge1xuICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vdCBhIGNvbnRyYWN0aW5nIGJ5cnVsZSBvciBoYXMgbm8gZGF0YSwgdGVzdCBwYXNzZXNcbiAgICAgIHBhc3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFzcztcbiAgfVxuXG4gIGNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkge1xuICAgIGxldCBkb3cgPSB0aGlzLmxhc3QuZGF5T2ZXZWVrKCk7XG4gICAgbGV0IHdlZWtObyA9IHRoaXMubGFzdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICBsZXQgZG95ID0gdGhpcy5sYXN0LmRheU9mWWVhcigpO1xuXG4gICAgcmV0dXJuICh0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllTRUNPTkRcIiwgdGhpcy5sYXN0LnNlY29uZCkgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1JTlVURVwiLCB0aGlzLmxhc3QubWludXRlKSAmJlxuICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZSE9VUlwiLCB0aGlzLmxhc3QuaG91cikgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWURBWVwiLCBSZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KGRvdykpICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllXRUVLTk9cIiwgd2Vla05vKSAmJlxuICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZTU9OVEhEQVlcIiwgdGhpcy5sYXN0LmRheSkgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIXCIsIHRoaXMubGFzdC5tb250aCkgJiZcbiAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVlFQVJEQVlcIiwgZG95KSk7XG4gIH1cblxuICBzZXR1cF9kZWZhdWx0cyhhUnVsZVR5cGUsIHJlcSwgZGVmdGltZSkge1xuICAgIGxldCBpbmRleE1hcFZhbHVlID0gUmVjdXJJdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICBsZXQgcnVsZU1hcFZhbHVlID0gUmVjdXJJdGVyYXRvci5fZXhwYW5kTWFwW3RoaXMucnVsZS5mcmVxXVtpbmRleE1hcFZhbHVlXTtcblxuICAgIGlmIChydWxlTWFwVmFsdWUgIT0gUmVjdXJJdGVyYXRvci5DT05UUkFDVCkge1xuICAgICAgaWYgKCEoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSkpIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV0gPSBbZGVmdGltZV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgIT0gcmVxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZnRpbWU7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBpdGVyYXRvciBpbnRvIGEgc2VyaWFsaXplLWFibGUgb2JqZWN0LiAgV2lsbCBwcmVzZXJ2ZSBjdXJyZW50XG4gICAqIGl0ZXJhdGlvbiBzZXF1ZW5jZSB0byBlbnN1cmUgdGhlIHNlYW1sZXNzIGNvbnRpbnVhdGlvbiBvZiB0aGUgcmVjdXJyZW5jZVxuICAgKiBydWxlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICByZXN1bHQuaW5pdGlhbGl6ZWQgPSB0aGlzLmluaXRpYWxpemVkO1xuICAgIHJlc3VsdC5ydWxlID0gdGhpcy5ydWxlLnRvSlNPTigpO1xuICAgIHJlc3VsdC5kdHN0YXJ0ID0gdGhpcy5kdHN0YXJ0LnRvSlNPTigpO1xuICAgIHJlc3VsdC5ieV9kYXRhID0gdGhpcy5ieV9kYXRhO1xuICAgIHJlc3VsdC5kYXlzID0gdGhpcy5kYXlzO1xuICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgIHJlc3VsdC5ieV9pbmRpY2VzID0gdGhpcy5ieV9pbmRpY2VzO1xuICAgIHJlc3VsdC5vY2N1cnJlbmNlX251bWJlciA9IHRoaXMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQW4gZXJyb3IgaW5kaWNhdGluZyB0aGF0IGEgcmVjdXJyZW5jZSBydWxlIGlzIGludmFsaWQgYW5kIHByb2R1Y2VzIG5vXG4gKiBvY2N1cnJlbmNlcy5cbiAqXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgSW52YWxpZFJlY3VycmVuY2VSdWxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiUmVjdXJyZW5jZSBydWxlIGhhcyBubyB2YWxpZCBvY2N1cnJlbmNlc1wiKTtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGxldHMgdHlwZXNjcmlwdCByZXNvbHZlIG91ciBjdXN0b20gdHlwZXMgaW4gdGhlXG4gKiBnZW5lcmF0ZWQgZC50cyBmaWxlcyAoanNkb2MgdHlwZWRlZnMgYXJlIGNvbnZlcnRlZCB0byB0eXBlc2NyaXB0IHR5cGVzKS5cbiAqIElnbm9yZSBwcmV2ZW50cyB0aGUgdHlwZWRlZnMgZnJvbSBiZWluZyBkb2N1bWVudGVkIG1vcmUgdGhhbiBvbmNlLlxuICpcbiAqIEBpZ25vcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLndlZWtEYXl9IHdlZWtEYXlcbiAqIEltcG9ydHMgdGhlICd3ZWVrRGF5JyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLmZyZXF1ZW5jeVZhbHVlc30gZnJlcXVlbmN5VmFsdWVzXG4gKiBJbXBvcnRzIHRoZSAnZnJlcXVlbmN5VmFsdWVzJyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqL1xuXG5jb25zdCBWQUxJRF9EQVlfTkFNRVMgPSAvXihTVXxNT3xUVXxXRXxUSHxGUnxTQSkkLztcbmNvbnN0IFZBTElEX0JZREFZX1BBUlQgPSAvXihbKy1dKT8oNVswLTNdfFsxLTRdWzAtOV18WzEtOV0pPyhTVXxNT3xUVXxXRXxUSHxGUnxTQSkkLztcbmNvbnN0IERPV19NQVAgPSB7XG4gIFNVOiBUaW1lLlNVTkRBWSxcbiAgTU86IFRpbWUuTU9OREFZLFxuICBUVTogVGltZS5UVUVTREFZLFxuICBXRTogVGltZS5XRURORVNEQVksXG4gIFRIOiBUaW1lLlRIVVJTREFZLFxuICBGUjogVGltZS5GUklEQVksXG4gIFNBOiBUaW1lLlNBVFVSREFZXG59O1xuXG5jb25zdCBSRVZFUlNFX0RPV19NQVAgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoRE9XX01BUCkubWFwKGVudHJ5ID0+IGVudHJ5LnJldmVyc2UoKSkpO1xuXG5jb25zdCBBTExPV0VEX0ZSRVEgPSBbJ1NFQ09ORExZJywgJ01JTlVURUxZJywgJ0hPVVJMWScsXG4gICAgICAgICAgICAgICAgICAgICAgJ0RBSUxZJywgJ1dFRUtMWScsICdNT05USExZJywgJ1lFQVJMWSddO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJyZWN1clwiIHZhbHVlIHR5cGUsIHVzZWQgZm9yIGV4YW1wbGUgYnkgUlJVTEUuIEl0IHByb3ZpZGVzIG1ldGhvZHMgdG9cbiAqIGNhbGN1bGF0ZSBvY2N1cnJlbmNlcyBhbW9uZyBvdGhlcnMuXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgUmVjdXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7UmVjdXJ9ICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgIGxldCBkYXRhID0gdGhpcy5fc3RyaW5nVG9EYXRhKHN0cmluZywgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgUmVjdXIoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWRcbiAgICogZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtmcmVxdWVuY3lWYWx1ZXM9fSBhRGF0YS5mcmVxICAgICAgICAgICAgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYURhdGEud2tzdCAgICAgICAgICAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtUaW1lPX0gYURhdGEudW50aWwgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZWNvbmQgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bWludXRlICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieWhvdXIgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBhRGF0YS5ieWRheSAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGhkYXkgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5eWVhcmRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl3ZWVrbm8gICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieW1vbnRoICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZXRwb3MgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJlY3VyKGFEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHJlY3VycmVuY2Ugc3RyaW5nIHRvIGEgZGF0YSBvYmplY3QsIHN1aXRhYmxlIGZvciB0aGUgZnJvbURhdGFcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm10SWNhbCAgIElmIHRydWUsIHRoZSBzdHJpbmcgaXMgY29uc2lkZXJlZCB0byBiZSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDYWxlbmRhciBzdHJpbmdcbiAgICogQHJldHVybiB7UmVjdXJ9ICAgICAgICAgICAgVGhlIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBfc3RyaW5nVG9EYXRhKHN0cmluZywgZm10SWNhbCkge1xuICAgIGxldCBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIHNwbGl0IGlzIHNsb3dlciBpbiBGRiBidXQgZmFzdCBlbm91Z2guXG4gICAgLy8gdjggaG93ZXZlciB0aGlzIGlzIGZhc3RlciB0aGVuIG1hbnVhbCBzcGxpdD9cbiAgICBsZXQgdmFsdWVzID0gc3RyaW5nLnNwbGl0KCc7Jyk7XG4gICAgbGV0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgcGFydHMgPSB2YWx1ZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIGxldCB1Y25hbWUgPSBwYXJ0c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgbGV0IGxjbmFtZSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBsZXQgbmFtZSA9IChmbXRJY2FsID8gbGNuYW1lIDogdWNuYW1lKTtcbiAgICAgIGxldCB2YWx1ZSA9IHBhcnRzWzFdO1xuXG4gICAgICBpZiAodWNuYW1lIGluIHBhcnREZXNpZ24pIHtcbiAgICAgICAgbGV0IHBhcnRBcnIgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICBsZXQgcGFydFNldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRBcnIpIHtcbiAgICAgICAgICBwYXJ0U2V0LmFkZChwYXJ0RGVzaWduW3VjbmFtZV0ocGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRBcnIgPSBbLi4ucGFydFNldF07XG5cbiAgICAgICAgZGljdFtuYW1lXSA9IChwYXJ0QXJyLmxlbmd0aCA9PSAxID8gcGFydEFyclswXSA6IHBhcnRBcnIpO1xuICAgICAgfSBlbHNlIGlmICh1Y25hbWUgaW4gb3B0aW9uRGVzaWduKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnblt1Y25hbWVdKHZhbHVlLCBkaWN0LCBmbXRJY2FsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IHN3YWxsb3cgdW5rbm93biB2YWx1ZXMuIEp1c3Qgc2V0IHRoZW0gYXMgdGhleSBhcmUuXG4gICAgICAgIGRpY3RbbGNuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGRheSAoU1UsIE1PLCBldGMuLilcbiAgICogaW50byBhIG51bWVyaWMgdmFsdWUgb2YgdGhhdCBkYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBpQ2FsZW5kYXIgZGF5IG5hbWVcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqL1xuICBzdGF0aWMgaWNhbERheVRvTnVtZXJpY0RheShzdHJpbmcsIGFXZWVrU3RhcnQpIHtcbiAgICAvL1hYWDogdGhpcyBpcyBoZXJlIHNvIHdlIGNhbiBkZWFsXG4gICAgLy8gICAgIHdpdGggcG9zc2libHkgaW52YWxpZCBzdHJpbmcgdmFsdWVzLlxuICAgIGxldCBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgVGltZS5TVU5EQVk7XG4gICAgcmV0dXJuICgoRE9XX01BUFtzdHJpbmddIC0gZmlyc3REb3cgKyA3KSAlIDcpICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgbnVtZXJpYyBkYXkgdmFsdWUgaW50byBpdHMgaWNhbCByZXByZXNlbnRhdGlvbiAoU1UsIE1PLCBldGMuLilcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bSAgICAgICAgTnVtZXJpYyB2YWx1ZSBvZiBnaXZlbiBkYXlcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBJQ0FMIGRheSB2YWx1ZSwgZS5nIFNVLE1PLC4uLlxuICAgKi9cbiAgc3RhdGljIG51bWVyaWNEYXlUb0ljYWxEYXkobnVtLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbCB3aXRoIHBvc3NpYmx5IGludmFsaWQgbnVtYmVyIHZhbHVlcy5cbiAgICAvLyAgICAgQWxzbywgdGhpcyBhbGxvd3MgY29uc2lzdGVudCBtYXBwaW5nIGJldHdlZW4gZGF5IG51bWJlcnMgYW5kIGRheVxuICAgIC8vICAgICBuYW1lcyBmb3IgZXh0ZXJuYWwgdXNlcnMuXG4gICAgbGV0IGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBUaW1lLlNVTkRBWTtcbiAgICBsZXQgZG93ID0gKG51bSArIGZpcnN0RG93IC0gVGltZS5TVU5EQVkpO1xuICAgIGlmIChkb3cgPiA3KSB7XG4gICAgICBkb3cgLT0gNztcbiAgICB9XG4gICAgcmV0dXJuIFJFVkVSU0VfRE9XX01BUFtkb3ddO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUmVjdXIgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtmcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgICAgICAgICAgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gZGF0YS53a3N0ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtUaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltaW51dGUgICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aGRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGggICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMucGFydHMgPSB7fTtcblxuICAgIGlmIChkYXRhICYmIHR5cGVvZihkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBob2xkaW5nIHRoZSBCWS1wYXJ0cyBvZiB0aGUgcmVjdXJyZW5jZSBydWxlXG4gICAqIEBtZW1iZXJvZiBJQ0FMLlJlY3VyXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IGJ5UGFydHNcbiAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPj19IEJZU0VDT05EICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj49fSBCWU1JTlVURSAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+PX0gQllIT1VSICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+PX0gQllEQVkgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj49fSBCWU1PTlRIREFZICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj49fSBCWVlFQVJEQVkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPj19IEJZV0VFS05PICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+PX0gQllNT05USCAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPj19IEJZU0VUUE9TICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cblxuICAvKipcbiAgICogQW4gb2JqZWN0IGhvbGRpbmcgdGhlIEJZLXBhcnRzIG9mIHRoZSByZWN1cnJlbmNlIHJ1bGVcbiAgICogQHR5cGUge2J5UGFydHN9XG4gICAqL1xuICBwYXJ0cyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlcnZhbCB2YWx1ZSBmb3IgdGhlIHJlY3VycmVuY2UgcnVsZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGludGVydmFsID0gMTtcblxuICAvKipcbiAgICogVGhlIHdlZWsgc3RhcnQgZGF5XG4gICAqXG4gICAqIEB0eXBlIHt3ZWVrRGF5fVxuICAgKiBAZGVmYXVsdCBJQ0FMLlRpbWUuTU9OREFZXG4gICAqL1xuICB3a3N0ID0gVGltZS5NT05EQVk7XG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHR5cGUgez9UaW1lfVxuICAgKi9cbiAgdW50aWwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAqL1xuICBjb3VudCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBmcmVxdWVuY3kgdmFsdWUuXG4gICAqIEB0eXBlIHtmcmVxdWVuY3lWYWx1ZXN9XG4gICAqL1xuICBmcmVxID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcImljYWxyZWN1clwiXG4gICAqL1xuICBpY2FsY2xhc3MgPSBcImljYWxyZWN1clwiO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwicmVjdXJcIlxuICAgKi9cbiAgaWNhbHR5cGUgPSBcInJlY3VyXCI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpdGVyYXRvciBmb3IgdGhpcyByZWN1cnJlbmNlIHJ1bGUuIFRoZSBwYXNzZWQgc3RhcnQgZGF0ZVxuICAgKiBtdXN0IGJlIHRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCwgbm90IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG9cbiAgICogc2VhcmNoIGluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgcmVjdXIgPSBjb21wLmdldEZpcnN0UHJvcGVydHlWYWx1ZSgncnJ1bGUnKTtcbiAgICogbGV0IGR0c3RhcnQgPSBjb21wLmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpO1xuICAgKiBsZXQgaXRlciA9IHJlY3VyLml0ZXJhdG9yKGR0c3RhcnQpO1xuICAgKiBmb3IgKGxldCBuZXh0ID0gaXRlci5uZXh0KCk7IG5leHQ7IG5leHQgPSBpdGVyLm5leHQoKSkge1xuICAgKiAgIGlmIChuZXh0LmNvbXBhcmUocmFuZ2VTdGFydCkgPCAwKSB7XG4gICAqICAgICBjb250aW51ZTtcbiAgICogICB9XG4gICAqICAgY29uc29sZS5sb2cobmV4dC50b1N0cmluZygpKTtcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWV9IGFTdGFydCAgICAgICAgVGhlIGl0ZW0ncyBzdGFydCBkYXRlXG4gICAqIEByZXR1cm4ge1JlY3VySXRlcmF0b3J9ICAgICBUaGUgcmVjdXJyZW5jZSBpdGVyYXRvclxuICAgKi9cbiAgaXRlcmF0b3IoYVN0YXJ0KSB7XG4gICAgcmV0dXJuIG5ldyBSZWN1ckl0ZXJhdG9yKHtcbiAgICAgIHJ1bGU6IHRoaXMsXG4gICAgICBkdHN0YXJ0OiBhU3RhcnRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHJlY3VycmVuY2Ugb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWN1cn0gICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN1cih0aGlzLnRvSlNPTigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBmaW5pdGUsIGkuZS4gaGFzIGEgY291bnQgb3IgdW50aWwgcGFydC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGZpbml0ZVxuICAgKi9cbiAgaXNGaW5pdGUoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY291bnQgfHwgdGhpcy51bnRpbCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHJ1bGUgaGFzIGEgY291bnQgcGFydCwgYW5kIG5vdCBsaW1pdGVkIGJ5IGFuIHVudGlsXG4gICAqIHBhcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBieSBjb3VudFxuICAgKi9cbiAgaXNCeUNvdW50KCkge1xuICAgIHJldHVybiAhISh0aGlzLmNvdW50ICYmICF0aGlzLnVudGlsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IChwYXJ0KSB0byB0aGUgcmVjdXJyZW5jZSBydWxlLiBUaGlzIGlzIG5vdCBhIGNvbXBvbmVudFxuICAgKiBpbiB0aGUgc2Vuc2Ugb2Yge0BsaW5rIElDQUwuQ29tcG9uZW50fSwgYnV0IGEgcGFydCBvZiB0aGUgcmVjdXJyZW5jZVxuICAgKiBydWxlLCBpLmUuIEJZTU9OVEguXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVHlwZSAgICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYVZhbHVlICAgICBUaGUgY29tcG9uZW50IHZhbHVlXG4gICAqL1xuICBhZGRDb21wb25lbnQoYVR5cGUsIGFWYWx1ZSkge1xuICAgIGxldCB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICh1Y25hbWUgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgdGhpcy5wYXJ0c1t1Y25hbWVdLnB1c2goYVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJ0c1t1Y25hbWVdID0gW2FWYWx1ZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbXBvbmVudCB2YWx1ZSBmb3IgdGhlIGdpdmVuIGJ5LXBhcnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVHlwZSAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IG5hbWVcbiAgICogQHBhcmFtIHtBcnJheX0gYVZhbHVlcyAgICAgICBUaGUgY29tcG9uZW50IHZhbHVlc1xuICAgKi9cbiAgc2V0Q29tcG9uZW50KGFUeXBlLCBhVmFsdWVzKSB7XG4gICAgdGhpcy5wYXJ0c1thVHlwZS50b1VwcGVyQ2FzZSgpXSA9IGFWYWx1ZXMuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIChhIGNvcHkpIG9mIHRoZSByZXF1ZXN0ZWQgY29tcG9uZW50IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IHZhbHVlXG4gICAqL1xuICBnZXRDb21wb25lbnQoYVR5cGUpIHtcbiAgICBsZXQgdWNuYW1lID0gYVR5cGUudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gKHVjbmFtZSBpbiB0aGlzLnBhcnRzID8gdGhpcy5wYXJ0c1t1Y25hbWVdLnNsaWNlKCkgOiBbXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBuZXh0IG9jY3VycmVuY2UgYWZ0ZXIgdGhlIGdpdmVuIHJlY3VycmVuY2UgaWQuIFNlZSB0aGVcbiAgICogZ3VpZGUgb24ge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogTk9URTogQ3VycmVudGx5LCB0aGlzIG1ldGhvZCBpdGVyYXRlcyBhbGwgb2NjdXJyZW5jZXMgZnJvbSB0aGUgc3RhcnRcbiAgICogZGF0ZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gYSBsb29wIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcbiAgICogd291bGQgbGlrZSB0byBnZXQgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlLCB5b3UgY2FuIGl0ZXJhdGUgdGhlXG4gICAqIG9jY3VycmVuY2VzIG1hbnVhbGx5LCBzZWUgdGhlIGV4YW1wbGUgb24gdGhlXG4gICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZX0gYVN0YXJ0VGltZSAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBldmVudCBzZXJpZXNcbiAgICogQHBhcmFtIHtUaW1lfSBhUmVjdXJyZW5jZUlkICAgICBUaGUgZGF0ZSBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlXG4gICAqIEByZXR1cm4ge1RpbWV9ICAgICAgICAgICAgICAgICAgVGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlclxuICAgKi9cbiAgZ2V0TmV4dE9jY3VycmVuY2UoYVN0YXJ0VGltZSwgYVJlY3VycmVuY2VJZCkge1xuICAgIGxldCBpdGVyID0gdGhpcy5pdGVyYXRvcihhU3RhcnRUaW1lKTtcbiAgICBsZXQgbmV4dDtcblxuICAgIGRvIHtcbiAgICAgIG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICB9IHdoaWxlIChuZXh0ICYmIG5leHQuY29tcGFyZShhUmVjdXJyZW5jZUlkKSA8PSAwKTtcblxuICAgIGlmIChuZXh0ICYmIGFSZWN1cnJlbmNlSWQuem9uZSkge1xuICAgICAgbmV4dC56b25lID0gYVJlY3VycmVuY2VJZC56b25lO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtmcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgICAgICAgICAgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHt3ZWVrRGF5PX0gZGF0YS53a3N0ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtUaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltaW51dGUgICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aGRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGggICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBmcm9tRGF0YShkYXRhKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGRhdGEpIHtcbiAgICAgIGxldCB1Y2tleSA9IGtleS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICBpZiAodWNrZXkgaW4gcGFydERlc2lnbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgdGhpcy5wYXJ0c1t1Y2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJ0c1t1Y2tleV0gPSBbZGF0YVtrZXldXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1trZXldID0gZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmludGVydmFsICYmIHR5cGVvZiB0aGlzLmludGVydmFsICE9IFwibnVtYmVyXCIpIHtcbiAgICAgIG9wdGlvbkRlc2lnbi5JTlRFUlZBTCh0aGlzLmludGVydmFsLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53a3N0ICYmIHR5cGVvZiB0aGlzLndrc3QgIT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy53a3N0ID0gUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheSh0aGlzLndrc3QpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVudGlsICYmICEodGhpcy51bnRpbCBpbnN0YW5jZW9mIFRpbWUpKSB7XG4gICAgICB0aGlzLnVudGlsID0gVGltZS5mcm9tU3RyaW5nKHRoaXMudW50aWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgakNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3VycmVuY2UgdHlwZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGxldCByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlcy5mcmVxID0gdGhpcy5mcmVxO1xuXG4gICAgaWYgKHRoaXMuY291bnQpIHtcbiAgICAgIHJlcy5jb3VudCA9IHRoaXMuY291bnQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwgPiAxKSB7XG4gICAgICByZXMuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsO1xuICAgIH1cblxuICAgIGZvciAobGV0IFtrLCBrcGFydHNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucGFydHMpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrcGFydHMpICYmIGtwYXJ0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IGtwYXJ0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0gY2xvbmUoa3BhcnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgcmVzLnVudGlsID0gdGhpcy51bnRpbC50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoJ3drc3QnIGluIHRoaXMgJiYgdGhpcy53a3N0ICE9PSBUaW1lLkRFRkFVTFRfV0VFS19TVEFSVCkge1xuICAgICAgcmVzLndrc3QgPSBSZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3VycmVuY2UgcnVsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgLy8gVE9ETyByZXRhaW4gb3JkZXJcbiAgICBsZXQgc3RyID0gXCJGUkVRPVwiICsgdGhpcy5mcmVxO1xuICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICBzdHIgKz0gXCI7Q09VTlQ9XCIgKyB0aGlzLmNvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgIHN0ciArPSBcIjtJTlRFUlZBTD1cIiArIHRoaXMuaW50ZXJ2YWw7XG4gICAgfVxuICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnBhcnRzKSkge1xuICAgICAgc3RyICs9IFwiO1wiICsgayArIFwiPVwiICsgdjtcbiAgICB9XG4gICAgaWYgKHRoaXMudW50aWwpIHtcbiAgICAgIHN0ciArPSAnO1VOVElMPScgKyB0aGlzLnVudGlsLnRvSUNBTFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoJ3drc3QnIGluIHRoaXMgJiYgdGhpcy53a3N0ICE9PSBUaW1lLkRFRkFVTFRfV0VFS19TVEFSVCkge1xuICAgICAgc3RyICs9ICc7V0tTVD0nICsgUmVjdXIubnVtZXJpY0RheVRvSWNhbERheSh0aGlzLndrc3QpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtZXJpY1ZhbHVlKHR5cGUsIG1pbiwgbWF4LCB2YWx1ZSkge1xuICBsZXQgcmVzdWx0ID0gdmFsdWU7XG5cbiAgaWYgKHZhbHVlWzBdID09PSAnKycpIHtcbiAgICByZXN1bHQgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIHJlc3VsdCA9IHN0cmljdFBhcnNlSW50KHJlc3VsdCk7XG5cbiAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgdHlwZSArICc6IGludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgbXVzdCBiZSA+ICcgKyBtaW5cbiAgICApO1xuICB9XG5cbiAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgdHlwZSArICc6IGludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgbXVzdCBiZSA8ICcgKyBtaW5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3Qgb3B0aW9uRGVzaWduID0ge1xuICBGUkVROiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgIC8vIHllcyB0aGlzIGlzIGFjdHVhbGx5IGVxdWFsIG9yIGZhc3RlciB0aGVuIHJlZ2V4LlxuICAgIC8vIHVwc2lkZSBoZXJlIGlzIHdlIGNhbiBlbnVtZXJhdGUgdGhlIHZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQUxMT1dFRF9GUkVRLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgZGljdC5mcmVxID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZnJlcXVlbmN5IFwiJyArIHZhbHVlICsgJ1wiIGV4cGVjdGVkOiBcIicgK1xuICAgICAgICBBTExPV0VEX0ZSRVEuam9pbignLCAnKSArICdcIidcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIENPVU5UOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgIGRpY3QuY291bnQgPSBzdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gIH0sXG5cbiAgSU5URVJWQUw6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgZGljdC5pbnRlcnZhbCA9IHN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICBpZiAoZGljdC5pbnRlcnZhbCA8IDEpIHtcbiAgICAgIC8vIDAgb3IgbmVnYXRpdmUgdmFsdWVzIGFyZSBub3QgYWxsb3dlZCwgc29tZSBlbmdpbmVzIHNlZW0gdG8gZ2VuZXJhdGVcbiAgICAgIC8vIGl0IHRob3VnaC4gQXNzdW1lIDEgaW5zdGVhZC5cbiAgICAgIGRpY3QuaW50ZXJ2YWwgPSAxO1xuICAgIH1cbiAgfSxcblxuICBVTlRJTDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMTApIHtcbiAgICAgIGRpY3QudW50aWwgPSBkZXNpZ24kMS5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdC51bnRpbCA9IGRlc2lnbiQxLmljYWxlbmRhci52YWx1ZS5kYXRlLmZyb21JQ0FMKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFmbXRJY2FsKSB7XG4gICAgICBkaWN0LnVudGlsID0gVGltZS5mcm9tU3RyaW5nKGRpY3QudW50aWwpO1xuICAgIH1cbiAgfSxcblxuICBXS1NUOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgIGlmIChWQUxJRF9EQVlfTkFNRVMudGVzdCh2YWx1ZSkpIHtcbiAgICAgIGRpY3Qud2tzdCA9IFJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgV0tTVCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgcGFydERlc2lnbiA9IHtcbiAgQllTRUNPTkQ6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllTRUNPTkQnLCAwLCA2MCksXG4gIEJZTUlOVVRFOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgJ0JZTUlOVVRFJywgMCwgNTkpLFxuICBCWUhPVVI6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllIT1VSJywgMCwgMjMpLFxuICBCWURBWTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoVkFMSURfQllEQVlfUEFSVC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQllEQVkgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICB9XG4gIH0sXG4gIEJZTU9OVEhEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllNT05USERBWScsIC0zMSwgMzEpLFxuICBCWVlFQVJEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllZRUFSREFZJywgLTM2NiwgMzY2KSxcbiAgQllXRUVLTk86IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodW5kZWZpbmVkLCAnQllXRUVLTk8nLCAtNTMsIDUzKSxcbiAgQllNT05USDogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh1bmRlZmluZWQsICdCWU1PTlRIJywgMSwgMTIpLFxuICBCWVNFVFBPUzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh1bmRlZmluZWQsICdCWVNFVFBPUycsIC0zNjYsIDM2Nilcbn07XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5qQ2FsQ29tcG9uZW50fSBqQ2FsQ29tcG9uZW50XG4gKiBJbXBvcnRzIHRoZSAnb2NjdXJyZW5jZURldGFpbHMnIHR5cGUgZnJvbSB0aGUgXCJ0eXBlcy5qc1wiIG1vZHVsZVxuICovXG5cbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInBlcmlvZFwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvbiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgUGVyaW9kIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUGVyaW9kfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBwcm9wICAgICAgICAgVGhlIHByb3BlcnR5IHRoaXMgcGVyaW9kIHdpbGwgYmUgb25cbiAgICogQHJldHVybiB7UGVyaW9kfSAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCBwcm9wKSB7XG4gICAgbGV0IHBhcnRzID0gc3RyLnNwbGl0KCcvJyk7XG5cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIHN0cmluZyB2YWx1ZTogXCInICsgc3RyICsgJ1wiIG11c3QgY29udGFpbiBhIFwiL1wiIGNoYXIuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBUaW1lLmZyb21EYXRlVGltZVN0cmluZyhwYXJ0c1swXSwgcHJvcClcbiAgICB9O1xuXG4gICAgbGV0IGVuZCA9IHBhcnRzWzFdO1xuXG4gICAgaWYgKER1cmF0aW9uLmlzVmFsdWVTdHJpbmcoZW5kKSkge1xuICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IER1cmF0aW9uLmZyb21TdHJpbmcoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5lbmQgPSBUaW1lLmZyb21EYXRlVGltZVN0cmluZyhlbmQsIHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUGVyaW9kKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUGVyaW9kfSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICogVGhlIHBhc3NlZCBkYXRhIG9iamVjdCBjYW5ub3QgY29udGFpbiBib3RoIGFuZCBlbmQgZGF0ZSBhbmQgYSBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7VGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7VGltZT19IGFEYXRhLmVuZCAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHBlcmlvZFxuICAgKiBAcmV0dXJuIHtQZXJpb2R9ICAgICAgICAgICAgICAgICAgICAgICBUaGUgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IFBlcmlvZChhRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBwZXJpb2QgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gakNhbCBkYXRhIGFycmF5LiBUaGUgZmlyc3RcbiAgICogbWVtYmVyIGlzIGFsd2F5cyB0aGUgc3RhcnQgZGF0ZSBzdHJpbmcsIHRoZSBzZWNvbmQgbWVtYmVyIGlzIGVpdGhlciBhXG4gICAqIGR1cmF0aW9uIG9yIGVuZCBkYXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtqQ2FsQ29tcG9uZW50fSBhRGF0YSAgICAgICAgICAgVGhlIGpDYWwgZGF0YSBhcnJheVxuICAgKiBAcGFyYW0ge1Byb3BlcnR5fSBhUHJvcCAgICAgICAgICAgICAgICBUaGUgcHJvcGVydHkgdGhpcyBqQ2FsIGRhdGEgaXMgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBhTGVuaWVudCAgICAgICAgICAgICAgSWYgdHJ1ZSwgZGF0YSB2YWx1ZSBjYW4gYmUgYm90aCBkYXRlIGFuZCBkYXRlLXRpbWVcbiAgICogQHJldHVybiB7UGVyaW9kfSAgICAgICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21KU09OKGFEYXRhLCBhUHJvcCwgYUxlbmllbnQpIHtcbiAgICBmdW5jdGlvbiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBkYXRlUHJvcCkge1xuICAgICAgaWYgKGFMZW5pZW50KSB7XG4gICAgICAgIHJldHVybiBUaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBkYXRlUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBkYXRlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKER1cmF0aW9uLmlzVmFsdWVTdHJpbmcoYURhdGFbMV0pKSB7XG4gICAgICByZXR1cm4gUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBkdXJhdGlvbjogRHVyYXRpb24uZnJvbVN0cmluZyhhRGF0YVsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBlbmQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVsxXSwgYVByb3ApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlBlcmlvZCBpbnN0YW5jZS4gVGhlIHBhc3NlZCBkYXRhIG9iamVjdCBjYW5ub3QgY29udGFpbiBib3RoIGFuZCBlbmQgZGF0ZSBhbmRcbiAgICogYSBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7VGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7VGltZT19IGFEYXRhLmVuZCAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHBlcmlvZFxuICAgKi9cbiAgY29uc3RydWN0b3IoYURhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG5cbiAgICBpZiAoYURhdGEgJiYgJ3N0YXJ0JyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLnN0YXJ0ICYmICEoYURhdGEuc3RhcnQgaW5zdGFuY2VvZiBUaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuc3RhcnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLlRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnQgPSBhRGF0YS5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgYURhdGEuZW5kICYmIGFEYXRhLmR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhY2NlcHQgYm90aCBlbmQgYW5kIGR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdlbmQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuZW5kICYmICEoYURhdGEuZW5kIGluc3RhbmNlb2YgVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmVuZCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIElDQUwuVGltZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBhRGF0YS5lbmQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdkdXJhdGlvbicgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5kdXJhdGlvbiAmJiAhKGFEYXRhLmR1cmF0aW9uIGluc3RhbmNlb2YgRHVyYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJy5kdXJhdGlvbiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIElDQUwuRHVyYXRpb24nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHVyYXRpb24gPSBhRGF0YS5kdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAdHlwZSB7VGltZX1cbiAgICovXG4gIHN0YXJ0ID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGVuZCBvZiB0aGUgcGVyaW9kXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKi9cbiAgZW5kID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICogQHR5cGUge0R1cmF0aW9ufVxuICAgKi9cbiAgZHVyYXRpb24gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IFwiaWNhbHBlcmlvZFwiXG4gICAqL1xuICBpY2FsY2xhc3MgPSBcImljYWxwZXJpb2RcIjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcInBlcmlvZFwiXG4gICAqL1xuICBpY2FsdHlwZSA9IFwicGVyaW9kXCI7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgZHVyYXRpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQZXJpb2R9ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBQZXJpb2QuZnJvbURhdGEoe1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgPyB0aGlzLnN0YXJ0LmNsb25lKCkgOiBudWxsLFxuICAgICAgZW5kOiB0aGlzLmVuZCA/IHRoaXMuZW5kLmNsb25lKCkgOiBudWxsLFxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24gPyB0aGlzLmR1cmF0aW9uLmNsb25lKCkgOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhlIHBlcmlvZCwgZWl0aGVyIGRpcmVjdGx5IG9yIGJ5IHN1YnRyYWN0aW5nXG4gICAqIHN0YXJ0IGZyb20gZW5kIGRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufSAgICAgIFRoZSBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAqL1xuICBnZXREdXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5kdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZC5zdWJ0cmFjdERhdGUodGhpcy5zdGFydCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGVuZCBkYXRlIG9mIHRoZSBwZXJpb2QsIGVpdGhlciBkaXJlY3RseSBvciBieSBhZGRpbmdcbiAgICogZHVyYXRpb24gdG8gc3RhcnQgZGF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7VGltZX0gICAgICAgICAgVGhlIGNhbGN1bGF0ZWQgZW5kIGRhdGVcbiAgICovXG4gIGdldEVuZCgpIHtcbiAgICBpZiAodGhpcy5lbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVuZCA9IHRoaXMuc3RhcnQuY2xvbmUoKTtcbiAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgXCIvXCIgKyAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QgdHlwZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBbdGhpcy5zdGFydC50b1N0cmluZygpLCAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbikudG9TdHJpbmcoKV07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlDYWxlbmRhciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSUNBTFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydC50b0lDQUxTdHJpbmcoKSArIFwiL1wiICtcbiAgICAgICAgICAgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvSUNBTFN0cmluZygpO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5kZXNpZ25TZXR9IGRlc2lnblNldFxuICogSW1wb3J0cyB0aGUgJ2Rlc2lnblNldCcgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuLyoqIEBtb2R1bGUgSUNBTC5kZXNpZ24gKi9cblxuY29uc3QgRlJPTV9JQ0FMX05FV0xJTkUgPSAvXFxcXFxcXFx8XFxcXDt8XFxcXCx8XFxcXFtObl0vZztcbmNvbnN0IFRPX0lDQUxfTkVXTElORSA9IC9cXFxcfDt8LHxcXG4vZztcbmNvbnN0IEZST01fVkNBUkRfTkVXTElORSA9IC9cXFxcXFxcXHxcXFxcLHxcXFxcW05uXS9nO1xuY29uc3QgVE9fVkNBUkRfTkVXTElORSA9IC9cXFxcfCx8XFxuL2c7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRUeXBlKGZyb21OZXdsaW5lLCB0b05ld2xpbmUpIHtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICBtYXRjaGVzOiAvLiovLFxuXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VOZXdsaW5lKGFWYWx1ZSwgZnJvbU5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAgICAgbGV0IHJlZ0V4ID0gdG9OZXdsaW5lO1xuICAgICAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgICAgICByZWdFeCA9IG5ldyBSZWdFeHAocmVnRXguc291cmNlICsgJ3wnICsgc3RydWN0dXJlZEVzY2FwZSwgcmVnRXguZmxhZ3MpO1xuICAgICAgcmV0dXJuIGFWYWx1ZS5yZXBsYWNlKHJlZ0V4LCBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc3dpdGNoIChzdHIpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFw7XCI7XG4gICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXCxcIjtcbiAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGRlZmF1bHQgdHlwZXMgdXNlZCBtdWx0aXBsZSB0aW1lc1xuY29uc3QgREVGQVVMVF9UWVBFX1RFWFQgPSB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiB9O1xuY29uc3QgREVGQVVMVF9UWVBFX1RFWFRfTVVMVEkgPSB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQgPSB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9O1xuY29uc3QgREVGQVVMVF9UWVBFX0lOVEVHRVIgPSB7IGRlZmF1bHRUeXBlOiBcImludGVnZXJcIiB9O1xuY29uc3QgREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLCBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0gfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9EQVRFVElNRSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9VUkkgPSB7IGRlZmF1bHRUeXBlOiBcInVyaVwiIH07XG5jb25zdCBERUZBVUxUX1RZUEVfVVRDT0ZGU0VUID0geyBkZWZhdWx0VHlwZTogXCJ1dGMtb2Zmc2V0XCIgfTtcbmNvbnN0IERFRkFVTFRfVFlQRV9SRUNVUiA9IHsgZGVmYXVsdFR5cGU6IFwicmVjdXJcIiB9O1xuY29uc3QgREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS1hbmQtb3ItdGltZVwiLCBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIiwgXCJ0ZXh0XCJdIH07XG5cbmZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lUmVwbGFjZShzdHJpbmcpIHtcbiAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICBjYXNlIFwiXFxcXFxcXFxcIjpcbiAgICAgIHJldHVybiBcIlxcXFxcIjtcbiAgICBjYXNlIFwiXFxcXDtcIjpcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICBjYXNlIFwiXFxcXCxcIjpcbiAgICAgIHJldHVybiBcIixcIjtcbiAgICBjYXNlIFwiXFxcXG5cIjpcbiAgICBjYXNlIFwiXFxcXE5cIjpcbiAgICAgIHJldHVybiBcIlxcblwiO1xuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0cmluZztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlTmV3bGluZSh2YWx1ZSwgbmV3bGluZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAvLyBhdm9pZCByZWdleCB3aGVuIHBvc3NpYmxlLlxuICBpZiAodmFsdWUuaW5kZXhPZignXFxcXCcpID09PSAtMSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoc3RydWN0dXJlZEVzY2FwZSlcbiAgICAgbmV3bGluZSA9IG5ldyBSZWdFeHAobmV3bGluZS5zb3VyY2UgKyAnfFxcXFxcXFxcJyArIHN0cnVjdHVyZWRFc2NhcGUsIG5ld2xpbmUuZmxhZ3MpO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShuZXdsaW5lLCByZXBsYWNlTmV3bGluZVJlcGxhY2UpO1xufVxuXG5sZXQgY29tbW9uUHJvcGVydGllcyA9IHtcbiAgXCJjYXRlZ29yaWVzXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICBcInVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcInZlcnNpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwidWlkXCI6IERFRkFVTFRfVFlQRV9URVhUXG59O1xuXG5sZXQgY29tbW9uVmFsdWVzID0ge1xuICBcImJvb2xlYW5cIjoge1xuICAgIHZhbHVlczogW1wiVFJVRVwiLCBcIkZBTFNFXCJdLFxuXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgc3dpdGNoIChhVmFsdWUpIHtcbiAgICAgICAgY2FzZSAnVFJVRSc6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ0ZBTFNFJzpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy9UT0RPOiBwYXJzZXIgd2FybmluZ1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGlmIChhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdUUlVFJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnRkFMU0UnO1xuICAgIH1cblxuICB9LFxuICBmbG9hdDoge1xuICAgIG1hdGNoZXM6IC9eWystXT9cXGQrXFwuXFxkKyQvLFxuXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgbGV0IHBhcnNlZCA9IHBhcnNlRmxvYXQoYVZhbHVlKTtcbiAgICAgIGlmIChpc1N0cmljdGx5TmFOKHBhcnNlZCkpIHtcbiAgICAgICAgLy8gVE9ETzogcGFyc2VyIHdhcm5pbmdcbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGFWYWx1ZSk7XG4gICAgfVxuICB9LFxuICBpbnRlZ2VyOiB7XG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgbGV0IHBhcnNlZCA9IHBhcnNlSW50KGFWYWx1ZSk7XG4gICAgICBpZiAoaXNTdHJpY3RseU5hTihwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIFwidXRjLW9mZnNldFwiOiB7XG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNykge1xuICAgICAgICAvLyBubyBzZWNvbmRzXG4gICAgICAgIC8vIC0wNTAwXG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgMykgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDQsIDYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAvLyAtMDUwMDAwXG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgMykgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDQsIDYpICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg3LCA5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA2KSB7XG4gICAgICAgIC8vIG5vIHNlY29uZHNcbiAgICAgICAgLy8gLTA1OjAwXG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgMykgKyAnOicgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDMsIDUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAvLyAtMDU6MDA6MDBcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5zbGljZSgwLCAzKSArICc6JyArXG4gICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoMywgNSkgKyAnOicgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDUsIDcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gVXRjT2Zmc2V0LmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICB9LFxuXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG59O1xuXG5sZXQgaWNhbFBhcmFtcyA9IHtcbiAgLy8gQWx0aG91Z2ggdGhlIHN5bnRheCBpcyBEUVVPVEUgdXJpIERRVU9URSwgSSBkb24ndCB0aGluayB3ZSBzaG91bGRcbiAgLy8gZW5mb3JjZSBhbnl0aGluZyBhc2lkZSBmcm9tIGl0IGJlaW5nIGEgdmFsaWQgY29udGVudCBsaW5lLlxuICAvL1xuICAvLyBBdCBsZWFzdCBzb21lIHBhcmFtcyByZXF1aXJlIC0gaWYgbXVsdGkgdmFsdWVzIGFyZSB1c2VkIC0gRFFVT1RFc1xuICAvLyBmb3IgZWFjaCBvZiBpdHMgdmFsdWVzIC0gZS5nLiBkZWxlZ2F0ZWQtZnJvbT1cInVyaTFcIixcInVyaTJcIlxuICAvLyBUbyBpbmRpY2F0ZSB0aGlzLCBJIGludHJvZHVjZWQgdGhlIG5ldyBrL3YgcGFpclxuICAvLyBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgLy9cbiAgLy8gXCJBTFRSRVBcIjogeyAuLi4gfSxcblxuICAvLyBDTiBqdXN0IHdhbnRzIGEgcGFyYW0tdmFsdWVcbiAgLy8gXCJDTlwiOiB7IC4uLiB9XG5cbiAgXCJjdXR5cGVcIjoge1xuICAgIHZhbHVlczogW1wiSU5ESVZJRFVBTFwiLCBcIkdST1VQXCIsIFwiUkVTT1VSQ0VcIiwgXCJST09NXCIsIFwiVU5LTk9XTlwiXSxcbiAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gIH0sXG5cbiAgXCJkZWxlZ2F0ZWQtZnJvbVwiOiB7XG4gICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gIH0sXG4gIFwiZGVsZWdhdGVkLXRvXCI6IHtcbiAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgfSxcbiAgLy8gXCJESVJcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICBcImVuY29kaW5nXCI6IHtcbiAgICB2YWx1ZXM6IFtcIjhCSVRcIiwgXCJCQVNFNjRcIl1cbiAgfSxcbiAgLy8gXCJGTVRUWVBFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgXCJmYnR5cGVcIjoge1xuICAgIHZhbHVlczogW1wiRlJFRVwiLCBcIkJVU1lcIiwgXCJCVVNZLVVOQVZBSUxBQkxFXCIsIFwiQlVTWS1URU5UQVRJVkVcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9LFxuICAvLyBcIkxBTkdVQUdFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgXCJtZW1iZXJcIjoge1xuICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICB9LFxuICBcInBhcnRzdGF0XCI6IHtcbiAgICAvLyBUT0RPIFRoZXNlIHZhbHVlcyBhcmUgYWN0dWFsbHkgZGlmZmVyZW50IHBlci1jb21wb25lbnRcbiAgICB2YWx1ZXM6IFtcIk5FRURTLUFDVElPTlwiLCBcIkFDQ0VQVEVEXCIsIFwiREVDTElORURcIiwgXCJURU5UQVRJVkVcIixcbiAgICAgICAgICAgICBcIkRFTEVHQVRFRFwiLCBcIkNPTVBMRVRFRFwiLCBcIklOLVBST0NFU1NcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9LFxuICBcInJhbmdlXCI6IHtcbiAgICB2YWx1ZXM6IFtcIlRISVNBTkRGVVRVUkVcIl1cbiAgfSxcbiAgXCJyZWxhdGVkXCI6IHtcbiAgICB2YWx1ZXM6IFtcIlNUQVJUXCIsIFwiRU5EXCJdXG4gIH0sXG4gIFwicmVsdHlwZVwiOiB7XG4gICAgdmFsdWVzOiBbXCJQQVJFTlRcIiwgXCJDSElMRFwiLCBcIlNJQkxJTkdcIl0sXG4gICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICB9LFxuICBcInJvbGVcIjoge1xuICAgIHZhbHVlczogW1wiUkVRLVBBUlRJQ0lQQU5UXCIsIFwiQ0hBSVJcIixcbiAgICAgICAgICAgICBcIk9QVC1QQVJUSUNJUEFOVFwiLCBcIk5PTi1QQVJUSUNJUEFOVFwiXSxcbiAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gIH0sXG4gIFwicnN2cFwiOiB7XG4gICAgdmFsdWVzOiBbXCJUUlVFXCIsIFwiRkFMU0VcIl1cbiAgfSxcbiAgXCJzZW50LWJ5XCI6IHtcbiAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIlxuICB9LFxuICBcInR6aWRcIjoge1xuICAgIG1hdGNoZXM6IC9eXFwvL1xuICB9LFxuICBcInZhbHVlXCI6IHtcbiAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICB2YWx1ZXM6IFtcImJpbmFyeVwiLCBcImJvb2xlYW5cIiwgXCJjYWwtYWRkcmVzc1wiLCBcImRhdGVcIiwgXCJkYXRlLXRpbWVcIixcbiAgICAgICAgICAgICBcImR1cmF0aW9uXCIsIFwiZmxvYXRcIiwgXCJpbnRlZ2VyXCIsIFwicGVyaW9kXCIsIFwicmVjdXJcIiwgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgXCJ0aW1lXCIsIFwidXJpXCIsIFwidXRjLW9mZnNldFwiXSxcbiAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gIH1cbn07XG5cbi8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbmNvbnN0IGljYWxWYWx1ZXMgPSBleHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fSUNBTF9ORVdMSU5FLCBUT19JQ0FMX05FV0xJTkUpLFxuXG4gIHVyaToge1xuICAgIC8vIFRPRE9cbiAgICAvKiAuLi4gKi9cbiAgfSxcblxuICBcImJpbmFyeVwiOiB7XG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICAgIHJldHVybiBCaW5hcnkuZnJvbVN0cmluZyhhU3RyaW5nKTtcbiAgICB9LFxuXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYUJpbmFyeSkge1xuICAgICAgcmV0dXJuIGFCaW5hcnkudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIFwiY2FsLWFkZHJlc3NcIjoge1xuICAgIC8vIG5lZWRzIHRvIGJlIGFuIHVyaVxuICB9LFxuICBcImRhdGVcIjoge1xuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICBpZiAoZGVzaWduLnN0cmljdCkge1xuICAgICAgICByZXR1cm4gVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBUaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuZGVjb3JhdGVzIGEgdGltZSBvYmplY3QuXG4gICAgICovXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIC8vIGZyb206IDIwMTIwOTAxXG4gICAgICAvLyB0bzogMjAxMi0wOS0wMVxuICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIGFWYWx1ZS5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGRhdGUtdGltZSwgZS5nLiAyMDEyMDkwMVQxMzAwMDBaXG4gICAgICAgIHJldHVybiBpY2FsVmFsdWVzW1wiZGF0ZS10aW1lXCJdLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnNsaWNlKDAsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg0LCA2KSArICctJyArXG4gICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoNiwgOCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAvLyBmcm9tOiAyMDEyLTA5LTAxXG4gICAgICAvLyB0bzogMjAxMjA5MDFcbiAgICAgIGxldCBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICBpZiAobGVuID09IDEwKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgNCkgK1xuICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDUsIDcpICtcbiAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg4LCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICByZXR1cm4gaWNhbFZhbHVlc1tcImRhdGUtdGltZVwiXS50b0lDQUwoYVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vVE9ETzogc2VyaWFsaXplIHdhcm5pbmc/XG4gICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICB9XG5cbiAgICB9XG4gIH0sXG4gIFwiZGF0ZS10aW1lXCI6IHtcbiAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAvLyBmcm9tOiAyMDEyMDkwMVQxMzAwMDBcbiAgICAgIC8vIHRvOiAyMDEyLTA5LTAxVDEzOjAwOjAwXG4gICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBkYXRlLCBlLmcuIDIwMTIwOTAxXG4gICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUuZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhVmFsdWUuc2xpY2UoMCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDQsIDYpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSg2LCA4KSArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc2xpY2UoOSwgMTEpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgxMSwgMTMpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgxMywgMTUpO1xuXG4gICAgICAgIGlmIChhVmFsdWVbMTVdICYmIGFWYWx1ZVsxNV0gPT09ICdaJykge1xuICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgLy8gZnJvbTogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgLy8gdG86IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgbGV0IGxlbiA9IGFWYWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW4gPT0gMTAgJiYgIWRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwoYVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuID49IDE5KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhVmFsdWUuc2xpY2UoMCwgNCkgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDUsIDcpICtcbiAgICAgICAgICAgICAgICAgICAgIC8vIGdyYWIgdGhlIChERFRISCkgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDgsIDEzKSArXG4gICAgICAgICAgICAgICAgICAgICAvLyBNTVxuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDE0LCAxNikgK1xuICAgICAgICAgICAgICAgICAgICAgLy8gU1NcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgxNywgMTkpO1xuXG4gICAgICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IGVycm9yXG4gICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICBpZiAoZGVzaWduLnN0cmljdCkge1xuICAgICAgICByZXR1cm4gVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVGltZS5mcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uOiB7XG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICB9LFxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgfSxcbiAgcGVyaW9kOiB7XG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgbGV0IHBhcnRzID0gc3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHBhcnRzWzBdKTtcblxuICAgICAgaWYgKCFEdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKHBhcnRzWzFdKSkge1xuICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHBhcnRzWzFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICBwYXJ0cyA9IHBhcnRzLnNsaWNlKCk7XG4gICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMF0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1swXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghRHVyYXRpb24uaXNWYWx1ZVN0cmluZyhwYXJ0c1sxXSkpIHtcbiAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIHBhcnRzWzFdLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHNbMV0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwocGFydHNbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiL1wiKTtcbiAgICB9LFxuXG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgIHJldHVybiBQZXJpb2QuZnJvbUpTT04oYVZhbHVlLCBhUHJvcCwgIWRlc2lnbi5zdHJpY3QpO1xuICAgIH0sXG5cbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUudG9KU09OKCk7XG4gICAgfVxuICB9LFxuICByZWN1cjoge1xuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiBSZWN1ci5fc3RyaW5nVG9EYXRhKHN0cmluZywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBbaywgdmFsXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICBpZiAoayA9PSBcInVudGlsXCIpIHtcbiAgICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICB2YWwgPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwodmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrID09IFwid2tzdFwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWwgPSBSZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgIHZhbCA9IHZhbC5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gay50b1VwcGVyQ2FzZSgpICsgXCI9XCIgKyB2YWwgKyBcIjtcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgTWF0aC5tYXgoMCwgc3RyLmxlbmd0aCAtIDEpKTtcbiAgICB9LFxuXG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uIGRlY29yYXRlKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFJlY3VyLmZyb21EYXRhKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFSZWN1cikge1xuICAgICAgcmV0dXJuIGFSZWN1ci50b0pTT04oKTtcbiAgICB9XG4gIH0sXG5cbiAgdGltZToge1xuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIC8vIGZyb206IE1NSEhTUyhaKT9cbiAgICAgIC8vIHRvOiBISDpNTTpTUyhaKT9cbiAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNikge1xuICAgICAgICAvLyBUT0RPOiBwYXJzZXIgZXhjZXB0aW9uP1xuICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBISDo6TU06OlNTWj9cbiAgICAgIGxldCByZXN1bHQgPSBhVmFsdWUuc2xpY2UoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgyLCA0KSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDQsIDYpO1xuXG4gICAgICBpZiAoYVZhbHVlWzZdID09PSAnWicpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIC8vIGZyb206IEhIOk1NOlNTKFopP1xuICAgICAgLy8gdG86IE1NSEhTUyhaKT9cbiAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgOCkge1xuICAgICAgICAvL1RPRE86IGVycm9yXG4gICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBhVmFsdWUuc2xpY2UoMCwgMikgK1xuICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zbGljZSgzLCA1KSArXG4gICAgICAgICAgICAgICAgICAgYVZhbHVlLnNsaWNlKDYsIDgpO1xuXG4gICAgICBpZiAoYVZhbHVlWzhdID09PSAnWicpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn0pO1xuXG5sZXQgaWNhbFByb3BlcnRpZXMgPSBleHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuXG4gIFwiYWN0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImF0dGFjaFwiOiB7IGRlZmF1bHRUeXBlOiBcInVyaVwiIH0sXG4gIFwiYXR0ZW5kZWVcIjogeyBkZWZhdWx0VHlwZTogXCJjYWwtYWRkcmVzc1wiIH0sXG4gIFwiY2Fsc2NhbGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwiY2xhc3NcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwiY29tbWVudFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJjb21wbGV0ZWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICBcImNvbnRhY3RcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwiY3JlYXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gIFwiZGVzY3JpcHRpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwiZHRlbmRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gIFwiZHRzdGFtcFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gIFwiZHRzdGFydFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSxcbiAgXCJkdWVcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gIFwiZHVyYXRpb25cIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiIH0sXG4gIFwiZXhkYXRlXCI6IHtcbiAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgbXVsdGlWYWx1ZTogJywnXG4gIH0sXG4gIFwiZXhydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgXCJmcmVlYnVzeVwiOiB7IGRlZmF1bHRUeXBlOiBcInBlcmlvZFwiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICBcImdlb1wiOiB7IGRlZmF1bHRUeXBlOiBcImZsb2F0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcbiAgXCJsYXN0LW1vZGlmaWVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgXCJsb2NhdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJtZXRob2RcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwib3JnYW5pemVyXCI6IHsgZGVmYXVsdFR5cGU6IFwiY2FsLWFkZHJlc3NcIiB9LFxuICBcInBlcmNlbnQtY29tcGxldGVcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gIFwicHJpb3JpdHlcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gIFwicHJvZGlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInJlbGF0ZWQtdG9cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwicmVwZWF0XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICBcInJkYXRlXCI6IHtcbiAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIiwgXCJwZXJpb2RcIl0sXG4gICAgbXVsdGlWYWx1ZTogJywnLFxuICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiAncGVyaW9kJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgfVxuICB9LFxuICBcInJlY3VycmVuY2UtaWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gIFwicmVzb3VyY2VzXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICBcInJlcXVlc3Qtc3RhdHVzXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gIFwicnJ1bGVcIjogREVGQVVMVF9UWVBFX1JFQ1VSLFxuICBcInNlcXVlbmNlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICBcInN0YXR1c1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJzdW1tYXJ5XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInRyYW5zcFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJ0cmlnZ2VyXCI6IHsgZGVmYXVsdFR5cGU6IFwiZHVyYXRpb25cIiwgYWxsb3dlZFR5cGVzOiBbXCJkdXJhdGlvblwiLCBcImRhdGUtdGltZVwiXSB9LFxuICBcInR6b2Zmc2V0ZnJvbVwiOiBERUZBVUxUX1RZUEVfVVRDT0ZGU0VULFxuICBcInR6b2Zmc2V0dG9cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgXCJ0enVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcInR6aWRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwidHpuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUXG59KTtcblxuLy8gV2hlbiBhZGRpbmcgYSB2YWx1ZSBoZXJlLCBiZSBzdXJlIHRvIGFkZCBpdCB0byB0aGUgcGFyYW1ldGVyIHR5cGVzIVxuY29uc3QgdmNhcmRWYWx1ZXMgPSBleHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fVkNBUkRfTkVXTElORSwgVE9fVkNBUkRfTkVXTElORSksXG4gIHVyaTogY3JlYXRlVGV4dFR5cGUoRlJPTV9WQ0FSRF9ORVdMSU5FLCBUT19WQ0FSRF9ORVdMSU5FKSxcblxuICBkYXRlOiB7XG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIFwiZGF0ZVwiKTtcbiAgICB9LFxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFWYWx1ZVswXSA9PSAnLScgJiYgYVZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgNCkgKyAnLScgKyBhVmFsdWUuc2xpY2UoNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGlmIChhVmFsdWUubGVuZ3RoID09IDEwKSB7XG4gICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKGFWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFWYWx1ZVswXSA9PSAnLScgJiYgYVZhbHVlLmxlbmd0aCA9PSA3KSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUuc2xpY2UoMCwgNCkgKyBhVmFsdWUuc2xpY2UoNSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0aW1lOiB7XG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhcIlRcIiArIGFWYWx1ZSwgXCJ0aW1lXCIpO1xuICAgIH0sXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICBsZXQgc3BsaXR6b25lID0gdmNhcmRWYWx1ZXMudGltZS5fc3BsaXRab25lKGFWYWx1ZSwgdHJ1ZSk7XG4gICAgICBsZXQgem9uZSA9IHNwbGl0em9uZVswXSwgdmFsdWUgPSBzcGxpdHpvbmVbMV07XG5cbiAgICAgIC8vY29uc29sZS5sb2coXCJTUExJVDogXCIsc3BsaXR6b25lKTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDIsIDQpICsgJzonICtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSg0LCA2KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDQgJiYgdmFsdWVbMF0gIT0gJy0nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgMikgKyAnOicgKyB2YWx1ZS5zbGljZSgyLCA0KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAzKSArICc6JyArIHZhbHVlLnNsaWNlKDMsIDUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoem9uZS5sZW5ndGggPT0gNSAmJiAoem9uZVswXSA9PSAnLScgfHwgem9uZVswXSA9PSAnKycpKSB7XG4gICAgICAgIHpvbmUgPSB6b25lLnNsaWNlKDAsIDMpICsgJzonICsgem9uZS5zbGljZSgzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICB9LFxuXG4gICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIGxldCBzcGxpdHpvbmUgPSB2Y2FyZFZhbHVlcy50aW1lLl9zcGxpdFpvbmUoYVZhbHVlKTtcbiAgICAgIGxldCB6b25lID0gc3BsaXR6b25lWzBdLCB2YWx1ZSA9IHNwbGl0em9uZVsxXTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgMikgK1xuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDMsIDUpICtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSg2LCA4KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDUgJiYgdmFsdWVbMF0gIT0gJy0nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgMikgKyB2YWx1ZS5zbGljZSgzLCA1KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAzKSArIHZhbHVlLnNsaWNlKDQsIDYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoem9uZS5sZW5ndGggPT0gNiAmJiAoem9uZVswXSA9PSAnLScgfHwgem9uZVswXSA9PSAnKycpKSB7XG4gICAgICAgIHpvbmUgPSB6b25lLnNsaWNlKDAsIDMpICsgem9uZS5zbGljZSg0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICB9LFxuXG4gICAgX3NwbGl0Wm9uZTogZnVuY3Rpb24oYVZhbHVlLCBpc0Zyb21JY2FsKSB7XG4gICAgICBsZXQgbGFzdENoYXIgPSBhVmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBzaWduQ2hhciA9IGFWYWx1ZS5sZW5ndGggLSAoaXNGcm9tSWNhbCA/IDUgOiA2KTtcbiAgICAgIGxldCBzaWduID0gYVZhbHVlW3NpZ25DaGFyXTtcbiAgICAgIGxldCB6b25lLCB2YWx1ZTtcblxuICAgICAgaWYgKGFWYWx1ZVtsYXN0Q2hhcl0gPT0gJ1onKSB7XG4gICAgICAgIHpvbmUgPSBhVmFsdWVbbGFzdENoYXJdO1xuICAgICAgICB2YWx1ZSA9IGFWYWx1ZS5zbGljZSgwLCBNYXRoLm1heCgwLCBsYXN0Q2hhcikpO1xuICAgICAgfSBlbHNlIGlmIChhVmFsdWUubGVuZ3RoID4gNiAmJiAoc2lnbiA9PSAnLScgfHwgc2lnbiA9PSAnKycpKSB7XG4gICAgICAgIHpvbmUgPSBhVmFsdWUuc2xpY2Uoc2lnbkNoYXIpO1xuICAgICAgICB2YWx1ZSA9IGFWYWx1ZS5zbGljZSgwLCBNYXRoLm1heCgwLCBzaWduQ2hhcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9uZSA9IFwiXCI7XG4gICAgICAgIHZhbHVlID0gYVZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3pvbmUsIHZhbHVlXTtcbiAgICB9XG4gIH0sXG5cbiAgXCJkYXRlLXRpbWVcIjoge1xuICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBWQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGUtdGltZVwiKTtcbiAgICB9LFxuXG4gICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiB2Y2FyZFZhbHVlc1snZGF0ZS1hbmQtb3ItdGltZSddLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gdmNhcmRWYWx1ZXNbJ2RhdGUtYW5kLW9yLXRpbWUnXS50b0lDQUwoYVZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgXCJkYXRlLWFuZC1vci10aW1lXCI6IHtcbiAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlLWFuZC1vci10aW1lXCIpO1xuICAgIH0sXG5cbiAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgbGV0IHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICByZXR1cm4gKHBhcnRzWzBdID8gdmNhcmRWYWx1ZXMuZGF0ZS5mcm9tSUNBTChwYXJ0c1swXSkgOiAnJykgK1xuICAgICAgICAgICAgIChwYXJ0c1sxXSA/ICdUJyArIHZjYXJkVmFsdWVzLnRpbWUuZnJvbUlDQUwocGFydHNbMV0pIDogJycpO1xuICAgIH0sXG5cbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgbGV0IHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICByZXR1cm4gdmNhcmRWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pICtcbiAgICAgICAgICAgICAocGFydHNbMV0gPyAnVCcgKyB2Y2FyZFZhbHVlcy50aW1lLnRvSUNBTChwYXJ0c1sxXSkgOiAnJyk7XG5cbiAgICB9XG4gIH0sXG4gIHRpbWVzdGFtcDogaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10sXG4gIFwibGFuZ3VhZ2UtdGFnXCI6IHtcbiAgICBtYXRjaGVzOiAvXlthLXpBLVowLTktXSskLyAvLyBDb3VsZCBnbyB3aXRoIGEgbW9yZSBzdHJpY3QgcmVnZXggaGVyZVxuICB9LFxuICBcInBob25lLW51bWJlclwiOiB7XG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oYVZhbHVlKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBjID09PSAnXFxcXCcgPyB1bmRlZmluZWQgOiBjO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICB9LFxuICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhVmFsdWUpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAnLCcgfHwgYyA9PT0gXCI7XCIgPyAnXFxcXCcgKyBjIDogYztcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufSk7XG5cbmxldCB2Y2FyZFBhcmFtcyA9IHtcbiAgXCJ0eXBlXCI6IHtcbiAgICB2YWx1ZVR5cGU6IFwidGV4dFwiLFxuICAgIG11bHRpVmFsdWU6IFwiLFwiXG4gIH0sXG4gIFwidmFsdWVcIjoge1xuICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgIHZhbHVlczogW1widGV4dFwiLCBcInVyaVwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZS10aW1lXCIsIFwiZGF0ZS1hbmQtb3ItdGltZVwiLFxuICAgICAgICAgICAgIFwidGltZXN0YW1wXCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIixcbiAgICAgICAgICAgICBcImxhbmd1YWdlLXRhZ1wiXSxcbiAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gIH1cbn07XG5cbmxldCB2Y2FyZFByb3BlcnRpZXMgPSBleHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuICBcImFkclwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgXCJhbm5pdmVyc2FyeVwiOiBERUZBVUxUX1RZUEVfREFURV9BTkRPUl9USU1FLFxuICBcImJkYXlcIjogREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSxcbiAgXCJjYWxhZHJ1cmlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJjYWx1cmlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJjbGllbnRwaWRtYXBcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgXCJlbWFpbFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgXCJmYnVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcImZuXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImdlbmRlclwiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICBcImdlb1wiOiBERUZBVUxUX1RZUEVfVVJJLFxuICBcImltcHBcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJrZXlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJraW5kXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcImxhbmdcIjogeyBkZWZhdWx0VHlwZTogXCJsYW5ndWFnZS10YWdcIiB9LFxuICBcImxvZ29cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJtZW1iZXJcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJuXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICBcIm5pY2tuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICBcIm5vdGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIFwib3JnXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gIFwicGhvdG9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgXCJyZWxhdGVkXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwicmV2XCI6IHsgZGVmYXVsdFR5cGU6IFwidGltZXN0YW1wXCIgfSxcbiAgXCJyb2xlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInNvdW5kXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwic291cmNlXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gIFwidGVsXCI6IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIsIGFsbG93ZWRUeXBlczogW1widXJpXCIsIFwidGV4dFwiXSB9LFxuICBcInRpdGxlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICBcInR6XCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBhbGxvd2VkVHlwZXM6IFtcInRleHRcIiwgXCJ1dGMtb2Zmc2V0XCIsIFwidXJpXCJdIH0sXG4gIFwieG1sXCI6IERFRkFVTFRfVFlQRV9URVhUXG59KTtcblxubGV0IHZjYXJkM1ZhbHVlcyA9IGV4dGVuZChjb21tb25WYWx1ZXMsIHtcbiAgYmluYXJ5OiBpY2FsVmFsdWVzLmJpbmFyeSxcbiAgZGF0ZTogdmNhcmRWYWx1ZXMuZGF0ZSxcbiAgXCJkYXRlLXRpbWVcIjogdmNhcmRWYWx1ZXNbXCJkYXRlLXRpbWVcIl0sXG4gIFwicGhvbmUtbnVtYmVyXCI6IHZjYXJkVmFsdWVzW1wicGhvbmUtbnVtYmVyXCJdLFxuICB1cmk6IGljYWxWYWx1ZXMudXJpLFxuICB0ZXh0OiBpY2FsVmFsdWVzLnRleHQsXG4gIHRpbWU6IGljYWxWYWx1ZXMudGltZSxcbiAgdmNhcmQ6IGljYWxWYWx1ZXMudGV4dCxcbiAgXCJ1dGMtb2Zmc2V0XCI6IHtcbiAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS5zbGljZSgwLCA3KTtcbiAgICB9LFxuXG4gICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS5zbGljZSgwLCA3KTtcbiAgICB9LFxuXG4gICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIFV0Y09mZnNldC5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxufSk7XG5cbmxldCB2Y2FyZDNQYXJhbXMgPSB7XG4gIFwidHlwZVwiOiB7XG4gICAgdmFsdWVUeXBlOiBcInRleHRcIixcbiAgICBtdWx0aVZhbHVlOiBcIixcIlxuICB9LFxuICBcInZhbHVlXCI6IHtcbiAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsIFwicGhvbmUtbnVtYmVyXCIsIFwidGltZVwiLFxuICAgICAgICAgICAgIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIiwgXCJ2Y2FyZFwiLCBcImJpbmFyeVwiXSxcbiAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gIH1cbn07XG5cbmxldCB2Y2FyZDNQcm9wZXJ0aWVzID0gZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcbiAgZm46IERFRkFVTFRfVFlQRV9URVhULFxuICBuOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgbmlja25hbWU6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICBwaG90bzogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcbiAgYmRheToge1xuICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgfVxuICB9LFxuXG4gIGFkcjogeyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gIGxhYmVsOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICB0ZWw6IHsgZGVmYXVsdFR5cGU6IFwicGhvbmUtbnVtYmVyXCIgfSxcbiAgZW1haWw6IERFRkFVTFRfVFlQRV9URVhULFxuICBtYWlsZXI6IERFRkFVTFRfVFlQRV9URVhULFxuXG4gIHR6OiB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ1dGMtb2Zmc2V0XCIsIFwidGV4dFwiXSB9LFxuICBnZW86IHsgZGVmYXVsdFR5cGU6IFwiZmxvYXRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuXG4gIHRpdGxlOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgcm9sZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gIGxvZ286IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG4gIGFnZW50OiB7IGRlZmF1bHRUeXBlOiBcInZjYXJkXCIsIGFsbG93ZWRUeXBlczogW1widmNhcmRcIiwgXCJ0ZXh0XCIsIFwidXJpXCJdIH0sXG4gIG9yZzogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcblxuICBub3RlOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgcHJvZGlkOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgcmV2OiB7XG4gICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdLFxuICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgcmV0dXJuIChzdHJpbmcuaW5kZXhPZignVCcpID09PSAtMSkgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICB9XG4gIH0sXG4gIFwic29ydC1zdHJpbmdcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gIHNvdW5kOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuXG4gIGNsYXNzOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAga2V5OiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInRleHRcIl0gfVxufSk7XG5cbi8qKlxuICogaUNhbGVuZGFyIGRlc2lnbiBzZXRcbiAqIEB0eXBlIHtkZXNpZ25TZXR9XG4gKi9cbmxldCBpY2FsU2V0ID0ge1xuICB2YWx1ZTogaWNhbFZhbHVlcyxcbiAgcGFyYW06IGljYWxQYXJhbXMsXG4gIHByb3BlcnR5OiBpY2FsUHJvcGVydGllcyxcbiAgcHJvcGVydHlHcm91cHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIHZDYXJkIDQuMCBkZXNpZ24gc2V0XG4gKiBAdHlwZSB7ZGVzaWduU2V0fVxuICovXG5sZXQgdmNhcmRTZXQgPSB7XG4gIHZhbHVlOiB2Y2FyZFZhbHVlcyxcbiAgcGFyYW06IHZjYXJkUGFyYW1zLFxuICBwcm9wZXJ0eTogdmNhcmRQcm9wZXJ0aWVzLFxuICBwcm9wZXJ0eUdyb3VwczogdHJ1ZVxufTtcblxuLyoqXG4gKiB2Q2FyZCAzLjAgZGVzaWduIHNldFxuICogQHR5cGUge2Rlc2lnblNldH1cbiAqL1xubGV0IHZjYXJkM1NldCA9IHtcbiAgdmFsdWU6IHZjYXJkM1ZhbHVlcyxcbiAgcGFyYW06IHZjYXJkM1BhcmFtcyxcbiAgcHJvcGVydHk6IHZjYXJkM1Byb3BlcnRpZXMsXG4gIHByb3BlcnR5R3JvdXBzOiB0cnVlXG59O1xuXG4vKipcbiAqIFRoZSBkZXNpZ24gZGF0YSwgdXNlZCBieSB0aGUgcGFyc2VyIHRvIGRldGVybWluZSB0eXBlcyBmb3IgcHJvcGVydGllcyBhbmRcbiAqIG90aGVyIG1ldGFkYXRhIG5lZWRlZCB0byBwcm9kdWNlIGNvcnJlY3QgakNhcmQvakNhbCBkYXRhLlxuICpcbiAqIEBhbGlhcyBJQ0FMLmRlc2lnblxuICogQGV4cG9ydHMgbW9kdWxlOklDQUwuZGVzaWduXG4gKi9cbmNvbnN0IGRlc2lnbiA9IHtcbiAgLyoqXG4gICAqIENhbiBiZSBzZXQgdG8gZmFsc2UgdG8gbWFrZSB0aGUgcGFyc2VyIG1vcmUgbGVuaWVudC5cbiAgICovXG4gIHN0cmljdDogdHJ1ZSxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgc2V0IGZvciBuZXcgcHJvcGVydGllcyBhbmQgY29tcG9uZW50cyBpZiBub25lIGlzIHNwZWNpZmllZC5cbiAgICogQHR5cGUge2Rlc2lnblNldH1cbiAgICovXG4gIGRlZmF1bHRTZXQ6IGljYWxTZXQsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHVua25vd24gcHJvcGVydGllc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZGVmYXVsdFR5cGU6ICd1bmtub3duJyxcblxuICAvKipcbiAgICogSG9sZHMgdGhlIGRlc2lnbiBzZXQgZm9yIGtub3duIHRvcC1sZXZlbCBjb21wb25lbnRzXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7ZGVzaWduU2V0fSB2Y2FyZCAgICAgICB2Q2FyZCBWQ0FSRFxuICAgKiBAcHJvcGVydHkge2Rlc2lnblNldH0gdmV2ZW50ICAgICAgaUNhbGVuZGFyIFZFVkVOVFxuICAgKiBAcHJvcGVydHkge2Rlc2lnblNldH0gdnRvZG8gICAgICAgaUNhbGVuZGFyIFZUT0RPXG4gICAqIEBwcm9wZXJ0eSB7ZGVzaWduU2V0fSB2am91cm5hbCAgICBpQ2FsZW5kYXIgVkpPVVJOQUxcbiAgICogQHByb3BlcnR5IHtkZXNpZ25TZXR9IHZhbGFybSAgICAgIGlDYWxlbmRhciBWQUxBUk1cbiAgICogQHByb3BlcnR5IHtkZXNpZ25TZXR9IHZ0aW1lem9uZSAgIGlDYWxlbmRhciBWVElNRVpPTkVcbiAgICogQHByb3BlcnR5IHtkZXNpZ25TZXR9IGRheWxpZ2h0ICAgIGlDYWxlbmRhciBEQVlMSUdIVFxuICAgKiBAcHJvcGVydHkge2Rlc2lnblNldH0gc3RhbmRhcmQgICAgaUNhbGVuZGFyIFNUQU5EQVJEXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGxldCBwcm9wZXJ0eU5hbWUgPSAnZm4nO1xuICAgKiBsZXQgY29tcG9uZW50RGVzaWduID0gSUNBTC5kZXNpZ24uY29tcG9uZW50cy52Y2FyZDtcbiAgICogbGV0IHByb3BlcnR5RGV0YWlscyA9IGNvbXBvbmVudERlc2lnbi5wcm9wZXJ0eVtwcm9wZXJ0eU5hbWVdO1xuICAgKiBpZiAocHJvcGVydHlEZXRhaWxzLmRlZmF1bHRUeXBlID09ICd0ZXh0Jykge1xuICAgKiAgIC8vIFllcCwgc3VyZSBpcy4uLlxuICAgKiB9XG4gICAqL1xuICBjb21wb25lbnRzOiB7XG4gICAgdmNhcmQ6IHZjYXJkU2V0LFxuICAgIHZjYXJkMzogdmNhcmQzU2V0LFxuICAgIHZldmVudDogaWNhbFNldCxcbiAgICB2dG9kbzogaWNhbFNldCxcbiAgICB2am91cm5hbDogaWNhbFNldCxcbiAgICB2YWxhcm06IGljYWxTZXQsXG4gICAgdnRpbWV6b25lOiBpY2FsU2V0LFxuICAgIGRheWxpZ2h0OiBpY2FsU2V0LFxuICAgIHN0YW5kYXJkOiBpY2FsU2V0XG4gIH0sXG5cblxuICAvKipcbiAgICogVGhlIGRlc2lnbiBzZXQgZm9yIGlDYWxlbmRhciAocmZjNTU0NS9yZmM3MjY1KSBjb21wb25lbnRzLlxuICAgKiBAdHlwZSB7ZGVzaWduU2V0fVxuICAgKi9cbiAgaWNhbGVuZGFyOiBpY2FsU2V0LFxuXG4gIC8qKlxuICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdkNhcmQgKHJmYzYzNTAvcmZjNzA5NSkgY29tcG9uZW50cy5cbiAgICogQHR5cGUge2Rlc2lnblNldH1cbiAgICovXG4gIHZjYXJkOiB2Y2FyZFNldCxcblxuICAvKipcbiAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmMyNDI1L3JmYzI0MjYvcmZjNzA5NSkgY29tcG9uZW50cy5cbiAgICogQHR5cGUge2Rlc2lnblNldH1cbiAgICovXG4gIHZjYXJkMzogdmNhcmQzU2V0LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZXNpZ24gc2V0IGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnROYW1lICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Rlc2lnblNldH0gICAgICBUaGUgZGVzaWduIHNldCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgZ2V0RGVzaWduU2V0OiBmdW5jdGlvbihjb21wb25lbnROYW1lKSB7XG4gICAgbGV0IGlzSW5EZXNpZ24gPSBjb21wb25lbnROYW1lICYmIGNvbXBvbmVudE5hbWUgaW4gZGVzaWduLmNvbXBvbmVudHM7XG4gICAgcmV0dXJuIGlzSW5EZXNpZ24gPyBkZXNpZ24uY29tcG9uZW50c1tjb21wb25lbnROYW1lXSA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICB9XG59O1xudmFyIGRlc2lnbiQxID0gZGVzaWduO1xuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGlzIGxldHMgdHlwZXNjcmlwdCByZXNvbHZlIG91ciBjdXN0b20gdHlwZXMgaW4gdGhlXG4gKiBnZW5lcmF0ZWQgZC50cyBmaWxlcyAoanNkb2MgdHlwZWRlZnMgYXJlIGNvbnZlcnRlZCB0byB0eXBlc2NyaXB0IHR5cGVzKS5cbiAqIElnbm9yZSBwcmV2ZW50cyB0aGUgdHlwZWRlZnMgZnJvbSBiZWluZyBkb2N1bWVudGVkIG1vcmUgdGhhbiBvbmNlLlxuICpcbiAqIEBpZ25vcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLmRlc2lnblNldH0gZGVzaWduU2V0XG4gKiBJbXBvcnRzIHRoZSAnZGVzaWduU2V0JyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqL1xuXG5jb25zdCBMSU5FX0VORElORyA9ICdcXHJcXG4nO1xuY29uc3QgREVGQVVMVF9WQUxVRV9UWVBFID0gJ3Vua25vd24nO1xuY29uc3QgUkZDNjg2OF9SRVBMQUNFX01BUCA9IHsgJ1wiJzogXCJeJ1wiLCBcIlxcblwiOiBcIl5uXCIsIFwiXlwiOiBcIl5eXCIgfTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZnVsbCBqQ2FsL2pDYXJkIGFycmF5IGludG8gYSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeVxuICogQHZhcmlhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHtBcnJheX0gakNhbCAgICBUaGUgakNhbC9qQ2FyZCBkb2N1bWVudFxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgc3RyaW5naWZpZWQgaUNhbGVuZGFyL3ZDYXJkIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShqQ2FsKSB7XG4gIGlmICh0eXBlb2YgakNhbFswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBjb21wb25lbnRcbiAgICBqQ2FsID0gW2pDYWxdO1xuICB9XG5cbiAgbGV0IGkgPSAwO1xuICBsZXQgbGVuID0gakNhbC5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSAnJztcblxuICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoakNhbFtpXSkgKyBMSU5FX0VORElORztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gakNhbCBjb21wb25lbnQgYXJyYXkgaW50byBhIElDQUwgc3RyaW5nLlxuICogUmVjdXJzaXZlIHdpbGwgcmVzb2x2ZSBzdWItY29tcG9uZW50cy5cbiAqXG4gKiBFeGFjdCBjb21wb25lbnQvcHJvcGVydHkgb3JkZXIgaXMgbm90IHNhdmVkIGFsbFxuICogcHJvcGVydGllcyB3aWxsIGNvbWUgYmVmb3JlIHN1YmNvbXBvbmVudHMuXG4gKlxuICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LmNvbXBvbmVudFxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50XG4gKiAgICAgICAgakNhbC9qQ2FyZCBmcmFnbWVudCBvZiBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtkZXNpZ25TZXR9IGRlc2lnblNldFxuICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gKi9cbnN0cmluZ2lmeS5jb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQsIGRlc2lnblNldCkge1xuICBsZXQgbmFtZSA9IGNvbXBvbmVudFswXS50b1VwcGVyQ2FzZSgpO1xuICBsZXQgcmVzdWx0ID0gJ0JFR0lOOicgKyBuYW1lICsgTElORV9FTkRJTkc7XG5cbiAgbGV0IHByb3BzID0gY29tcG9uZW50WzFdO1xuICBsZXQgcHJvcElkeCA9IDA7XG4gIGxldCBwcm9wTGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gIGxldCBkZXNpZ25TZXROYW1lID0gY29tcG9uZW50WzBdO1xuICAvLyByZmM2MzUwIHJlcXVpcmVzIHRoYXQgaW4gdkNhcmQgNC4wIHRoZSBmaXJzdCBjb21wb25lbnQgaXMgdGhlIFZFUlNJT05cbiAgLy8gY29tcG9uZW50IHdpdGggYXMgdmFsdWUgNC4wLCBub3RlIHRoYXQgMy4wIGRvZXMgbm90IGhhdmUgdGhpcyByZXF1aXJlbWVudC5cbiAgaWYgKGRlc2lnblNldE5hbWUgPT09ICd2Y2FyZCcgJiYgY29tcG9uZW50WzFdLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAhKGNvbXBvbmVudFsxXVswXVswXSA9PT0gXCJ2ZXJzaW9uXCIgJiYgY29tcG9uZW50WzFdWzBdWzNdID09PSBcIjQuMFwiKSkge1xuICAgIGRlc2lnblNldE5hbWUgPSBcInZjYXJkM1wiO1xuICB9XG4gIGRlc2lnblNldCA9IGRlc2lnblNldCB8fCBkZXNpZ24kMS5nZXREZXNpZ25TZXQoZGVzaWduU2V0TmFtZSk7XG5cbiAgZm9yICg7IHByb3BJZHggPCBwcm9wTGVuOyBwcm9wSWR4KyspIHtcbiAgICByZXN1bHQgKz0gc3RyaW5naWZ5LnByb3BlcnR5KHByb3BzW3Byb3BJZHhdLCBkZXNpZ25TZXQpICsgTElORV9FTkRJTkc7XG4gIH1cblxuICAvLyBJZ25vcmUgc3ViY29tcG9uZW50cyBpZiBub25lIGV4aXN0LCBlLmcuIGluIHZDYXJkLlxuICBsZXQgY29tcHMgPSBjb21wb25lbnRbMl0gfHwgW107XG4gIGxldCBjb21wSWR4ID0gMDtcbiAgbGV0IGNvbXBMZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgZm9yICg7IGNvbXBJZHggPCBjb21wTGVuOyBjb21wSWR4KyspIHtcbiAgICByZXN1bHQgKz0gc3RyaW5naWZ5LmNvbXBvbmVudChjb21wc1tjb21wSWR4XSwgZGVzaWduU2V0KSArIExJTkVfRU5ESU5HO1xuICB9XG5cbiAgcmVzdWx0ICs9ICdFTkQ6JyArIG5hbWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc2luZ2xlIGpDYWwvakNhcmQgcHJvcGVydHkgdG8gYSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eVxuICogQHBhcmFtIHtBcnJheX0gcHJvcGVydHlcbiAqICAgICAgICBqQ2FsL2pDYXJkIHByb3BlcnR5IGFycmF5XG4gKiBAcGFyYW0ge2Rlc2lnblNldH0gZGVzaWduU2V0XG4gKiAgICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICogQHBhcmFtIHtCb29sZWFufSBub0ZvbGRcbiAqICAgICAgICBJZiB0cnVlLCB0aGUgbGluZSBpcyBub3QgZm9sZGVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gKi9cbnN0cmluZ2lmeS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBkZXNpZ25TZXQsIG5vRm9sZCkge1xuICBsZXQgbmFtZSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCk7XG4gIGxldCBqc05hbWUgPSBwcm9wZXJ0eVswXTtcbiAgbGV0IHBhcmFtcyA9IHByb3BlcnR5WzFdO1xuXG4gIGlmICghZGVzaWduU2V0KSB7XG4gICAgZGVzaWduU2V0ID0gZGVzaWduJDEuZGVmYXVsdFNldDtcbiAgfVxuXG4gIGxldCBncm91cE5hbWUgPSBwYXJhbXMuZ3JvdXA7XG4gIGxldCBsaW5lO1xuICBpZiAoZGVzaWduU2V0LnByb3BlcnR5R3JvdXBzICYmIGdyb3VwTmFtZSkge1xuICAgIGxpbmUgPSBncm91cE5hbWUudG9VcHBlckNhc2UoKSArIFwiLlwiICsgbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lID0gbmFtZTtcbiAgfVxuXG4gIGZvciAobGV0IFtwYXJhbU5hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgaWYgKGRlc2lnblNldC5wcm9wZXJ0eUdyb3VwcyAmJiBwYXJhbU5hbWUgPT0gJ2dyb3VwJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHBhcmFtRGVzaWduID0gZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV07XG4gICAgbGV0IG11bHRpVmFsdWUgPSBwYXJhbURlc2lnbiAmJiBwYXJhbURlc2lnbi5tdWx0aVZhbHVlO1xuICAgIGlmIChtdWx0aVZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUodmFsKTtcbiAgICAgICAgdmFsID0gc3RyaW5naWZ5LnBhcmFtUHJvcGVydHlWYWx1ZSh2YWwsIHBhcmFtRGVzaWduLm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9KTtcbiAgICAgIHZhbHVlID0gc3RyaW5naWZ5Lm11bHRpVmFsdWUodmFsdWUsIG11bHRpVmFsdWUsIFwidW5rbm93blwiLCBudWxsLCBkZXNpZ25TZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gc3RyaW5naWZ5LnBhcmFtUHJvcGVydHlWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgbGluZSArPSAnOycgKyBwYXJhbU5hbWUudG9VcHBlckNhc2UoKSArICc9JyArIHZhbHVlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5Lmxlbmd0aCA9PT0gMykge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyB2YWx1ZXMsIHdlIG11c3QgYXNzdW1lIGEgYmxhbmsgdmFsdWVcbiAgICByZXR1cm4gbGluZSArICc6JztcbiAgfVxuXG4gIGxldCB2YWx1ZVR5cGUgPSBwcm9wZXJ0eVsyXTtcblxuICBsZXQgcHJvcERldGFpbHM7XG4gIGxldCBtdWx0aVZhbHVlID0gZmFsc2U7XG4gIGxldCBzdHJ1Y3R1cmVkVmFsdWUgPSBmYWxzZTtcbiAgbGV0IGlzRGVmYXVsdCA9IGZhbHNlO1xuXG4gIGlmIChqc05hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgcHJvcERldGFpbHMgPSBkZXNpZ25TZXQucHJvcGVydHlbanNOYW1lXTtcblxuICAgIGlmICgnbXVsdGlWYWx1ZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgIG11bHRpVmFsdWUgPSBwcm9wRGV0YWlscy5tdWx0aVZhbHVlO1xuICAgIH1cblxuICAgIGlmICgoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gcHJvcERldGFpbHMpICYmIEFycmF5LmlzQXJyYXkocHJvcGVydHlbM10pKSB7XG4gICAgICBzdHJ1Y3R1cmVkVmFsdWUgPSBwcm9wRGV0YWlscy5zdHJ1Y3R1cmVkVmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgIGlmICh2YWx1ZVR5cGUgPT09IHByb3BEZXRhaWxzLmRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZVR5cGUgPT09IERFRkFVTFRfVkFMVUVfVFlQRSkge1xuICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWVUeXBlID09PSBERUZBVUxUX1ZBTFVFX1RZUEUpIHtcbiAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gcHVzaCB0aGUgVkFMVUUgcHJvcGVydHkgaWYgdHlwZSBpcyBub3QgdGhlIGRlZmF1bHRcbiAgLy8gZm9yIHRoZSBjdXJyZW50IHByb3BlcnR5LlxuICBpZiAoIWlzRGVmYXVsdCkge1xuICAgIC8vIHZhbHVlIHdpbGwgbmV2ZXIgY29udGFpbiA7LzovLCBzbyB3ZSBkb24ndCBlc2NhcGUgaXQgaGVyZS5cbiAgICBsaW5lICs9ICc7VkFMVUU9JyArIHZhbHVlVHlwZS50b1VwcGVyQ2FzZSgpO1xuICB9XG5cbiAgbGluZSArPSAnOic7XG5cbiAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgIHByb3BlcnR5WzNdLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgbXVsdGlWYWx1ZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWVcbiAgICApO1xuICB9IGVsc2UgaWYgKG11bHRpVmFsdWUpIHtcbiAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgcHJvcGVydHkuc2xpY2UoMyksIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgbnVsbCwgZGVzaWduU2V0LCBmYWxzZVxuICAgICk7XG4gIH0gZWxzZSBpZiAoc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgIHByb3BlcnR5WzNdLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWVcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxpbmUgKz0gc3RyaW5naWZ5LnZhbHVlKHByb3BlcnR5WzNdLCB2YWx1ZVR5cGUsIGRlc2lnblNldCwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIG5vRm9sZCA/IGxpbmUgOiBmb2xkbGluZShsaW5lKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBlc2NhcGluZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBtYXkgY29udGFpbjpcbiAqXG4gKiAgICBDT0xPTiAoOiksIFNFTUlDT0xPTiAoOyksIG9yIENPTU1BICgsKVxuICpcbiAqIElmIGFueSBvZiB0aGUgYWJvdmUgYXJlIHByZXNlbnQgdGhlIHJlc3VsdCBpcyB3cmFwcGVkXG4gKiBpbiBkb3VibGUgcXVvdGVzLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5wYXJhbVByb3BlcnR5VmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFJhdyBwcm9wZXJ0eSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAgICAgSWYgdmFsdWUgc2hvdWxkIGJlIGVzY2FwZWQgZXZlbiB3aGVuIHVubmVjZXNzYXJ5XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBHaXZlbiBvciBlc2NhcGVkIHZhbHVlIHdoZW4gbmVlZGVkXG4gKi9cbnN0cmluZ2lmeS5wYXJhbVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgZm9yY2UpIHtcbiAgaWYgKCFmb3JjZSAmJlxuICAgICAgKHZhbHVlLmluZGV4T2YoJywnKSA9PT0gLTEpICYmXG4gICAgICAodmFsdWUuaW5kZXhPZignOicpID09PSAtMSkgJiZcbiAgICAgICh2YWx1ZS5pbmRleE9mKCc7JykgPT09IC0xKSkge1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGljYWwgdmFsdWVzIGludG8gYSBzaW5nbGVcbiAqIHN0cmluZyBiYXNlZCBvbiBhIHR5cGUgYW5kIGEgZGVsaW1pdGVyIHZhbHVlIChsaWtlIFwiLFwiKS5cbiAqXG4gKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkubXVsdGlWYWx1ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgICAgTGlzdCBvZiB2YWx1ZXMgdG8gY29udmVydFxuICogQHBhcmFtIHtTdHJpbmd9IGRlbGltICAgICAgVXNlZCB0byBqb2luIHRoZSB2YWx1ZXMgKFwiLFwiLCBcIjtcIiwgXCI6XCIpXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICBMb3dlY2FzZSBpY2FsIHZhbHVlIHR5cGVcbiAqICAgICAgICAobGlrZSBib29sZWFuLCBkYXRlLXRpbWUsIGV0Yy4uKVxuICogQHBhcmFtIHs/U3RyaW5nfSBpbm5lck11bHRpIElmIHNldCwgZWFjaCB2YWx1ZSB3aWxsIGFnYWluIGJlIHByb2Nlc3NlZFxuICogICAgICAgIFVzZWQgZm9yIHN0cnVjdHVyZWQgdmFsdWVzXG4gKiBAcGFyYW0ge2Rlc2lnblNldH0gZGVzaWduU2V0XG4gKiAgICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcgZm9yIHZhbHVlXG4gKi9cbnN0cmluZ2lmeS5tdWx0aVZhbHVlID0gZnVuY3Rpb24odmFsdWVzLCBkZWxpbSwgdHlwZSwgaW5uZXJNdWx0aSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBsZXQgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaW5uZXJNdWx0aSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc1tpXSkpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZSh2YWx1ZXNbaV0sIGlubmVyTXVsdGksIHR5cGUsIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS52YWx1ZSh2YWx1ZXNbaV0sIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoaSAhPT0gKGxlbiAtIDEpKSB7XG4gICAgICByZXN1bHQgKz0gZGVsaW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIGEgc2luZ2xlIGljYWwgdmFsdWUgcnVucyB0aGUgYXNzb2NpYXRlZCBcInRvSUNBTFwiIG1ldGhvZCBmcm9tIHRoZVxuICogZGVzaWduIHZhbHVlIHR5cGUgaWYgYXZhaWxhYmxlIHRvIGNvbnZlcnQgdGhlIHZhbHVlLlxuICpcbiAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS52YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZSAgICAgICBBIGZvcm1hdHRlZCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgICAgICBMb3dlcmNhc2UgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIHR5cGVcbiAqICAobGlrZSBib29sZWFuLCBkYXRlLXRpbWUsIGV0Yy4uKVxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICBpQ2FsZW5kYXIvdkNhcmQgdmFsdWUgZm9yIHNpbmdsZSB2YWx1ZVxuICovXG5zdHJpbmdpZnkudmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICd0b0lDQUwnIGluIGRlc2lnblNldC52YWx1ZVt0eXBlXSkge1xuICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0udG9JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciByZmM2ODY4LiBFeHBvc2luZyB0aGlzIG9uIElDQUwuc3RyaW5naWZ5IHNvIHRoYXRcbiAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbCAgICAgICAgVGhlIHZhbHVlIHRvIHVuZXNjYXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICovXG5zdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsLnJlcGxhY2UoL1tcXG5eXCJdL2csIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gUkZDNjg2OF9SRVBMQUNFX01BUFt4XTtcbiAgfSk7XG59O1xuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuY29uc3QgTkFNRV9JTkRFWCQxID0gMDtcbmNvbnN0IFBST1BfSU5ERVggPSAxO1xuY29uc3QgVFlQRV9JTkRFWCA9IDI7XG5jb25zdCBWQUxVRV9JTkRFWCA9IDM7XG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqIEBpZ25vcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLmRlc2lnblNldH0gZGVzaWduU2V0XG4gKiBJbXBvcnRzIHRoZSAnZGVzaWduU2V0JyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLkdlb30gR2VvXG4gKiBJbXBvcnRzIHRoZSAnR2VvJyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgbGF5ZXIgb24gdG9wIG9mIHRoZSByYXcgakNhbCBvYmplY3QgZm9yIG1hbmlwdWxhdGluZyBhIHNpbmdsZSBwcm9wZXJ0eSwgd2l0aCBpdHNcbiAqIHBhcmFtZXRlcnMgYW5kIHZhbHVlLlxuICpcbiAqIEBtZW1iZXJvZiBJQ0FMXG4gKi9cbmNsYXNzIFByb3BlcnR5IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB7QGxpbmsgSUNBTC5Qcm9wZXJ0eX0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICBUaGUgaUNhbGVuZGFyIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge2Rlc2lnblNldD19IGRlc2lnblNldCAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaUNhbGVuZGFyIHByb3BlcnR5XG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHIsIGRlc2lnblNldCkge1xuICAgIHJldHVybiBuZXcgUHJvcGVydHkocGFyc2UucHJvcGVydHkoc3RyLCBkZXNpZ25TZXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuUHJvcGVydHkgaW5zdGFuY2UuXG4gICAqXG4gICAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgbXV0YXRpb25zIGRvbmUgaW4gdGhlIHdyYXBwZXIgZGlyZWN0bHkgbXV0YXRlIHRoZSBqQ2FsIG9iamVjdCB1c2VkXG4gICAqIHRvIGluaXRpYWxpemUuXG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBwcm9wZXJ0aWVzIGJ5IHBhc3NpbmcgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IChhcyBhIFN0cmluZykuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgcmVwcmVzZW50YXRpb24gT1IgdGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0NvbXBvbmVudD19IHBhcmVudCAgICAgICAgIFBhcmVudCBjb21wb25lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGpDYWwsIHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuXG4gICAgaWYgKHR5cGVvZihqQ2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBjcmVhdGluZyB0aGUgcHJvcGVydHkgYnkgbmFtZSBhbmQgbmVlZCB0byBkZXRlY3QgdGhlIHR5cGVcbiAgICAgIHRoaXMuakNhbCA9IFtqQ2FsLCB7fSwgZGVzaWduJDEuZGVmYXVsdFR5cGVdO1xuICAgICAgdGhpcy5qQ2FsW1RZUEVfSU5ERVhdID0gdGhpcy5nZXREZWZhdWx0VHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmpDYWwgPSBqQ2FsO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZhbHVlIHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmpDYWxbVFlQRV9JTkRFWF07XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eSwgaW4gbG93ZXJjYXNlLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYJDFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJlbnQgY29tcG9uZW50IGZvciB0aGlzIHByb3BlcnR5LlxuICAgKiBAdHlwZSB7Q29tcG9uZW50fVxuICAgKi9cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9XG5cbiAgc2V0IHBhcmVudChwKSB7XG4gICAgLy8gQmVmb3JlIHNldHRpbmcgdGhlIHBhcmVudCwgY2hlY2sgaWYgdGhlIGRlc2lnbiBzZXQgaGFzIGNoYW5nZWQuIElmIGl0XG4gICAgLy8gaGFzLCB3ZSBsYXRlciBuZWVkIHRvIHVwZGF0ZSB0aGUgdHlwZSBpZiBpdCB3YXMgdW5rbm93biBiZWZvcmUuXG4gICAgbGV0IGRlc2lnblNldENoYW5nZWQgPSAhdGhpcy5fcGFyZW50IHx8IChwICYmIHAuX2Rlc2lnblNldCAhPSB0aGlzLl9wYXJlbnQuX2Rlc2lnblNldCk7XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBwO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PSBkZXNpZ24kMS5kZWZhdWx0VHlwZSAmJiBkZXNpZ25TZXRDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIHByb3BlcnR5LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgKlxuICAgKiBAdHlwZSB7ZGVzaWduU2V0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IF9kZXNpZ25TZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX2Rlc2lnblNldCA6IGRlc2lnbiQxLmRlZmF1bHRTZXQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdHlwZSBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IGpDYWwgdHlwZSBhbmQgZGVzaWduIHNldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVUeXBlKCkge1xuICAgIGxldCBkZXNpZ25TZXQgPSB0aGlzLl9kZXNpZ25TZXQ7XG5cbiAgICBpZiAodGhpcy50eXBlIGluIGRlc2lnblNldC52YWx1ZSkge1xuICAgICAgaWYgKCdkZWNvcmF0ZScgaW4gZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0pIHtcbiAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzRGVjb3JhdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMuaXNNdWx0aVZhbHVlID0gKCdtdWx0aVZhbHVlJyBpbiBkZXNpZ25TZXQucHJvcGVydHlbdGhpcy5uYW1lXSk7XG4gICAgICAgIHRoaXMuaXNTdHJ1Y3R1cmVkVmFsdWUgPSAoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIeWRyYXRlIGEgc2luZ2xlIHZhbHVlLiBUaGUgYWN0IG9mIGh5ZHJhdGluZyBtZWFucyB0dXJuaW5nIHRoZSByYXcgakNhbFxuICAgKiB2YWx1ZSBpbnRvIGEgcG90ZW50aWFsbHkgd3JhcHBlZCBvYmplY3QsIGZvciBleGFtcGxlIHtAbGluayBJQ0FMLlRpbWV9LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAgIFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gaHlkcmF0ZVxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSAgICAgICAgICAgICBUaGUgZGVjb3JhdGVkIHZhbHVlLlxuICAgKi9cbiAgX2h5ZHJhdGVWYWx1ZShpbmRleCkge1xuICAgIGlmICh0aGlzLl92YWx1ZXMgJiYgdGhpcy5fdmFsdWVzW2luZGV4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1tpbmRleF07XG4gICAgfVxuXG4gICAgLy8gZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgIGlmICh0aGlzLmpDYWwubGVuZ3RoIDw9IChWQUxVRV9JTkRFWCArIGluZGV4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZXNbaW5kZXhdID0gdGhpcy5fZGVjb3JhdGUoXG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XVxuICAgICAgKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29yYXRlIGEgc2luZ2xlIHZhbHVlLCByZXR1cm5pbmcgaXRzIHdyYXBwZWQgb2JqZWN0LiBUaGlzIGlzIHVzZWQgYnlcbiAgICogdGhlIGh5ZHJhdGUgZnVuY3Rpb24gdG8gYWN0dWFsbHkgd3JhcCB0aGUgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7P30gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gZGVjb3JhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFRoZSBkZWNvcmF0ZWQgdmFsdWVcbiAgICovXG4gIF9kZWNvcmF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9kZXNpZ25TZXQudmFsdWVbdGhpcy50eXBlXS5kZWNvcmF0ZSh2YWx1ZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVW5kZWNvcmF0ZSBhIHNpbmdsZSB2YWx1ZSwgcmV0dXJuaW5nIGl0cyByYXcgakNhbCBkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gdW5kZWNvcmF0ZVxuICAgKiBAcmV0dXJuIHs/fSAgICAgICAgICAgICAgICAgICBUaGUgdW5kZWNvcmF0ZWQgdmFsdWVcbiAgICovXG4gIF91bmRlY29yYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLnVuZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCB3aGlsZSBhbHNvIGh5ZHJhdGluZyBpdC4gVGhlIHBhc3NlZFxuICAgKiB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgZGVjb3JhdGVkIG9yIHVuZGVjb3JhdGVkIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgICBUaGUgaW5kZXggdG8gc2V0IGl0IGF0XG4gICAqL1xuICBfc2V0RGVjb3JhdGVkVmFsdWUodmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAnaWNhbHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAvLyBkZWNvcmF0ZWQgdmFsdWVcbiAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XSA9IHRoaXMuX3VuZGVjb3JhdGUodmFsdWUpO1xuICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmRlY29yYXRlZCB2YWx1ZVxuICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdID0gdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdGhpcy5fZGVjb3JhdGUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICogQHJldHVybiB7QXJyYXl8U3RyaW5nfSAgICAgICAgUGFyYW1ldGVyIHZhbHVlXG4gICAqL1xuICBnZXRQYXJhbWV0ZXIobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuakNhbFtQUk9QX0lOREVYXSkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBmaXJzdCBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIG5hbWUgICBQYXJhbWV0ZXIgbmFtZSAobG93ZXJjYXNlKVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICovXG4gIGdldEZpcnN0UGFyYW1ldGVyKG5hbWUpIHtcbiAgICBsZXQgcGFyYW1ldGVycyA9IHRoaXMuZ2V0UGFyYW1ldGVyKG5hbWUpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgbmFtZSAgICAgVGhlIHBhcmFtZXRlciBuYW1lXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSB2YWx1ZSAgICBUaGUgcGFyYW1ldGVyIHZhbHVlXG4gICAqL1xuICBzZXRQYXJhbWV0ZXIobmFtZSwgdmFsdWUpIHtcbiAgICBsZXQgbGNuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgbGNuYW1lIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbSAmJlxuICAgICAgICAnbXVsdGlWYWx1ZScgaW4gdGhpcy5fZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0pIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgIH1cbiAgICB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcGFyYW1ldGVyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICBUaGUgcGFyYW1ldGVyIG5hbWVcbiAgICovXG4gIHJlbW92ZVBhcmFtZXRlcihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvbiB0aGlzIHByb3BlcnR5J3MgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgVGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0RGVmYXVsdFR5cGUoKSB7XG4gICAgbGV0IG5hbWUgPSB0aGlzLmpDYWxbTkFNRV9JTkRFWCQxXTtcbiAgICBsZXQgZGVzaWduU2V0ID0gdGhpcy5fZGVzaWduU2V0O1xuXG4gICAgaWYgKG5hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICBsZXQgZGV0YWlscyA9IGRlc2lnblNldC5wcm9wZXJ0eVtuYW1lXTtcbiAgICAgIGlmICgnZGVmYXVsdFR5cGUnIGluIGRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIGRldGFpbHMuZGVmYXVsdFR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpZ24kMS5kZWZhdWx0VHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHR5cGUgb2YgcHJvcGVydHkgYW5kIGNsZWFycyBvdXQgYW55IGV4aXN0aW5nIHZhbHVlcyBvZiB0aGUgY3VycmVudFxuICAgKiB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgTmV3IGlDQUwgdHlwZSAoc2VlIGRlc2lnbi4qLnZhbHVlcylcbiAgICovXG4gIHJlc2V0VHlwZSh0eXBlKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcbiAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0eXBlO1xuICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0JpbmFyeSB8IER1cmF0aW9uIHwgUGVyaW9kIHxcbiAgICogUmVjdXIgfCBUaW1lIHwgVXRjT2Zmc2V0IHwgR2VvIHwgc3RyaW5nIHwgbnVsbH0gICAgICAgICBGaXJzdCBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgZ2V0Rmlyc3RWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faHlkcmF0ZVZhbHVlKDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHZhbHVlcyBvbiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIE5PVEU6IHRoaXMgY3JlYXRlcyBhbiBhcnJheSBkdXJpbmcgZWFjaCBjYWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgTGlzdCBvZiB2YWx1ZXNcbiAgICovXG4gIGdldFZhbHVlcygpIHtcbiAgICBsZXQgbGVuID0gdGhpcy5qQ2FsLmxlbmd0aCAtIFZBTFVFX0lOREVYO1xuXG4gICAgaWYgKGxlbiA8IDEpIHtcbiAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGZvciBhIHByb3BlcnR5IHRvIGhhdmUgbm8gdmFsdWUuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX2h5ZHJhdGVWYWx1ZShpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIHRoaXMgcHJvcGVydHlcbiAgICovXG4gIHJlbW92ZUFsbFZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5fdmFsdWVzKSB7XG4gICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5qQ2FsLmxlbmd0aCA9IDM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0eS4gIFdpbGwgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB2YWx1ZXMuXG4gICAqIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBmb3IgbXVsdGktdmFsdWUgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgIEFuIGFycmF5IG9mIHZhbHVlc1xuICAgKi9cbiAgc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc011bHRpVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdGhpcy5uYW1lICsgJzogZG9lcyBub3Qgbm90IHN1cHBvcnQgbXVsaXRWYWx1ZS5cXG4nICtcbiAgICAgICAgJ292ZXJyaWRlIGlzTXVsdGlWYWx1ZSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG5cbiAgICBpZiAobGVuID4gMCAmJlxuICAgICAgICB0eXBlb2YodmFsdWVzWzBdKSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2ljYWx0eXBlJyBpbiB2YWx1ZXNbMF0pIHtcbiAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlc1swXS5pY2FsdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fc2V0RGVjb3JhdGVkVmFsdWUodmFsdWVzW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpXSA9IHZhbHVlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuIElmIHRoaXMgaXMgYSBtdWx0aS12YWx1ZVxuICAgKiBwcm9wZXJ0eSwgYWxsIG90aGVyIHZhbHVlcyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgICAgIE5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgJ2ljYWx0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNldFR5cGUodmFsdWUuaWNhbHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICB0aGlzLl9zZXREZWNvcmF0ZWRWYWx1ZSh2YWx1ZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gICAqIGlzIGEgbGl2ZSBqQ2FsIG9iamVjdCBhbmQgc2hvdWxkIGJlIGNsb25lZCBpZiBtb2RpZmllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmpDYWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9JQ0FMU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJpbmdpZnkucHJvcGVydHkoXG4gICAgICB0aGlzLmpDYWwsIHRoaXMuX2Rlc2lnblNldCwgdHJ1ZVxuICAgICk7XG4gIH1cbn1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoICovXG5cbi8qKlxuICogVGhpcyBsZXRzIHR5cGVzY3JpcHQgcmVzb2x2ZSBvdXIgY3VzdG9tIHR5cGVzIGluIHRoZVxuICogZ2VuZXJhdGVkIGQudHMgZmlsZXMgKGpzZG9jIHR5cGVkZWZzIGFyZSBjb252ZXJ0ZWQgdG8gdHlwZXNjcmlwdCB0eXBlcykuXG4gKiBJZ25vcmUgcHJldmVudHMgdGhlIHR5cGVkZWZzIGZyb20gYmVpbmcgZG9jdW1lbnRlZCBtb3JlIHRoYW4gb25jZS5cbiAqIEBpZ25vcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLmRlc2lnblNldH0gZGVzaWduU2V0XG4gKiBJbXBvcnRzIHRoZSAnZGVzaWduU2V0JyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL3R5cGVzLmpzXCIpLkdlb30gR2VvXG4gKiBJbXBvcnRzIHRoZSAnR2VvJyB0eXBlIGZyb20gdGhlIFwidHlwZXMuanNcIiBtb2R1bGVcbiAqL1xuXG5jb25zdCBOQU1FX0lOREVYID0gMDtcbmNvbnN0IFBST1BFUlRZX0lOREVYID0gMTtcbmNvbnN0IENPTVBPTkVOVF9JTkRFWCA9IDI7XG5cbi8qKlxuICogV3JhcHMgYSBqQ2FsIGNvbXBvbmVudCwgYWRkaW5nIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gYWRkLCByZW1vdmUgYW5kIHVwZGF0ZSBzdWJjb21wb25lbnRzIGFuZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBAbWVtYmVyb2YgSUNBTFxuICovXG5jbGFzcyBDb21wb25lbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIHtAbGluayBJQ0FMLkNvbXBvbmVudH0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHRvIHBhcnNlXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gbmV3IENvbXBvbmVudChwYXJzZS5jb21wb25lbnQoc3RyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgY29tcG9uZW50IGRhdGEgT1IgbmFtZSBvZiBuZXdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0NvbXBvbmVudD19IHBhcmVudCAgICAgUGFyZW50IGNvbXBvbmVudCB0byBhc3NvY2lhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGpDYWwsIHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBqQ2FsIHNwZWMgKG5hbWUsIHByb3BlcnRpZXMsIGNvbXBvbmVudHMpXG4gICAgICBqQ2FsID0gW2pDYWwsIFtdLCBbXV07XG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGZvciBsZWdhY3kgcmVhc29ucy5cbiAgICB0aGlzLmpDYWwgPSBqQ2FsO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblxuICAgIGlmICghdGhpcy5wYXJlbnQgJiYgdGhpcy5uYW1lID09PSAndmNhbGVuZGFyJykge1xuICAgICAgdGhpcy5fdGltZXpvbmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSHlkcmF0ZWQgcHJvcGVydGllcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgX3Byb3BlcnRpZXMgYXJyYXkgYXQgdGhlIHNhbWVcbiAgICogcG9zaXRpb24gYXMgaW4gdGhlIGpDYWwgYXJyYXksIHNvIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGFycmF5IGNvbnRhaW5zXG4gICAqIHVuZGVmaW5lZCB2YWx1ZXMgZm9yIHVuaHlkcmRhdGVkIHByb3BlcnRpZXMuIFRvIGF2b2lkIGl0ZXJhdGluZyB0aGVcbiAgICogYXJyYXkgd2hlbiBjaGVja2luZyBpZiBhbGwgcHJvcGVydGllcyBoYXZlIGJlZW4gaHlkcmF0ZWQsIHdlIHNhdmUgdGhlXG4gICAqIGNvdW50IGhlcmUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcblxuICAvKipcbiAgICogVGhlIHNhbWUgY291bnQgYXMgZm9yIF9oeWRyYXRlZFByb3BlcnR5Q291bnQsIGJ1dCBmb3Igc3ViY29tcG9uZW50c1xuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuXG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIGh5ZHJhdGVkIHRpbWUgem9uZSBvYmplY3RzIHdoaWNoIG1heSBiZSB1c2VkIGJ5IGNvbnN1bWVycywga2V5ZWRcbiAgICogYnkgdGltZSB6b25lIElELlxuICAgKlxuICAgKiBAdHlwZSB7TWFwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RpbWV6b25lQ2FjaGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXBvbmVudHMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb3BlcnRpZXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdGhpcyBjb21wb25lbnQsIGUuZy4gaWNhbGVuZGFyIHZzIHZjYXJkXG4gICAqXG4gICAqIEB0eXBlIHtkZXNpZ25TZXR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgX2Rlc2lnblNldCgpIHtcbiAgICBsZXQgcGFyZW50RGVzaWduID0gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuX2Rlc2lnblNldDtcbiAgICByZXR1cm4gcGFyZW50RGVzaWduIHx8IGRlc2lnbiQxLmdldERlc2lnblNldCh0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaHlkcmF0ZUNvbXBvbmVudChpbmRleCkge1xuICAgIGlmICghdGhpcy5fY29tcG9uZW50cykge1xuICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpbmRleF07XG4gICAgfVxuXG4gICAgbGV0IGNvbXAgPSBuZXcgQ29tcG9uZW50KFxuICAgICAgdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF1baW5kZXhdLFxuICAgICAgdGhpc1xuICAgICk7XG5cbiAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50Kys7XG4gICAgcmV0dXJuICh0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IGNvbXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaHlkcmF0ZVByb3BlcnR5KGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIGxldCBwcm9wID0gbmV3IFByb3BlcnR5KFxuICAgICAgdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXVtpbmRleF0sXG4gICAgICB0aGlzXG4gICAgKTtcblxuICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgIHJldHVybiAodGhpcy5fcHJvcGVydGllc1tpbmRleF0gPSBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBmaXJzdCBzdWIgY29tcG9uZW50LCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgT3B0aW9uYWwgbmFtZSB0byBmaWx0ZXIgYnlcbiAgICogQHJldHVybiB7P0NvbXBvbmVudH0gICAgIFRoZSBmb3VuZCBzdWJjb21wb25lbnRcbiAgICovXG4gIGdldEZpcnN0U3ViY29tcG9uZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGNvbXBzID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF07XG4gICAgICBsZXQgbGVuID0gY29tcHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjb21wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZUNvbXBvbmVudCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgd2UgcmV0dXJuIGEgdmFsdWUgKHN0cmljdCBtb2RlKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBzdWIgY29tcG9uZW50cywgb3B0aW9uYWxseSBmaWx0ZXJpbmcgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICAgICAgT3B0aW9uYWwgbmFtZSB0byBmaWx0ZXIgYnlcbiAgICogQHJldHVybiB7Q29tcG9uZW50W119ICAgICAgIFRoZSBmb3VuZCBzdWIgY29tcG9uZW50c1xuICAgKi9cbiAgZ2V0QWxsU3ViY29tcG9uZW50cyhuYW1lKSB7XG4gICAgbGV0IGpDYWxMZW4gPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGxldCBjb21wcyA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdO1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICBpZiAobmFtZSA9PT0gY29tcHNbaV1bTkFNRV9JTkRFWF0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoaSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMgfHxcbiAgICAgICAgICAodGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCAhPT0gakNhbExlbikpIHtcbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzIHx8IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiBhIG5hbWVkIHByb3BlcnR5IGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCB3aGVuIHByb3BlcnR5IGlzIGZvdW5kXG4gICAqL1xuICBoYXNQcm9wZXJ0eShuYW1lKSB7XG4gICAgbGV0IHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICBsZXQgbGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIDAgaXMgcHJvcGVydHkgbmFtZVxuICAgICAgaWYgKHByb3BzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHksIG9wdGlvbmFsbHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHs/UHJvcGVydHl9ICAgICBUaGUgZm91bmQgcHJvcGVydHlcbiAgICovXG4gIGdldEZpcnN0UHJvcGVydHkobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBsZXQgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgbGV0IGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAocHJvcHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlUHJvcGVydHkoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmaXJzdCBwcm9wZXJ0eSdzIHZhbHVlLCBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgICAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7QmluYXJ5IHwgRHVyYXRpb24gfCBQZXJpb2QgfFxuICAgKiBSZWN1ciB8IFRpbWUgfCBVdGNPZmZzZXQgfCBHZW8gfCBzdHJpbmcgfCBudWxsfSAgICAgICAgIFRoZSBmb3VuZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGdldEZpcnN0UHJvcGVydHlWYWx1ZShuYW1lKSB7XG4gICAgbGV0IHByb3AgPSB0aGlzLmdldEZpcnN0UHJvcGVydHkobmFtZSk7XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLmdldEZpcnN0VmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHByb3BlcnRpZXMgaW4gdGhlIGNvbXBvbmVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAqIEByZXR1cm4ge1Byb3BlcnR5W119ICAgIExpc3Qgb2YgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0QWxsUHJvcGVydGllcyhuYW1lKSB7XG4gICAgbGV0IGpDYWxMZW4gPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgbGV0IHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHByb3BzW2ldW05BTUVfSU5ERVhdKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMgfHxcbiAgICAgICAgICAodGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ICE9PSBqQ2FsTGVuKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcyB8fCBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGUsIGluZGV4KSB7XG4gICAgY2FjaGUgPSBjYWNoZSB8fCBbXTtcbiAgICAvLyByZW1vdmUgY2FjaGVkIHZlcnNpb25cbiAgICBpZiAoY2FjaGVbaW5kZXhdKSB7XG4gICAgICBsZXQgb2JqID0gY2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKFwicGFyZW50XCIgaW4gb2JqKSB7XG4gICAgICAgICAgb2JqLnBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FjaGUuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBqQ2FsXG4gICAgdGhpcy5qQ2FsW2pDYWxJbmRleF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZU9iamVjdChqQ2FsSW5kZXgsIGNhY2hlLCBuYW1lT3JPYmplY3QpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG9iamVjdHMgPSB0aGlzLmpDYWxbakNhbEluZGV4XTtcbiAgICBsZXQgbGVuID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXNbY2FjaGVdO1xuXG4gICAgaWYgKHR5cGVvZihuYW1lT3JPYmplY3QpID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAob2JqZWN0c1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhY2hlZCkge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoY2FjaGVkW2ldICYmIGNhY2hlZFtpXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVBbGxPYmplY3RzKGpDYWxJbmRleCwgY2FjaGUsIG5hbWUpIHtcbiAgICBsZXQgY2FjaGVkID0gdGhpc1tjYWNoZV07XG5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIGhhdmUgdG8gcnVuIHRocm91Z2ggYWxsIGNoaWxkcmVuIHRvIHJlc2V0IHRoZWlyXG4gICAgLy8gcGFyZW50IHByb3BlcnR5LlxuICAgIGxldCBvYmplY3RzID0gdGhpcy5qQ2FsW2pDYWxJbmRleF07XG4gICAgbGV0IGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBkZXNjZW5kaW5nIHNlYXJjaCByZXF1aXJlZCBiZWNhdXNlIHNwbGljZVxuICAgIC8vIGlzIHVzZWQgYW5kIHdpbGwgZWZmZWN0IHRoZSBpbmRpY2VzLlxuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCFuYW1lIHx8IG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBzaW5nbGUgc3ViIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudCAgICAgICAgVGhlIGNvbXBvbmVudCB0byBhZGRcbiAgICogQHJldHVybiB7Q29tcG9uZW50fSAgICAgICAgICAgICAgICAgVGhlIHBhc3NlZCBpbiBjb21wb25lbnRcbiAgICovXG4gIGFkZFN1YmNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQucGFyZW50KSB7XG4gICAgICBjb21wb25lbnQucGFyZW50LnJlbW92ZVN1YmNvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGxldCBpZHggPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5wdXNoKGNvbXBvbmVudC5qQ2FsKTtcbiAgICB0aGlzLl9jb21wb25lbnRzW2lkeCAtIDFdID0gY29tcG9uZW50O1xuICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQrKztcbiAgICBjb21wb25lbnQucGFyZW50ID0gdGhpcztcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzaW5nbGUgY29tcG9uZW50IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIGEgc3BlY2lmaWNcbiAgICogY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudHxTdHJpbmd9IG5hbWVPckNvbXAgICAgTmFtZSBvZiBjb21wb25lbnQsIG9yIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlIHdoZW4gY29tcCBpcyByZW1vdmVkXG4gICAqL1xuICByZW1vdmVTdWJjb21wb25lbnQobmFtZU9yQ29tcCkge1xuICAgIGxldCByZW1vdmVkID0gdGhpcy5fcmVtb3ZlT2JqZWN0KENPTVBPTkVOVF9JTkRFWCwgJ19jb21wb25lbnRzJywgbmFtZU9yQ29tcCk7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQtLTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY29tcG9uZW50cyBvciAoaWYgZ2l2ZW4pIGFsbCBjb21wb25lbnRzIGJ5IGEgcGFydGljdWxhclxuICAgKiBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgICAgICBMb3dlcmNhc2UgY29tcG9uZW50IG5hbWVcbiAgICovXG4gIHJlbW92ZUFsbFN1YmNvbXBvbmVudHMobmFtZSkge1xuICAgIGxldCByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWUpO1xuICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4ge0BsaW5rIElDQUwuUHJvcGVydHl9IHRvIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvcGVydHl9IHByb3BlcnR5ICAgICAgVGhlIHByb3BlcnR5IHRvIGFkZFxuICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gICAgICAgICAgICAgIFRoZSBwYXNzZWQgaW4gcHJvcGVydHlcbiAgICovXG4gIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBQcm9wZXJ0eSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgaW5zdGFuY2Ugb2YgSUNBTC5Qcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IFtdO1xuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHkucGFyZW50KSB7XG4gICAgICBwcm9wZXJ0eS5wYXJlbnQucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cblxuICAgIGxldCBpZHggPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLnB1c2gocHJvcGVydHkuakNhbCk7XG4gICAgdGhpcy5fcHJvcGVydGllc1tpZHggLSAxXSA9IHByb3BlcnR5O1xuICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgIHByb3BlcnR5LnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgcHJvcGVydHkgd2l0aCBhIHZhbHVlIHRvIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIGFkZFxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSB2YWx1ZSAgICAgICAgUHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7UHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgKi9cbiAgYWRkUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgICBsZXQgcHJvcCA9IG5ldyBQcm9wZXJ0eShuYW1lKTtcbiAgICBwcm9wLnNldFZhbHVlKHZhbHVlKTtcblxuICAgIHRoaXMuYWRkUHJvcGVydHkocHJvcCk7XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgd2lsbCB1cGRhdGUgb3IgY3JlYXRlIGEgcHJvcGVydHkgb2YgdGhlIGdpdmVuIG5hbWVcbiAgICogYW5kIHNldHMgaXRzIHZhbHVlLiBJZiBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3QsXG4gICAqIG9ubHkgdGhlIGZpcnN0IGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSB2YWx1ZSAgICAgICAgUHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7UHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgKi9cbiAgdXBkYXRlUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgICBsZXQgcHJvcCA9IHRoaXMuZ2V0Rmlyc3RQcm9wZXJ0eShuYW1lKTtcblxuICAgIGlmIChwcm9wKSB7XG4gICAgICBwcm9wLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcCA9IHRoaXMuYWRkUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzaW5nbGUgcHJvcGVydHkgYnkgbmFtZSBvciB0aGUgaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmljXG4gICAqIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xQcm9wZXJ0eX0gbmFtZU9yUHJvcCAgICAgUHJvcGVydHkgbmFtZSBvciBpbnN0YW5jZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgd2hlbiBkZWxldGVkXG4gICAqL1xuICByZW1vdmVQcm9wZXJ0eShuYW1lT3JQcm9wKSB7XG4gICAgbGV0IHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVPYmplY3QoUFJPUEVSVFlfSU5ERVgsICdfcHJvcGVydGllcycsIG5hbWVPclByb3ApO1xuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQtLTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQsIG9wdGlvbmFsbHlcbiAgICogZmlsdGVyZWQgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIFRydWUsIHdoZW4gZGVsZXRlZFxuICAgKi9cbiAgcmVtb3ZlQWxsUHJvcGVydGllcyhuYW1lKSB7XG4gICAgbGV0IHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVBbGxPYmplY3RzKFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lKTtcbiAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC4gVGhlIHJldHVybmVkIG9iamVjdFxuICAgKiBpcyBhIGxpdmUgakNhbCBvYmplY3QgYW5kIHNob3VsZCBiZSBjbG9uZWQgaWYgbW9kaWZpZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5qQ2FsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzdHJpbmdpZnkuY29tcG9uZW50KFxuICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgdGltZSB6b25lIGRlZmluaXRpb24gZnJvbSB0aGUgY29tcG9uZW50IHRyZWUsIGlmIGFueSBpcyBwcmVzZW50LlxuICAgKiBJZiB0aGUgdHJlZSBjb250YWlucyBubyB0aW1lIHpvbmUgZGVmaW5pdGlvbnMgb3IgdGhlIFRaSUQgY2Fubm90IGJlXG4gICAqIG1hdGNoZWQsIHJldHVybnMgbnVsbC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRoZSBJRCBvZiB0aGUgdGltZSB6b25lIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm4ge1RpbWV6b25lfSAgVGhlIHRpbWUgem9uZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBJRCwgb3IgbnVsbFxuICAgKi9cbiAgZ2V0VGltZVpvbmVCeUlEKHR6aWQpIHtcbiAgICAvLyBWVElNRVpPTkUgY29tcG9uZW50cyBjYW4gb25seSBhcHBlYXIgYXMgYSBjaGlsZCBvZiB0aGUgVkNBTEVOREFSXG4gICAgLy8gY29tcG9uZW50OyB3YWxrIHRoZSB0cmVlIGlmIHdlJ3JlIG5vdCB0aGUgcm9vdC5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRUaW1lWm9uZUJ5SUQodHppZCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGltZSB6b25lIGNhY2hlLCB3ZSBhcmUgcHJvYmFibHkgcGFyc2luZyBhbiBpbmNvbXBsZXRlXG4gICAgLy8gZmlsZSBhbmQgd2lsbCBoYXZlIG5vIHRpbWUgem9uZSBkZWZpbml0aW9ucy5cbiAgICBpZiAoIXRoaXMuX3RpbWV6b25lQ2FjaGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90aW1lem9uZUNhY2hlLmhhcyh0emlkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWV6b25lQ2FjaGUuZ2V0KHR6aWQpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB0aW1lIHpvbmUgaXMgbm90IGFscmVhZHkgY2FjaGVkLCBoeWRyYXRlIGl0IGZyb20gdGhlXG4gICAgLy8gc3ViY29tcG9uZW50cy5cbiAgICBjb25zdCB6b25lcyA9IHRoaXMuZ2V0QWxsU3ViY29tcG9uZW50cygndnRpbWV6b25lJyk7XG4gICAgZm9yIChjb25zdCB6b25lIG9mIHpvbmVzKSB7XG4gICAgICBpZiAoem9uZS5nZXRGaXJzdFByb3BlcnR5KCd0emlkJykuZ2V0Rmlyc3RWYWx1ZSgpID09PSB0emlkKSB7XG4gICAgICAgIGNvbnN0IGh5ZHJhdGVkWm9uZSA9IG5ldyBUaW1lem9uZSh7XG4gICAgICAgICAgY29tcG9uZW50OiB6b25lLFxuICAgICAgICAgIHR6aWQ6IHR6aWQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3RpbWV6b25lQ2FjaGUuc2V0KHR6aWQsIGh5ZHJhdGVkWm9uZSk7XG5cbiAgICAgICAgcmV0dXJuIGh5ZHJhdGVkWm9uZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQZXIgdGhlIHN0YW5kYXJkLCB3ZSBzaG91bGQgYWx3YXlzIGhhdmUgYSB0aW1lIHpvbmUgZGVmaW5lZCBpbiBhIGZpbGVcbiAgICAvLyBmb3IgYW55IHJlZmVyZW5jZWQgVFpJRCwgYnV0IGRvbid0IGJsb3cgdXAgaWYgdGhlIGZpbGUgaXMgaW52YWxpZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBQcmltYXJ5IGNsYXNzIGZvciBleHBhbmRpbmcgcmVjdXJyaW5nIHJ1bGVzLiAgQ2FuIHRha2UgbXVsdGlwbGUgcnJ1bGVzLCByZGF0ZXMsIGV4ZGF0ZShzKSBhbmRcbiAqIGl0ZXJhdGUgKGluIG9yZGVyKSBvdmVyIGVhY2ggbmV4dCBvY2N1cnJlbmNlLlxuICpcbiAqIE9uY2UgaW5pdGlhbGl6ZWQgdGhpcyBjbGFzcyBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIHNhdmVkIGFuZCBjb250aW51ZSBpdGVyYXRpb24gZnJvbSB0aGUgbGFzdFxuICogcG9pbnQuXG4gKlxuICogTk9URTogaXQgaXMgaW50ZW5kZWQgdGhhdCB0aGlzIGNsYXNzIGlzIHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgSUNBTC5FdmVudH0gd2hpY2ggaGFuZGxlcyByZWN1cnJlbmNlXG4gKiBleGNlcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBhc3N1bWluZyBldmVudCBpcyBhIHBhcnNlZCBpY2FsIGNvbXBvbmVudFxuICogdmFyIGV2ZW50O1xuICpcbiAqIHZhciBleHBhbmQgPSBuZXcgSUNBTC5SZWN1ckV4cGFuc2lvbih7XG4gKiAgIGNvbXBvbmVudDogZXZlbnQsXG4gKiAgIGR0c3RhcnQ6IGV2ZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpXG4gKiB9KTtcbiAqXG4gKiAvLyByZW1lbWJlciB0aGVyZSBhcmUgaW5maW5pdGUgcnVsZXMgc28gaXQgaXMgYSBnb29kIGlkZWEgdG8gbGltaXQgdGhlIHNjb3BlIG9mIHRoZSBpdGVyYXRpb25zXG4gKiAvLyB0aGVuIHJlc3VtZSBsYXRlciBvbi5cbiAqXG4gKiAvLyBuZXh0IGlzIGFsd2F5cyBhbiBJQ0FMLlRpbWUgb3IgbnVsbFxuICogdmFyIG5leHQ7XG4gKlxuICogd2hpbGUgKHNvbWVDb25kaXRpb24gJiYgKG5leHQgPSBleHBhbmQubmV4dCgpKSkge1xuICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCBuZXh0XG4gKiB9XG4gKlxuICogLy8gc2F2ZSBpbnN0YW5jZSBmb3IgbGF0ZXJcbiAqIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZXhwYW5kKTtcbiAqXG4gKiAvLy4uLlxuICpcbiAqIC8vIE5PVEU6IGlmIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzIGhhdmUgY2hhbmdlZCB5b3Ugd2lsbCBuZWVkIHRvIHJlYnVpbGQgdGhlIGNsYXNzIGFuZCBzdGFydFxuICogLy8gb3Zlci4gVGhpcyBvbmx5IHdvcmtzIHdoZW4gdGhlIGNvbXBvbmVudCdzIHJlY3VycmVuY2UgaW5mbyBpcyB0aGUgc2FtZS5cbiAqIHZhciBleHBhbmQgPSBuZXcgSUNBTC5SZWN1ckV4cGFuc2lvbihKU09OLnBhcnNlKGpzb24pKTtcbiAqXG4gKiBAbWVtYmVyb2YgSUNBTFxuICovXG5jbGFzcyBSZWN1ckV4cGFuc2lvbiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuUmVjdXJFeHBhbnNpb24gaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gYmUgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCBpbml0aWFsIHZhbHVlcy4gSXQgY2FuIGFsc28gY29udGFpblxuICAgKiBhZGRpdGlvbmFsIG1lbWJlcnMsIGFzIGEgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIGEgcHJldmlvdXMgZXhwYW5zaW9uIHN0YXRlLCBhcyBzaG93biBpbiB0aGVcbiAgICogZXhhbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFJlY3VycmVuY2UgZXhwYW5zaW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtUaW1lfSBvcHRpb25zLmR0c3RhcnRcbiAgICogICAgICAgIFN0YXJ0IHRpbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7Q29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICogICAgICAgIENvbXBvbmVudCBmb3IgZXhwYW5zaW9uLCByZXF1aXJlZCBpZiBub3QgcmVzdW1pbmcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlRGF0ZXMgPSBbXTtcbiAgICB0aGlzLmV4RGF0ZXMgPSBbXTtcbiAgICB0aGlzLmZyb21EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiBpdGVyYXRpb24gaXMgZnVsbHkgY29tcGxldGVkLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGNvbXBsZXRlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIHJydWxlIGl0ZXJhdG9ycy5cbiAgICpcbiAgICogQHR5cGUge1JlY3VySXRlcmF0b3JbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ1bGVJdGVyYXRvcnMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiByZGF0ZSBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEB0eXBlIHtUaW1lW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydWxlRGF0ZXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBleGRhdGUgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7VGltZVtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXhEYXRlcyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gcnVsZURhdGVzIGFycmF5LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnVsZURhdGVJbmMgPSAwO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIGV4RGF0ZXMgYXJyYXlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGV4RGF0ZUluYyA9IDA7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgbmVnYXRpdmUgZGF0ZS5cbiAgICpcbiAgICogQHR5cGUge1RpbWV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleERhdGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IGFkZGl0aW9uYWwgZGF0ZS5cbiAgICpcbiAgICogQHR5cGUge1RpbWV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydWxlRGF0ZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGRhdGUgb2YgcmVjdXJyaW5nIHJ1bGVzLlxuICAgKlxuICAgKiBAdHlwZSB7VGltZX1cbiAgICovXG4gIGR0c3RhcnQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBMYXN0IGV4cGFuZGVkIHRpbWVcbiAgICpcbiAgICogQHR5cGUge1RpbWV9XG4gICAqL1xuICBsYXN0ID0gbnVsbDtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24gZnJvbSB0aGUgZGF0YSBvYmplY3QuIFRoZSBvcHRpb25zXG4gICAqIG9iamVjdCBtYXkgYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgc2VlIHRoZVxuICAgKiB7QGxpbmsgSUNBTC5SZWN1ckV4cGFuc2lvbiBjb25zdHJ1Y3Rvcn0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFJlY3VycmVuY2UgZXhwYW5zaW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtUaW1lfSBvcHRpb25zLmR0c3RhcnRcbiAgICogICAgICAgIFN0YXJ0IHRpbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7Q29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICogICAgICAgIENvbXBvbmVudCBmb3IgZXhwYW5zaW9uLCByZXF1aXJlZCBpZiBub3QgcmVzdW1pbmcuXG4gICAqL1xuICBmcm9tRGF0YShvcHRpb25zKSB7XG4gICAgbGV0IHN0YXJ0ID0gZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMuZHRzdGFydCwgVGltZSk7XG5cbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy5kdHN0YXJ0IChJQ0FMLlRpbWUpIG11c3QgYmUgZ2l2ZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kdHN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMuY29tcG9uZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0ID0gZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMubGFzdCwgVGltZSkgfHwgc3RhcnQuY2xvbmUoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLnJ1bGVJdGVyYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcucnVsZUl0ZXJhdG9ycyBvciAuY29tcG9uZW50IG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ydWxlSXRlcmF0b3JzID0gb3B0aW9ucy5ydWxlSXRlcmF0b3JzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRDbGFzc1R5cGUoaXRlbSwgUmVjdXJJdGVyYXRvcik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IG9wdGlvbnMucnVsZURhdGVJbmM7XG4gICAgICB0aGlzLmV4RGF0ZUluYyA9IG9wdGlvbnMuZXhEYXRlSW5jO1xuXG4gICAgICBpZiAob3B0aW9ucy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgdGhpcy5ydWxlRGF0ZXMgPSBvcHRpb25zLnJ1bGVEYXRlcy5tYXAoaXRlbSA9PiBmb3JtYXRDbGFzc1R5cGUoaXRlbSwgVGltZSkpO1xuICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmV4RGF0ZXMpIHtcbiAgICAgICAgdGhpcy5leERhdGVzID0gb3B0aW9ucy5leERhdGVzLm1hcChpdGVtID0+IGZvcm1hdENsYXNzVHlwZShpdGVtLCBUaW1lKSk7XG4gICAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzW3RoaXMuZXhEYXRlSW5jXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZihvcHRpb25zLmNvbXBsZXRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBuZXh0IG9jY3VycmVuY2UgaW4gdGhlIHNlcmllcy5cbiAgICogQHJldHVybiB7VGltZX1cbiAgICovXG4gIG5leHQoKSB7XG4gICAgbGV0IGl0ZXI7XG4gICAgbGV0IG5leHQ7XG4gICAgbGV0IGNvbXBhcmU7XG5cbiAgICBsZXQgbWF4VHJpZXMgPSA1MDA7XG4gICAgbGV0IGN1cnJlbnRUcnkgPSAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChjdXJyZW50VHJ5KysgPiBtYXhUcmllcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ21heCB0cmllcyBoYXZlIG9jY3VycmVkLCBydWxlIG1heSBiZSBpbXBvc3NpYmxlIHRvIGZ1bGZpbGwuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBuZXh0ID0gdGhpcy5ydWxlRGF0ZTtcbiAgICAgIGl0ZXIgPSB0aGlzLl9uZXh0UmVjdXJyZW5jZUl0ZXIodGhpcy5sYXN0KTtcblxuICAgICAgLy8gbm8gbW9yZSBtYXRjaGVzXG4gICAgICAvLyBiZWNhdXNlIHdlIGluY3JlbWVudCB0aGUgcnVsZSBkYXkgb3IgcnVsZVxuICAgICAgLy8gX2FmdGVyXyB3ZSBjaG9vc2UgYSB2YWx1ZSB0aGlzIHNob3VsZCBiZVxuICAgICAgLy8gdGhlIG9ubHkgc3BvdCB3aGVyZSB3ZSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZVxuICAgICAgLy8gZW5kIG9mIGV2ZW50cy5cbiAgICAgIGlmICghbmV4dCAmJiAhaXRlcikge1xuICAgICAgICAvLyB0aGVyZSBhcmUgbm8gbW9yZSBpdGVyYXRvcnMgb3IgcmRhdGVzXG4gICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbmV4dCBydWxlIGRheSBvciByZWN1cnJlbmNlIHJ1bGUgaXMgZmlyc3QuXG4gICAgICBpZiAoIW5leHQgfHwgKGl0ZXIgJiYgbmV4dC5jb21wYXJlKGl0ZXIubGFzdCkgPiAwKSkge1xuICAgICAgICAvLyBtdXN0IGJlIGNsb25lZCwgcmVjdXIgd2lsbCByZXVzZSB0aGUgdGltZSBlbGVtZW50LlxuICAgICAgICBuZXh0ID0gaXRlci5sYXN0LmNsb25lKCk7XG4gICAgICAgIC8vIG1vdmUgdG8gbmV4dCBzbyB3ZSBjYW4gY29udGludWVcbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBydWxlRGF0ZSBpcyBzdGlsbCBuZXh0IGluY3JlbWVudCBpdC5cbiAgICAgIGlmICh0aGlzLnJ1bGVEYXRlID09PSBuZXh0KSB7XG4gICAgICAgIHRoaXMuX25leHRSdWxlRGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdCA9IG5leHQ7XG5cbiAgICAgIC8vIGNoZWNrIHRoZSBuZWdhdGl2ZSBydWxlc1xuICAgICAgaWYgKHRoaXMuZXhEYXRlKSB7XG4gICAgICAgIGNvbXBhcmUgPSB0aGlzLmV4RGF0ZS5jb21wYXJlKHRoaXMubGFzdCk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmUgPCAwKSB7XG4gICAgICAgICAgdGhpcy5fbmV4dEV4RGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGV4Y2x1ZGVkIHNraXAgaXQuXG4gICAgICAgIGlmIChjb21wYXJlID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fbmV4dEV4RGF5KCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9YWFg6IFRoZSBzcGVjIHN0YXRlcyB0aGF0IGFmdGVyIHdlIHJlc29sdmUgdGhlIGZpbmFsXG4gICAgICAvLyAgICAgbGlzdCBvZiBkYXRlcyB3ZSBleGVjdXRlIGV4ZGF0ZSB0aGlzIHNlZW1zIHNvbWV3aGF0IGNvdW50ZXJcbiAgICAgIC8vICAgICBpbnR1aXRpdmUgdG8gd2hhdCBJIGhhdmUgc2VlbiBtb3N0IHNlcnZlcnMgZG8gc28gZm9yIG5vd1xuICAgICAgLy8gICAgIEkgZXhjbHVkZSBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgZGF0ZSBub3QgdGhlIG9uZSB0aGF0IG1heVxuICAgICAgLy8gICAgIGhhdmUgYmVlbiBtb2RpZmllZCBieSB0aGUgZXhjZXB0aW9uLlxuICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgb2JqZWN0IGludG8gYSBzZXJpYWxpemUtYWJsZSBmb3JtYXQuIFRoaXMgZm9ybWF0IGNhbiBiZSBwYXNzZWRcbiAgICogYmFjayBpbnRvIHRoZSBleHBhbnNpb24gdG8gcmVzdW1lIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGZ1bmN0aW9uIHRvSlNPTihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS50b0pTT04oKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXN1bHQucnVsZUl0ZXJhdG9ycyA9IHRoaXMucnVsZUl0ZXJhdG9ycy5tYXAodG9KU09OKTtcblxuICAgIGlmICh0aGlzLnJ1bGVEYXRlcykge1xuICAgICAgcmVzdWx0LnJ1bGVEYXRlcyA9IHRoaXMucnVsZURhdGVzLm1hcCh0b0pTT04pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4RGF0ZXMpIHtcbiAgICAgIHJlc3VsdC5leERhdGVzID0gdGhpcy5leERhdGVzLm1hcCh0b0pTT04pO1xuICAgIH1cblxuICAgIHJlc3VsdC5ydWxlRGF0ZUluYyA9IHRoaXMucnVsZURhdGVJbmM7XG4gICAgcmVzdWx0LmV4RGF0ZUluYyA9IHRoaXMuZXhEYXRlSW5jO1xuICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgIHJlc3VsdC5kdHN0YXJ0ID0gdGhpcy5kdHN0YXJ0LnRvSlNPTigpO1xuICAgIHJlc3VsdC5jb21wbGV0ZSA9IHRoaXMuY29tcGxldGU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYWxsIGRhdGVzIGZyb20gdGhlIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIGNvbXBvbmVudC4gVGhlXG4gICAqIHByb3BlcnRpZXMgd2lsbCBiZSBmaWx0ZXJlZCBieSB0aGUgcHJvcGVydHkgbmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudCAgICAgICAgICAgICBUaGUgY29tcG9uZW50IHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lICAgICAgICAgICAgIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybiB7VGltZVtdfSAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXh0cmFjdGVkIGRhdGVzLlxuICAgKi9cbiAgX2V4dHJhY3REYXRlcyhjb21wb25lbnQsIHByb3BlcnR5TmFtZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcHJvcHMgPSBjb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcyhwcm9wZXJ0eU5hbWUpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBwcm9wIG9mIHByb3BzW2ldLmdldFZhbHVlcygpKSB7XG4gICAgICAgIGxldCBpZHggPSBiaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgKGEsIGIpID0+IGEuY29tcGFyZShiKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG9yZGVyZWQgaW5zZXJ0XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgZXhwYW5zaW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50ICAgIFRoZSBjb21wb25lbnQgdG8gaW5pdGlhbGl6ZSBmcm9tLlxuICAgKi9cbiAgX2luaXQoY29tcG9uZW50KSB7XG4gICAgdGhpcy5ydWxlSXRlcmF0b3JzID0gW107XG5cbiAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcblxuICAgIC8vIHRvIHByb3ZpZGUgYXBpIGNvbnNpc3RlbmN5IG5vbi1yZWN1cnJpbmdcbiAgICAvLyBldmVudHMgY2FuIGFsc28gdXNlIHRoZSBpdGVyYXRvciB0aG91Z2ggaXQgd2lsbFxuICAgIC8vIG9ubHkgcmV0dXJuIGEgc2luZ2xlIHRpbWUuXG4gICAgaWYgKCFjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JkYXRlJykgJiZcbiAgICAgICAgIWNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSAmJlxuICAgICAgICAhY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykpIHtcbiAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JkYXRlJykpIHtcbiAgICAgIHRoaXMucnVsZURhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ3JkYXRlJyk7XG5cbiAgICAgIC8vIHNwZWNpYWwgaGFjayBmb3IgY2FzZXMgd2hlcmUgZmlyc3QgcmRhdGUgaXMgcHJpb3JcbiAgICAgIC8vIHRvIHRoZSBzdGFydCBkYXRlLiBXZSBvbmx5IGNoZWNrIGZvciB0aGUgZmlyc3QgcmRhdGUuXG4gICAgICAvLyBUaGlzIGlzIG1vc3RseSBmb3IgZ29vZ2xlJ3MgY3JhenkgcmVjdXJyaW5nIGRhdGUgbG9naWNcbiAgICAgIC8vIChjb250YWN0cyBiaXJ0aGRheXMpLlxuICAgICAgaWYgKCh0aGlzLnJ1bGVEYXRlc1swXSkgJiZcbiAgICAgICAgICAodGhpcy5ydWxlRGF0ZXNbMF0uY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCkpIHtcblxuICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5ydWxlRGF0ZXNbMF0uY2xvbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSBiaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZXMsXG4gICAgICAgICAgdGhpcy5sYXN0LFxuICAgICAgICAgIChhLCBiKSA9PiBhLmNvbXBhcmUoYilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzW3RoaXMucnVsZURhdGVJbmNdO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JydWxlJykpIHtcbiAgICAgIGxldCBydWxlcyA9IGNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdycnVsZScpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICAgICAgbGV0IHJ1bGU7XG4gICAgICBsZXQgaXRlcjtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBydWxlID0gcnVsZXNbaV0uZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICBpdGVyID0gcnVsZS5pdGVyYXRvcih0aGlzLmR0c3RhcnQpO1xuICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMucHVzaChpdGVyKTtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgdG8gdGhlIG5leHQgb2NjdXJyZW5jZSBzbyBmdXR1cmVcbiAgICAgICAgLy8gY2FsbHMgdG8gbmV4dCByZXR1cm4gdGltZXMgYmV5b25kIHRoZSBpbml0aWFsIGl0ZXJhdGlvbi5cbiAgICAgICAgLy8gWFhYOiBJIGZpbmQgdGhpcyBzdXNwaWNpb3VzIG1pZ2h0IGJlIGEgYnVnP1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdleGRhdGUnKSkge1xuICAgICAgdGhpcy5leERhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ2V4ZGF0ZScpO1xuICAgICAgLy8gaWYgd2UgaGF2ZSBhIC5sYXN0IGRheSB3ZSBpbmNyZW1lbnQgdGhlIGluZGV4IHRvIGJleW9uZCBpdC5cbiAgICAgIHRoaXMuZXhEYXRlSW5jID0gYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICB0aGlzLmV4RGF0ZXMsXG4gICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgKGEsIGIpID0+IGEuY29tcGFyZShiKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbdGhpcy5leERhdGVJbmNdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRvIHRoZSBuZXh0IGV4ZGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25leHRFeERheSgpIHtcbiAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1srK3RoaXMuZXhEYXRlSW5jXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRvIHRoZSBuZXh0IHJ1bGUgZGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25leHRSdWxlRGF5KCkge1xuICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1srK3RoaXMucnVsZURhdGVJbmNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHJldHVybiB0aGUgcmVjdXJyZW5jZSBydWxlIHdpdGggdGhlIG1vc3QgcmVjZW50IGV2ZW50IGFuZFxuICAgKiByZXR1cm4gaXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4gez9SZWN1ckl0ZXJhdG9yfSAgICBGb3VuZCBpdGVyYXRvci5cbiAgICovXG4gIF9uZXh0UmVjdXJyZW5jZUl0ZXIoKSB7XG4gICAgbGV0IGl0ZXJzID0gdGhpcy5ydWxlSXRlcmF0b3JzO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGl0ZXJzLmxlbmd0aDtcbiAgICBsZXQgaXRlcjtcbiAgICBsZXQgaXRlclRpbWU7XG4gICAgbGV0IGl0ZXJJZHggPSAwO1xuICAgIGxldCBjaG9zZW5JdGVyO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlcmF0b3JcbiAgICBmb3IgKDsgaXRlcklkeCA8IGxlbjsgaXRlcklkeCsrKSB7XG4gICAgICBpdGVyID0gaXRlcnNbaXRlcklkeF07XG4gICAgICBpdGVyVGltZSA9IGl0ZXIubGFzdDtcblxuICAgICAgLy8gaWYgaXRlcmF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAvLyB0aGVuIHdlIG11c3QgZXhjbHVkZSBpdCBmcm9tXG4gICAgICAvLyB0aGUgc2VhcmNoIGFuZCByZW1vdmUgaXQuXG4gICAgICBpZiAoaXRlci5jb21wbGV0ZWQpIHtcbiAgICAgICAgbGVuLS07XG4gICAgICAgIGlmIChpdGVySWR4ICE9PSAwKSB7XG4gICAgICAgICAgaXRlcklkeC0tO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJzLnNwbGljZShpdGVySWR4LCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgdGhlIG1vc3QgcmVjZW50IHBvc3NpYmxlIGNob2ljZVxuICAgICAgaWYgKCFjaG9zZW5JdGVyIHx8IGNob3Nlbkl0ZXIubGFzdC5jb21wYXJlKGl0ZXJUaW1lKSA+IDApIHtcbiAgICAgICAgLy8gdGhhdCBpdGVyYXRvciBpcyBzYXZlZFxuICAgICAgICBjaG9zZW5JdGVyID0gaXRlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGUgY2hvc2VuIGl0ZXJhdG9yIGlzIHJldHVybmVkIGJ1dCBub3QgbXV0YXRlZFxuICAgIC8vIHRoaXMgaXRlcmF0b3IgY29udGFpbnMgdGhlIG1vc3QgcmVjZW50IGV2ZW50LlxuICAgIHJldHVybiBjaG9zZW5JdGVyO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoaXMgbGV0cyB0eXBlc2NyaXB0IHJlc29sdmUgb3VyIGN1c3RvbSB0eXBlcyBpbiB0aGVcbiAqIGdlbmVyYXRlZCBkLnRzIGZpbGVzIChqc2RvYyB0eXBlZGVmcyBhcmUgY29udmVydGVkIHRvIHR5cGVzY3JpcHQgdHlwZXMpLlxuICogSWdub3JlIHByZXZlbnRzIHRoZSB0eXBlZGVmcyBmcm9tIGJlaW5nIGRvY3VtZW50ZWQgbW9yZSB0aGFuIG9uY2UuXG4gKiBAaWdub3JlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5mcmVxdWVuY3lWYWx1ZXN9IGZyZXF1ZW5jeVZhbHVlc1xuICogSW1wb3J0cyB0aGUgJ2ZyZXF1ZW5jeVZhbHVlcycgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi90eXBlcy5qc1wiKS5vY2N1cnJlbmNlRGV0YWlsc30gb2NjdXJyZW5jZURldGFpbHNcbiAqIEltcG9ydHMgdGhlICdvY2N1cnJlbmNlRGV0YWlscycgdHlwZSBmcm9tIHRoZSBcInR5cGVzLmpzXCIgbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBJQ0FMLmpzIGlzIG9yZ2FuaXplZCBpbnRvIG11bHRpcGxlIGxheWVycy4gVGhlIGJvdHRvbSBsYXllciBpcyBhIHJhdyBqQ2FsXG4gKiBvYmplY3QsIGZvbGxvd2VkIGJ5IHRoZSBjb21wb25lbnQvcHJvcGVydHkgbGF5ZXIuIFRoZSBoaWdoZXN0IGxldmVsIGlzIHRoZVxuICogZXZlbnQgcmVwcmVzZW50YXRpb24sIHdoaWNoIHRoaXMgY2xhc3MgaXMgcGFydCBvZi4gU2VlIHRoZVxuICoge0B0dXRvcmlhbCBsYXllcnN9IGd1aWRlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLkV2ZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudD19IGNvbXBvbmVudCAgICAgICAgICAgICAgVGhlIElDQUwuQ29tcG9uZW50IHRvIGJhc2UgdGhpcyBldmVudCBvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICAgICAgICAgICAgT3B0aW9ucyBmb3IgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnMgIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVpciBVVUlEXG4gICAqIEBwYXJhbSB7QXJyYXk8Q29tcG9uZW50fEV2ZW50Pj19IG9wdGlvbnMuZXhjZXB0aW9uc1xuICAgKiAgICAgICAgICBFeGNlcHRpb25zIHRvIHRoaXMgZXZlbnQsIGVpdGhlciBhcyBjb21wb25lbnRzIG9yIGV2ZW50cy4gSWYgbm90XG4gICAqICAgICAgICAgICAgc3BlY2lmaWVkIGV4Y2VwdGlvbnMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNldCBpbiByZWxhdGlvbiBvZlxuICAgKiAgICAgICAgICAgIGNvbXBvbmVudCdzIHBhcmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgQ29tcG9uZW50KSkge1xuICAgICAgb3B0aW9ucyA9IGNvbXBvbmVudDtcbiAgICAgIGNvbXBvbmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IENvbXBvbmVudCgndmV2ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5leGNlcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zKSB7XG4gICAgICB0aGlzLnN0cmljdEV4Y2VwdGlvbnMgPSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leGNlcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbnMuZm9yRWFjaCh0aGlzLnJlbGF0ZUV4Y2VwdGlvbiwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudC5wYXJlbnQgJiYgIXRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnBhcmVudC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpKSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGVFeGNlcHRpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuXG4gIHN0YXRpYyBUSElTQU5ERlVUVVJFID0gJ1RISVNBTkRGVVRVUkUnO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHJlbGF0ZWQgZXZlbnQgZXhjZXB0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50W119XG4gICAqL1xuICBleGNlcHRpb25zID0gbnVsbDtcblxuICAvKipcbiAgICogV2hlbiB0cnVlLCB3aWxsIHZlcmlmeSBleGNlcHRpb25zIGFyZSByZWxhdGVkIGJ5IHRoZWlyIFVVSUQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RyaWN0RXhjZXB0aW9ucyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBSZWxhdGVzIGEgZ2l2ZW4gZXZlbnQgZXhjZXB0aW9uIHRvIHRoaXMgb2JqZWN0LiAgSWYgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgKiBkb2VzIG5vdCBzaGFyZSB0aGUgVUlEIG9mIHRoaXMgZXZlbnQgaXQgY2Fubm90IGJlIHJlbGF0ZWQgYW5kIHdpbGwgdGhyb3dcbiAgICogYW4gZXhjZXB0aW9uLlxuICAgKlxuICAgKiBJZiB0aGlzIGNvbXBvbmVudCBpcyBhbiBleGNlcHRpb24gaXQgY2Fubm90IGhhdmUgb3RoZXIgZXhjZXB0aW9uc1xuICAgKiByZWxhdGVkIHRvIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudHxFdmVudH0gb2JqICAgICAgIENvbXBvbmVudCBvciBldmVudFxuICAgKi9cbiAgcmVsYXRlRXhjZXB0aW9uKG9iaikge1xuICAgIGlmICh0aGlzLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWxhdGUgZXhjZXB0aW9uIHRvIGV4Y2VwdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICBvYmogPSBuZXcgRXZlbnQob2JqKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJpY3RFeGNlcHRpb25zICYmIG9iai51aWQgIT09IHRoaXMudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHRlZCB0byByZWxhdGUgdW5yZWxhdGVkIGV4Y2VwdGlvbicpO1xuICAgIH1cblxuICAgIGxldCBpZCA9IG9iai5yZWN1cnJlbmNlSWQudG9TdHJpbmcoKTtcblxuICAgIC8vIHdlIGRvbid0IHNvcnQgb3IgbWFuYWdlIGV4Y2VwdGlvbnMgZGlyZWN0bHlcbiAgICAvLyBoZXJlIHRoZSByZWN1cnJlbmNlIGV4cGFuZGVyIGhhbmRsZXMgdGhhdC5cbiAgICB0aGlzLmV4Y2VwdGlvbnNbaWRdID0gb2JqO1xuXG4gICAgLy8gaW5kZXggUkFOR0U9VEhJU0FOREZVVFVSRSBleGNlcHRpb25zIHNvIHdlIGNhblxuICAgIC8vIGxvb2sgdGhlbSB1cCBsYXRlciBpbiBnZXRPY2N1cnJlbmNlRGV0YWlscy5cbiAgICBpZiAob2JqLm1vZGlmaWVzRnV0dXJlKCkpIHtcbiAgICAgIGxldCBpdGVtID0gW1xuICAgICAgICBvYmoucmVjdXJyZW5jZUlkLnRvVW5peFRpbWUoKSwgaWRcbiAgICAgIF07XG5cbiAgICAgIC8vIHdlIGtlZXAgdGhlbSBzb3J0ZWQgc28gd2UgY2FuIGZpbmQgdGhlIG5lYXJlc3RcbiAgICAgIC8vIHZhbHVlIGxhdGVyIG9uLi4uXG4gICAgICBsZXQgaWR4ID0gYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyxcbiAgICAgICAgaXRlbSxcbiAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICApO1xuXG4gICAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucy5zcGxpY2UoaWR4LCAwLCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgcmVjb3JkIGlzIGFuIGV4Y2VwdGlvbiBhbmQgaGFzIHRoZSBSQU5HRT1USElTQU5ERlVUVVJFXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSwgd2hlbiBleGNlcHRpb24gaXMgd2l0aGluIHJhbmdlXG4gICAqL1xuICBtb2RpZmllc0Z1dHVyZSgpIHtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmFuZ2UgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykuZ2V0UGFyYW1ldGVyKCdyYW5nZScpO1xuICAgIHJldHVybiByYW5nZSA9PT0gRXZlbnQuVEhJU0FOREZVVFVSRTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgcmFuZ2UgZXhjZXB0aW9uIG5lYXJlc3QgdG8gdGhlIGdpdmVuIGRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZX0gdGltZSAgIHVzdWFsbHkgYW4gb2NjdXJyZW5jZSB0aW1lIG9mIGFuIGV2ZW50XG4gICAqIEByZXR1cm4gez9FdmVudH0gICAgIHRoZSByZWxhdGVkIGV2ZW50L2V4Y2VwdGlvbiBvciBudWxsXG4gICAqL1xuICBmaW5kUmFuZ2VFeGNlcHRpb24odGltZSkge1xuICAgIGlmICghdGhpcy5yYW5nZUV4Y2VwdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgdXRjID0gdGltZS50b1VuaXhUaW1lKCk7XG4gICAgbGV0IGlkeCA9IGJpbnNlYXJjaEluc2VydChcbiAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgW3V0Y10sXG4gICAgICBjb21wYXJlUmFuZ2VFeGNlcHRpb25cbiAgICApO1xuXG4gICAgaWR4IC09IDE7XG5cbiAgICAvLyBvY2N1cnMgYmVmb3JlXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCByYW5nZUl0ZW0gPSB0aGlzLnJhbmdlRXhjZXB0aW9uc1tpZHhdO1xuXG4gICAgLyogYzggaWdub3JlIG5leHQgNCAqL1xuICAgIGlmICh1dGMgPCByYW5nZUl0ZW1bMF0pIHtcbiAgICAgIC8vIHNhbml0eSBjaGVjayBvbmx5XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2VJdGVtWzFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9jY3VycmVuY2UgZGV0YWlscyBiYXNlZCBvbiBpdHMgc3RhcnQgdGltZS4gIElmIHRoZVxuICAgKiBvY2N1cnJlbmNlIGhhcyBhbiBleGNlcHRpb24gd2lsbCByZXR1cm4gdGhlIGRldGFpbHMgZm9yIHRoYXQgZXhjZXB0aW9uLlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBpcyBpbnRlbmQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvblxuICAgKiAgICAgICB3aXRoIHRoZSB7QGxpbmsgSUNBTC5FdmVudCNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWV9IG9jY3VycmVuY2UgICAgICAgICAgICAgICB0aW1lIG9jY3VycmVuY2VcbiAgICogQHJldHVybiB7b2NjdXJyZW5jZURldGFpbHN9ICAgICAgICAgICAgSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9jY3VycmVuY2VcbiAgICovXG4gIGdldE9jY3VycmVuY2VEZXRhaWxzKG9jY3VycmVuY2UpIHtcbiAgICBsZXQgaWQgPSBvY2N1cnJlbmNlLnRvU3RyaW5nKCk7XG4gICAgbGV0IHV0Y0lkID0gb2NjdXJyZW5jZS5jb252ZXJ0VG9ab25lKFRpbWV6b25lLnV0Y1RpbWV6b25lKS50b1N0cmluZygpO1xuICAgIGxldCBpdGVtO1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAvL1hYWDogQ2xvbmU/XG4gICAgICByZWN1cnJlbmNlSWQ6IG9jY3VycmVuY2VcbiAgICB9O1xuXG4gICAgaWYgKGlkIGluIHRoaXMuZXhjZXB0aW9ucykge1xuICAgICAgaXRlbSA9IHJlc3VsdC5pdGVtID0gdGhpcy5leGNlcHRpb25zW2lkXTtcbiAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgIHJlc3VsdC5lbmREYXRlID0gaXRlbS5lbmREYXRlO1xuICAgICAgcmVzdWx0Lml0ZW0gPSBpdGVtO1xuICAgIH0gZWxzZSBpZiAodXRjSWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICBpdGVtID0gdGhpcy5leGNlcHRpb25zW3V0Y0lkXTtcbiAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgIHJlc3VsdC5lbmREYXRlID0gaXRlbS5lbmREYXRlO1xuICAgICAgcmVzdWx0Lml0ZW0gPSBpdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByYW5nZSBleGNlcHRpb25zIChSQU5HRT1USElTQU5ERlVUVVJFKSBoYXZlIGFcbiAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHRoZW4gZGlyZWN0IGV4Y2VwdGlvbnMgYnV0XG4gICAgICAvLyBtdXN0IGJlIGFjY291bnRlZCBmb3IgZmlyc3QuIFRoZWlyIGl0ZW0gaXNcbiAgICAgIC8vIGFsd2F5cyB0aGUgZmlyc3QgZXhjZXB0aW9uIHdpdGggdGhlIHJhbmdlIHByb3AuXG4gICAgICBsZXQgcmFuZ2VFeGNlcHRpb25JZCA9IHRoaXMuZmluZFJhbmdlRXhjZXB0aW9uKFxuICAgICAgICBvY2N1cnJlbmNlXG4gICAgICApO1xuICAgICAgbGV0IGVuZDtcblxuICAgICAgaWYgKHJhbmdlRXhjZXB0aW9uSWQpIHtcbiAgICAgICAgbGV0IGV4Y2VwdGlvbiA9IHRoaXMuZXhjZXB0aW9uc1tyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAvLyByYW5nZSBleGNlcHRpb24gbXVzdCBtb2RpZnkgc3RhbmRhcmQgdGltZVxuICAgICAgICAvLyBieSB0aGUgZGlmZmVyZW5jZSAoaWYgYW55KSBpbiBzdGFydC9lbmQgdGltZXMuXG4gICAgICAgIHJlc3VsdC5pdGVtID0gZXhjZXB0aW9uO1xuXG4gICAgICAgIGxldCBzdGFydERpZmYgPSB0aGlzLl9yYW5nZUV4Y2VwdGlvbkNhY2hlW3JhbmdlRXhjZXB0aW9uSWRdO1xuXG4gICAgICAgIGlmICghc3RhcnREaWZmKSB7XG4gICAgICAgICAgbGV0IG9yaWdpbmFsID0gZXhjZXB0aW9uLnJlY3VycmVuY2VJZC5jbG9uZSgpO1xuICAgICAgICAgIGxldCBuZXdTdGFydCA9IGV4Y2VwdGlvbi5zdGFydERhdGUuY2xvbmUoKTtcblxuICAgICAgICAgIC8vIHpvbmVzIG11c3QgYmUgc2FtZSBvdGhlcndpc2Ugc3VidHJhY3QgbWF5IGJlIGluY29ycmVjdC5cbiAgICAgICAgICBvcmlnaW5hbC56b25lID0gbmV3U3RhcnQuem9uZTtcbiAgICAgICAgICBzdGFydERpZmYgPSBuZXdTdGFydC5zdWJ0cmFjdERhdGUob3JpZ2luYWwpO1xuXG4gICAgICAgICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXSA9IHN0YXJ0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydCA9IG9jY3VycmVuY2UuY2xvbmUoKTtcbiAgICAgICAgc3RhcnQuem9uZSA9IGV4Y2VwdGlvbi5zdGFydERhdGUuem9uZTtcbiAgICAgICAgc3RhcnQuYWRkRHVyYXRpb24oc3RhcnREaWZmKTtcblxuICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICBlbmQuYWRkRHVyYXRpb24oZXhjZXB0aW9uLmR1cmF0aW9uKTtcblxuICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gc3RhcnQ7XG4gICAgICAgIHJlc3VsdC5lbmREYXRlID0gZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gcmFuZ2UgZXhjZXB0aW9uIHN0YW5kYXJkIGV4cGFuc2lvblxuICAgICAgICBlbmQgPSBvY2N1cnJlbmNlLmNsb25lKCk7XG4gICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcblxuICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgcmVzdWx0LnN0YXJ0RGF0ZSA9IG9jY3VycmVuY2U7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHJlY3VyIGV4cGFuc2lvbiBpbnN0YW5jZSBmb3IgYSBzcGVjaWZpYyBwb2ludCBpbiB0aW1lIChkZWZhdWx0c1xuICAgKiB0byBzdGFydERhdGUpLlxuICAgKlxuICAgKiBAcGFyYW0ge1RpbWU9fSBzdGFydFRpbWUgICAgIFN0YXJ0aW5nIHBvaW50IGZvciBleHBhbnNpb25cbiAgICogQHJldHVybiB7UmVjdXJFeHBhbnNpb259ICAgIEV4cGFuc2lvbiBvYmplY3RcbiAgICovXG4gIGl0ZXJhdG9yKHN0YXJ0VGltZSkge1xuICAgIHJldHVybiBuZXcgUmVjdXJFeHBhbnNpb24oe1xuICAgICAgY29tcG9uZW50OiB0aGlzLmNvbXBvbmVudCxcbiAgICAgIGR0c3RhcnQ6IHN0YXJ0VGltZSB8fCB0aGlzLnN0YXJ0RGF0ZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZXZlbnQgaXMgcmVjdXJyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiBldmVudCBpcyByZWN1cnJpbmdcbiAgICovXG4gIGlzUmVjdXJyaW5nKCkge1xuICAgIGxldCBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JydWxlJykgfHwgY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGRlc2NyaWJlcyBhIHJlY3VycmVuY2UgZXhjZXB0aW9uLiBTZWVcbiAgICoge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUsIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvblxuICAgKi9cbiAgaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGVzIG9mIHJlY3VycmVuY2VzIHRoaXMgZXZlbnQgbWF5IGhhdmUuXG4gICAqXG4gICAqIFJldHVybmVkIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcG9zc2libGUga2V5czpcbiAgICpcbiAgICogICAgLSBZRUFSTFlcbiAgICogICAgLSBNT05USExZXG4gICAqICAgIC0gV0VFS0xZXG4gICAqICAgIC0gREFJTFlcbiAgICogICAgLSBNSU5VVEVMWVxuICAgKiAgICAtIFNFQ09ORExZXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdC48ZnJlcXVlbmN5VmFsdWVzLCBCb29sZWFuPn1cbiAgICogICAgICAgICAgT2JqZWN0IG9mIHJlY3VycmVuY2UgZmxhZ3NcbiAgICovXG4gIGdldFJlY3VycmVuY2VUeXBlcygpIHtcbiAgICBsZXQgcnVsZXMgPSB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdycnVsZScpO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gcnVsZXNbaV0uZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgcmVzdWx0W3ZhbHVlLmZyZXFdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB1aWQgb2YgdGhpcyBldmVudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCd1aWQnKTtcbiAgfVxuXG4gIHNldCB1aWQodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRQcm9wKCd1aWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YXJ0IGRhdGVcbiAgICogQHR5cGUge1RpbWV9XG4gICAqL1xuICBnZXQgc3RhcnREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2R0c3RhcnQnKTtcbiAgfVxuXG4gIHNldCBzdGFydERhdGUodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRUaW1lKCdkdHN0YXJ0JywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgZGF0ZS4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAqIGVuZCBkYXRlIGNhbGN1bGF0ZWQgZnJvbSBzdGFydCBkYXRlIGFuZCBkdXJhdGlvbi4gU2V0dGluZyB0aGUgcHJvcGVydHlcbiAgICogd2lsbCByZW1vdmUgYW55IGR1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZERhdGUoKSB7XG4gICAgbGV0IGVuZERhdGUgPSB0aGlzLl9maXJzdFByb3AoJ2R0ZW5kJyk7XG4gICAgaWYgKCFlbmREYXRlKSB7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuX2ZpcnN0UHJvcCgnZHVyYXRpb24nKTtcbiAgICAgICAgZW5kRGF0ZSA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kRGF0ZS5hZGREdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kRGF0ZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIGVuZERhdGUuZGF5ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZERhdGU7XG4gIH1cblxuICBzZXQgZW5kRGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xuICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R1cmF0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX3NldFRpbWUoJ2R0ZW5kJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbi4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAqIGR1cmF0aW9uIGNhbGN1bGF0ZWQgZnJvbSBzdGFydCBkYXRlIGFuZCBlbmQgZGF0ZS4gU2V0dGluZyB0aGUgcHJvcGVydHlcbiAgICogd2lsbCByZW1vdmUgYW55IGBkdGVuZGAgcHJvcGVydGllcy5cbiAgICogQHR5cGUge0R1cmF0aW9ufVxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuX2ZpcnN0UHJvcCgnZHVyYXRpb24nKTtcbiAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmREYXRlLnN1YnRyYWN0RGF0ZVR6KHRoaXMuc3RhcnREYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG5cbiAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdkdGVuZCcpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5yZW1vdmVQcm9wZXJ0eSgnZHRlbmQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRQcm9wKCdkdXJhdGlvbicsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIGV2ZW50LlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2xvY2F0aW9uJyk7XG4gIH1cblxuICBzZXQgbG9jYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9zZXRQcm9wKCdsb2NhdGlvbicsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXR0ZW5kZWVzIGluIHRoZSBldmVudFxuICAgKiBAdHlwZSB7UHJvcGVydHlbXX1cbiAgICovXG4gIGdldCBhdHRlbmRlZXMoKSB7XG4gICAgLy9YWFg6IFRoaXMgaXMgd2F5IGxhbWUgd2Ugc2hvdWxkIGhhdmUgYSBiZXR0ZXJcbiAgICAvLyAgICAgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRoaXMgbGF0ZXIuXG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ2F0dGVuZGVlJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGV2ZW50IHN1bW1hcnlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3N1bW1hcnknKTtcbiAgfVxuXG4gIHNldCBzdW1tYXJ5KHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0UHJvcCgnc3VtbWFyeScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgZGVzY3JpcHRpb24uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnZGVzY3JpcHRpb24nKTtcbiAgfVxuXG4gIHNldCBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3NldFByb3AoJ2Rlc2NyaXB0aW9uJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCBjb2xvciBmcm9tIFtyZmM3OTg2XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc5ODYpXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnY29sb3InKTtcbiAgfVxuXG4gIHNldCBjb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX3NldFByb3AoJ2NvbG9yJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcmdhbml6ZXIgdmFsdWUgYXMgYW4gdXJpLiBJbiBtb3N0IGNhc2VzIHRoaXMgaXMgYSBtYWlsdG86IHVyaSwgYnV0XG4gICAqIGl0IGNhbiBhbHNvIGJlIHNvbWV0aGluZyBlbHNlLCBsaWtlIHVybjp1dWlkOi4uLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9yZ2FuaXplcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdvcmdhbml6ZXInKTtcbiAgfVxuXG4gIHNldCBvcmdhbml6ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRQcm9wKCdvcmdhbml6ZXInLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNlcXVlbmNlIHZhbHVlIGZvciB0aGlzIGV2ZW50LiBVc2VkIGZvciBzY2hlZHVsaW5nXG4gICAqIHNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdzZXF1ZW5jZScpO1xuICB9XG5cbiAgc2V0IHNlcXVlbmNlKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0UHJvcCgnc2VxdWVuY2UnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlY3VycmVuY2UgaWQgZm9yIHRoaXMgZXZlbnQuIFNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICogQHR5cGUge1RpbWV9XG4gICAqL1xuICBnZXQgcmVjdXJyZW5jZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3JlY3VycmVuY2UtaWQnKTtcbiAgfVxuXG4gIHNldCByZWN1cnJlbmNlSWQodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRUaW1lKCdyZWN1cnJlbmNlLWlkJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldC91cGRhdGUgYSB0aW1lIHByb3BlcnR5J3MgdmFsdWUuXG4gICAqIFRoaXMgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgVFpJRCBvZiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIFRPRE86IHRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIHN3aXRjaGluZ1xuICAgKiBmcm9tIGEga25vd24gdGltZXpvbmUgdG8gYW4gaW1wbGllZCB0aW1lem9uZSAob25lIHdpdGhvdXQgVFpJRCkuXG4gICAqIFRoaXMgZG9lcyBfbm90XyBoYW5kbGUgdGhlIGNhc2Ugb2YgbW92aW5nIGJldHdlZW4gYSBrbm93blxuICAgKiAgKGJ5IFRpbWV6b25lU2VydmljZSkgdGltZXpvbmUgdG8gYW4gdW5rbm93biB0aW1lem9uZS4uLlxuICAgKlxuICAgKiBXZSB3aWxsIG5vdCBhZGQvcmVtb3ZlL3VwZGF0ZSB0aGUgVlRJTUVaT05FIHN1YmNvbXBvbmVudHNcbiAgICogIGxlYWRpbmcgdG8gaW52YWxpZCBJQ0FMIGRhdGEuLi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lICAgICBUaGUgcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1RpbWV9IHRpbWUgICAgICAgICAgIFRoZSB0aW1lIHRvIHNldFxuICAgKi9cbiAgX3NldFRpbWUocHJvcE5hbWUsIHRpbWUpIHtcbiAgICBsZXQgcHJvcCA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkocHJvcE5hbWUpO1xuXG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBwcm9wID0gbmV3IFByb3BlcnR5KHByb3BOYW1lKTtcbiAgICAgIHRoaXMuY29tcG9uZW50LmFkZFByb3BlcnR5KHByb3ApO1xuICAgIH1cblxuICAgIC8vIHV0YyBhbmQgbG9jYWwgZG9uJ3QgZ2V0IGEgdHppZFxuICAgIGlmIChcbiAgICAgIHRpbWUuem9uZSA9PT0gVGltZXpvbmUubG9jYWxUaW1lem9uZSB8fFxuICAgICAgdGltZS56b25lID09PSBUaW1lem9uZS51dGNUaW1lem9uZVxuICAgICkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSB0emlkXG4gICAgICBwcm9wLnJlbW92ZVBhcmFtZXRlcigndHppZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnNldFBhcmFtZXRlcigndHppZCcsIHRpbWUuem9uZS50emlkKTtcbiAgICB9XG5cbiAgICBwcm9wLnNldFZhbHVlKHRpbWUpO1xuICB9XG5cbiAgX3NldFByb3AobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmNvbXBvbmVudC51cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gIH1cblxuICBfZmlyc3RQcm9wKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudC5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVJhbmdlRXhjZXB0aW9uKGEsIGIpIHtcbiAgaWYgKGFbMF0gPiBiWzBdKSByZXR1cm4gMTtcbiAgaWYgKGJbMF0gPiBhWzBdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2ggKi9cblxuLyoqXG4gKiBUaGUgQ29tcG9uZW50UGFyc2VyIGlzIHVzZWQgdG8gcHJvY2VzcyBhIFN0cmluZyBvciBqQ2FsIE9iamVjdCxcbiAqIGZpcmluZyBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZm91bmQgY29tcG9uZW50cywgYXMgd2VsbCBhcyBjb21wbGV0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgb3B0aW9ucyA9IHtcbiAqICAgLy8gd2hlbiBmYWxzZSBubyBldmVudHMgd2lsbCBiZSBlbWl0dGVkIGZvciB0eXBlXG4gKiAgIHBhcnNlRXZlbnQ6IHRydWUsXG4gKiAgIHBhcnNlVGltZXpvbmU6IHRydWVcbiAqIH07XG4gKlxuICogdmFyIHBhcnNlciA9IG5ldyBJQ0FMLkNvbXBvbmVudFBhcnNlcihvcHRpb25zKTtcbiAqXG4gKiBwYXJzZXIub25ldmVudChldmVudENvbXBvbmVudCkge1xuICogICAvLy4uLlxuICogfVxuICpcbiAqIC8vIG9udGltZXpvbmUsIGV0Yy4uLlxuICpcbiAqIHBhcnNlci5vbmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gKlxuICogfTtcbiAqXG4gKiBwYXJzZXIucHJvY2VzcyhzdHJpbmdPckNvbXBvbmVudCk7XG4gKlxuICogQG1lbWJlcm9mIElDQUxcbiAqL1xuY2xhc3MgQ29tcG9uZW50UGFyc2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5Db21wb25lbnRQYXJzZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICBDb21wb25lbnQgcGFyc2VyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlRXZlbnQgICAgICAgIFdoZXRoZXIgZXZlbnRzIHNob3VsZCBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlVGltZXplb25lICAgIFdoZXRoZXIgdGltZXpvbmVzIHNob3VsZCBiZSBwYXJzZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mKG9wdGlvbnMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgcGFyc2UgZXZlbnRzXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcGFyc2VFdmVudCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgcGFyc2UgdGltZXpvbmVzXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcGFyc2VUaW1lem9uZSA9IHRydWU7XG5cblxuICAvKiBTQVggbGlrZSBldmVudHMgaGVyZSBmb3IgcmVmZXJlbmNlICovXG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gcGFyc2luZyBpcyBjb21wbGV0ZVxuICAgKiBAY2FsbGJhY2tcbiAgICovXG4gIG9uY29tcGxldGUgPSAvKiBjOCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbigpIHt9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHBhcnNpbmcuXG4gICAqXG4gICAqIEBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZGV0YWlscyBvZiBlcnJvclxuICAgKi9cbiAgb25lcnJvciA9IC8qIGM4IGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGVycikge307XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWVElNRVpPTkUpIGlzIGZvdW5kXG4gICAqXG4gICAqIEBjYWxsYmFja1xuICAgKiBAcGFyYW0ge1RpbWV6b25lfSBjb21wb25lbnQgICAgIFRpbWV6b25lIG9iamVjdFxuICAgKi9cbiAgb250aW1lem9uZSA9IC8qIGM4IGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge307XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWRVZFTlQpIGlzIGZvdW5kLlxuICAgKlxuICAgKiBAY2FsbGJhY2tcbiAgICogQHBhcmFtIHtFdmVudH0gY29tcG9uZW50ICAgIFRvcCBsZXZlbCBjb21wb25lbnRcbiAgICovXG4gIG9uZXZlbnQgPSAvKiBjOCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbihjb21wb25lbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgc3RyaW5nIG9yIHBhcnNlIGljYWwgb2JqZWN0LiAgVGhpcyBmdW5jdGlvbiBpdHNlbGYgd2lsbCByZXR1cm5cbiAgICogbm90aGluZyBidXQgd2lsbCBzdGFydCB0aGUgcGFyc2luZyBwcm9jZXNzLlxuICAgKlxuICAgKiBFdmVudHMgbXVzdCBiZSByZWdpc3RlcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fFN0cmluZ3xPYmplY3R9IGljYWwgICAgICBUaGUgY29tcG9uZW50IHRvIHByb2Nlc3MsXG4gICAqICAgICAgICBlaXRoZXIgaW4gaXRzIGZpbmFsIGZvcm0sIGFzIGEgakNhbCBPYmplY3QsIG9yIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgcHJvY2VzcyhpY2FsKSB7XG4gICAgLy9UT0RPOiB0aGlzIGlzIHN5bmMgbm93IGluIHRoZSBmdXR1cmUgd2Ugd2lsbCBoYXZlIGEgaW5jcmVtZW50YWwgcGFyc2VyLlxuICAgIGlmICh0eXBlb2YoaWNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpY2FsID0gcGFyc2UoaWNhbCk7XG4gICAgfVxuXG4gICAgaWYgKCEoaWNhbCBpbnN0YW5jZW9mIENvbXBvbmVudCkpIHtcbiAgICAgIGljYWwgPSBuZXcgQ29tcG9uZW50KGljYWwpO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnRzID0gaWNhbC5nZXRBbGxTdWJjb21wb25lbnRzKCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICBsZXQgY29tcG9uZW50O1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgc3dpdGNoIChjb21wb25lbnQubmFtZSkge1xuICAgICAgICBjYXNlICd2dGltZXpvbmUnOlxuICAgICAgICAgIGlmICh0aGlzLnBhcnNlVGltZXpvbmUpIHtcbiAgICAgICAgICAgIGxldCB0emlkID0gY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgICAgICAgaWYgKHR6aWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbnRpbWV6b25lKG5ldyBUaW1lem9uZSh7XG4gICAgICAgICAgICAgICAgdHppZDogdHppZCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2ZXZlbnQnOlxuICAgICAgICAgIGlmICh0aGlzLnBhcnNlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMub25ldmVudChuZXcgRXZlbnQoY29tcG9uZW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vWFhYOiBpZGVhbGx5IHdlIHNob3VsZCBkbyBhIFwibmV4dFRpY2tcIiBoZXJlXG4gICAgLy8gICAgIHNvIGluIGFsbCBjYXNlcyB0aGlzIGlzIGFjdHVhbGx5IGFzeW5jLlxuICAgIHRoaXMub25jb21wbGV0ZSgpO1xuICB9XG59XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCAqL1xuXG4vKipcbiAqIFRoZSBtYWluIElDQUwgbW9kdWxlLiBQcm92aWRlcyBhY2Nlc3MgdG8gZXZlcnl0aGluZyBlbHNlLlxuICpcbiAqIEBhbGlhcyBJQ0FMXG4gKiBAbmFtZXNwYWNlIElDQUxcbiAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ259IGRlc2lnblxuICogQHByb3BlcnR5IHtJQ0FMLmhlbHBlcnN9IGhlbHBlcnNcbiAqL1xudmFyIElDQUxtb2R1bGUgPSB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYmVmb3JlIGlDYWxlbmRhciBsaW5lIGZvbGRpbmcgc2hvdWxkIG9jY3VyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDc1XG4gICAqL1xuICBmb2xkTGVuZ3RoOiA3NSxcblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIocykgdG8gYmUgdXNlZCBmb3IgYSBuZXdsaW5lLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZCBieVxuICAgKiByZmM1NTQ1LlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBcIlxcclxcblwiXG4gICAqL1xuICBuZXdMaW5lQ2hhcjogJ1xcclxcbicsXG5cbiAgQmluYXJ5LFxuICBDb21wb25lbnQsXG4gIENvbXBvbmVudFBhcnNlcixcbiAgRHVyYXRpb24sXG4gIEV2ZW50LFxuICBQZXJpb2QsXG4gIFByb3BlcnR5LFxuICBSZWN1cixcbiAgUmVjdXJFeHBhbnNpb24sXG4gIFJlY3VySXRlcmF0b3IsXG4gIFRpbWUsXG4gIFRpbWV6b25lLFxuICBUaW1lem9uZVNlcnZpY2UsXG4gIFV0Y09mZnNldCxcbiAgVkNhcmRUaW1lLFxuXG4gIHBhcnNlLFxuICBzdHJpbmdpZnksXG5cbiAgZGVzaWduOiBkZXNpZ24kMSxcbiAgaGVscGVyc1xufTtcblxuZXhwb3J0IHsgSUNBTG1vZHVsZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiQmluYXJ5IiwiZnJvbVN0cmluZyIsImFTdHJpbmciLCJkZWNvZGVWYWx1ZSIsIl9iNjRfZGVjb2RlIiwidmFsdWUiLCJzZXRFbmNvZGVkVmFsdWUiLCJhVmFsdWUiLCJfYjY0X2VuY29kZSIsImRhdGEiLCJiNjQiLCJvMSIsIm8yIiwibzMiLCJoMSIsImgyIiwiaDMiLCJoNCIsImJpdHMiLCJpIiwiYWMiLCJlbmMiLCJ0bXBfYXJyIiwiY2hhckNvZGVBdCIsImNoYXJBdCIsImxlbmd0aCIsImpvaW4iLCJyIiwic2xpY2UiLCJkZWMiLCJpbmRleE9mIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwidG9TdHJpbmciLCJjb25zdHJ1Y3RvciIsImljYWx0eXBlIiwiRFVSQVRJT05fTEVUVEVSUyIsIkRBVEFfUFJPUFNfVE9fQ09QWSIsIkR1cmF0aW9uIiwiZnJvbVNlY29uZHMiLCJhU2Vjb25kcyIsImlzVmFsdWVTdHJpbmciLCJzdHJpbmciLCJhU3RyIiwicG9zIiwiZGljdCIsIk9iamVjdCIsImNyZWF0ZSIsImNodW5rcyIsInNlYXJjaCIsInR5cGUiLCJudW1lcmljIiwiTWF0aCIsIm1heCIsInBhcnNlRHVyYXRpb25DaHVuayIsIkVycm9yIiwiZnJvbURhdGEiLCJhRGF0YSIsImNsb25lIiwidG9TZWNvbmRzIiwic2Vjb25kcyIsIm1pbnV0ZXMiLCJob3VycyIsImRheXMiLCJ3ZWVrcyIsImlzTmVnYXRpdmUiLCJzZWNzIiwiYWJzIiwidHJ1bmMiLCJwcm9wIiwicmVzZXQiLCJjb21wYXJlIiwiYU90aGVyIiwidGhpc1NlY29uZHMiLCJvdGhlclNlY29uZHMiLCJub3JtYWxpemUiLCJzdHIiLCJ0b0lDQUxTdHJpbmciLCJpY2FsY2xhc3MiLCJ3cmFwcGVkSlNPYmplY3QiLCJsZXR0ZXIiLCJudW1iZXIiLCJvYmplY3QiLCJudW0iLCJwYXJzZUludCIsImlzU3RyaWN0bHlOYU4iLCJUaW1lIiwiZGF5c0luTW9udGgiLCJtb250aCIsInllYXIiLCJfZGF5c0luTW9udGgiLCJpc0xlYXBZZWFyIiwiZnJvbURheU9mWWVhciIsImFEYXlPZlllYXIiLCJhWWVhciIsImRveSIsInR0IiwiYXV0b19ub3JtYWxpemUiLCJpc19sZWFwIiwiZGF5c0luWWVhclBhc3NlZE1vbnRoIiwiaXNEYXRlIiwiZGF5IiwiZnJvbVN0cmluZ3YyIiwiZnJvbURhdGVTdHJpbmciLCJzdHJpY3RQYXJzZUludCIsImZyb21EYXRlVGltZVN0cmluZyIsInpvbmUiLCJ6b25lSWQiLCJUaW1lem9uZSIsInV0Y1RpbWV6b25lIiwiZ2V0UGFyYW1ldGVyIiwicGFyZW50IiwibmFtZSIsImxvY2FsVGltZXpvbmUiLCJnZXRUaW1lWm9uZUJ5SUQiLCJ0aW1lRGF0YSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJ0aW1lem9uZSIsImFQcm9wZXJ0eSIsImZyb21KU0RhdGUiLCJhRGF0ZSIsInVzZVVUQyIsIm5vdyIsIkRhdGUiLCJ3ZWVrT25lU3RhcnRzIiwiYVdlZWtTdGFydCIsInQiLCJkb3ciLCJkYXlPZldlZWsiLCJ3a3N0IiwiREVGQVVMVF9XRUVLX1NUQVJUIiwiVEhVUlNEQVkiLCJnZXREb21pbmljYWxMZXR0ZXIiLCJ5ciIsIkxUUlMiLCJkb20iLCJpc0xlYXAiLCJlcG9jaFRpbWUiLCJfY21wX2F0dHIiLCJhIiwiYiIsImF0dHIiLCJfdGltZSIsInJlc2V0VG8iLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJfY2FjaGVkVW5peFRpbWUiLCJhWm9uZSIsImtleSIsImVudHJpZXMiLCJUaW1lem9uZVNlcnZpY2UiLCJnZXQiLCJmaXJzdERvdyIsIlNVTkRBWSIsImRvd0NhY2hlS2V5IiwiX2Rvd0NhY2hlIiwicSIsIm0iLCJZIiwiaCIsImRheU9mWWVhciIsImRpeXBtIiwic3RhcnRPZldlZWsiLCJyZXN1bHQiLCJlbmRPZldlZWsiLCJzdGFydE9mTW9udGgiLCJlbmRPZk1vbnRoIiwic3RhcnRPZlllYXIiLCJlbmRPZlllYXIiLCJzdGFydERveVdlZWsiLCJhRmlyc3REYXlPZldlZWsiLCJkZWx0YSIsIm50aFdlZWtEYXkiLCJhRGF5T2ZXZWVrIiwiYVBvcyIsIndlZWtkYXkiLCJzdGFydCIsIm90aGVyRGF5Iiwic3RhcnREb3ciLCJvZmZzZXQiLCJlbmREb3ciLCJpc050aFdlZWtEYXkiLCJ3ZWVrTnVtYmVyIiwid25DYWNoZUtleSIsIl93bkNhY2hlIiwid2VlazEiLCJkdCIsImlzb3llYXIiLCJkYXlzQmV0d2VlbiIsInN1YnRyYWN0RGF0ZSIsImFuc3dlciIsImFkZER1cmF0aW9uIiwiYUR1cmF0aW9uIiwibXVsdCIsInVuaXhUaW1lIiwidG9Vbml4VGltZSIsInV0Y09mZnNldCIsIm90aGVyIiwic3VidHJhY3REYXRlVHoiLCJjb21wYXJlRGF0ZU9ubHlUeiIsInR6IiwiY29udmVydFRvWm9uZSIsInJjIiwiY29weSIsInpvbmVfZXF1YWxzIiwidHppZCIsImNvbnZlcnRfdGltZSIsImRlc2lnbiQxIiwiaWNhbGVuZGFyIiwidG9JQ0FMIiwiZGF0ZSIsInBhZDIiLCJ0b0pTRGF0ZSIsIl9ub3JtYWxpemUiLCJhZGp1c3QiLCJhRXh0cmFEYXlzIiwiYUV4dHJhSG91cnMiLCJhRXh0cmFNaW51dGVzIiwiYUV4dHJhU2Vjb25kcyIsImFUaW1lIiwibWludXRlc092ZXJmbG93IiwiaG91cnNPdmVyZmxvdyIsImRheXNPdmVyZmxvdyIsInllYXJzT3ZlcmZsb3ciLCJ0aW1lIiwiZnJvbVVuaXhUaW1lIiwibXMiLCJVVEMiLCJ0b0pTT04iLCJsZW4iLCJfcGVuZGluZ05vcm1hbGl6YXRpb24iLCJNT05EQVkiLCJUVUVTREFZIiwiV0VETkVTREFZIiwiRlJJREFZIiwiU0FUVVJEQVkiLCJzZXR1cE5vcm1hbGl6ZUF0dHJpYnV0ZXMiLCJkZWZpbmVBdHRyIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJnZXRUaW1lQXR0ciIsInNldCIsInNldFRpbWVBdHRyIiwidmFsIiwiQ0hBUiIsIlZBTFVFX0RFTElNSVRFUiIsIlBBUkFNX0RFTElNSVRFUiIsIlBBUkFNX05BTUVfREVMSU1JVEVSIiwiREVGQVVMVF9WQUxVRV9UWVBFJDEiLCJERUZBVUxUX1BBUkFNX1RZUEUiLCJSRkM2ODY4X1JFUExBQ0VfTUFQJDEiLCJwYXJzZSIsImlucHV0Iiwic3RhdGUiLCJyb290IiwiY29tcG9uZW50Iiwic3RhY2siLCJfZWFjaExpbmUiLCJlcnIiLCJsaW5lIiwiX2hhbmRsZUNvbnRlbnRMaW5lIiwiUGFyc2VyRXJyb3IiLCJwcm9wZXJ0eSIsImRlc2lnblNldCIsImRlZmF1bHRTZXQiLCJ2YWx1ZVBvcyIsInBhcmFtUG9zIiwibGFzdFBhcmFtSW5kZXgiLCJsYXN0VmFsdWVQb3MiLCJwYXJhbXMiLCJwYXJzZWRQYXJhbXMiLCJ0b0xvd2VyQ2FzZSIsIl9wYXJzZVBhcmFtZXRlcnMiLCJuZXdDb21wb25lbnQiLCJwdXNoIiwiZ2V0RGVzaWduU2V0IiwicG9wIiwidmFsdWVUeXBlIiwibXVsdGlWYWx1ZSIsInN0cnVjdHVyZWRWYWx1ZSIsInByb3BlcnR5RGV0YWlscyIsInNwbGl0TmFtZSIsInVuZ3JvdXBlZE5hbWUiLCJwcm9wZXJ0eUdyb3VwcyIsInNwbGl0IiwiZ3JvdXAiLCJkZXRlY3RUeXBlIiwiZGVmYXVsdFR5cGUiLCJfcGFyc2VNdWx0aVZhbHVlIiwiX3BhcnNlVmFsdWUiLCJmcm9tSUNBTCIsImxhc3RQYXJhbSIsImRlbGltIiwibGNuYW1lIiwibXZkZWxpbSIsInBhcmFtIiwibXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlIiwiX3JmYzY4NjhFc2NhcGUiLCJuZXh0Q2hhciIsImV4dGVuZGVkVmFsdWUiLCJwcm9wVmFsdWVQb3MiLCJuZXh0UG9zIiwibGVuZ3RoX2JlZm9yZSIsImRlbGltaXRlciIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJ4IiwiYnVmZmVyIiwiaW5uZXJNdWx0aSIsImxhc3RQb3MiLCJ1bmVzY2FwZWRJbmRleE9mIiwiY2FsbGJhY2siLCJmaXJzdENoYXIiLCJuZXdsaW5lT2Zmc2V0IiwidHJpbSIsIk9QVElPTlMiLCJfY29tcGFyZV9jaGFuZ2VfZm4iLCJmcm9tX3pvbmUiLCJ0b196b25lIiwiYWRqdXN0X2NoYW5nZSIsImNoYW5nZSIsImNhbGwiLCJleHBhbmRlZFVudGlsWWVhciIsImNoYW5nZXMiLCJDb21wb25lbnQiLCJqQ2FsIiwiZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlIiwiX2Vuc3VyZUNvdmVyYWdlIiwidHRfY2hhbmdlIiwiY2hhbmdlX251bSIsIl9maW5kTmVhcmJ5Q2hhbmdlIiwiY2hhbmdlX251bV90b191c2UiLCJzdGVwIiwicHJldlV0Y09mZnNldCIsImNtcCIsInpvbmVfY2hhbmdlIiwidXRjT2Zmc2V0X2NoYW5nZSIsInRtcF9jaGFuZ2UiLCJwcmV2X3pvbmVfY2hhbmdlIiwid2FudF9kYXlsaWdodCIsImlzX2RheWxpZ2h0IiwiaWR4IiwiYmluc2VhcmNoSW5zZXJ0IiwiX21pbmltdW1FeHBhbnNpb25ZZWFyIiwidG9kYXkiLCJjaGFuZ2VzRW5kWWVhciIsIkVYVFJBX0NPVkVSQUdFIiwic3ViY29tcHMiLCJnZXRBbGxTdWJjb21wb25lbnRzIiwiY29tcExlbiIsImNvbXBJZHgiLCJfZXhwYW5kQ29tcG9uZW50Iiwic29ydCIsImFDb21wb25lbnQiLCJoYXNQcm9wZXJ0eSIsImR0c3RhcnQiLCJnZXRGaXJzdFByb3BlcnR5IiwiZ2V0Rmlyc3RWYWx1ZSIsImNvbnZlcnRfdHpvZmZzZXQiLCJmYWN0b3IiLCJpbml0X2NoYW5nZXMiLCJjaGFuZ2ViYXNlIiwicHJvcHMiLCJnZXRBbGxQcm9wZXJ0aWVzIiwicmRhdGUiLCJycnVsZSIsInVudGlsIiwiaXRlcmF0b3IiLCJvY2MiLCJuZXh0IiwidHpuYW1lcyIsImxvY2F0aW9uIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b25lcyIsImNvdW50Iiwia2V5cyIsInV0YyIsIloiLCJHTVQiLCJfaGFyZF9yZXNldCIsImhhcyIsInJlZ2lzdGVyIiwiVHlwZUVycm9yIiwicmVtb3ZlIiwidXBkYXRlVGltZXpvbmVzIiwidmNhbCIsImFsbHN1YnMiLCJwcm9wZXJ0aWVzIiwidnRpbWV6b25lcyIsInJlcVR6aWQiLCJjb25jYXQiLCJjb21wIiwicmVtb3ZlU3ViY29tcG9uZW50IiwiYWRkU3ViY29tcG9uZW50IiwiaXNOYU4iLCJmb3JtYXRDbGFzc1R5cGUiLCJ1bmRlZmluZWQiLCJsaXN0Iiwic2Vla1ZhbCIsImNtcGZ1bmMiLCJsb3ciLCJoaWdoIiwibWlkIiwiY21wdmFsIiwiZmxvb3IiLCJhU3JjIiwiYURlZXAiLCJnZXRUaW1lIiwiYXJyIiwib2JqIiwiZm9sZGxpbmUiLCJhTGluZSIsImxpbmVfbGVuZ3RoIiwiY3AiLCJjb2RlUG9pbnRBdCIsIklDQUxtb2R1bGUiLCJmb2xkTGVuZ3RoIiwibmV3TGluZUNoYXIiLCJjZWlsIiwiZXh0ZW5kIiwic291cmNlIiwidGFyZ2V0IiwiZGVzY3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJoZWxwZXJzIiwiZnJlZXplIiwiX19wcm90b19fIiwiVXRjT2Zmc2V0Iiwib3B0aW9ucyIsImluc3RhbmNlIiwiVkNhcmRUaW1lIiwiZnJvbURhdGVBbmRPclRpbWVTdHJpbmciLCJhSWNhbFR5cGUiLCJwYXJ0IiwidiIsInMiLCJlIiwicGFydHMiLCJ0bXoiLCJzcGxpdHpvbmUiLCJ2Y2FyZCIsIl9zcGxpdFpvbmUiLCJ0bSIsImR0bGVuIiwidG1sZW4iLCJoYXNEYXNoRGF0ZSIsImhhc0Rhc2hUaW1lIiwibyIsImFwcGx5IiwiYXJndW1lbnRzIiwieSIsImQiLCJtbSIsImhhc1llYXIiLCJoYXNNb250aCIsImhhc0RheSIsImhhc0hvdXIiLCJoYXNNaW51dGUiLCJoYXNTZWNvbmQiLCJkYXRlcGFydCIsInRpbWVwYXJ0IiwiUmVjdXJJdGVyYXRvciIsInJ1bGUiLCJSZWN1ciIsImJ5X2RhdGEiLCJvY2N1cnJlbmNlX251bWJlciIsImxhc3QiLCJieV9pbmRpY2VzIiwiaW5pdGlhbGl6ZWQiLCJpbml0IiwiSW52YWxpZFJlY3VycmVuY2VSdWxlRXJyb3IiLCJjb21wbGV0ZWQiLCJzb3J0X2J5ZGF5X3J1bGVzIiwiQllEQVkiLCJmcmVxIiwic2V0dXBfZGVmYXVsdHMiLCJydWxlRGF5T2ZXZWVrIiwid2tkeSIsImRheU5hbWUiLCJudW1lcmljRGF5VG9JY2FsRGF5IiwidW50aWxZZWFyIiwiZXhwYW5kX3llYXJfZGF5cyIsImluY3JlbWVudF95ZWFyIiwiaW50ZXJ2YWwiLCJfbmV4dEJ5WWVhckRheSIsImhhc19ieV9kYXRhIiwidGVtcExhc3QiLCJpbml0TGFzdCIsImJ5ZG93IiwiZGF5T2ZNb250aCIsImluY3JlbWVudF9tb250aCIsIl9ieURheUFuZE1vbnRoRGF5Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyIsIkJZTU9OVEhEQVkiLCJmaWx0ZXIiLCJuZXh0X21vbnRoIiwiYWdhaW4iLCJiZWZvcmUiLCJ2YWxpZCIsIm5leHRfc2Vjb25kIiwibmV4dF9taW51dGUiLCJuZXh0X2hvdXIiLCJuZXh0X2RheSIsIm5leHRfd2VlayIsIm5leHRfeWVhciIsImNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzIiwibmV4dF9nZW5lcmljIiwiaW5jcmVtZW50X3NlY29uZCIsImluYyIsImluY3JlbWVudF9nZW5lcmljIiwiaW5jcmVtZW50X21pbnV0ZSIsImluY3JlbWVudF9ob3VyIiwidGhpc19mcmVxIiwiaW5jcmVtZW50X21vbnRoZGF5IiwiZW5kX29mX2RhdGEiLCJuZXh0X3dlZWtkYXlfYnlfd2VlayIsIkJZV0VFS05PIiwid2Vla19ubyIsInJ1bGVzIiwibmV3UnVsZXMiLCJydWxlSWR4IiwiaXNJbml0IiwiYnlNb250aERheSIsImJ5RGF5IiwiZGF0ZUlkeCIsImRhdGVMZW4iLCJkYXlMZW4iLCJkYXRhSXNWYWxpZCIsInNlbGYiLCJsYXN0RGF5IiwiaW5pdE1vbnRoIiwibmV4dE1vbnRoIiwibW9udGhzQ291bnRlciIsImRheUlkeCIsImRhdGFfdmFsaWQiLCJzZXRwb3MiLCJzZXRwb3NfdG90YWwiLCJsYXN0X2RheSIsImlzX2RheV9pbl9ieWRheSIsImNoZWNrX3NldF9wb3NpdGlvbiIsImNvZGVkX2RheSIsImRheXNfaW5kZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJpY2FsRGF5VG9OdW1lcmljRGF5IiwiYVJ1bGVUeXBlIiwiYUludGVydmFsIiwiYURhdGVBdHRyIiwiYUZvbGxvd2luZ0F0dHIiLCJhUHJldmlvdXNJbmNyIiwiaGFzX2J5X3J1bGUiLCJkdGEiLCJCWU1PTlRIIiwieWVhcnMiLCJhRmFjdG9yIiwiYU5leHRJbmNyZW1lbnQiLCJuZXh0dW5pdCIsInZhbGlkV2Vla3MiLCJtb250aElkeCIsImZpcnN0X3dlZWsiLCJsYXN0X3dlZWsiLCJ3ZWVrSWR4Iiwid2Vla25vIiwicGFydENvdW50IiwidDEiLCJ0MiIsIm1vbnRoZGF5IiwidDMiLCJleHBhbmRfYnlfZGF5IiwiZmlyc3RfZG93IiwiZG95X29mZnNldCIsImxhc3RfZG93IiwiYnlfbW9udGhfZGF5Iiwic3BJbmRleCIsImJ5ZGF5UGFydHMiLCJtb250aF9kYXkiLCJmaXJzdF9tYXRjaGluZ19kYXkiLCJsYXN0X21hdGNoaW5nX2RheSIsImV4cGFuZGVkRGF5cyIsIkJZWUVBUkRBWSIsImRheXNJblllYXIiLCJkYXlzX2xpc3QiLCJ0bXAiLCJzdGFydF9kb3ciLCJlbmRfZG93IiwiZW5kX3llYXJfZGF5IiwidG1wX3N0YXJ0X2RveSIsImZpcnN0IiwidGhpc19kb3ciLCJCWVNFVFBPUyIsImFSdWxlcyIsImoiLCJvbmUiLCJ0d28iLCJjaGVja19jb250cmFjdF9yZXN0cmljdGlvbiIsImluZGV4TWFwVmFsdWUiLCJfaW5kZXhNYXAiLCJydWxlTWFwVmFsdWUiLCJfZXhwYW5kTWFwIiwicGFzcyIsIkNPTlRSQUNUIiwicnVsZVR5cGUiLCJieWRhdGEiLCJ3ZWVrTm8iLCJyZXEiLCJkZWZ0aW1lIiwiVU5LTk9XTiIsIkVYUEFORCIsIklMTEVHQUwiLCJWQUxJRF9EQVlfTkFNRVMiLCJWQUxJRF9CWURBWV9QQVJUIiwiRE9XX01BUCIsIlNVIiwiTU8iLCJUVSIsIldFIiwiVEgiLCJGUiIsIlNBIiwiUkVWRVJTRV9ET1dfTUFQIiwiZnJvbUVudHJpZXMiLCJtYXAiLCJlbnRyeSIsInJldmVyc2UiLCJBTExPV0VEX0ZSRVEiLCJfc3RyaW5nVG9EYXRhIiwiZm10SWNhbCIsInZhbHVlcyIsInVjbmFtZSIsInRvVXBwZXJDYXNlIiwicGFydERlc2lnbiIsInBhcnRBcnIiLCJwYXJ0U2V0IiwiU2V0IiwiYWRkIiwib3B0aW9uRGVzaWduIiwiYVN0YXJ0IiwiaXNGaW5pdGUiLCJpc0J5Q291bnQiLCJhZGRDb21wb25lbnQiLCJhVHlwZSIsInNldENvbXBvbmVudCIsImFWYWx1ZXMiLCJnZXRDb21wb25lbnQiLCJnZXROZXh0T2NjdXJyZW5jZSIsImFTdGFydFRpbWUiLCJhUmVjdXJyZW5jZUlkIiwiaXRlciIsInVja2V5IiwiSU5URVJWQUwiLCJyZXMiLCJrIiwia3BhcnRzIiwicGFyc2VOdW1lcmljVmFsdWUiLCJtaW4iLCJGUkVRIiwiQ09VTlQiLCJVTlRJTCIsIldLU1QiLCJ0ZXN0IiwiQllTRUNPTkQiLCJiaW5kIiwiQllNSU5VVEUiLCJCWUhPVVIiLCJQZXJpb2QiLCJlbmQiLCJkdXJhdGlvbiIsImZyb21KU09OIiwiYVByb3AiLCJhTGVuaWVudCIsImZyb21EYXRlT3JEYXRlVGltZVN0cmluZyIsImRhdGVQcm9wIiwiZ2V0RHVyYXRpb24iLCJnZXRFbmQiLCJGUk9NX0lDQUxfTkVXTElORSIsIlRPX0lDQUxfTkVXTElORSIsIkZST01fVkNBUkRfTkVXTElORSIsIlRPX1ZDQVJEX05FV0xJTkUiLCJjcmVhdGVUZXh0VHlwZSIsImZyb21OZXdsaW5lIiwidG9OZXdsaW5lIiwic3RydWN0dXJlZEVzY2FwZSIsInJlcGxhY2VOZXdsaW5lIiwicmVnRXgiLCJSZWdFeHAiLCJmbGFncyIsIkRFRkFVTFRfVFlQRV9URVhUIiwiREVGQVVMVF9UWVBFX1RFWFRfTVVMVEkiLCJERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVEIiwiREVGQVVMVF9UWVBFX0lOVEVHRVIiLCJERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSIsImFsbG93ZWRUeXBlcyIsIkRFRkFVTFRfVFlQRV9EQVRFVElNRSIsIkRFRkFVTFRfVFlQRV9VUkkiLCJERUZBVUxUX1RZUEVfVVRDT0ZGU0VUIiwiREVGQVVMVF9UWVBFX1JFQ1VSIiwiREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSIsInJlcGxhY2VOZXdsaW5lUmVwbGFjZSIsIm5ld2xpbmUiLCJjb21tb25Qcm9wZXJ0aWVzIiwiY29tbW9uVmFsdWVzIiwiZmxvYXQiLCJwYXJzZWQiLCJwYXJzZUZsb2F0IiwiaW50ZWdlciIsImRlY29yYXRlIiwidW5kZWNvcmF0ZSIsImljYWxQYXJhbXMiLCJhbGxvd1hOYW1lIiwiYWxsb3dJYW5hVG9rZW4iLCJpY2FsVmFsdWVzIiwidGV4dCIsInVyaSIsImFCaW5hcnkiLCJkZXNpZ24iLCJzdHJpY3QiLCJwZXJpb2QiLCJyZWN1ciIsImFSZWN1ciIsImljYWxQcm9wZXJ0aWVzIiwidmNhcmRWYWx1ZXMiLCJpc0Zyb21JY2FsIiwibGFzdENoYXIiLCJzaWduQ2hhciIsInNpZ24iLCJ0aW1lc3RhbXAiLCJmcm9tIiwiYyIsInZjYXJkUGFyYW1zIiwidmNhcmRQcm9wZXJ0aWVzIiwidmNhcmQzVmFsdWVzIiwiYmluYXJ5IiwidmNhcmQzUGFyYW1zIiwidmNhcmQzUHJvcGVydGllcyIsImZuIiwibiIsIm5pY2tuYW1lIiwicGhvdG8iLCJiZGF5IiwiYWRyIiwibGFiZWwiLCJ0ZWwiLCJlbWFpbCIsIm1haWxlciIsImdlbyIsInRpdGxlIiwicm9sZSIsImxvZ28iLCJhZ2VudCIsIm9yZyIsIm5vdGUiLCJwcm9kaWQiLCJyZXYiLCJzb3VuZCIsImNsYXNzIiwiaWNhbFNldCIsInZjYXJkU2V0IiwidmNhcmQzU2V0IiwiY29tcG9uZW50cyIsInZjYXJkMyIsInZldmVudCIsInZ0b2RvIiwidmpvdXJuYWwiLCJ2YWxhcm0iLCJ2dGltZXpvbmUiLCJkYXlsaWdodCIsInN0YW5kYXJkIiwiY29tcG9uZW50TmFtZSIsImlzSW5EZXNpZ24iLCJMSU5FX0VORElORyIsIkRFRkFVTFRfVkFMVUVfVFlQRSIsIlJGQzY4NjhfUkVQTEFDRV9NQVAiLCJzdHJpbmdpZnkiLCJwcm9wSWR4IiwicHJvcExlbiIsImRlc2lnblNldE5hbWUiLCJjb21wcyIsIm5vRm9sZCIsImpzTmFtZSIsImdyb3VwTmFtZSIsInBhcmFtTmFtZSIsInBhcmFtRGVzaWduIiwiX3JmYzY4NjhVbmVzY2FwZSIsInBhcmFtUHJvcGVydHlWYWx1ZSIsInByb3BEZXRhaWxzIiwiaXNEZWZhdWx0IiwiZm9yY2UiLCJOQU1FX0lOREVYJDEiLCJQUk9QX0lOREVYIiwiVFlQRV9JTkRFWCIsIlZBTFVFX0lOREVYIiwiUHJvcGVydHkiLCJfcGFyZW50IiwicCIsImRlc2lnblNldENoYW5nZWQiLCJfZGVzaWduU2V0IiwiZ2V0RGVmYXVsdFR5cGUiLCJfdXBkYXRlVHlwZSIsImlzRGVjb3JhdGVkIiwiaXNNdWx0aVZhbHVlIiwiaXNTdHJ1Y3R1cmVkVmFsdWUiLCJfaHlkcmF0ZVZhbHVlIiwiaW5kZXgiLCJfdmFsdWVzIiwiX2RlY29yYXRlIiwiX3VuZGVjb3JhdGUiLCJfc2V0RGVjb3JhdGVkVmFsdWUiLCJnZXRGaXJzdFBhcmFtZXRlciIsInBhcmFtZXRlcnMiLCJzZXRQYXJhbWV0ZXIiLCJyZW1vdmVQYXJhbWV0ZXIiLCJkZXRhaWxzIiwicmVzZXRUeXBlIiwicmVtb3ZlQWxsVmFsdWVzIiwiZ2V0VmFsdWVzIiwic2V0VmFsdWVzIiwic2V0VmFsdWUiLCJOQU1FX0lOREVYIiwiUFJPUEVSVFlfSU5ERVgiLCJDT01QT05FTlRfSU5ERVgiLCJwYXJlbnREZXNpZ24iLCJfaHlkcmF0ZUNvbXBvbmVudCIsIl9jb21wb25lbnRzIiwiX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQiLCJfaHlkcmF0ZVByb3BlcnR5IiwiX3Byb3BlcnRpZXMiLCJfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50IiwiZ2V0Rmlyc3RTdWJjb21wb25lbnQiLCJqQ2FsTGVuIiwiX3JlbW92ZU9iamVjdEJ5SW5kZXgiLCJqQ2FsSW5kZXgiLCJjYWNoZSIsInNwbGljZSIsIl9yZW1vdmVPYmplY3QiLCJuYW1lT3JPYmplY3QiLCJvYmplY3RzIiwiY2FjaGVkIiwiX3JlbW92ZUFsbE9iamVjdHMiLCJuYW1lT3JDb21wIiwicmVtb3ZlZCIsInJlbW92ZUFsbFN1YmNvbXBvbmVudHMiLCJhZGRQcm9wZXJ0eSIsInJlbW92ZVByb3BlcnR5IiwiYWRkUHJvcGVydHlXaXRoVmFsdWUiLCJ1cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZSIsIm5hbWVPclByb3AiLCJyZW1vdmVBbGxQcm9wZXJ0aWVzIiwiX3RpbWV6b25lQ2FjaGUiLCJoeWRyYXRlZFpvbmUiLCJNYXAiLCJSZWN1ckV4cGFuc2lvbiIsIl9pbml0IiwicnVsZUl0ZXJhdG9ycyIsIml0ZW0iLCJydWxlRGF0ZUluYyIsImV4RGF0ZUluYyIsInJ1bGVEYXRlcyIsInJ1bGVEYXRlIiwiZXhEYXRlcyIsImV4RGF0ZSIsImNvbXBsZXRlIiwibWF4VHJpZXMiLCJjdXJyZW50VHJ5IiwiX25leHRSZWN1cnJlbmNlSXRlciIsIl9uZXh0UnVsZURheSIsIl9uZXh0RXhEYXkiLCJfZXh0cmFjdERhdGVzIiwicHJvcGVydHlOYW1lIiwiaXRlcnMiLCJpdGVyVGltZSIsIml0ZXJJZHgiLCJjaG9zZW5JdGVyIiwiRXZlbnQiLCJyZWxhdGVFeGNlcHRpb24iLCJpc1JlY3VycmVuY2VFeGNlcHRpb24iLCJzdHJpY3RFeGNlcHRpb25zIiwidWlkIiwiaWQiLCJyZWN1cnJlbmNlSWQiLCJleGNlcHRpb25zIiwibW9kaWZpZXNGdXR1cmUiLCJyYW5nZUV4Y2VwdGlvbnMiLCJjb21wYXJlUmFuZ2VFeGNlcHRpb24iLCJyYW5nZSIsIlRISVNBTkRGVVRVUkUiLCJmaW5kUmFuZ2VFeGNlcHRpb24iLCJyYW5nZUl0ZW0iLCJnZXRPY2N1cnJlbmNlRGV0YWlscyIsIm9jY3VycmVuY2UiLCJ1dGNJZCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJyYW5nZUV4Y2VwdGlvbklkIiwiZXhjZXB0aW9uIiwic3RhcnREaWZmIiwiX3JhbmdlRXhjZXB0aW9uQ2FjaGUiLCJvcmlnaW5hbCIsIm5ld1N0YXJ0Iiwic3RhcnRUaW1lIiwiaXNSZWN1cnJpbmciLCJnZXRSZWN1cnJlbmNlVHlwZXMiLCJfZmlyc3RQcm9wIiwiX3NldFByb3AiLCJfc2V0VGltZSIsImF0dGVuZGVlcyIsInN1bW1hcnkiLCJkZXNjcmlwdGlvbiIsImNvbG9yIiwib3JnYW5pemVyIiwic2VxdWVuY2UiLCJwcm9wTmFtZSIsImZvckVhY2giLCJldmVudCIsIkNvbXBvbmVudFBhcnNlciIsInByb2Nlc3MiLCJpY2FsIiwicGFyc2VUaW1lem9uZSIsIm9udGltZXpvbmUiLCJwYXJzZUV2ZW50Iiwib25ldmVudCIsIm9uY29tcGxldGUiLCJvbmVycm9yIiwiZGVidWciLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ical.js/dist/ical.js\n"));

/***/ })

});